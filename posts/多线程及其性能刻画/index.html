<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=zh-cn dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>多线程及其性能刻画 - fffzlfk's Blog</title>
<meta name=theme-color><meta name=description content='使用多线程提高并行性
同步的代价
我们研究对一列整数 $0, &mldr;, n - 1$ 求和，我们将序列划分成 $t$ 个不相交的的区域，给 $t$ 个线程每个分配一个区域。将线程的和放入一个变量中，并且我们使用互斥锁来保护这个变量。
use std::{
    sync::{Arc, Mutex},
    thread,
    time::Instant,
};

fn main() {
    let args = std::env::args().collect::<Vec<String>>();
    if args.len() != 3 {
        panic!("Usage: {} <nthreads> <log_nelems>", args[0]);
    }

    let nthreads: usize = args[1].parse().unwrap();
    let log_nelems: usize = args[2].parse().unwrap();

    let nelems = 1_usize << log_nelems;
    let nelems_per_thread = nelems / nthreads;

    let gsum = Arc::new(Mutex::new(0));

    let now = Instant::now();

    let mut handlers = vec![];
    for i in 0..nthreads {
        let gsum = Arc::clone(&amp;gsum);
        let handler = thread::spawn(move || {
            let start = i * nelems_per_thread;
            let end = start + nelems_per_thread;
            for j in start..end {
                let mut sum = gsum.lock().unwrap();
                *sum += j;
            }
        });
        handlers.push(handler);
    }

    for handle in handlers {
        handle.join().unwrap();
    }

    assert_eq!(nelems * (nelems - 1) / 2, *gsum.lock().unwrap());

    println!("Running took {} s.", now.elapsed().as_secs())
}
我们在一个四核系统上，对一个大小为 $n=2^{20}$ 的序列进行测试，运算时间以毫秒为单位，结果如下：'><meta name=author content="fffzlfk"><link rel="preload stylesheet" as=style href=https://fffzlfk.github.io/main.min.css><link rel=preload as=image href=https://fffzlfk.github.io/theme.svg><link rel=preload as=image href="https://avatars.githubusercontent.com/u/44939690?v=4"><link rel=preload as=image href=https://fffzlfk.github.io/github.svg><link rel=preload as=image href=https://fffzlfk.github.io/instagram.svg><link rel=preload as=image href=https://fffzlfk.github.io/rss.svg><link rel=stylesheet href=/css/fonts.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",()=>renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1}))</script><link rel=icon href=https://fffzlfk.github.io/favicon.ico><link rel=apple-touch-icon href=https://fffzlfk.github.io/apple-touch-icon.png><meta name=generator content="Hugo 0.147.4"><meta itemprop=name content="多线程及其性能刻画"><meta itemprop=description content='使用多线程提高并行性 同步的代价 我们研究对一列整数 $0, …, n - 1$ 求和，我们将序列划分成 $t$ 个不相交的的区域，给 $t$ 个线程每个分配一个区域。将线程的和放入一个变量中，并且我们使用互斥锁来保护这个变量。
use std::{ sync::{Arc, Mutex}, thread, time::Instant, }; fn main() { let args = std::env::args().collect::<Vec<String>>(); if args.len() != 3 { panic!("Usage: {} <nthreads> <log_nelems>", args[0]); } let nthreads: usize = args[1].parse().unwrap(); let log_nelems: usize = args[2].parse().unwrap(); let nelems = 1_usize << log_nelems; let nelems_per_thread = nelems / nthreads; let gsum = Arc::new(Mutex::new(0)); let now = Instant::now(); let mut handlers = vec![]; for i in 0..nthreads { let gsum = Arc::clone(&amp;gsum); let handler = thread::spawn(move || { let start = i * nelems_per_thread; let end = start + nelems_per_thread; for j in start..end { let mut sum = gsum.lock().unwrap(); *sum += j; } }); handlers.push(handler); } for handle in handlers { handle.join().unwrap(); } assert_eq!(nelems * (nelems - 1) / 2, *gsum.lock().unwrap()); println!("Running took {} s.", now.elapsed().as_secs()) } 我们在一个四核系统上，对一个大小为 $n=2^{20}$ 的序列进行测试，运算时间以毫秒为单位，结果如下：'><meta itemprop=datePublished content="2022-02-27T23:21:12+08:00"><meta itemprop=dateModified content="2022-02-27T23:21:12+08:00"><meta itemprop=wordCount content="382"><meta itemprop=keywords content="Rust"><meta property="og:url" content="https://fffzlfk.github.io/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%8A%E5%85%B6%E6%80%A7%E8%83%BD%E5%88%BB%E7%94%BB/"><meta property="og:site_name" content="fffzlfk's Blog"><meta property="og:title" content="多线程及其性能刻画"><meta property="og:description" content='使用多线程提高并行性 同步的代价 我们研究对一列整数 $0, …, n - 1$ 求和，我们将序列划分成 $t$ 个不相交的的区域，给 $t$ 个线程每个分配一个区域。将线程的和放入一个变量中，并且我们使用互斥锁来保护这个变量。
use std::{ sync::{Arc, Mutex}, thread, time::Instant, }; fn main() { let args = std::env::args().collect::<Vec<String>>(); if args.len() != 3 { panic!("Usage: {} <nthreads> <log_nelems>", args[0]); } let nthreads: usize = args[1].parse().unwrap(); let log_nelems: usize = args[2].parse().unwrap(); let nelems = 1_usize << log_nelems; let nelems_per_thread = nelems / nthreads; let gsum = Arc::new(Mutex::new(0)); let now = Instant::now(); let mut handlers = vec![]; for i in 0..nthreads { let gsum = Arc::clone(&amp;gsum); let handler = thread::spawn(move || { let start = i * nelems_per_thread; let end = start + nelems_per_thread; for j in start..end { let mut sum = gsum.lock().unwrap(); *sum += j; } }); handlers.push(handler); } for handle in handlers { handle.join().unwrap(); } assert_eq!(nelems * (nelems - 1) / 2, *gsum.lock().unwrap()); println!("Running took {} s.", now.elapsed().as_secs()) } 我们在一个四核系统上，对一个大小为 $n=2^{20}$ 的序列进行测试，运算时间以毫秒为单位，结果如下：'><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-02-27T23:21:12+08:00"><meta property="article:modified_time" content="2022-02-27T23:21:12+08:00"><meta property="article:tag" content="Rust"><meta name=twitter:card content="summary"><meta name=twitter:title content="多线程及其性能刻画"><meta name=twitter:description content='使用多线程提高并行性 同步的代价 我们研究对一列整数 $0, …, n - 1$ 求和，我们将序列划分成 $t$ 个不相交的的区域，给 $t$ 个线程每个分配一个区域。将线程的和放入一个变量中，并且我们使用互斥锁来保护这个变量。
use std::{ sync::{Arc, Mutex}, thread, time::Instant, }; fn main() { let args = std::env::args().collect::<Vec<String>>(); if args.len() != 3 { panic!("Usage: {} <nthreads> <log_nelems>", args[0]); } let nthreads: usize = args[1].parse().unwrap(); let log_nelems: usize = args[2].parse().unwrap(); let nelems = 1_usize << log_nelems; let nelems_per_thread = nelems / nthreads; let gsum = Arc::new(Mutex::new(0)); let now = Instant::now(); let mut handlers = vec![]; for i in 0..nthreads { let gsum = Arc::clone(&amp;gsum); let handler = thread::spawn(move || { let start = i * nelems_per_thread; let end = start + nelems_per_thread; for j in start..end { let mut sum = gsum.lock().unwrap(); *sum += j; } }); handlers.push(handler); } for handle in handlers { handle.join().unwrap(); } assert_eq!(nelems * (nelems - 1) / 2, *gsum.lock().unwrap()); println!("Running took {} s.", now.elapsed().as_secs()) } 我们在一个四核系统上，对一个大小为 $n=2^{20}$ 的序列进行测试，运算时间以毫秒为单位，结果如下：'><link rel=canonical href=https://fffzlfk.github.io/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%8A%E5%85%B6%E6%80%A7%E8%83%BD%E5%88%BB%E7%94%BB/></head><body class="bg-(--bg) text-black antialiased duration-200 ease-out [-webkit-tap-highlight-color:transparent] dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-(--w) px-8 whitespace-nowrap lg:justify-center"><div class="relative z-50 flex items-center ltr:mr-auto rtl:ml-auto"><a class="-translate-y-[1px] text-2xl font-medium" href=https://fffzlfk.github.io/>fffzlfk's Blog</a><div class="btn-dark text-[0px] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden ltr:-mr-8 rtl:-ml-8" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full flex-col justify-center bg-(--bg) pb-16 duration-200 select-none lg:static lg:h-auto lg:flex-row lg:bg-transparent! lg:pb-0 lg:transition-none"><nav class="mt-12 flex justify-center space-x-10 lg:mt-0 lg:items-center ltr:lg:ml-14 rtl:space-x-reverse rtl:lg:mr-14 dark:invert"><a class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/fffzlfk target=_blank rel=me>github</a>
<a class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./instagram.svg) href=https://instagram.com/fffzlfk target=_blank rel=me>instagram</a>
<a class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./rss.svg) href=https://fffzlfk.github.io/index.xml target=_blank rel=alternate>rss</a></nav></div></header><main class="prose prose-neutral dark:prose-invert relative mx-auto min-h-[calc(100vh-9rem)] max-w-(--w) px-8 pt-14 pb-16"><article><header class=mb-14><h1 class="my-0! pb-2.5">多线程及其性能刻画</h1><div class="text-xs antialiased opacity-60"><time>Feb 27, 2022</time></div></header><section><h2 id=使用多线程提高并行性>使用多线程提高并行性</h2><h3 id=同步的代价>同步的代价</h3><p>我们研究对一列整数 $0, &mldr;, n - 1$ 求和，我们将序列划分成 $t$ 个不相交的的区域，给 $t$ 个线程每个分配一个区域。将线程的和放入一个变量中，并且我们使用互斥锁来保护这个变量。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::{
</span></span><span style=display:flex><span>    sync::{Arc, Mutex},
</span></span><span style=display:flex><span>    thread,
</span></span><span style=display:flex><span>    time::Instant,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> args <span style=color:#f92672>=</span> std::env::args().collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> args.len() <span style=color:#f92672>!=</span> <span style=color:#ae81ff>3</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;Usage: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> &lt;nthreads&gt; &lt;log_nelems&gt;&#34;</span>, args[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> nthreads: <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> args[<span style=color:#ae81ff>1</span>].parse().unwrap();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> log_nelems: <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> args[<span style=color:#ae81ff>2</span>].parse().unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> nelems <span style=color:#f92672>=</span> <span style=color:#ae81ff>1_</span><span style=color:#66d9ef>usize</span> <span style=color:#f92672>&lt;&lt;</span> log_nelems;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> nelems_per_thread <span style=color:#f92672>=</span> nelems <span style=color:#f92672>/</span> nthreads;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> gsum <span style=color:#f92672>=</span> Arc::new(Mutex::new(<span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> now <span style=color:#f92672>=</span> Instant::now();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> handlers <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>nthreads {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> gsum <span style=color:#f92672>=</span> Arc::clone(<span style=color:#f92672>&amp;</span>gsum);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> handler <span style=color:#f92672>=</span> thread::spawn(<span style=color:#66d9ef>move</span> <span style=color:#f92672>||</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> start <span style=color:#f92672>=</span> i <span style=color:#f92672>*</span> nelems_per_thread;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> end <span style=color:#f92672>=</span> start <span style=color:#f92672>+</span> nelems_per_thread;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> j <span style=color:#66d9ef>in</span> start<span style=color:#f92672>..</span>end {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> sum <span style=color:#f92672>=</span> gsum.lock().unwrap();
</span></span><span style=display:flex><span>                <span style=color:#f92672>*</span>sum <span style=color:#f92672>+=</span> j;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>        handlers.push(handler);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> handle <span style=color:#66d9ef>in</span> handlers {
</span></span><span style=display:flex><span>        handle.join().unwrap();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>assert_eq!</span>(nelems <span style=color:#f92672>*</span> (nelems <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>, <span style=color:#f92672>*</span>gsum.lock().unwrap());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Running took </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> s.&#34;</span>, now.elapsed().as_secs())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们在一个四核系统上，对一个大小为 $n=2^{20}$ 的序列进行测试，运算时间以毫秒为单位，结果如下：</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>线程数</td><td>1</td><td>2</td><td>4</td><td>8</td><td>16</td><td>32</td></tr><tr><td>时间</td><td>14932</td><td>72823</td><td>76478</td><td>118155</td><td>108878</td><td>101532</td></tr></tbody></table><p>结果令人难以理解，使用的<code>CPU</code>核数越多，性能越差。造成性能差的原因是相对于内存更新操作的开销，同步操作代价太大（<code>P</code>和<code>V</code>）。这突显了并行编程的一个重要教训：<strong>同步开销巨大，要尽可能避免。如果无法避免，必须要用尽可能多的有用计算弥补这个开销。</strong></p><h3 id=用局部变量优化消除同步>用局部变量优化，消除同步</h3><p>因此，我们使用局部变量来消除不必要的内存引用，将每个对等线程把它的部分和累积在一个局部变量而不是全局变量中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::{thread, time::Instant};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> args <span style=color:#f92672>=</span> std::env::args().collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> args.len() <span style=color:#f92672>!=</span> <span style=color:#ae81ff>3</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;Usage: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> &lt;nthreads&gt; &lt;log_nelems&gt;&#34;</span>, args[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> nthreads: <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> args[<span style=color:#ae81ff>1</span>].parse().unwrap();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> log_nelems: <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> args[<span style=color:#ae81ff>2</span>].parse().unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> nelems <span style=color:#f92672>=</span> <span style=color:#ae81ff>1_</span><span style=color:#66d9ef>usize</span> <span style=color:#f92672>&lt;&lt;</span> log_nelems;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> nelems_per_thread <span style=color:#f92672>=</span> nelems <span style=color:#f92672>/</span> nthreads;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> now <span style=color:#f92672>=</span> Instant::now();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> handlers <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>nthreads {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> handler <span style=color:#f92672>=</span> thread::spawn(<span style=color:#66d9ef>move</span> <span style=color:#f92672>||</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> sum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> start <span style=color:#f92672>=</span> i <span style=color:#f92672>*</span> nelems_per_thread;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> end <span style=color:#f92672>=</span> start <span style=color:#f92672>+</span> nelems_per_thread;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> j <span style=color:#66d9ef>in</span> start<span style=color:#f92672>..</span>end {
</span></span><span style=display:flex><span>                sum <span style=color:#f92672>+=</span> j;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            sum
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>        handlers.push(handler);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> gsum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> handle <span style=color:#66d9ef>in</span> handlers {
</span></span><span style=display:flex><span>        gsum <span style=color:#f92672>+=</span> handle.join().unwrap();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>assert_eq!</span>(nelems <span style=color:#f92672>*</span> (nelems <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>, gsum);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;Running took </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> s.&#34;</span>, now.elapsed().as_micros() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f64</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>1e6</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们在一个四核系统上，对一个大小为 $n=2^{31}$ 的序列进行测试，运算时间以秒为单位，结果如下：</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>线程数</td><td>1</td><td>2</td><td>4</td><td>8</td><td>16</td><td>32</td></tr><tr><td>时间</td><td>22.413</td><td>11.430</td><td>6.087</td><td>7.414</td><td>7.428</td><td>7.411</td></tr></tbody></table><p>结果基本符合预期，得到一组递减的运行时间。</p><h2 id=刻画并行程序的性能>刻画并行程序的性能</h2><p><img src=https://s3.bmp.ovh/imgs/2022/02/700ae3a337f3d100.png alt></p><p>如图，我们看到，随着线程数的增加，运行时间下降，直到增加到四个线程，此时，运行时间趋于平稳，甚至开始有点增加。在理想的情况中，我们会期望运行时间随着核数的增加线性下降。也就是说，我们会期望线程数每增加一倍，运行时间就下降一半。确实是这样，直到到达 $t > 4$ 的时候，此时四个核中的每一个都忙于运行至少一个线程。随着线程数量的增加，运行时间实际上增加了一点儿，这是由于在一个核上多个线程上下文切换的开销。由于这个原因，并行程序常常被写为每个核上只运行一个线程。</p><p>虽然绝对运行时间是衡量程序性能的终极标准，但是还是有一些有用的相对衡量标准能够说明并行程序有多好的利用了潜在的并行性。并行程序的<strong>加速比</strong>通常定义为： $$ S_p = \frac{T_1}{T_p} $$ $p$ 是处理器核的数量， $T_k$ 是在 $k$ 个核上的运行时间。这个公式有时被称为<strong>强扩展</strong>（strong scaling）。当 $T_1$ 是程序顺序执行版本的执行时间时， $S_p$ 称为<strong>绝对加速比</strong>（absolute speedup）。绝对加速比比相对加速比能更真实地衡量并行的好处。即使是当并行程序在一个处理器上运行时，也常常会受到同步开销的影响，而这些开销会人为地增加相对加速比的数值，因为它们增加了分子的大小。另一方面，绝对加速比比相对加速比更难以测量，因为测量绝对加速比需要程序的两种不同的版本。对于复杂的并行代码，创建一个独立的顺序版本可能不太实际，或者因为代码太复杂，或者因为源代码不可得。</p><p>一种相关的测量量称为<strong>效率</strong>（efficiency），定义为: $$ E_p = \frac{S_p}{p} = \frac{T_1}{pT_p} $$通常表示为范围在 $(0, 100]$ 之间的百分比。效率是对由于并行化造成的开销的衡量。具有高效率的程序比效率低的程序在有用的工作上花费更多的时间，在同步和通信上花费更少的时间。</p><p>下表给出了我们并行求和示例程序的各个加速比和效率测量值。像这样超过 $90%$ 的效率是非常好的，但是不要被欺骗了。能取得这么高的效率是因为我们的问题非常容易并行化。在实际中，很少会这样。数十年来，并行编程一直是一个很活跃的研究领域。随着商用多核机器的出现，这些机器的核数每几年就翻一番，并行编程会继续是一个深入、困难而活跃的研究领域。</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>线程（$t$）</td><td>$1$</td><td>$2$</td><td>$4$</td><td>$8$</td><td>$16$</td><td>$32$</td></tr><tr><td>核（$p$）</td><td>$1$</td><td>$2$</td><td>$4$</td><td>$8$</td><td>$16$</td><td>$32$</td></tr><tr><td>运行时间（ $T_p$ ）</td><td>$22.413$</td><td>$11.430$</td><td>$6.087$</td><td>$7.414$</td><td>$7.428$</td><td>$7.411$</td></tr><tr><td>加速比（ $S_p$ ）</td><td>$1$</td><td>$1.96$</td><td>$3.68$</td><td>$3.023$</td><td>$3.017$</td><td>$3.024$</td></tr><tr><td>效率（ $E_p$ ）</td><td>$100\%$</td><td>$98\%$</td><td>$92\%$</td><td>$76\%$</td><td>$75\%$</td><td>$76\%$</td></tr></tbody></table><h2 id=references>References</h2><p><a href=https://hansimov.gitbook.io/csapp/part3/ch12-concurrent-programming/12.6-using-threads-for-parallelism>https://hansimov.gitbook.io/csapp/part3/ch12-concurrent-programming/12.6-using-threads-for-parallelism</a></p></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] ltr:mr-1.5 rtl:ml-1.5 dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://fffzlfk.github.io/tags/rust>Rust</a></footer><div class="giscus mt-24"></div><script src=https://giscus.app/client.js data-repo=fffzlfk/fffzlfk.github.io data-repo-id=R_kgDOG4ERGw data-category=Q&amp;A data-category-id=DIC_kwDOG4ERG84CBP5t data-mapping=pathname data-strict=1 data-reactions-enabled=0 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class="mx-auto flex h-[4.5rem] max-w-(--w) items-center px-8 text-xs tracking-wider uppercase opacity-60"><div class=mr-auto>&copy;2025
<a class=link href=https://fffzlfk.github.io/>fffzlfk's Blog</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>powered by hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>hugo-paper</a></footer></body></html>