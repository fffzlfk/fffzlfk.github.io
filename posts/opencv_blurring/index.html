<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=zh-cn dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>OpenCV Blurring - fffzlfk's Blog</title>
<meta name=theme-color><meta name=description content="理论


Smoothing也叫blurring（模糊化），是一个简单而常用的图像处理操作。


Smoothing有很多原因。在本教程中，我们将重点讨论平滑操作，以减少噪音。


为了进行平滑操作，我们将对我们的图像应用一个filter。最常见的filter是线性的，其中输出像素的值（即 $g(i,j)$ ）为输入像素值的加权和（即 $f(i+k,j+l)$ ）。


$$
g(i, j) = \sum_{k, l}{f(i+k, j+l)h(k, l)}
$$


$h(k,l)$ 被称为kernel，它只不过是filter的系数。这有助于把滤波器想象成一个在图像上滑动的系数窗口。


滤波器有很多种类，这里我们将提到最常用的几种。


Normalized Box Filter（归一化块滤波器）

这个滤波器是最简单的，每个输出像素都是其内核邻居的平均值（所有的像素都有相同的权重）。

$$
K = \frac{1}{K_{width} \cdot k_{height}}
\begin{bmatrix}
1 & 1 & 1 & &mldr;& 1\\
1 & 1 & 1 & &mldr;& 1\\
. & . & . & &mldr;& 1\\
1 & 1 & 1 & &mldr;& 1
\end{bmatrix}
$$
Gaussian Filter（高斯滤波器）


可能是最有用的滤波器（尽管不是最快的）。高斯滤波是通过用高斯内核对输入阵列中的每个点进行卷积，然后将它们全部相加来产生输出阵列的。


让我们回顾一下1D Gaussian kernel是什么样子：
"><meta name=author content="fffzlfk"><link rel="preload stylesheet" as=style href=https://fffzlfk.github.io/main.min.css><link rel=preload as=image href=https://fffzlfk.github.io/theme.svg><link rel=preload as=image href="https://avatars.githubusercontent.com/u/44939690?v=4"><link rel=preload as=image href=https://fffzlfk.github.io/github.svg><link rel=preload as=image href=https://fffzlfk.github.io/instagram.svg><link rel=preload as=image href=https://fffzlfk.github.io/rss.svg><link rel=stylesheet href=/css/fonts.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",()=>renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1}))</script><link rel=icon href=https://fffzlfk.github.io/favicon.ico><link rel=apple-touch-icon href=https://fffzlfk.github.io/apple-touch-icon.png><meta name=generator content="Hugo 0.147.4"><meta itemprop=name content="OpenCV Blurring"><meta itemprop=description content="理论 Smoothing也叫blurring（模糊化），是一个简单而常用的图像处理操作。
Smoothing有很多原因。在本教程中，我们将重点讨论平滑操作，以减少噪音。
为了进行平滑操作，我们将对我们的图像应用一个filter。最常见的filter是线性的，其中输出像素的值（即 $g(i,j)$ ）为输入像素值的加权和（即 $f(i+k,j+l)$ ）。
$$ g(i, j) = \sum_{k, l}{f(i+k, j+l)h(k, l)} $$
$h(k,l)$ 被称为kernel，它只不过是filter的系数。这有助于把滤波器想象成一个在图像上滑动的系数窗口。
滤波器有很多种类，这里我们将提到最常用的几种。
Normalized Box Filter（归一化块滤波器） 这个滤波器是最简单的，每个输出像素都是其内核邻居的平均值（所有的像素都有相同的权重）。 $$ K = \frac{1}{K_{width} \cdot k_{height}} \begin{bmatrix} 1 & 1 & 1 & …& 1\\ 1 & 1 & 1 & …& 1\\ . & . & . & …& 1\\ 1 & 1 & 1 & …& 1 \end{bmatrix} $$
Gaussian Filter（高斯滤波器） 可能是最有用的滤波器（尽管不是最快的）。高斯滤波是通过用高斯内核对输入阵列中的每个点进行卷积，然后将它们全部相加来产生输出阵列的。
让我们回顾一下1D Gaussian kernel是什么样子："><meta itemprop=datePublished content="2022-01-09T07:37:09+08:00"><meta itemprop=dateModified content="2022-01-09T07:37:09+08:00"><meta itemprop=wordCount content="165"><meta itemprop=keywords content="OpenCV"><meta property="og:url" content="https://fffzlfk.github.io/posts/opencv_blurring/"><meta property="og:site_name" content="fffzlfk's Blog"><meta property="og:title" content="OpenCV Blurring"><meta property="og:description" content="理论 Smoothing也叫blurring（模糊化），是一个简单而常用的图像处理操作。
Smoothing有很多原因。在本教程中，我们将重点讨论平滑操作，以减少噪音。
为了进行平滑操作，我们将对我们的图像应用一个filter。最常见的filter是线性的，其中输出像素的值（即 $g(i,j)$ ）为输入像素值的加权和（即 $f(i+k,j+l)$ ）。
$$ g(i, j) = \sum_{k, l}{f(i+k, j+l)h(k, l)} $$
$h(k,l)$ 被称为kernel，它只不过是filter的系数。这有助于把滤波器想象成一个在图像上滑动的系数窗口。
滤波器有很多种类，这里我们将提到最常用的几种。
Normalized Box Filter（归一化块滤波器） 这个滤波器是最简单的，每个输出像素都是其内核邻居的平均值（所有的像素都有相同的权重）。 $$ K = \frac{1}{K_{width} \cdot k_{height}} \begin{bmatrix} 1 & 1 & 1 & …& 1\\ 1 & 1 & 1 & …& 1\\ . & . & . & …& 1\\ 1 & 1 & 1 & …& 1 \end{bmatrix} $$
Gaussian Filter（高斯滤波器） 可能是最有用的滤波器（尽管不是最快的）。高斯滤波是通过用高斯内核对输入阵列中的每个点进行卷积，然后将它们全部相加来产生输出阵列的。
让我们回顾一下1D Gaussian kernel是什么样子："><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-09T07:37:09+08:00"><meta property="article:modified_time" content="2022-01-09T07:37:09+08:00"><meta property="article:tag" content="OpenCV"><meta name=twitter:card content="summary"><meta name=twitter:title content="OpenCV Blurring"><meta name=twitter:description content="理论 Smoothing也叫blurring（模糊化），是一个简单而常用的图像处理操作。
Smoothing有很多原因。在本教程中，我们将重点讨论平滑操作，以减少噪音。
为了进行平滑操作，我们将对我们的图像应用一个filter。最常见的filter是线性的，其中输出像素的值（即 $g(i,j)$ ）为输入像素值的加权和（即 $f(i+k,j+l)$ ）。
$$ g(i, j) = \sum_{k, l}{f(i+k, j+l)h(k, l)} $$
$h(k,l)$ 被称为kernel，它只不过是filter的系数。这有助于把滤波器想象成一个在图像上滑动的系数窗口。
滤波器有很多种类，这里我们将提到最常用的几种。
Normalized Box Filter（归一化块滤波器） 这个滤波器是最简单的，每个输出像素都是其内核邻居的平均值（所有的像素都有相同的权重）。 $$ K = \frac{1}{K_{width} \cdot k_{height}} \begin{bmatrix} 1 & 1 & 1 & …& 1\\ 1 & 1 & 1 & …& 1\\ . & . & . & …& 1\\ 1 & 1 & 1 & …& 1 \end{bmatrix} $$
Gaussian Filter（高斯滤波器） 可能是最有用的滤波器（尽管不是最快的）。高斯滤波是通过用高斯内核对输入阵列中的每个点进行卷积，然后将它们全部相加来产生输出阵列的。
让我们回顾一下1D Gaussian kernel是什么样子："><link rel=canonical href=https://fffzlfk.github.io/posts/opencv_blurring/></head><body class="bg-(--bg) text-black antialiased duration-200 ease-out [-webkit-tap-highlight-color:transparent] dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-(--w) px-8 whitespace-nowrap lg:justify-center"><div class="relative z-50 flex items-center ltr:mr-auto rtl:ml-auto"><a class="-translate-y-[1px] text-2xl font-medium" href=https://fffzlfk.github.io/>fffzlfk's Blog</a><div class="btn-dark text-[0px] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden ltr:-mr-8 rtl:-ml-8" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full flex-col justify-center bg-(--bg) pb-16 duration-200 select-none lg:static lg:h-auto lg:flex-row lg:bg-transparent! lg:pb-0 lg:transition-none"><nav class="mt-12 flex justify-center space-x-10 lg:mt-0 lg:items-center ltr:lg:ml-14 rtl:space-x-reverse rtl:lg:mr-14 dark:invert"><a class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/fffzlfk target=_blank rel=me>github</a>
<a class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./instagram.svg) href=https://instagram.com/fffzlfk target=_blank rel=me>instagram</a>
<a class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./rss.svg) href=https://fffzlfk.github.io/index.xml target=_blank rel=alternate>rss</a></nav></div></header><main class="prose prose-neutral dark:prose-invert relative mx-auto min-h-[calc(100vh-9rem)] max-w-(--w) px-8 pt-14 pb-16"><article><header class=mb-14><h1 class="my-0! pb-2.5">OpenCV Blurring</h1><div class="text-xs antialiased opacity-60"><time>Jan 9, 2022</time></div></header><section><h2 id=理论>理论</h2><ul><li><p><code>Smoothing</code>也叫<code>blurring</code>（模糊化），是一个简单而常用的图像处理操作。</p></li><li><p><code>Smoothing</code>有很多原因。在本教程中，我们将重点讨论平滑操作，以减少噪音。</p></li><li><p>为了进行平滑操作，我们将对我们的图像应用一个<code>filter</code>。最常见的<code>filter</code>是线性的，其中输出像素的值（即 $g(i,j)$ ）为输入像素值的加权和（即 $f(i+k,j+l)$ ）。</p></li></ul><p>$$
g(i, j) = \sum_{k, l}{f(i+k, j+l)h(k, l)}
$$</p><ul><li><p>$h(k,l)$ 被称为<code>kernel</code>，它只不过是<code>filter</code>的系数。这有助于把滤波器想象成一个在图像上滑动的系数窗口。</p></li><li><p>滤波器有很多种类，这里我们将提到最常用的几种。</p></li></ul><h2 id=normalized-box-filter归一化块滤波器>Normalized Box Filter（归一化块滤波器）</h2><ul><li>这个滤波器是最简单的，每个输出像素都是其内核邻居的平均值（所有的像素都有相同的权重）。</li></ul><p>$$
K = \frac{1}{K_{width} \cdot k_{height}}
\begin{bmatrix}
1 & 1 & 1 & &mldr;& 1\\
1 & 1 & 1 & &mldr;& 1\\
. & . & . & &mldr;& 1\\
1 & 1 & 1 & &mldr;& 1
\end{bmatrix}
$$</p><h2 id=gaussian-filter高斯滤波器>Gaussian Filter（高斯滤波器）</h2><ul><li><p>可能是最有用的滤波器（尽管不是最快的）。高斯滤波是通过用高斯内核对输入阵列中的每个点进行卷积，然后将它们全部相加来产生输出阵列的。</p></li><li><p>让我们回顾一下<code>1D Gaussian kernel</code>是什么样子：
<img src=https://docs.opencv.org/4.5.5/Smoothing_Tutorial_theory_gaussian_0.jpg alt></p></li><li><p>假设图像是一维的，你可以注意到，位于中间的像素会有最大的权重。它的邻居的权重随着它们与中心像素之间的空间距离增加而减少。</p></li></ul><blockquote><p>一个二维高斯可以表示为：
$$
G_0(x, y)=Ae^{\frac{-(x-\mu_x)^2}{2\sigma_x^2}+\frac{-(y-\mu_y)^2}{2\sigma_y^2}}
$$
其中 $\mu$ 是平均值（峰值）， $\sigma^2$ 代表方差（每一个变量 $x$ 和 $y$ ）。</p></blockquote><h2 id=bilateral-filter双边滤波器>Bilateral Filter（双边滤波器）</h2><ul><li><p>到目前为止，我们已经解释了一些主要目标是平滑输入图像的滤波器。然而，有时这些滤波器不仅能消除噪声，还会使边缘变得平滑。为了避免这种情况（至少在一定程度上），我们可以使用一个双边滤波器。</p></li><li><p>类似于高斯滤波器的方式，双边滤波器也考虑了相邻的像素，并为每个像素分配权重。这些权重有两个组成部分，第一个组成部分与高斯滤波器使用的权重相同。第二部分考虑到了相邻像素和被评估像素之间的强度差异。</p></li></ul><h2 id=code>Code</h2><ul><li>这个程序是做什么的？<ul><li>加载一张图片</li><li>应用4种不同的过滤器（在理论中解释过的），并按顺序显示过滤后的图片</li></ul></li><li><a href=https://github.com/fffzlfk/opencv_learning/blob/main/src/basic/blur.cpp>代码链接</a></li></ul><h3 id=函数解释>函数解释</h3><h4 id=normalized-block-filter>Normalized Block Filter</h4><ul><li>OpenCV 提供了<code>blur</code>函数来用这个滤波器进行平滑处理。<ul><li><code>src</code>：源图像</li><li><code>dst</code>: 目的图像</li><li><code>ksize: Size(w, h)</code>: 定义要使用的内核的大小（宽度为 $w$ 像素，高度为 $h$ 像素）。</li><li><code>anchor: Point(-1, -1)</code>: 表示锚点（被评估的像素）相对于邻域的位置。如果有一个负值，那么内核的中心被认为是锚点。</li></ul></li></ul><h4 id=gaussian-filter>Gaussian Filter</h4><ul><li>function<code>GaussianBlur</code><ul><li><code>src</code>：源图像</li><li><code>dst</code>: 目的图像</li><li><code>ksize: Size(w, h)</code>: 要使用的核的大小（要考虑的邻居）。 $w$ 和 $h$ 必须是奇数和正数，否则大小将用 $\sigma_x$ 和 $\sigma_y$ 参数计算</li><li><code>sigmaX</code>：x的标准偏差。写成 $0$ 意味着用核大小计算的。</li><li><code>sigmaY</code>：y的标准差。写 $0$ 意味着是用内核大小计算的。</li></ul></li></ul><h4 id=median-filter中值滤波器>Median Filter（中值滤波器）</h4><ul><li>function<code>medianBlur</code><ul><li><code>src</code>：源图像</li><li><code>dst</code>: 目的图像</li><li><code>ksize</code>：内核的大小（只有一个数，因为我们使用的是方形窗口），必须是奇数。</li></ul></li></ul><h4 id=bilateral-filter双边滤波>Bilateral Filter（双边滤波）</h4><ul><li>function<code>bilateralFilter</code><ul><li><code>src</code>：源图像</li><li><code>dst</code>: 目的图像</li><li><code>d</code>: 每个像素邻域的直径</li><li><code>sigmaColor</code>：色彩空间的标准偏差</li><li><code>sigmaSpace</code>：坐标空间中的标准偏差</li></ul></li></ul><h2 id=结果>结果</h2><h3 id=原图>原图</h3><p><img src=https://s3.bmp.ovh/imgs/2022/01/f5549e957ee61360.png alt></p><h3 id=归一化块滤波>归一化块滤波</h3><p><img src=https://s3.bmp.ovh/imgs/2022/01/af6bea85825437db.png alt></p><h3 id=高斯滤波>高斯滤波</h3><p><img src=https://s3.bmp.ovh/imgs/2022/01/7c940b8963215a69.png alt></p><h3 id=中值滤波>中值滤波</h3><p><img src=https://s3.bmp.ovh/imgs/2022/01/c7a7643fbe5ac8a1.png alt></p><h3 id=双边滤波>双边滤波</h3><p><img src=https://s3.bmp.ovh/imgs/2022/01/787448c87c53ff10.png alt></p><h2 id=references>References</h2><p><a href=https://docs.opencv.org/4.5.5/d7/da8/tutorial_table_of_content_imgproc.html>https://docs.opencv.org/4.5.5/d7/da8/tutorial_table_of_content_imgproc.html</a></p></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] ltr:mr-1.5 rtl:ml-1.5 dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://fffzlfk.github.io/tags/opencv>OpenCV</a></footer><div class="giscus mt-24"></div><script src=https://giscus.app/client.js data-repo=fffzlfk/fffzlfk.github.io data-repo-id=R_kgDOG4ERGw data-category=Q&amp;A data-category-id=DIC_kwDOG4ERG84CBP5t data-mapping=pathname data-strict=1 data-reactions-enabled=0 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class="mx-auto flex h-[4.5rem] max-w-(--w) items-center px-8 text-xs tracking-wider uppercase opacity-60"><div class=mr-auto>&copy;2025
<a class=link href=https://fffzlfk.github.io/>fffzlfk's Blog</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>powered by hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>hugo-paper</a></footer></body></html>