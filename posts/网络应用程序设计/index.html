<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=zh-cn dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>网络应用程序设计 - fffzlfk's Blog</title>
<meta name=theme-color><meta name=description content="Network Program Design for Application"><meta name=author content="fffzlfk"><link rel="preload stylesheet" as=style href=https://fffzlfk.github.io/main.min.css><link rel=preload as=image href=https://fffzlfk.github.io/theme.svg><link rel=preload as=image href="https://avatars.githubusercontent.com/u/44939690?v=4"><link rel=preload as=image href=https://fffzlfk.github.io/github.svg><link rel=preload as=image href=https://fffzlfk.github.io/instagram.svg><link rel=preload as=image href=https://fffzlfk.github.io/rss.svg><link rel=stylesheet href=/css/fonts.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",()=>renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1}))</script><link rel=icon href=https://fffzlfk.github.io/favicon.ico><link rel=apple-touch-icon href=https://fffzlfk.github.io/apple-touch-icon.png><meta name=generator content="Hugo 0.147.4"><meta itemprop=name content="网络应用程序设计"><meta itemprop=description content="Network Program Design for Application"><meta itemprop=datePublished content="2021-04-07T20:48:12+08:00"><meta itemprop=dateModified content="2021-04-07T20:48:12+08:00"><meta itemprop=wordCount content="2935"><meta itemprop=keywords content="Academic"><meta property="og:url" content="https://fffzlfk.github.io/posts/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"><meta property="og:site_name" content="fffzlfk's Blog"><meta property="og:title" content="网络应用程序设计"><meta property="og:description" content="Network Program Design for Application"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-07T20:48:12+08:00"><meta property="article:modified_time" content="2021-04-07T20:48:12+08:00"><meta property="article:tag" content="Academic"><meta name=twitter:card content="summary"><meta name=twitter:title content="网络应用程序设计"><meta name=twitter:description content="Network Program Design for Application"><link rel=canonical href=https://fffzlfk.github.io/posts/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/></head><body class="bg-(--bg) text-black antialiased duration-200 ease-out [-webkit-tap-highlight-color:transparent] dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-(--w) px-8 whitespace-nowrap lg:justify-center"><div class="relative z-50 flex items-center ltr:mr-auto rtl:ml-auto"><a class="-translate-y-[1px] text-2xl font-medium" href=https://fffzlfk.github.io/>fffzlfk's Blog</a><div class="btn-dark text-[0px] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden ltr:-mr-8 rtl:-ml-8" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full flex-col justify-center bg-(--bg) pb-16 duration-200 select-none lg:static lg:h-auto lg:flex-row lg:bg-transparent! lg:pb-0 lg:transition-none"><nav class="mt-12 flex justify-center space-x-10 lg:mt-0 lg:items-center ltr:lg:ml-14 rtl:space-x-reverse rtl:lg:mr-14 dark:invert"><a class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/fffzlfk target=_blank rel=me>github</a>
<a class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./instagram.svg) href=https://instagram.com/fffzlfk target=_blank rel=me>instagram</a>
<a class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./rss.svg) href=https://fffzlfk.github.io/index.xml target=_blank rel=alternate>rss</a></nav></div></header><main class="prose prose-neutral dark:prose-invert relative mx-auto min-h-[calc(100vh-9rem)] max-w-(--w) px-8 pt-14 pb-16"><article><header class=mb-14><h1 class="my-0! pb-2.5">网络应用程序设计</h1><div class="text-xs antialiased opacity-60"><time>Apr 7, 2021</time></div></header><section><h2 id=基本socket函数>基本socket函数</h2><h3 id=创建网络端点>创建网络端点</h3><ul><li>创建socket描述符</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>socket</span> (<span style=color:#66d9ef>int</span> family, <span style=color:#66d9ef>int</span> type, <span style=color:#66d9ef>int</span> protocol)
</span></span></code></pre></div><h3 id=socket地址>Socket地址</h3><h4 id=tcpip协议的socket地址>TCP/IP协议的socket地址</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> sockaddr_in {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>short</span> 		    sin_family;    <span style=color:#75715e>/*AF_INET*/</span>
</span></span><span style=display:flex><span>        u_short 		sin_port;      <span style=color:#75715e>/*端口号，网络字节顺序*/</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> n_addr 	sin_addr;      <span style=color:#75715e>/*IP地址，网络字节顺序*/</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span>    		sin_zero[<span style=color:#ae81ff>8</span>];   <span style=color:#75715e>/*填充字节，必须为全零*/</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> in_addr {
</span></span><span style=display:flex><span>  	<span style=color:#66d9ef>union</span> {
</span></span><span style=display:flex><span>          		<span style=color:#66d9ef>struct</span> { u_char s_b1,s_b2,s_b3,s_b4; }   S_un_b;
</span></span><span style=display:flex><span>          		<span style=color:#66d9ef>struct</span> { u_short s_w1,s_w2; }   S_un_w;
</span></span><span style=display:flex><span>         		 u_long   S_addr;
</span></span><span style=display:flex><span> 	 } S_un;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=地址转换函数>地址转换函数</h4><ul><li>字符串形式地址转换为网络地址形式<code>inet_aton(const char *cp,struct in_addr *inp);</code></li><li>网络地址转换为字符串地址形式<code>char* inet_ntoa(struct in_addr in);</code></li></ul><h3 id=字节顺序>字节顺序</h3><h4 id=主机字节顺序>主机字节顺序</h4><ul><li><code>little-endian</code>低字节在前</li><li><code>big-endian</code>高字节在前</li></ul><h4 id=网络字节顺序>网络字节顺序</h4><p>采用<code>big-endian</code>顺序</p><h4 id=主机字节顺序和网络字节顺序的转换>主机字节顺序和网络字节顺序的转换</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>htons</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span> <span style=color:#66d9ef>int</span> hostshort)
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>htonl</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>int</span> hotlong)
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>ntohs</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span> <span style=color:#66d9ef>int</span> netshort)
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>ntohl</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>int</span> netlong)
</span></span></code></pre></div><h3 id=连接服务器>连接服务器</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>connect</span>(<span style=color:#66d9ef>int</span> sockfd,<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>servaddr,<span style=color:#66d9ef>int</span> addrlen)
</span></span></code></pre></div><h3 id=绑定服务器地址和端口>绑定服务器地址和端口</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>bind</span>(<span style=color:#66d9ef>int</span> sockfd,<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>myaddr,<span style=color:#66d9ef>int</span> addrlen); 
</span></span></code></pre></div><h4 id=地址可重用>地址可重用</h4><p>在<code>bind</code>之前</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> on <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, <span style=color:#f92672>&amp;</span>on, <span style=color:#66d9ef>sizeof</span>(on));
</span></span></code></pre></div><h3 id=监听端口>监听端口</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>listen</span>(<span style=color:#66d9ef>int</span> sockfd,<span style=color:#66d9ef>int</span> backlog)
</span></span></code></pre></div><ul><li>sockfd－已绑定的socket描述符</li><li>backlog－以完成连接，等待接受的队列长度</li></ul><h3 id=接收客户端连接>接收客户端连接</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>accept</span>(<span style=color:#66d9ef>int</span> sockfd,<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>clientaddr,<span style=color:#66d9ef>int</span> addrlen);
</span></span></code></pre></div><h3 id=代码示例>代码示例</h3><h4 id=server>server</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netinet/in.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define MAXDATASIZE 128
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define PORT 3000
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define BACKLOG 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sockfd, new_fd, nbytes, sin_size;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> buf[MAXDATASIZE];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> sockaddr_in srvaddr, clientaddr;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 1.创建网络端点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    sockfd <span style=color:#f92672>=</span> <span style=color:#a6e22e>socket</span>(AF_INET, SOCK_STREAM, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (sockfd <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;can;t create socket</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> on <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>setsockopt</span>(sockfd, SOL_SOCKET, SO_REUSEADDR, <span style=color:#f92672>&amp;</span>on, <span style=color:#66d9ef>sizeof</span>(on));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;reuse addr</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//填充地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>bzero</span>(<span style=color:#f92672>&amp;</span>srvaddr, <span style=color:#66d9ef>sizeof</span>(srvaddr));
</span></span><span style=display:flex><span>    srvaddr.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>    srvaddr.sin_port <span style=color:#f92672>=</span> <span style=color:#a6e22e>htons</span>(PORT);
</span></span><span style=display:flex><span>    srvaddr.sin_addr.s_addr <span style=color:#f92672>=</span> <span style=color:#a6e22e>htonl</span>(INADDR_ANY);
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>    if(inet_aton(argv[1],&amp;srvaddr.sin_addr)==-1){
</span></span></span><span style=display:flex><span><span style=color:#75715e>            printf(&#34;addr convert error\n&#34;);
</span></span></span><span style=display:flex><span><span style=color:#75715e>            exit(1);
</span></span></span><span style=display:flex><span><span style=color:#75715e>    }
</span></span></span><span style=display:flex><span><span style=color:#75715e>    */</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2.绑定服务器地址和端口
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>bind</span>(sockfd, (<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>srvaddr, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> sockaddr)) <span style=color:#f92672>==</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;bind error</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3. 监听端口
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>listen</span>(sockfd, BACKLOG) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;listen error</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 4.接受客户端连接
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        sin_size <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> sockaddr_in);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ((new_fd <span style=color:#f92672>=</span> <span style=color:#a6e22e>accept</span>(sockfd, (<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>clientaddr,
</span></span><span style=display:flex><span>                             <span style=color:#f92672>&amp;</span>sin_size)) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;accept error</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;client addr:%s %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>inet_ntoa</span>(clientaddr.sin_addr),
</span></span><span style=display:flex><span>               <span style=color:#a6e22e>ntohs</span>(clientaddr.sin_port));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 5.接收请求
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>getchar</span>();
</span></span><span style=display:flex><span>        nbytes <span style=color:#f92672>=</span> <span style=color:#a6e22e>read</span>(new_fd, buf, MAXDATASIZE);
</span></span><span style=display:flex><span>        buf[nbytes] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;\0&#39;</span>;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;client:%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, buf);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 6.回送响应
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>sprintf</span>(buf, <span style=color:#e6db74>&#34;wellcome!&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>write</span>(new_fd, buf, <span style=color:#a6e22e>strlen</span>(buf));
</span></span><span style=display:flex><span>        <span style=color:#75715e>//关闭socket
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>close</span>(new_fd);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>close</span>(sockfd);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=client>client</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;errno.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netdb.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netinet/in.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define MAXDATASIZE 128
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define PORT 3000
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>addr_conv</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>address, <span style=color:#66d9ef>struct</span> in_addr <span style=color:#f92672>*</span>inaddr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sockfd, nbytes;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> port <span style=color:#f92672>=</span> PORT;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> buf[MAXDATASIZE];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> sockaddr_in srvaddr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>!=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>&amp;&amp;</span> argc <span style=color:#f92672>!=</span> <span style=color:#ae81ff>3</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;usage:./client hostname|ip. Or usage:./client hostname|ip port</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>==</span> <span style=color:#ae81ff>3</span>) port <span style=color:#f92672>=</span> <span style=color:#a6e22e>atoi</span>(argv[<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 1.创建网络端点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    sockfd <span style=color:#f92672>=</span> <span style=color:#a6e22e>socket</span>(AF_INET, SOCK_STREAM, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (sockfd <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;can;t create socket</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//指定服务器地址（本地socket地址采用默认值）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>bzero</span>(<span style=color:#f92672>&amp;</span>srvaddr, <span style=color:#66d9ef>sizeof</span>(srvaddr));
</span></span><span style=display:flex><span>    srvaddr.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>    srvaddr.sin_port <span style=color:#f92672>=</span> <span style=color:#a6e22e>htons</span>(port);
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>    if(inet_aton(&#34;127.0.0.1&#34;,&amp;srvaddr.sin_addr)==-1){
</span></span></span><span style=display:flex><span><span style=color:#75715e>            printf(&#34;addr convert error\n&#34;);
</span></span></span><span style=display:flex><span><span style=color:#75715e>            exit(1);
</span></span></span><span style=display:flex><span><span style=color:#75715e>    }
</span></span></span><span style=display:flex><span><span style=color:#75715e>    */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>addr_conv</span>(argv[<span style=color:#ae81ff>1</span>], <span style=color:#f92672>&amp;</span>srvaddr.sin_addr) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>perror</span>(<span style=color:#a6e22e>strerror</span>(errno));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2.连接服务器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>connect</span>(sockfd, (<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>srvaddr, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> sockaddr)) <span style=color:#f92672>==</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;connect error</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3.发送请求
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sprintf</span>(buf, <span style=color:#e6db74>&#34;hello&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>write</span>(sockfd, buf, <span style=color:#a6e22e>strlen</span>(buf));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sprintf</span>(buf, <span style=color:#e6db74>&#34;hello2&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>write</span>(sockfd, buf, <span style=color:#a6e22e>strlen</span>(buf));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sprintf</span>(buf, <span style=color:#e6db74>&#34;hello3&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>write</span>(sockfd, buf, <span style=color:#a6e22e>strlen</span>(buf));
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 4.接收响应
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> ((nbytes <span style=color:#f92672>=</span> <span style=color:#a6e22e>read</span>(sockfd, buf, MAXDATASIZE)) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;read error</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    buf[nbytes] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;\0&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;srv respons:%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, buf);
</span></span><span style=display:flex><span>    <span style=color:#75715e>//关闭socket
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>close</span>(sockfd);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>addr_conv</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>address, <span style=color:#66d9ef>struct</span> in_addr <span style=color:#f92672>*</span>inaddr) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> hostent <span style=color:#f92672>*</span>he;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>inet_aton</span>(address, inaddr) <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;call inet_aton sucess.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;call inet_aton fail.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    he <span style=color:#f92672>=</span> <span style=color:#a6e22e>gethostbyname</span>(address);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (he <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;call gethostbyname sucess.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>inaddr <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>((<span style=color:#66d9ef>struct</span> in_addr <span style=color:#f92672>*</span>)(he<span style=color:#f92672>-&gt;</span>h_addr_list[<span style=color:#ae81ff>0</span>]));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=高级socket函数>高级socket函数</h2><h3 id=dhcp>DHCP</h3><p><strong>动态主机配置协议</strong>（Dynamic Host Configuration Protocol）</p><h4 id=分配方式>分配方式</h4><ul><li>自动分配</li><li>动态分配</li><li>人工分配</li></ul><h4 id=dhcp过程>DHCP过程</h4><p><img src=https://files.catbox.moe/exth7w.png alt></p><h3 id=域名访问>域名访问</h3><h4 id=域名系统dns>域名系统——DNS</h4><ul><li>域名查找过程</li></ul><p><img src=https://files.catbox.moe/9rdt4n.png alt></p><h4 id=域名到ip的转换函数>域名到IP的转换函数</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> hostent<span style=color:#f92672>*</span> <span style=color:#a6e22e>gethostbyname</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> hostent{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>char</span>	h_name;	        <span style=color:#75715e>/*主机正式名称*/</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>char</span>	<span style=color:#f92672>**</span>h_aliases;	<span style=color:#75715e>/*别名列表，以NULL结束*/</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> 	h_addrtype;	    <span style=color:#75715e>/*主机地址类型：AF_INET*/</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> 	h_length;	    <span style=color:#75715e>/*主机地址长度：4字节32位*/</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>char</span> 	<span style=color:#f92672>**</span>h_addr_list;	<span style=color:#75715e>/*主机网络地址列表，以NULL结束*/</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>#define 	h_addr 	h_addr_list[0]; </span><span style=color:#75715e>//主机的第一个网络地址
</span></span></span></code></pre></div><p>示例代码</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fcntl.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netdb.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/stat.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>!=</span> <span style=color:#ae81ff>2</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;invalid args</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> hostent <span style=color:#f92672>*</span>he;
</span></span><span style=display:flex><span>    he <span style=color:#f92672>=</span> <span style=color:#a6e22e>gethostbyname</span>(argv[<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (he <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;h_name:%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, he<span style=color:#f92672>-&gt;</span>h_name);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;h_length:%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, he<span style=color:#f92672>-&gt;</span>h_length);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;h_addrtype:%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, he<span style=color:#f92672>-&gt;</span>h_addrtype);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; he<span style=color:#f92672>-&gt;</span>h_aliases[i] <span style=color:#f92672>!=</span> NULL; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;h_aliases[%d]:%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, he<span style=color:#f92672>-&gt;</span>h_aliases[i]);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;first ip:%s</span><span style=color:#ae81ff>\r\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>inet_ntoa</span>(<span style=color:#f92672>*</span>((<span style=color:#66d9ef>struct</span> in_addr <span style=color:#f92672>*</span>)he<span style=color:#f92672>-&gt;</span>h_addr)));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; he<span style=color:#f92672>-&gt;</span>h_addr_list[i] <span style=color:#f92672>!=</span> NULL; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;ip%d:%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>                   <span style=color:#a6e22e>inet_ntoa</span>(<span style=color:#f92672>*</span>(<span style=color:#66d9ef>struct</span> in_addr <span style=color:#f92672>*</span>)he<span style=color:#f92672>-&gt;</span>h_addr_list[i]));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;gethostbyname error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>hstrerror</span>(h_errno));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=ip到域名的转换函数>IP到域名的转换函数</h4><ul><li>查询IP对应的域名</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> hostent <span style=color:#f92672>*</span><span style=color:#a6e22e>gethostbyaddr</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>addr, <span style=color:#66d9ef>size_t</span> len, in family);
</span></span></code></pre></div><ul><li>示例代码</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netdb.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netinet/in.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[]) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> in_addr addr;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>inet_aton</span>(argv[<span style=color:#ae81ff>1</span>], <span style=color:#f92672>&amp;</span>addr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> hostent <span style=color:#f92672>*</span>he;
</span></span><span style=display:flex><span>    he <span style=color:#f92672>=</span> <span style=color:#a6e22e>gethostbyaddr</span>((<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>addr, <span style=color:#ae81ff>4</span>, AF_INET);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (he <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;h_name: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, he<span style=color:#f92672>-&gt;</span>h_name);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;gethostbyaddr error: %s&#34;</span>, <span style=color:#a6e22e>hstrerror</span>(h_errno));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=高级socket函数-1>高级Socket函数</h3><h4 id=recv和send>recv和send</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>recv</span>(<span style=color:#66d9ef>int</span> sockfd,<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> buf,<span style=color:#66d9ef>int</span> len, <span style=color:#66d9ef>int</span> flags);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>send</span>(<span style=color:#66d9ef>int</span> sockfd,<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> buf,<span style=color:#66d9ef>int</span> len,<span style=color:#66d9ef>int</span> flags);
</span></span></code></pre></div><ul><li>flags<ul><li><code>MSG_DONTROUTE</code>不路由——主机在本地网，不需路由。多网卡时，逐个搜索</li><li><code>MSG_OBB</code>带外数据——紧急数据</li><li><code>MSG_PEEK</code>不从缓存区移走数据——多进程共享数据，还可以用来查看缓存区数据</li><li><code>MSG_WAITALL</code>等待所有数据——发现文件结束符时（Crtl+D），函数也结束</li></ul></li></ul><h4 id=shutdown关闭连接>shutdown关闭连接</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>shutdown</span>(<span style=color:#66d9ef>int</span> sockfd,<span style=color:#66d9ef>int</span> howto); 
</span></span></code></pre></div><ul><li><code>howto = 0</code>对后来接收到的数据返回确认后丢弃</li><li><code>howto = 1</code>继续发送发送缓冲区未发送完的数据，然后发送FIN字段关闭写通道</li><li><code>howto = 2</code>关闭读写通道，任何进程不能再操作这个socket<ul><li>与<code>close</code>的区别<ul><li>shutdown操作连接通道，其他进程不能再使用已被关闭的通道；close操作描述符，其他进程仍然可以使用该socket描述符</li><li>close关闭应用程序与socket的接口，调用close之后进程不能再读写这个socket；shutdown可以只关闭一个通道，另一个通道仍然可以操作</li></ul></li></ul></li></ul><h2 id=udp与原始socket编程>UDP与原始Socket编程</h2><h3 id=udp-socket编程>UDP Socket编程</h3><p><img src=https://files.catbox.moe/k0q0ar.png alt></p><h4 id=recvfrom接受udp数据包><code>recvfrom</code>：接受UDP数据包</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>recvfrom</span>(<span style=color:#66d9ef>int</span> sockfd, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>buf, <span style=color:#66d9ef>int</span> len, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> flags,
</span></span><span style=display:flex><span>             <span style=color:#66d9ef>struct</span> socketaddr <span style=color:#f92672>*</span>from, <span style=color:#66d9ef>socklen_t</span> <span style=color:#f92672>*</span>addrlen);
</span></span></code></pre></div><h4 id=sendto发送udp数据包><code>sendto</code>：发送UDP数据包</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sendto</span>(<span style=color:#66d9ef>int</span> sockfd,<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>buf,<span style=color:#66d9ef>int</span> len,<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> flags,
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>struct</span> socketaddr <span style=color:#f92672>*</span>to,<span style=color:#66d9ef>int</span>  tolen); 
</span></span></code></pre></div><h4 id=udp服务器>UDP服务器</h4><ul><li>服务器不接受客户端连接，只需监听端口</li><li>循环服务器，可以交替处理各个客户端数据包</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;errno.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netdb.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netinet/in.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/time.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>!=</span> <span style=color:#ae81ff>2</span>) {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;argument invalid&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>short</span> port <span style=color:#f92672>=</span> atoi(argv[<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sockfd <span style=color:#f92672>=</span> socket(AF_INET, SOCK_DGRAM, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (sockfd <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;create socket error&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    sockaddr_in addr;
</span></span><span style=display:flex><span>    bzero(<span style=color:#f92672>&amp;</span>addr, <span style=color:#66d9ef>sizeof</span>(addr));
</span></span><span style=display:flex><span>    addr.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>    addr.sin_port <span style=color:#f92672>=</span> htons(port);
</span></span><span style=display:flex><span>    addr.sin_addr.s_addr <span style=color:#f92672>=</span> htonl(INADDR_ANY);
</span></span><span style=display:flex><span>    <span style=color:#75715e>//绑定服务器地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (bind(sockfd, (<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>addr, <span style=color:#66d9ef>sizeof</span>(addr)) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;bind error&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>32</span>];
</span></span><span style=display:flex><span>        sockaddr_in client_addr;
</span></span><span style=display:flex><span>        socklen_t addr_len;
</span></span><span style=display:flex><span>        <span style=color:#75715e>//接收客户端数据包
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> recvfrom(sockfd, buf, <span style=color:#ae81ff>16</span>, <span style=color:#ae81ff>0</span>, (<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>client_addr,
</span></span><span style=display:flex><span>                         <span style=color:#f92672>&amp;</span>addr_len);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            buf[n] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;recv:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> buf <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>timeval</span> tv;
</span></span><span style=display:flex><span>            gettimeofday(<span style=color:#f92672>&amp;</span>tv, NULL);
</span></span><span style=display:flex><span>            sprintf(buf, <span style=color:#e6db74>&#34;%d %d&#34;</span>, (<span style=color:#66d9ef>int</span>)tv.tv_sec, (<span style=color:#66d9ef>int</span>)tv.tv_usec);
</span></span><span style=display:flex><span>            <span style=color:#75715e>//利用recvfron中得到的地址回送数据包
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            sendto(sockfd, buf, strlen(buf), <span style=color:#ae81ff>0</span>, (<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>client_addr,
</span></span><span style=display:flex><span>                   <span style=color:#66d9ef>sizeof</span>(client_addr));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    close(sockfd);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=udp客户端>UDP客户端</h4><ul><li>客户端不用建立连接，第一次调用sendto函数时，<strong>UDP协议为这个UDP socket选择一个端口号，以后的发送和接受操作均使用这个端口号</strong>。</li><li>客户端可以接收来自任何主机的数据报</li><li>客户端可能永远阻塞（服务器主机崩溃）</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;errno.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netdb.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netinet/in.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>) {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;argument invalid&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>short</span> port <span style=color:#f92672>=</span> atoi(argv[<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sockfd <span style=color:#f92672>=</span> socket(AF_INET, SOCK_DGRAM, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (sockfd <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;create socket error&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sockaddr_in addr;
</span></span><span style=display:flex><span>    bzero(<span style=color:#f92672>&amp;</span>addr, <span style=color:#66d9ef>sizeof</span>(addr));
</span></span><span style=display:flex><span>    addr.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>    addr.sin_port <span style=color:#f92672>=</span> htons(port);
</span></span><span style=display:flex><span>    addr.sin_addr.s_addr <span style=color:#f92672>=</span> htonl(INADDR_ANY);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>==</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>&amp;&amp;</span> strcmp(argv[<span style=color:#ae81ff>2</span>], <span style=color:#e6db74>&#34;-c&#34;</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//记录服务器地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        connect(sockfd, (<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>addr, <span style=color:#66d9ef>sizeof</span>(addr));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>10</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>16</span>];
</span></span><span style=display:flex><span>        sprintf(buf, <span style=color:#e6db74>&#34;%d hello&#34;</span>, getpid());
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;send:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> buf <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>==</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>&amp;&amp;</span> strcmp(argv[<span style=color:#ae81ff>2</span>], <span style=color:#e6db74>&#34;-c&#34;</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>//发送时不需要服务器地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            n <span style=color:#f92672>=</span> sendto(sockfd, buf, strlen(buf), <span style=color:#ae81ff>0</span>, NULL, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>//发送时需要服务器地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            n <span style=color:#f92672>=</span> sendto(sockfd, buf, strlen(buf), <span style=color:#ae81ff>0</span>, (<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>addr,
</span></span><span style=display:flex><span>                       <span style=color:#66d9ef>sizeof</span>(addr));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> recvfrom(sockfd, buf, <span style=color:#ae81ff>16</span>, <span style=color:#ae81ff>0</span>, NULL, NULL);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            buf[n] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;recv:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> buf <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        sleep(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    close(sockfd);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=有连接的udp-socket>有连接的UDP Socket</h4><ul><li>在UDP Socket上调用connect函数，但不会产生3次握手过程，只记录连接另一方的IP和端口，connect函数马上返回</li></ul><h4 id=使用udp-socket的说明>使用UDP Socket的说明</h4><ul><li>UDP协议不保证数据包可靠到达（<strong>超时和重发机制</strong>）</li><li>UDP协议不保证数据报顺序到达（<strong>数据报序列号</strong>区分）</li><li>UDP协议没有流控</li></ul><h4 id=udp广播>UDP广播</h4><h5 id=server-1>server</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstring&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sockfd;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((sockfd <span style=color:#f92672>=</span> socket(AF_INET, SOCK_DGRAM, <span style=color:#ae81ff>0</span>)) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> on <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST <span style=color:#f92672>|</span> SO_REUSEADDR, <span style=color:#f92672>&amp;</span>on,
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr_in</span> addr;
</span></span><span style=display:flex><span>    memset(<span style=color:#f92672>&amp;</span>addr, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr_in</span>));
</span></span><span style=display:flex><span>    addr.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>    addr.sin_addr.s_addr <span style=color:#f92672>=</span> inet_addr(<span style=color:#e6db74>&#34;255.255.255.255&#34;</span>);
</span></span><span style=display:flex><span>    addr.sin_port <span style=color:#f92672>=</span> htons(<span style=color:#ae81ff>8080</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> msg[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Broadcast Message: Hello!&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((n <span style=color:#f92672>=</span> sendto(sockfd, msg, strlen(msg), <span style=color:#ae81ff>0</span>, (<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>addr,
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>sizeof</span>(addr))) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;msg=%s, msgLen=%ld, sendBytes=%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, msg, strlen(msg), n);
</span></span><span style=display:flex><span>    close(sockfd);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=client-1>client</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstring&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netinet/in.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sockfd;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((sockfd <span style=color:#f92672>=</span> socket(AF_INET, SOCK_DGRAM, <span style=color:#ae81ff>0</span>)) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> on <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, <span style=color:#f92672>&amp;</span>on, <span style=color:#66d9ef>sizeof</span> on);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr_in</span> addr;
</span></span><span style=display:flex><span>    memset(<span style=color:#f92672>&amp;</span>addr, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(sockaddr_in));
</span></span><span style=display:flex><span>    addr.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>    addr.sin_port <span style=color:#f92672>=</span> htons(<span style=color:#ae81ff>8080</span>);
</span></span><span style=display:flex><span>    addr.sin_addr.s_addr <span style=color:#f92672>=</span> INADDR_ANY;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (bind(sockfd, (<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>addr, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr</span>)) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>256</span>];
</span></span><span style=display:flex><span>    socklen_t addr_len <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr_in</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((n <span style=color:#f92672>=</span> recvfrom(sockfd, buf, <span style=color:#ae81ff>256</span>, <span style=color:#ae81ff>0</span>, (<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>addr,
</span></span><span style=display:flex><span>                      <span style=color:#f92672>&amp;</span>addr_len)) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    buf[n] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;\0&#39;</span>;
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;Received: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, buf);
</span></span><span style=display:flex><span>    close(sockfd);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=原始socket编程>原始Socket编程</h3><h4 id=概述>概述</h4><ul><li>TCP、UDP Socket对TCP协议和UDP协议做了封装来简化编程接口，但失去了对IP数据包操作的灵活性</li><li>原始Socket直接针对IP数据包编程，具有更强的灵活性</li><li>可以编写基于IP协议的高层协议</li></ul><h4 id=发送数据包>发送数据包</h4><ul><li>没有调用<code>connect</code>函数绑定对方地址时必须用<code>sendto</code>或<code>sendmsg</code>发送数据包；调用<code>connect</code>绑定对方IP地址后，可以使用<code>write</code>和<code>send</code>发送数据包</li></ul><h4 id=接收数据包>接收数据包</h4><ul><li>UDP包和TCP包</li><li>大多数ICMP包的拷贝将传递给原始socket</li><li>其他类型的数据包的拷贝传递给匹配的socket</li><li>内核不能识别的IP数据包将传送给匹配的原始socket</li></ul><h2 id=linux进程与信号机制>Linux进程与信号机制</h2><h3 id=概述-1>概述</h3><ul><li>linux进程是系统进行资源分配和调度的基本单位。</li><li>进程的状态：<ol><li>新建</li><li>运行</li><li>阻塞</li><li>就绪</li><li>完成</li></ol></li><li>按继承关系分类<ol><li>父、子、孙进程</li><li>兄弟进程</li><li>孤儿进程</li></ol></li></ul><h3 id=创建进程>创建进程</h3><ul><li><code>pid_t fork(void);</code><ul><li>功能：创建新的进程，调用者成为父进程，产生的新进程成为子进程</li><li>返回值：<ul><li><code>> 0</code>, 子进程的id，只在父进程中返回</li><li><code>-1</code>, 调用失败</li><li><code>=0</code>, 只在子进程中返回</li></ul></li><li>头文件：<code>#include &lt;sys/types.h></code> <code>#include &lt;unistd.h></code></li></ul></li><li>fork的原理<ul><li>两次返回<ul><li>调用fork的进程（父进程）返回正整数（子进程ID）</li><li>在新创建的进程（子进程）中返回0，表示是子进程</li></ul></li><li>在调用fork时发生了什么<ul><li>系统创建新进程，并为该进程准备数据段、堆栈段和代码段</li><li>代码段使用和父进程相同的代码段</li><li>父进程的数据段和堆栈段被复制（<a href=https://zh.wikipedia.org/wiki/%E5%AF%AB%E5%85%A5%E6%99%82%E8%A4%87%E8%A3%BD>copy on write, 写入时复制</a>）给子进程
<img src=https://files.catbox.moe/6yhyeq.png alt></li></ul></li><li>子进程和父进程共享的内容<ul><li><strong>代码段</strong></li><li>用户标识符</li><li>环境变量</li><li><strong>打开的文件描述符(Socket描述符)</strong></li><li>根目录</li><li>当前工作目录</li><li>创建文件的模式</li><li>&#9888;&#xfe0f; 数据段和堆栈段通过复制方式共享，因此子进程或父进程修改了变量值后不会影响另一个进程，即使是全局变量。</li></ul></li><li>父子进程执行顺序随机</li></ul></li><li>执行另一个程序<ul><li><code>int execve(const char *path,char * const argv[],char *envp);</code>只有execve是真正的系统调用</li><li><code>int execl(const char *path, const char * argv,…);</code></li></ul></li><li>注意：<ol><li><code>fork()</code>和<code>exec()</code>这两个函数，前者用于并行执行，父、子进程执行相同正文中的不同部分；后者用于调用其他进程，进程执行新的正文。</li><li><code>fork()</code>以后，父、子进程共享代码段，并只重新创建数据有改变的页（段页式管理）</li><li><code>exec()</code>以后，建立新的代码段，用被调用程序的内容填充。</li><li>前者的子进程执行后续的公共代码，后者的子进程不执行后续的公共代码</li></ol></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    pid_t pid;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((pid <span style=color:#f92672>=</span> fork()) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 子进程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Son Process&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (pid <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 父进程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Father Process&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Error&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=创建守护进程>创建守护进程</h4><ul><li><code>fork()</code>子进程，父进程退出</li><li>子进程建立新会话<code>setsid()</code></li><li>改变当前工作目录chdir(不是必须)</li><li>重设文件掩码(不是必须)<ul><li>子进程会继承父进程的掩码</li><li>增加子进程程序的灵活性</li><li><code>umask(0);</code></li></ul></li><li>关键文件描述符（不是必须）<ul><li>close(0), close(1), close(2)</li><li>释放资源</li></ul></li><li>执行核心工作</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdlib&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;signal.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/param.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/stat.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fcntl.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>argv[]) {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 1. 调用fork，父进程退出，子进程继续运行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    pid_t pid <span style=color:#f92672>=</span> fork();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (pid <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (pid <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2. 调用setsid变成会长
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 会长就是一个守护进程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    setsid();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3. 忽略SIGHUP信号
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    signal(SIGHUP, SIG_IGN);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 再次fork，父进程（session的头进程）退出
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> ((pid <span style=color:#f92672>=</span> fork()) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (pid <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 4. chdir 改变当前工作目录
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    chdir(<span style=color:#e6db74>&#34;/tmp&#34;</span>);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 5. 重设文件掩码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    umask(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 6. 关闭所有打开的文件描述符
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> NOFILE; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        close(i);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 7. 为标准输入（0），标准输出（1）、标准错误输出（2）打开新的文件描述符
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> fd_rd <span style=color:#f92672>=</span> open(<span style=color:#e6db74>&#34;/dev/null&#34;</span>, O_RDONLY);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> fd_wr <span style=color:#f92672>=</span> open(<span style=color:#e6db74>&#34;/root/deamon.log&#34;</span>, O_WRONLY);
</span></span><span style=display:flex><span>    dup(fd_rd);
</span></span><span style=display:flex><span>    dup(fd_wr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 8. 处理SICHLD，避免守护进程的子进程称为僵尸进程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    signal(SIGCHLD, SIG_IGN);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 让子进程一直活着
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span> (true) {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=信号机制>信号机制</h3><h4 id=信号分类>信号分类</h4><ul><li>常用信号：<ul><li><code>SIGALARM</code>——计时器到时</li><li><code>SIGCHLD</code>——子进程停止时通知父进程</li><li><code>SIGKILL</code>——终止进程</li><li><code>SIGSTOP</code>——停止进程（暂停）</li><li><code>SIGINT</code>——中断字符</li></ul></li><li>可靠信号和非可靠信号</li><li>实时信号和非实时信号</li></ul><h4 id=发送信号>发送信号</h4><ul><li><code>int kill(pid_t pid, int sig)</code></li><li><code>int raise(int sig)</code>向进程自身发送信号</li><li><code>unsigned int alarm(unsigned int seconds)</code></li><li><code>void abort()</code></li><li><code>int sigqueue(pid_t pid, int sig, const union sigval val)</code></li><li>用<code>kill</code>发送信号</li><li>用特定的键盘字符产生信号<ul><li><code>CTRL+C</code>产生<strong>SIGINT</strong></li><li><code>CTRL+BACKSPACE</code>产生<strong>SIGQUIT</strong></li></ul></li></ul><h4 id=接收信号>接收信号</h4><ul><li><code>int sigcation(int signum, const struct sigaction *act, struct sigaction *oldact);</code></li><li><code>sigaction结构</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> sigaction {                  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>sa_handler)(<span style=color:#66d9ef>int</span>);  			            <span style=color:#75715e>// 函数指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>sa_sigaction)(<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>siginfo_t</span> <span style=color:#f92672>*</span>, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>); <span style=color:#75715e>//函数指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>sigset_t</span> sa_mask; 		                        <span style=color:#75715e>// 屏蔽的信号集
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>int</span> sa_flags;			                        <span style=color:#75715e>// 标志，SA_SIGINFO
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>sa_restorer)(<span style=color:#66d9ef>void</span>); 	                    <span style=color:#75715e>// 已废弃
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h4 id=示例>示例</h4><p>INT信号处理</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;csignal&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>signalHandler</span>(<span style=color:#66d9ef>int</span> signum) {
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Catched signal: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> signum <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// exit(signum);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 注册信号SIGNAL和信号处理程序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    signal(SIGINT, signalHandler);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (true) {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Going to sleep...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        sleep(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=进程终止>进程终止</h3><p><code>exit()</code></p><h3 id=处理子进程死亡>处理子进程死亡</h3><ul><li>僵尸进程（zombie）<ul><li>子进程终止时如果父进程存在且未处理SIGCHLD信号则子进程变为僵尸进程</li><li>僵尸进程占据系统进程表项</li><li>对比孤儿进程<ul><li>子进程终止，父进程并没有调用 wait/waitpid 获取子进程的终止状态，且父进程还没有结束（子进程没有被 init 收养），那么当子进程结束后，它的进程描述符仍然保存在系统中，这就成了僵尸进程。</li><li>子进程还没有结束，但是父进程结束了，这个时候子进程失去其唯一的父进程，成为了孤儿进程。</li></ul></li></ul></li><li><strong>清理僵尸进程的方法1</strong><ul><li>忽略SIGCHLD信号（使用信号处理函数（SIG_IGN)</li><li>忽略SIGCHLD信号时，系统将清除子进程的进程表项，这种方法依赖于Linux版本的实现</li></ul></li><li>终端操作<ul><li><code>top</code>，查看动态进程状态</li><li>`ps -A -ostat, ppid, pid, cmd | grep -e &lsquo;^[Zz]&rsquo;，查看僵尸进程</li><li><code>kill -HUP xxxx</code>, 清除僵尸</li></ul></li><li><strong>清除僵尸进程的方法2</strong><ul><li>调用<code>wait</code>或<code>waitpid</code>等待子进程<ul><li><code>pid_t wait(int *status);</code>等待任意子进程终止，没有子进程终止时阻塞，如果没有子进程返回<code>-1</code></li><li><code>pid_t waitpid(int pid, int *status, int option)</code></li><li>此方法没有兼容性问题</li></ul></li></ul></li><li><strong>清除僵尸进程的方法3</strong><ul><li>捕获SIGCHLD信号</li></ul></li><li><strong>清除僵尸进程的方法4</strong><ul><li>调用<code>fork()</code>两次，使得子进程成为孤儿进程，由init管理<ul><li>这种方法第一次调用fork产生的子进程可能成为僵尸进程</li><li>这种方法第二次调用fork产生的子进程由init处理子进程退出，不会成为僵尸进程</li></ul><blockquote><p>通俗点讲，就是爷爷第一次 fork 生一个老爸，老爸出生后立刻 fork 生下儿子，这个时候老爸的任务就结束了，可以死掉了 (exit)，这个时候儿子被强大的 init 收养，爷爷爱干啥干啥，从而儿子永远不会成为僵尸进程。</p></blockquote></li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/wait.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pid_t</span> pid;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((pid <span style=color:#f92672>=</span> <span style=color:#a6e22e>fork</span>()) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        pid <span style=color:#f92672>=</span> <span style=color:#a6e22e>fork</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (pid <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 父亲生下儿子直接退出，儿子会被收养
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>sleep</span>(<span style=color:#ae81ff>0.5</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;I&#39;m son after second fork.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;my parent&#39;s pid: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>getppid</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 爷爷生下父亲后直接等待为其收尸
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>waitpid</span>(pid, NULL, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 爷爷尽情快活
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=进程同步>进程同步</h3><p>当fork调用成功后，父子进程各做各的事情，但当父进程的工作告一段落，需要用到子进程的结果时，它就停下来调用wait，一直等到子进程运行结束，然后利用子进程的结果继续执行。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/wait.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pid_t</span> pc, pr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> status;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    pc <span style=color:#f92672>=</span> <span style=color:#a6e22e>fork</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (pc <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Error occured on forking.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (pc <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* 子进程的工作 */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;son</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* 父进程的工作 */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;father</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        pr <span style=color:#f92672>=</span> <span style=color:#a6e22e>wait</span>(<span style=color:#f92672>&amp;</span>status);
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* 利用子进程的结果 */</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=linux进程间通信ipc>Linux进程间通信（IPC)</h2><h3 id=管道>管道</h3><ul><li>单向通信，实现双向通信需创建两个管道</li><li>只适用于<strong>父子间</strong>进程通信</li></ul><h4 id=使用管道>使用管道</h4><ol><li>用<code>pipe</code>创建两个管道<code>pipe1</code>和<code>pipe2</code></li><li><code>pipe[0]</code>读，<code>pipe[1]</code>写</li><li><code>fork()</code>创建子进程</li><li>父进程用<code>pipe1</code>写数据（关闭<code>pipe1</code>读端口），<code>pipe2</code>读数据（关闭<code>pipe2</code>写端口）</li><li>子进程用<code>pipe1</code>读数据（关闭<code>pipe1</code>写端口），<code>pipe2</code>写数据（关闭<code>pipe2</code>读端口）</li></ol><h4 id=示例-1>示例</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;errno.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> pipe1[<span style=color:#ae81ff>2</span>], pipe2[<span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> pstr[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;parent data&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> cstr[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;child data&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>100</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (pipe(pipe1) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> pipe(pipe2) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;pipe error&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    pid_t pid <span style=color:#f92672>=</span> fork();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (pid <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 父进程,用管道1写数据,管道2读数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        close(pipe1[<span style=color:#ae81ff>0</span>]);  <span style=color:#75715e>//关闭pipe1读端口
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        close(pipe2[<span style=color:#ae81ff>1</span>]);  <span style=color:#75715e>//关闭pipe2写端口
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        write(pipe1[<span style=color:#ae81ff>1</span>], pstr, <span style=color:#66d9ef>sizeof</span>(pstr));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (read(pipe2[<span style=color:#ae81ff>0</span>], buf, <span style=color:#ae81ff>100</span>) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;parent received:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> buf <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (pid <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 子进程用管道1读数据,管道2写数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        close(pipe1[<span style=color:#ae81ff>1</span>]);  <span style=color:#75715e>//关闭pipe1写端口
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        close(pipe2[<span style=color:#ae81ff>0</span>]);  <span style=color:#75715e>//关闭pipe2读端口
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (read(pipe1[<span style=color:#ae81ff>0</span>], buf, <span style=color:#ae81ff>100</span>) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;child received:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> buf <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        write(pipe2[<span style=color:#ae81ff>1</span>], cstr, <span style=color:#66d9ef>sizeof</span>(cstr));
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;fork error&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=命名管道>命名管道</h3><h4 id=特点>特点</h4><ul><li>与一个<strong>路径名</strong>相关联，以文件形式存在于文件系统中</li><li>该文件名所对应的文件没有数据只是为了便于其他进程引用</li><li>可以在兄弟进程通信</li></ul><h4 id=创建>创建</h4><p><code>int mkfifo(char *pathname, mode_t mode);</code></p><h4 id=使用>使用</h4><ul><li>写进程<code>mkfifo</code>创建命名管道</li><li>写进程<code>open</code>以<strong>写阻塞</strong>方式打开管道</li><li>读进程<code>open</code>以<strong>读阻塞</strong>方式打开管道</li><li>写进程调用<code>write</code>写，读进程<code>read</code>读出数据</li></ul><h4 id=示例-2>示例</h4><p>fifo_server.cpp</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;errno.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fcntl.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;signal.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/stat.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/time.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/wait.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define FIFO_NAME &#34;/home/fffzlfk/fifo_test&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> pstr[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;server data&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (mkfifo(FIFO_NAME, O_CREAT <span style=color:#f92672>|</span> O_EXCL) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> (errno <span style=color:#f92672>!=</span> EEXIST))
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;create fifo error&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> fd;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>&amp;&amp;</span> strcmp(argv[<span style=color:#ae81ff>1</span>], <span style=color:#e6db74>&#34;-b&#34;</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        fd <span style=color:#f92672>=</span> open(FIFO_NAME, O_WRONLY, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        fd <span style=color:#f92672>=</span> open(FIFO_NAME, O_WRONLY <span style=color:#f92672>|</span> O_NONBLOCK, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (fd <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;open success&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        perror(<span style=color:#e6db74>&#34;open fail&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> write_num <span style=color:#f92672>=</span> write(fd, pstr, <span style=color:#66d9ef>sizeof</span>(pstr));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (write_num <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (errno <span style=color:#f92672>=</span> EAGAIN) cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;write fifo error,try later:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;real write num is:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> write_num <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>fifo_client.cpp</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;errno.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fcntl.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;signal.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/stat.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/time.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/wait.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define FIFO_NAME &#34;/home/fffzlfk/fifo_test&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>1024</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> fd;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>&amp;&amp;</span> strcmp(argv[<span style=color:#ae81ff>1</span>], <span style=color:#e6db74>&#34;-b&#34;</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        fd <span style=color:#f92672>=</span> open(FIFO_NAME, O_RDONLY, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        fd <span style=color:#f92672>=</span> open(FIFO_NAME, O_RDONLY <span style=color:#f92672>|</span> O_NONBLOCK, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (fd <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;open success&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        perror(<span style=color:#e6db74>&#34;open fail&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> read_num <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>;
</span></span><span style=display:flex><span>    memset(buf, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(buf));
</span></span><span style=display:flex><span>    read_num <span style=color:#f92672>=</span> read(fd, buf, <span style=color:#ae81ff>1024</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (read_num <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (errno <span style=color:#f92672>==</span> EAGAIN) cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;no data,try later:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;real read bytes:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> read_num <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;read data:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> buf <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//删除管道文件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// unlink(FIFO_NAME);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=unix域socket>Unix域Socket</h3><ul><li>不是真正的网络协议</li><li>提供<strong>同一台机器</strong>的的进程间通信</li><li>是双向通道</li><li>分为命名和非命名两种</li></ul><h4 id=命名unix域socket>命名Unix域Socket</h4><ul><li>特点<ul><li>服务器可以接收多个客户端连接请求</li><li>客户端调用函数connect服务器连接<ul><li>connect使用的socket应该是<strong>已打开的UNIX域socket</strong></li><li>客户端必须拥有打开socket地址所指文件<strong>权限</strong></li><li>监听socket的连接队列满时connect立刻返回错误</li></ul></li></ul></li></ul><h4 id=非命名unix域socket>非命名Unix域Socket</h4><ul><li>特点<ul><li>无名的</li><li><strong>全双工</strong></li><li><strong>不需要连接</strong></li><li>父子进程间通信使用socketpair</li></ul></li></ul><h2 id=io模型>I/O模型</h2><h3 id=阻塞io模型>阻塞I/O模型</h3><ul><li>产生阻塞的原因——时间片调度算法</li><li>好处——阻塞进程不占用CPU时间</li><li>产生阻塞的函数——读、写、建立连接、接受连接<ul><li>读：<code>read</code>、<code>readv</code>、<code>recv</code>、<code>recvfrom</code>和<code>recvmsg</code></li><li>写：<code>write</code>、<code>writev</code>、<code>send</code>、<code>sendto</code>和<code>sendmsg</code></li><li>建立连接：<code>connect</code></li><li>接受连接：<code>accept</code></li></ul></li><li>超时控制<ul><li>调用alarm函数设置超时</li><li>设置socket选项——设置<code>SO_RCVTIMEO</code>和<code>SO_SNDTIMEO</code>选项</li></ul></li></ul><h3 id=非阻塞io模型>非阻塞I/O模型</h3><ul><li>设置Socket为非阻塞方式<ul><li>函数<code>fcntl</code><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> flags;
</span></span><span style=display:flex><span>flag <span style=color:#f92672>=</span> <span style=color:#a6e22e>fcntl</span>(sockfd,F_GETFL,<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>fcntl</span>(sockfd,F_SETFL,flag<span style=color:#f92672>|</span>O_NONBLOCK);
</span></span></code></pre></div></li><li>函数<code>ioctl</code><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> on<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>ioctl</span>(sockfd,FIONBIO,<span style=color:#f92672>&amp;</span>on);
</span></span></code></pre></div></li></ul></li><li>检查操作是否可以完成的方式（轮询）</li></ul><h3 id=输入输出多路复用io模型>输入输出多路复用I/O模型</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>select</span>(<span style=color:#66d9ef>int</span> maxfd,  <span style=color:#66d9ef>struct</span> fd_set<span style=color:#f92672>*</span> rdset,  <span style=color:#66d9ef>struct</span> fd_set<span style=color:#f92672>*</span> wrset, 
</span></span><span style=display:flex><span>		   <span style=color:#66d9ef>struct</span> fd_set<span style=color:#f92672>*</span> exset,  <span style=color:#66d9ef>struct</span> timeval<span style=color:#f92672>*</span> timeout);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>FD_SET</span>(<span style=color:#66d9ef>int</span> fd,fd_set <span style=color:#f92672>*</span>fdset)   <span style=color:#75715e>//将fd加入到fdset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>FD_CLR</span>(<span style=color:#66d9ef>int</span> fd,fd_set <span style=color:#f92672>*</span>fdset)   <span style=color:#75715e>//将fd从fdset里面清除
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>FD_ZERO</span>(fd_set <span style=color:#f92672>*</span>fdset)         <span style=color:#75715e>//从fdset中清除所有的文件描述符
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>FD_ISSET</span>(<span style=color:#66d9ef>int</span> fd,fd_set <span style=color:#f92672>*</span>fdset) <span style=color:#75715e>//判断fd是否在fdset集合中
</span></span></span></code></pre></div><p>select()可以设置超时，使长期没有文件描述符就绪时，进程可以跳出阻塞状态。select()的第一个参数 maxfd 是集合中最大的文件描述符加1，如：一个包含3个套接字描述符的集合{12，23，30}，那么 maxfd 就应该是30+1=31。</p><p>在我们调用select( )时，进程会一直阻塞到以下的一种情况发生:</p><ul><li>有文件可以读，包括出现错误；</li><li>有文件可以写，包括出现错误；</li><li>超时所设置的时间到；</li><li>被信号中断。</li></ul><h3 id=信号驱动io模型>信号驱动I/O模型</h3><ol><li>设置SIGIO信号处理函数</li><li>设置socket描述符所有者</li><li>允许这个socket进行信号驱动I/O</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sigio_handler</span>(<span style=color:#66d9ef>int</span> signo) {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sockfd;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> on <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    signal(SIGIO, sigio_handler);
</span></span><span style=display:flex><span>    fcntl(sockfd, F_SETOWN, getpid()); <span style=color:#75715e>// 设置套接字所有者为当前进程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ioctl(sockfd, FIOASYNC, <span style=color:#f92672>&amp;</span>on);      <span style=color:#75715e>// 启动信号驱动模式
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=服务器模型>服务器模型</h2><h3 id=网络服务器分类>网络服务器分类</h3><ul><li>循环服务器：同一时刻只能处理一个客户端请求</li><li>并发服务器：同一时刻可以处理多个客户端请求</li><li>UDP和TCP服务器模型<ul><li>UDP服务器通常采用循环服务器模型</li><li>TCP服务器通常采用并发服务器模型</li></ul></li></ul><h3 id=循环服务器模型>循环服务器模型</h3><h4 id=udp循环服务器模型>UDP循环服务器模型</h4><p><img src=https://ftp.bmp.ovh/imgs/2021/05/006763a9f8b52346.png alt></p><h4 id=tcp循环服务器模型>TCP循环服务器模型</h4><p><img src=https://ftp.bmp.ovh/imgs/2021/05/0ef562a30cd8c6b8.png alt></p><h3 id=并发服务器模型>并发服务器模型</h3><h4 id=ucp并发服务器模型>UCP并发服务器模型</h4><p><img src=https://ftp.bmp.ovh/imgs/2021/05/034f12814488cd5f.png alt></p><h4 id=tcp并发服务器模型>TCP并发服务器模型</h4><ul><li>一个子进程对应一个客户端<ul><li>创建子进程开销大，适合长时间客户请求（如FTP）</li><li>客户端数量大、请求时间短会大大降低效率（如HTTP）
<img src=https://ftp.bmp.ovh/imgs/2021/05/05f64327a35f8e4d.png alt></li></ul></li><li>延迟创建子进程<ul><li>处理短请求以循环方式完成</li><li>处理时间长的请求以并发方式完成
<img src=https://ftp.bmp.ovh/imgs/2021/05/1d8fd44e6068663b.png alt></li></ul></li><li>预创建子进程<ul><li>数量固定<ul><li>所有进程调用accept，无连接时将睡眠</li><li>有连接到来时所有进程被唤醒</li><li>某一个进程接受连接后，其余连接继续睡眠
<img src=https://i.loli.net/2021/05/18/ctweTXfW5zx1h4E.png alt></li></ul></li><li>动态子进程数<ul><li>父进程与子进程通过管道通信</li><li>子进程接收连接时给父进程发1，关闭时发0</li><li>父进程收到1时，检查空闲子进程数是否小于上限，小于则创建新的子进程</li><li>父进程收到0时，检查空闲子进程数是否大于上限，大于则终止一些子进程
<img src=https://i.loli.net/2021/05/18/8IV7OS2vrqAayew.png alt></li></ul></li></ul></li><li>多路复用I/O<ul><li>select函数检查侦听socket是否有连接到达、已连接socket是否有数据到达、已连接socket是否可以写数据</li><li>在测试是否可读的描述符集合rdset中同时包含侦听socket和已连接socket，在测试是否可写描述符集合中包含已连接socket，就可以实现多路复用</li></ul></li></ul><h4 id=linux-epoll>Linux epoll</h4><ul><li>一种多路复用模型</li><li>对比select<ul><li><p>select</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> <span style=color:#a6e22e>select</span>(maxfd<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>&amp;</span>rds, NULL, NULL, <span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> fdset_size; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>FD_ISSET</span>(allFD[i],<span style=color:#f92672>&amp;</span>rds)) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>handleEvent</span>(allFD[i]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>epoll</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> <span style=color:#a6e22e>epoll_wait</span>(epfd, events, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n;i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>handleEvent</span>(events[n]);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li></ul><h2 id=带外数据oob>带外数据（OOB）</h2><p>带外数据（Out Of Band）：传输层使用带外数据发送重要数据</p><p>紧急状态</p><ul><li>发送方TCP协议保证紧急状态能够立即发送</li><li>接收方通过信号<code>SIGURG</code>或<code>select</code>函数得知紧急状态</li></ul><h3 id=tcp带外数据发送>TCP带外数据发送</h3><ul><li>TCP只支持<strong>1字节</strong>带外数据</li><li>TCP使用URG标志位和紧急指针指明带外数据：紧急指针=带外数据位置+1
<img src=https://i.loli.net/2021/05/25/DsXykvhjlIaTzY3.png alt></li></ul><h3 id=发送tcp带外数据的函数>发送TCP带外数据的函数</h3><p><code>send</code>函数和标志<code>MSG_OOB</code></p><p>一个进程已经往TCP连接的发送缓冲区写入了N个字节的普通数据，然后该进程又向这个连接写入了3字节的带外数据“abc”。此时，待发送的TCP报文段头部将被设置为URG标志，并将紧急指针设置为指向带外数据的下一字节。</p><ul><li>发送单个字节，这个字节被认为是带外数据<code>send(sockfd, "A", 1, MSG_OOB);</code></li><li>发送多个字节，只有最后一个字节被认为是带外数据<code>send(sockfd, "ABC", 3, MSG_OOB);</code>，其他数据被当作普通数据。</li></ul><h3 id=tcp接收带外数据的过程>TCP接收带外数据的过程</h3><p>TCP接收端在收到紧急指针标志时检查紧急指针，然后根据紧急指针的位置确定带外数据的位置，并将它读入一个特殊的缓存中（1字节），称之为带外缓存。</p><ul><li>未设置<code>SO_OOBINLINE</code>选项时新到来的带外数据将覆盖未处理的带外数据。</li><li>设置了<code>SO_OOBINLINE</code>选项时新到来的带外数据不会覆盖未处理的带外数据，但未处理的带外数据将会变成普通数据。</li></ul><h3 id=代码>代码</h3><ul><li><a href="https://paste.blinking.fun/?id=60ac9fb8b2b1d74df21cc730">./sigurg port</a>，读数据，带外数据在信号处理中</li><li><a href="https://paste.blinking.fun/?id=60aca00be2fa0d4db8addc63">./oobserver port</a>，接受连接并给客户机发包含带外数据的包</li><li><a href="https://paste.blinking.fun/?id=60aca054b2b1d74df21cc804">./oobclient port</a><code>-i</code>，oob_inline</li></ul><h2 id=复习>复习</h2><ul><li><p>一台工作于内外网模式的主机，具有一个外网地址IP_OUTTER和一个内网地址192.168.1，内网的掩码为192.168.1.125。该主机可将外网用户的请求广播给内网用户。请设计和实现该主机程序。</p><ul><li>问题分析和方案设计<ul><li>TCP协议具有稳定可靠的特性，本题中外网通信属于单播，使用TCP协议能够具有良好性能，因此外网通信使用TCP套接字。</li><li>内网涉及到广播，适合使用UDP协议进行工作，因此内网采用UDP套接字工作。</li><li>主机采用单进程、阻塞式工作。</li></ul></li><li>编程<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstring&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netinet/in.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> port <span style=color:#f92672>=</span> <span style=color:#ae81ff>8080</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sockt, connfd, socku;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr_in</span> addr, addrX;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>2048</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((sockt <span style=color:#f92672>=</span> socket(AF_INET, SOCK_STREAM, <span style=color:#ae81ff>0</span>)) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    bzero(<span style=color:#f92672>&amp;</span>addr, <span style=color:#66d9ef>sizeof</span>(addr));
</span></span><span style=display:flex><span>    addr.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>    addr.sin_port <span style=color:#f92672>=</span> htons(port);
</span></span><span style=display:flex><span>    addr.sin_addr.s_addr <span style=color:#f92672>=</span> htonl(INADDR_ANY);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((bind(sockt, (sockaddr <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>addr, <span style=color:#66d9ef>sizeof</span>(addr))) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (listen(sockt, <span style=color:#ae81ff>5</span>) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr_in</span> cli_addr;
</span></span><span style=display:flex><span>    socklen_t sin_size <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr_in</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>        connfd <span style=color:#f92672>=</span> accept(sockt, (sockaddr <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>cli_addr, <span style=color:#f92672>&amp;</span>sin_size);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (connfd <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> read(connfd, buf, <span style=color:#ae81ff>2048</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ((socku <span style=color:#f92672>=</span> socket(AF_INET, SOCK_DGRAM, <span style=color:#ae81ff>0</span>)) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        bzero(<span style=color:#f92672>&amp;</span>addrX, <span style=color:#66d9ef>sizeof</span>(addr));
</span></span><span style=display:flex><span>        addrX.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>        addrX.sin_port <span style=color:#f92672>=</span> htons(port);
</span></span><span style=display:flex><span>        addrX.sin_addr.s_addr <span style=color:#f92672>=</span> inet_addr(<span style=color:#e6db74>&#34;192.168.1.1&#34;</span>);
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> sendto(socku, buf, n, <span style=color:#ae81ff>0</span>, (sockaddr <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>addrX, <span style=color:#66d9ef>sizeof</span>(addrX));
</span></span><span style=display:flex><span>        close(socku);
</span></span><span style=display:flex><span>        close(sockt);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><p>有一台服务器，可以为多个客户机同时提供两个整数的乘法和除法运算，请设计和实现该服务器。提示：需考虑应用层协议、僵尸进程的清除等问题。</p><ul><li>问题分析和方案设计<ul><li>本题需要同时为多个客户机服务，应采用并发方式；</li><li>对于整数、要考虑字节顺序转换；</li><li>除法要考虑除0问题；</li><li>设计服务器接收数据格式如下：<ul><li>int mType (运算类型：0-乘、1-除)</li><li>n1(整数1)，n2(整数2)</li></ul></li><li>服务器发送数据格式如下：<ul><li>int mRet(0-正确、1-错误)</li><li>n（运算结果）</li></ul></li><li>工作于TCP方式。</li></ul></li><li>编程<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sigchild_handler</span>(<span style=color:#66d9ef>int</span> sig) {
</span></span><span style=display:flex><span>    wait(NULL);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>main() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sock, connfd;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr_in</span> addr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sigaction</span> sigact;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>short</span> mRet, mType;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n, n1, n2;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>1024</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sigact.sa_handler <span style=color:#f92672>=</span> sigchild_handler;
</span></span><span style=display:flex><span>    sigact.sa_mask <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    sigact.sa_flags <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    sigaction(SIGCHILD, <span style=color:#f92672>&amp;</span>sigact, NULL);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((sock <span style=color:#f92672>=</span> socket(AF_INET, SOCK_STREAM, <span style=color:#ae81ff>0</span>))<span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    SET_ADDR_PORT;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (bind() <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (listen(sock, <span style=color:#ae81ff>5</span>) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>        connfd <span style=color:#f92672>=</span> accept();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (connfd <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (fork() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            close(sock);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> read(conndf, buf, <span style=color:#ae81ff>2048</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            mRet <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            ntoh(CharToInt);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (mType <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                n <span style=color:#f92672>=</span> hton(n1<span style=color:#f92672>*</span>n2);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (mType <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> n2 <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                n <span style=color:#f92672>=</span> hton(n1<span style=color:#f92672>/</span>n2);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                mRet <span style=color:#f92672>=</span> hton(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>                n <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            IntToChar;
</span></span><span style=display:flex><span>            write(connfd, buf, <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span><span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>            close(connfd);
</span></span><span style=display:flex><span>            exit(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    close(sock);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li></ul></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] ltr:mr-1.5 rtl:ml-1.5 dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://fffzlfk.github.io/tags/academic>Academic</a></footer><div class="giscus mt-24"></div><script src=https://giscus.app/client.js data-repo=fffzlfk/fffzlfk.github.io data-repo-id=R_kgDOG4ERGw data-category=Q&amp;A data-category-id=DIC_kwDOG4ERG84CBP5t data-mapping=pathname data-strict=1 data-reactions-enabled=0 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class="mx-auto flex h-[4.5rem] max-w-(--w) items-center px-8 text-xs tracking-wider uppercase opacity-60"><div class=mr-auto>&copy;2025
<a class=link href=https://fffzlfk.github.io/>fffzlfk's Blog</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>powered by hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>hugo-paper</a></footer></body></html>