<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>网络应用程序设计 | fffzlfk's Blog</title><meta name=keywords content="Academic"><meta name=description content="Network Program Design for Application"><meta name=author content="fffzlfk"><link rel=canonical href=https://fffzlfk.github.io/posts/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/><link crossorigin=anonymous href=/assets/css/stylesheet.ed331df0b6ad79ed9400d9c3b949b6b246796da7b136819b1fe4331a13f53e0c.css integrity="sha256-7TMd8Latee2UANnDuUm2skZ5baexNoGbH+QzGhP1Pgw=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.ab916b8151320cc693135f5df9fe4b75e6e4754d8f0dff5782df332cacd1ba8e.js integrity="sha256-q5FrgVEyDMaTE19d+f5LdebkdU2PDf9Xgt8zLKzRuo4=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://fffzlfk.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://fffzlfk.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://fffzlfk.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://fffzlfk.github.io/apple_touch_icon.png><link rel=mask-icon href=https://fffzlfk.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:title" content="网络应用程序设计"><meta property="og:description" content="Network Program Design for Application"><meta property="og:type" content="article"><meta property="og:url" content="https://fffzlfk.github.io/posts/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-07T20:48:12+08:00"><meta property="article:modified_time" content="2021-04-07T20:48:12+08:00"><meta property="og:site_name" content="fffzlfk's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="网络应用程序设计"><meta name=twitter:description content="Network Program Design for Application"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://fffzlfk.github.io/posts/"},{"@type":"ListItem","position":3,"name":"网络应用程序设计","item":"https://fffzlfk.github.io/posts/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"网络应用程序设计","name":"网络应用程序设计","description":"Network Program Design for Application","keywords":["Academic"],"articleBody":"基本socket函数 创建网络端点 创建socket描述符 int socket (int family, int type, int protocol) Socket地址 TCP/IP协议的socket地址 struct sockaddr_in { short sin_family; /*AF_INET*/ u_short sin_port; /*端口号，网络字节顺序*/ struct n_addr sin_addr; /*IP地址，网络字节顺序*/ char sin_zero[8]; /*填充字节，必须为全零*/ }; struct in_addr { union { struct { u_char s_b1,s_b2,s_b3,s_b4; } S_un_b; struct { u_short s_w1,s_w2; } S_un_w; u_long S_addr; } S_un; }; 地址转换函数 字符串形式地址转换为网络地址形式inet_aton(const char *cp,struct in_addr *inp); 网络地址转换为字符串地址形式char* inet_ntoa(struct in_addr in); 字节顺序 主机字节顺序 little-endian低字节在前 big-endian高字节在前 网络字节顺序 采用big-endian顺序\n主机字节顺序和网络字节顺序的转换 unsigned short int htons(unsigned short int hostshort) unsigned long int htonl(unsigned long int hotlong) unsigned short int ntohs(unsigned short int netshort) unsigned long int ntohl(unsigned long int netlong) 连接服务器 int connect(int sockfd,struct sockaddr *servaddr,int addrlen) 绑定服务器地址和端口 int bind(int sockfd,struct sockaddr *myaddr,int addrlen); 地址可重用 在bind之前\nint on = 1; setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, \u0026on, sizeof(on)); 监听端口 int listen(int sockfd,int backlog) sockfd－已绑定的socket描述符 backlog－以完成连接，等待接受的队列长度 接收客户端连接 int accept(int sockfd,struct sockaddr *clientaddr,int addrlen); 代码示例 server #include #include #include #include #include #include #include #include #define MAXDATASIZE 128 #define PORT 3000 #define BACKLOG 5 int main(int argc, char **argv) { int sockfd, new_fd, nbytes, sin_size; char buf[MAXDATASIZE]; struct sockaddr_in srvaddr, clientaddr; // 1.创建网络端点 sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd == -1) { printf(\"can;t create socket\\n\"); exit(1); } if (argc == 2) { int on = 1; setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, \u0026on, sizeof(on)); printf(\"reuse addr\\n\"); } //填充地址 bzero(\u0026srvaddr, sizeof(srvaddr)); srvaddr.sin_family = AF_INET; srvaddr.sin_port = htons(PORT); srvaddr.sin_addr.s_addr = htonl(INADDR_ANY); /* if(inet_aton(argv[1],\u0026srvaddr.sin_addr)==-1){ printf(\"addr convert error\\n\"); exit(1); } */ // 2.绑定服务器地址和端口 if (bind(sockfd, (struct sockaddr *)\u0026srvaddr, sizeof(struct sockaddr)) == -1) { printf(\"bind error\\n\"); exit(1); } // 3. 监听端口 if (listen(sockfd, BACKLOG) == -1) { printf(\"listen error\\n\"); exit(1); } for (;;) { // 4.接受客户端连接 sin_size = sizeof(struct sockaddr_in); if ((new_fd = accept(sockfd, (struct sockaddr *)\u0026clientaddr, \u0026sin_size)) == -1) { printf(\"accept error\\n\"); continue; } printf(\"client addr:%s %d\\n\", inet_ntoa(clientaddr.sin_addr), ntohs(clientaddr.sin_port)); // 5.接收请求 getchar(); nbytes = read(new_fd, buf, MAXDATASIZE); buf[nbytes] = '\\0'; printf(\"client:%s\\n\", buf); // 6.回送响应 sprintf(buf, \"wellcome!\"); write(new_fd, buf, strlen(buf)); //关闭socket close(new_fd); } close(sockfd); return 0; } client #include #include #include #include #include #include #include #include #include #define MAXDATASIZE 128 #define PORT 3000 int addr_conv(char *address, struct in_addr *inaddr); int main(int argc, char **argv) { int sockfd, nbytes; int port = PORT; char buf[MAXDATASIZE]; struct sockaddr_in srvaddr; if (argc != 2 \u0026\u0026 argc != 3) { printf( \"usage:./client hostname|ip. Or usage:./client hostname|ip port\\n\"); exit(0); } if (argc == 3) port = atoi(argv[2]); // 1.创建网络端点 sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd == -1) { printf(\"can;t create socket\\n\"); exit(1); } //指定服务器地址（本地socket地址采用默认值） bzero(\u0026srvaddr, sizeof(srvaddr)); srvaddr.sin_family = AF_INET; srvaddr.sin_port = htons(port); /* if(inet_aton(\"127.0.0.1\",\u0026srvaddr.sin_addr)==-1){ printf(\"addr convert error\\n\"); exit(1); } */ if (addr_conv(argv[1], \u0026srvaddr.sin_addr) == -1) { perror(strerror(errno)); } // 2.连接服务器 if (connect(sockfd, (struct sockaddr *)\u0026srvaddr, sizeof(struct sockaddr)) == -1) { printf(\"connect error\\n\"); exit(1); } // 3.发送请求 sprintf(buf, \"hello\"); write(sockfd, buf, strlen(buf)); sprintf(buf, \"hello2\"); write(sockfd, buf, strlen(buf)); sprintf(buf, \"hello3\"); write(sockfd, buf, strlen(buf)); // 4.接收响应 if ((nbytes = read(sockfd, buf, MAXDATASIZE)) == -1) { printf(\"read error\\n\"); exit(1); } buf[nbytes] = '\\0'; printf(\"srv respons:%s\\n\", buf); //关闭socket close(sockfd); return 0; } int addr_conv(char *address, struct in_addr *inaddr) { struct hostent *he; if (inet_aton(address, inaddr) == 1) { printf(\"call inet_aton sucess.\\n\"); return 0; } printf(\"call inet_aton fail.\\n\"); he = gethostbyname(address); if (he != NULL) { printf(\"call gethostbyname sucess.\\n\"); *inaddr = *((struct in_addr *)(he-\u003eh_addr_list[0])); return 0; } return -1; } 高级socket函数 DHCP 动态主机配置协议（Dynamic Host Configuration Protocol）\n分配方式 自动分配 动态分配 人工分配 DHCP过程 域名访问 域名系统——DNS 域名查找过程 域名到IP的转换函数 struct hostent* gethostbyname(const char *name) struct hostent{ char\th_name;\t/*主机正式名称*/ char\t**h_aliases;\t/*别名列表，以NULL结束*/ int h_addrtype;\t/*主机地址类型：AF_INET*/ int h_length;\t/*主机地址长度：4字节32位*/ char **h_addr_list;\t/*主机网络地址列表，以NULL结束*/ } #define h_addr h_addr_list[0]; //主机的第一个网络地址 示例代码\n#include #include #include #include #include #include #include #include int main(int argc, char **argv) { if (argc != 2) { printf(\"invalid args\\n\"); } struct hostent *he; he = gethostbyname(argv[1]); if (he != NULL) { printf(\"h_name:%s\\n\", he-\u003eh_name); printf(\"h_length:%d\\n\", he-\u003eh_length); printf(\"h_addrtype:%d\\n\", he-\u003eh_addrtype); int i; for (i = 0; he-\u003eh_aliases[i] != NULL; i++) printf(\"h_aliases[%d]:%s\\n\", i + 1, he-\u003eh_aliases[i]); printf(\"first ip:%s\\r\\n\", inet_ntoa(*((struct in_addr *)he-\u003eh_addr))); for (i = 0; he-\u003eh_addr_list[i] != NULL; i++) printf(\"ip%d:%s\\n\", i + 1, inet_ntoa(*(struct in_addr *)he-\u003eh_addr_list[i])); } else { printf(\"gethostbyname error: %s\\n\", hstrerror(h_errno)); } return 0; } IP到域名的转换函数 查询IP对应的域名 struct hostent *gethostbyaddr(const char *addr, size_t len, in family); 示例代码 #include #include #include #include #include #include #include int main(int argc, char *argv[]) { struct in_addr addr; inet_aton(argv[1], \u0026addr); struct hostent *he; he = gethostbyaddr((char *)\u0026addr, 4, AF_INET); if (he != NULL) { printf(\"h_name: %s\\n\", he-\u003eh_name); } else { printf(\"gethostbyaddr error: %s\", hstrerror(h_errno)); } return 0; } 高级Socket函数 recv和send int recv(int sockfd,void* buf,int len, int flags); int send(int sockfd,void* buf,int len,int flags); flags MSG_DONTROUTE不路由——主机在本地网，不需路由。多网卡时，逐个搜索 MSG_OBB带外数据——紧急数据 MSG_PEEK不从缓存区移走数据——多进程共享数据，还可以用来查看缓存区数据 MSG_WAITALL等待所有数据——发现文件结束符时（Crtl+D），函数也结束 shutdown关闭连接 int shutdown(int sockfd,int howto); howto = 0对后来接收到的数据返回确认后丢弃 howto = 1继续发送发送缓冲区未发送完的数据，然后发送FIN字段关闭写通道 howto = 2关闭读写通道，任何进程不能再操作这个socket 与close的区别 shutdown操作连接通道，其他进程不能再使用已被关闭的通道；close操作描述符，其他进程仍然可以使用该socket描述符 close关闭应用程序与socket的接口，调用close之后进程不能再读写这个socket；shutdown可以只关闭一个通道，另一个通道仍然可以操作 UDP与原始Socket编程 UDP Socket编程 recvfrom：接受UDP数据包 int recvfrom(int sockfd, void *buf, int len, unsigned char flags, struct socketaddr *from, socklen_t *addrlen); sendto：发送UDP数据包 int sendto(int sockfd,const void *buf,int len,unsigned char flags, struct socketaddr *to,int tolen); UDP服务器 服务器不接受客户端连接，只需监听端口 循环服务器，可以交替处理各个客户端数据包 #include #include #include #include #include #include #include #include #include #include #include using namespace std; int main(int argc, char **argv) { if (argc != 2) { cout \u003c\u003c \"argument invalid\" \u003c\u003c endl; return 1; } short port = atoi(argv[1]); int sockfd = socket(AF_INET, SOCK_DGRAM, 0); if (sockfd == -1) { cout \u003c\u003c \"create socket error\" \u003c\u003c endl; return 1; } sockaddr_in addr; bzero(\u0026addr, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = htonl(INADDR_ANY); //绑定服务器地址 if (bind(sockfd, (struct sockaddr *)\u0026addr, sizeof(addr)) == -1) { cout \u003c\u003c \"bind error\" \u003c\u003c endl; return 1; } for (;;) { char buf[32]; sockaddr_in client_addr; socklen_t addr_len; //接收客户端数据包 int n = recvfrom(sockfd, buf, 16, 0, (struct sockaddr *)\u0026client_addr, \u0026addr_len); if (n \u003e= 0) { buf[n] = 0; cout \u003c\u003c \"recv:\" \u003c\u003c buf \u003c\u003c endl; struct timeval tv; gettimeofday(\u0026tv, NULL); sprintf(buf, \"%d %d\", (int)tv.tv_sec, (int)tv.tv_usec); //利用recvfron中得到的地址回送数据包 sendto(sockfd, buf, strlen(buf), 0, (struct sockaddr *)\u0026client_addr, sizeof(client_addr)); } } close(sockfd); return 0; } UDP客户端 客户端不用建立连接，第一次调用sendto函数时，UDP协议为这个UDP socket选择一个端口号，以后的发送和接受操作均使用这个端口号。 客户端可以接收来自任何主机的数据报 客户端可能永远阻塞（服务器主机崩溃） #include #include #include #include #include #include #include #include #include #include using namespace std; int main(int argc, char **argv) { if (argc \u003c 2) { cout \u003c\u003c \"argument invalid\" \u003c\u003c endl; return 1; } short port = atoi(argv[1]); int sockfd = socket(AF_INET, SOCK_DGRAM, 0); if (sockfd == -1) { cout \u003c\u003c \"create socket error\" \u003c\u003c endl; return 1; } sockaddr_in addr; bzero(\u0026addr, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = htonl(INADDR_ANY); if (argc == 3 \u0026\u0026 strcmp(argv[2], \"-c\") == 0) { //记录服务器地址 connect(sockfd, (struct sockaddr *)\u0026addr, sizeof(addr)); } for (int i = 0; i \u003c 10; i++) { char buf[16]; sprintf(buf, \"%d hello\", getpid()); cout \u003c\u003c \"send:\" \u003c\u003c buf \u003c\u003c endl; int n; if (argc == 3 \u0026\u0026 strcmp(argv[2], \"-c\") == 0) { //发送时不需要服务器地址 n = sendto(sockfd, buf, strlen(buf), 0, NULL, 0); } else { //发送时需要服务器地址 n = sendto(sockfd, buf, strlen(buf), 0, (struct sockaddr *)\u0026addr, sizeof(addr)); } n = recvfrom(sockfd, buf, 16, 0, NULL, NULL); if (n \u003e= 0) { buf[n] = 0; cout \u003c\u003c \"recv:\" \u003c\u003c buf \u003c\u003c endl; } sleep(1); } close(sockfd); return 0; } 有连接的UDP Socket 在UDP Socket上调用connect函数，但不会产生3次握手过程，只记录连接另一方的IP和端口，connect函数马上返回 使用UDP Socket的说明 UDP协议不保证数据包可靠到达（超时和重发机制） UDP协议不保证数据报顺序到达（数据报序列号区分） UDP协议没有流控 UDP广播 server #include #include #include #include #include #include int main() { int sockfd; if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) \u003c 0) { exit(-1); } int on = 1; setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST | SO_REUSEADDR, \u0026on, sizeof(int)); struct sockaddr_in addr; memset(\u0026addr, 0, sizeof(struct sockaddr_in)); addr.sin_family = AF_INET; addr.sin_addr.s_addr = inet_addr(\"255.255.255.255\"); addr.sin_port = htons(8080); char msg[] = \"Broadcast Message: Hello!\"; int n; if ((n = sendto(sockfd, msg, strlen(msg), 0, (struct sockaddr *)\u0026addr, sizeof(addr))) \u003c 0) { exit(-1); } printf(\"msg=%s, msgLen=%ld, sendBytes=%d\\n\", msg, strlen(msg), n); close(sockfd); return 0; } client #include #include #include #include #include #include int main() { int sockfd; if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) \u003c 0) { exit(-1); } int on = 1; setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, \u0026on, sizeof on); struct sockaddr_in addr; memset(\u0026addr, 0, sizeof(sockaddr_in)); addr.sin_family = AF_INET; addr.sin_port = htons(8080); addr.sin_addr.s_addr = INADDR_ANY; if (bind(sockfd, (struct sockaddr *)\u0026addr, sizeof(struct sockaddr)) \u003c 0) { exit(-1); } int n; char buf[256]; socklen_t addr_len = sizeof(struct sockaddr_in); if ((n = recvfrom(sockfd, buf, 256, 0, (struct sockaddr *)\u0026addr, \u0026addr_len)) \u003c 0) { exit(-1); } buf[n] = '\\0'; printf(\"Received: %s\\n\", buf); close(sockfd); return 0; } 原始Socket编程 概述 TCP、UDP Socket对TCP协议和UDP协议做了封装来简化编程接口，但失去了对IP数据包操作的灵活性 原始Socket直接针对IP数据包编程，具有更强的灵活性 可以编写基于IP协议的高层协议 发送数据包 没有调用connect函数绑定对方地址时必须用sendto或sendmsg发送数据包；调用connect绑定对方IP地址后，可以使用write和send发送数据包 接收数据包 UDP包和TCP包 大多数ICMP包的拷贝将传递给原始socket 其他类型的数据包的拷贝传递给匹配的socket 内核不能识别的IP数据包将传送给匹配的原始socket Linux进程与信号机制 概述 linux进程是系统进行资源分配和调度的基本单位。 进程的状态： 新建 运行 阻塞 就绪 完成 按继承关系分类 父、子、孙进程 兄弟进程 孤儿进程 创建进程 pid_t fork(void); 功能：创建新的进程，调用者成为父进程，产生的新进程成为子进程 返回值： \u003e 0, 子进程的id，只在父进程中返回 -1, 调用失败 =0, 只在子进程中返回 头文件：#include #include fork的原理 两次返回 调用fork的进程（父进程）返回正整数（子进程ID） 在新创建的进程（子进程）中返回0，表示是子进程 在调用fork时发生了什么 系统创建新进程，并为该进程准备数据段、堆栈段和代码段 代码段使用和父进程相同的代码段 父进程的数据段和堆栈段被复制（copy on write, 写入时复制）给子进程 子进程和父进程共享的内容 代码段 用户标识符 环境变量 打开的文件描述符(Socket描述符) 根目录 当前工作目录 创建文件的模式 ⚠️ 数据段和堆栈段通过复制方式共享，因此子进程或父进程修改了变量值后不会影响另一个进程，即使是全局变量。 父子进程执行顺序随机 执行另一个程序 int execve(const char *path,char * const argv[],char *envp);只有execve是真正的系统调用 int execl(const char *path, const char * argv,…); 注意： fork()和exec()这两个函数，前者用于并行执行，父、子进程执行相同正文中的不同部分；后者用于调用其他进程，进程执行新的正文。 fork()以后，父、子进程共享代码段，并只重新创建数据有改变的页（段页式管理） exec()以后，建立新的代码段，用被调用程序的内容填充。 前者的子进程执行后续的公共代码，后者的子进程不执行后续的公共代码 #include #include using namespace std; int main() { pid_t pid; if ((pid = fork()) == 0) { // 子进程 cout \u003c\u003c \"Son Process\" \u003c\u003c endl; exit(0); } else if (pid \u003e 0) { // 父进程 cout \u003c\u003c \"Father Process\" \u003c\u003c endl; exit(0); } else { cout \u003c\u003c \"Error\" \u003c\u003c endl; exit(1); } return 0; } 创建守护进程 fork()子进程，父进程退出 子进程建立新会话setsid() 改变当前工作目录chdir(不是必须) 重设文件掩码(不是必须) 子进程会继承父进程的掩码 增加子进程程序的灵活性 umask(0); 关键文件描述符（不是必须） close(0), close(1), close(2) 释放资源 执行核心工作 #include #include #include #include #include #include #include #include using namespace std; int main(int argc, char const *argv[]) { // 1. 调用fork，父进程退出，子进程继续运行 pid_t pid = fork(); if (pid \u003c 0) { exit(1); } else if (pid \u003e 0) { exit(0); } // 2. 调用setsid变成会长 // 会长就是一个守护进程 setsid(); // 3. 忽略SIGHUP信号 signal(SIGHUP, SIG_IGN); // 再次fork，父进程（session的头进程）退出 if ((pid = fork()) \u003e 0) { exit(0); } else if (pid \u003c 0) { exit(1); } // 4. chdir 改变当前工作目录 chdir(\"/tmp\"); // 5. 重设文件掩码 umask(0); // 6. 关闭所有打开的文件描述符 for (int i = 0; i \u003c NOFILE; i++) { close(i); } // 7. 为标准输入（0），标准输出（1）、标准错误输出（2）打开新的文件描述符 int fd_rd = open(\"/dev/null\", O_RDONLY); int fd_wr = open(\"/root/deamon.log\", O_WRONLY); dup(fd_rd); dup(fd_wr); // 8. 处理SICHLD，避免守护进程的子进程称为僵尸进程 signal(SIGCHLD, SIG_IGN); // 让子进程一直活着 while (true) { } return 0; } 信号机制 信号分类 常用信号： SIGALARM——计时器到时 SIGCHLD——子进程停止时通知父进程 SIGKILL——终止进程 SIGSTOP——停止进程（暂停） SIGINT——中断字符 可靠信号和非可靠信号 实时信号和非实时信号 发送信号 int kill(pid_t pid, int sig) int raise(int sig)向进程自身发送信号 unsigned int alarm(unsigned int seconds) void abort() int sigqueue(pid_t pid, int sig, const union sigval val) 用kill发送信号 用特定的键盘字符产生信号 CTRL+C产生SIGINT CTRL+BACKSPACE产生SIGQUIT 接收信号 int sigcation(int signum, const struct sigaction *act, struct sigaction *oldact); sigaction结构 struct sigaction { void (*sa_handler)(int); // 函数指针 void (*sa_sigaction)(int, siginfo_t *, void *); //函数指针 sigset_t sa_mask; // 屏蔽的信号集 int sa_flags;\t// 标志，SA_SIGINFO void (*sa_restorer)(void); // 已废弃 } 示例 INT信号处理\n#include #include #include using namespace std; void signalHandler(int signum) { cout \u003c\u003c \"Catched signal: \" \u003c\u003c signum \u003c\u003c endl; // exit(signum); } int main() { // 注册信号SIGNAL和信号处理程序 signal(SIGINT, signalHandler); while (true) { cout \u003c\u003c \"Going to sleep...\" \u003c\u003c endl; sleep(1); } return 0; } 进程终止 exit()\n处理子进程死亡 僵尸进程（zombie） 子进程终止时如果父进程存在且未处理SIGCHLD信号则子进程变为僵尸进程 僵尸进程占据系统进程表项 对比孤儿进程 子进程终止，父进程并没有调用 wait/waitpid 获取子进程的终止状态，且父进程还没有结束（子进程没有被 init 收养），那么当子进程结束后，它的进程描述符仍然保存在系统中，这就成了僵尸进程。 子进程还没有结束，但是父进程结束了，这个时候子进程失去其唯一的父进程，成为了孤儿进程。 清理僵尸进程的方法1 忽略SIGCHLD信号（使用信号处理函数（SIG_IGN) 忽略SIGCHLD信号时，系统将清除子进程的进程表项，这种方法依赖于Linux版本的实现 终端操作 top，查看动态进程状态 `ps -A -ostat, ppid, pid, cmd | grep -e ‘^[Zz]’，查看僵尸进程 kill -HUP xxxx, 清除僵尸 清除僵尸进程的方法2 调用wait或waitpid等待子进程 pid_t wait(int *status);等待任意子进程终止，没有子进程终止时阻塞，如果没有子进程返回-1 pid_t waitpid(int pid, int *status, int option) 此方法没有兼容性问题 清除僵尸进程的方法3 捕获SIGCHLD信号 清除僵尸进程的方法4 调用fork()两次，使得子进程成为孤儿进程，由init管理 这种方法第一次调用fork产生的子进程可能成为僵尸进程 这种方法第二次调用fork产生的子进程由init处理子进程退出，不会成为僵尸进程 通俗点讲，就是爷爷第一次 fork 生一个老爸，老爸出生后立刻 fork 生下儿子，这个时候老爸的任务就结束了，可以死掉了 (exit)，这个时候儿子被强大的 init 收养，爷爷爱干啥干啥，从而儿子永远不会成为僵尸进程。\n#include #include #include #include int main() { pid_t pid; if ((pid = fork()) == 0) { pid = fork(); if (pid \u003e 0) { // 父亲生下儿子直接退出，儿子会被收养 exit(0); } sleep(0.5); printf(\"I'm son after second fork.\\n\"); printf(\"my parent's pid: %d\\n\", getppid()); exit(0); } // 爷爷生下父亲后直接等待为其收尸 waitpid(pid, NULL, 0); // 爷爷尽情快活 return 0; } 进程同步 当fork调用成功后，父子进程各做各的事情，但当父进程的工作告一段落，需要用到子进程的结果时，它就停下来调用wait，一直等到子进程运行结束，然后利用子进程的结果继续执行。\n#include #include #include #include #include int main() { pid_t pc, pr; int status; pc = fork(); if (pc \u003c 0) printf(\"Error occured on forking.\\n\"); else if (pc == 0) { /* 子进程的工作 */ printf(\"son\\n\"); exit(0); } else { /* 父进程的工作 */ printf(\"father\\n\"); pr = wait(\u0026status); /* 利用子进程的结果 */ } return 0; } Linux进程间通信（IPC) 管道 单向通信，实现双向通信需创建两个管道 只适用于父子间进程通信 使用管道 用pipe创建两个管道pipe1和pipe2 pipe[0]读，pipe[1]写 fork()创建子进程 父进程用pipe1写数据（关闭pipe1读端口），pipe2读数据（关闭pipe2写端口） 子进程用pipe1读数据（关闭pipe1写端口），pipe2写数据（关闭pipe2读端口） 示例 #include #include #include #include #include using namespace std; int main(int argc, char **argv) { int pipe1[2], pipe2[2]; char pstr[] = \"parent data\"; char cstr[] = \"child data\"; char buf[100]; if (pipe(pipe1) \u003c 0 || pipe(pipe2) \u003c 0) cout \u003c\u003c \"pipe error\" \u003c\u003c endl; pid_t pid = fork(); if (pid \u003e 0) { // 父进程,用管道1写数据,管道2读数据 close(pipe1[0]); //关闭pipe1读端口 close(pipe2[1]); //关闭pipe2写端口 write(pipe1[1], pstr, sizeof(pstr)); if (read(pipe2[0], buf, 100) \u003e 0) cout \u003c\u003c \"parent received:\" \u003c\u003c buf \u003c\u003c endl; } else if (pid == 0) { // 子进程用管道1读数据,管道2写数据 close(pipe1[1]); //关闭pipe1写端口 close(pipe2[0]); //关闭pipe2读端口 if (read(pipe1[0], buf, 100) \u003e 0) cout \u003c\u003c \"child received:\" \u003c\u003c buf \u003c\u003c endl; write(pipe2[1], cstr, sizeof(cstr)); exit(0); } else cout \u003c\u003c \"fork error\" \u003c\u003c endl; return 0; } 命名管道 特点 与一个路径名相关联，以文件形式存在于文件系统中 该文件名所对应的文件没有数据只是为了便于其他进程引用 可以在兄弟进程通信 创建 int mkfifo(char *pathname, mode_t mode);\n使用 写进程mkfifo创建命名管道 写进程open以写阻塞方式打开管道 读进程open以读阻塞方式打开管道 写进程调用write写，读进程read读出数据 示例 fifo_server.cpp\n#include #include #include #include #include #include #include #include #include #include #include #include using namespace std; #define FIFO_NAME \"/home/fffzlfk/fifo_test\" int main(int argc, char **argv) { char pstr[] = \"server data\"; if (mkfifo(FIFO_NAME, O_CREAT | O_EXCL) \u003c 0 \u0026\u0026 (errno != EEXIST)) cout \u003c\u003c \"create fifo error\" \u003c\u003c endl; int fd; if (argc == 2 \u0026\u0026 strcmp(argv[1], \"-b\") == 0) fd = open(FIFO_NAME, O_WRONLY, 0); else fd = open(FIFO_NAME, O_WRONLY | O_NONBLOCK, 0); if (fd != -1) cout \u003c\u003c \"open success\" \u003c\u003c endl; else { perror(\"open fail\"); return 0; } int write_num = write(fd, pstr, sizeof(pstr)); if (write_num == -1) { if (errno = EAGAIN) cout \u003c\u003c \"write fifo error,try later:\" \u003c\u003c endl; } else cout \u003c\u003c \"real write num is:\" \u003c\u003c write_num \u003c\u003c endl; return 0; } fifo_client.cpp\n#include #include #include #include #include #include #include #include #include #include #include #include using namespace std; #define FIFO_NAME \"/home/fffzlfk/fifo_test\" int main(int argc, char **argv) { char buf[1024]; int fd; if (argc == 2 \u0026\u0026 strcmp(argv[1], \"-b\") == 0) fd = open(FIFO_NAME, O_RDONLY, 0); else fd = open(FIFO_NAME, O_RDONLY | O_NONBLOCK, 0); if (fd != -1) cout \u003c\u003c \"open success\" \u003c\u003c endl; else { perror(\"open fail\"); return 0; } int read_num = 20; memset(buf, 0, sizeof(buf)); read_num = read(fd, buf, 1024); if (read_num == -1) { if (errno == EAGAIN) cout \u003c\u003c \"no data,try later:\" \u003c\u003c endl; } else { cout \u003c\u003c \"real read bytes:\" \u003c\u003c read_num \u003c\u003c endl; cout \u003c\u003c \"read data:\" \u003c\u003c buf \u003c\u003c endl; } //删除管道文件 // unlink(FIFO_NAME); return 0; } Unix域Socket 不是真正的网络协议 提供同一台机器的的进程间通信 是双向通道 分为命名和非命名两种 命名Unix域Socket 特点 服务器可以接收多个客户端连接请求 客户端调用函数connect服务器连接 connect使用的socket应该是已打开的UNIX域socket 客户端必须拥有打开socket地址所指文件权限 监听socket的连接队列满时connect立刻返回错误 非命名Unix域Socket 特点 无名的 全双工 不需要连接 父子进程间通信使用socketpair I/O模型 阻塞I/O模型 产生阻塞的原因——时间片调度算法 好处——阻塞进程不占用CPU时间 产生阻塞的函数——读、写、建立连接、接受连接 读：read、readv、recv、recvfrom和recvmsg 写：write、writev、send、sendto和sendmsg 建立连接：connect 接受连接：accept 超时控制 调用alarm函数设置超时 设置socket选项——设置SO_RCVTIMEO和SO_SNDTIMEO选项 非阻塞I/O模型 设置Socket为非阻塞方式 函数fcntl int flags; flag = fcntl(sockfd,F_GETFL,0); fcntl(sockfd,F_SETFL,flag|O_NONBLOCK); 函数ioctl int on=1; ioctl(sockfd,FIONBIO,\u0026on); 检查操作是否可以完成的方式（轮询） 输入输出多路复用I/O模型 int select(int maxfd, struct fd_set* rdset, struct fd_set* wrset, struct fd_set* exset, struct timeval* timeout); void FD_SET(int fd,fd_set *fdset) //将fd加入到fdset void FD_CLR(int fd,fd_set *fdset) //将fd从fdset里面清除 void FD_ZERO(fd_set *fdset) //从fdset中清除所有的文件描述符 int FD_ISSET(int fd,fd_set *fdset) //判断fd是否在fdset集合中 select()可以设置超时，使长期没有文件描述符就绪时，进程可以跳出阻塞状态。select()的第一个参数 maxfd 是集合中最大的文件描述符加1，如：一个包含3个套接字描述符的集合{12，23，30}，那么 maxfd 就应该是30+1=31。\n在我们调用select( )时，进程会一直阻塞到以下的一种情况发生:\n有文件可以读，包括出现错误； 有文件可以写，包括出现错误； 超时所设置的时间到； 被信号中断。 信号驱动I/O模型 设置SIGIO信号处理函数 设置socket描述符所有者 允许这个socket进行信号驱动I/O void sigio_handler(int signo) { ... } int main() { int sockfd; int on = 1; ... signal(SIGIO, sigio_handler); fcntl(sockfd, F_SETOWN, getpid()); // 设置套接字所有者为当前进程 ioctl(sockfd, FIOASYNC, \u0026on); // 启动信号驱动模式 ... } 服务器模型 网络服务器分类 循环服务器：同一时刻只能处理一个客户端请求 并发服务器：同一时刻可以处理多个客户端请求 UDP和TCP服务器模型 UDP服务器通常采用循环服务器模型 TCP服务器通常采用并发服务器模型 循环服务器模型 UDP循环服务器模型 TCP循环服务器模型 并发服务器模型 UCP并发服务器模型 TCP并发服务器模型 一个子进程对应一个客户端 创建子进程开销大，适合长时间客户请求（如FTP） 客户端数量大、请求时间短会大大降低效率（如HTTP） 延迟创建子进程 处理短请求以循环方式完成 处理时间长的请求以并发方式完成 预创建子进程 数量固定 所有进程调用accept，无连接时将睡眠 有连接到来时所有进程被唤醒 某一个进程接受连接后，其余连接继续睡眠 动态子进程数 父进程与子进程通过管道通信 子进程接收连接时给父进程发1，关闭时发0 父进程收到1时，检查空闲子进程数是否小于上限，小于则创建新的子进程 父进程收到0时，检查空闲子进程数是否大于上限，大于则终止一些子进程 多路复用I/O select函数检查侦听socket是否有连接到达、已连接socket是否有数据到达、已连接socket是否可以写数据 在测试是否可读的描述符集合rdset中同时包含侦听socket和已连接socket，在测试是否可写描述符集合中包含已连接socket，就可以实现多路复用 Linux epoll 一种多路复用模型 对比select select\nint n = select(maxfd+1, \u0026rds, NULL, NULL, 100); if (n \u003e 0) { for(int i = 0; i \u003c fdset_size; i++) { if (FD_ISSET(allFD[i],\u0026rds)) { handleEvent(allFD[i]); } } } epoll\nint n = epoll_wait(epfd, events, 10, 100); for(int i = 0; i \u003c n;i++) { handleEvent(events[n]); } 带外数据（OOB） 带外数据（Out Of Band）：传输层使用带外数据发送重要数据\n紧急状态\n发送方TCP协议保证紧急状态能够立即发送 接收方通过信号SIGURG或select函数得知紧急状态 TCP带外数据发送 TCP只支持1字节带外数据 TCP使用URG标志位和紧急指针指明带外数据：紧急指针=带外数据位置+1 发送TCP带外数据的函数 send函数和标志MSG_OOB\n一个进程已经往TCP连接的发送缓冲区写入了N个字节的普通数据，然后该进程又向这个连接写入了3字节的带外数据“abc”。此时，待发送的TCP报文段头部将被设置为URG标志，并将紧急指针设置为指向带外数据的下一字节。\n发送单个字节，这个字节被认为是带外数据send(sockfd, \"A\", 1, MSG_OOB); 发送多个字节，只有最后一个字节被认为是带外数据send(sockfd, \"ABC\", 3, MSG_OOB);，其他数据被当作普通数据。 TCP接收带外数据的过程 TCP接收端在收到紧急指针标志时检查紧急指针，然后根据紧急指针的位置确定带外数据的位置，并将它读入一个特殊的缓存中（1字节），称之为带外缓存。\n未设置SO_OOBINLINE选项时新到来的带外数据将覆盖未处理的带外数据。 设置了SO_OOBINLINE选项时新到来的带外数据不会覆盖未处理的带外数据，但未处理的带外数据将会变成普通数据。 代码 ./sigurg port，读数据，带外数据在信号处理中 ./oobserver port，接受连接并给客户机发包含带外数据的包 ./oobclient port-i，oob_inline 复习 一台工作于内外网模式的主机，具有一个外网地址IP_OUTTER和一个内网地址192.168.1，内网的掩码为192.168.1.125。该主机可将外网用户的请求广播给内网用户。请设计和实现该主机程序。\n问题分析和方案设计 TCP协议具有稳定可靠的特性，本题中外网通信属于单播，使用TCP协议能够具有良好性能，因此外网通信使用TCP套接字。 内网涉及到广播，适合使用UDP协议进行工作，因此内网采用UDP套接字工作。 主机采用单进程、阻塞式工作。 编程 #include #include #include #include #include #include using namespace std; const int port = 8080; int main() { int sockt, connfd, socku; struct sockaddr_in addr, addrX; char buf[2048]; if ((sockt = socket(AF_INET, SOCK_STREAM, 0)) \u003c 0) { exit(-1); } bzero(\u0026addr, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = htonl(INADDR_ANY); if ((bind(sockt, (sockaddr *)\u0026addr, sizeof(addr))) \u003c 0) { exit(-1); } if (listen(sockt, 5) == -1) { exit(-1); } struct sockaddr_in cli_addr; socklen_t sin_size = sizeof(struct sockaddr_in); for (;;) { connfd = accept(sockt, (sockaddr *)\u0026cli_addr, \u0026sin_size); if (connfd \u003c 0) { exit(-1); } int n = read(connfd, buf, 2048); if (n \u003c= 0) { exit(-1); } if ((socku = socket(AF_INET, SOCK_DGRAM, 0)) \u003c 0) { exit(-1); } bzero(\u0026addrX, sizeof(addr)); addrX.sin_family = AF_INET; addrX.sin_port = htons(port); addrX.sin_addr.s_addr = inet_addr(\"192.168.1.1\"); n = sendto(socku, buf, n, 0, (sockaddr *)\u0026addrX, sizeof(addrX)); close(socku); close(sockt); } return 0; } 有一台服务器，可以为多个客户机同时提供两个整数的乘法和除法运算，请设计和实现该服务器。提示：需考虑应用层协议、僵尸进程的清除等问题。\n问题分析和方案设计 本题需要同时为多个客户机服务，应采用并发方式； 对于整数、要考虑字节顺序转换； 除法要考虑除0问题； 设计服务器接收数据格式如下： int mType (运算类型：0-乘、1-除) n1(整数1)，n2(整数2) 服务器发送数据格式如下： int mRet(0-正确、1-错误) n（运算结果） 工作于TCP方式。 编程 void sigchild_handler(int sig) { wait(NULL); } main() { int sock, connfd; struct sockaddr_in addr; struct sigaction sigact; short mRet, mType; int n, n1, n2; char buf[1024]; sigact.sa_handler = sigchild_handler; sigact.sa_mask = 0; sigact.sa_flags = 0; sigaction(SIGCHILD, \u0026sigact, NULL); if ((sock = socket(AF_INET, SOCK_STREAM, 0))\u003c 0) { exit(-1); } SET_ADDR_PORT; if (bind() \u003c 0) { exit(-1); } if (listen(sock, 5) \u003c 0) { exit(-1); } for (;;) { connfd = accept(); if (connfd \u003c 0) { exit(-1); } if (fork() == 0) { close(sock); int n = read(conndf, buf, 2048); if (n \u003c= 0) { exit(-1); } mRet = 0; ntoh(CharToInt); if (mType == 0) { n = hton(n1*n2); } else if (mType == 1 \u0026\u0026 n2 != 0) { n = hton(n1/n2); } else { mRet = hton(1); n = 0; } IntToChar; write(connfd, buf, 2*sizeof(int)); close(connfd); exit(0); } exit(0); } close(sock); } ","wordCount":"2935","inLanguage":"en","datePublished":"2021-04-07T20:48:12+08:00","dateModified":"2021-04-07T20:48:12+08:00","author":{"@type":"Person","name":"fffzlfk"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://fffzlfk.github.io/posts/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},"publisher":{"@type":"Organization","name":"fffzlfk's Blog","logo":{"@type":"ImageObject","url":"https://fffzlfk.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://fffzlfk.github.io accesskey=h title="fffzlfk's Blog (Alt + H)"><img src=https://fffzlfk.github.io/android-chrome-512x512.png alt=logo aria-label=logo height=35>fffzlfk's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://github.com/fffzlfk title=GitHub><span>GitHub</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://fffzlfk.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://fffzlfk.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://fffzlfk.github.io/about/ title=About><span>About</span></a></li><li><a href=https://fffzlfk.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://fffzlfk.github.io>Home</a>&nbsp;»&nbsp;<a href=https://fffzlfk.github.io/posts/>Posts</a></div><h1 class=post-title>网络应用程序设计</h1><div class=post-meta><span title='2021-04-07 20:48:12 +0800 +0800'>April 7, 2021</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;fffzlfk&nbsp;|&nbsp;<a href=https://github.com/fffzlfk/fffzlfk.github.io/blob/master/content/posts/%e7%bd%91%e7%bb%9c%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%9f%ba%e6%9c%acsocket%e5%87%bd%e6%95%b0 aria-label=基本socket函数>基本socket函数</a><ul><li><a href=#%e5%88%9b%e5%bb%ba%e7%bd%91%e7%bb%9c%e7%ab%af%e7%82%b9 aria-label=创建网络端点>创建网络端点</a></li><li><a href=#socket%e5%9c%b0%e5%9d%80 aria-label=Socket地址>Socket地址</a><ul><li><a href=#tcpip%e5%8d%8f%e8%ae%ae%e7%9a%84socket%e5%9c%b0%e5%9d%80 aria-label=TCP/IP协议的socket地址>TCP/IP协议的socket地址</a></li><li><a href=#%e5%9c%b0%e5%9d%80%e8%bd%ac%e6%8d%a2%e5%87%bd%e6%95%b0 aria-label=地址转换函数>地址转换函数</a></li></ul></li><li><a href=#%e5%ad%97%e8%8a%82%e9%a1%ba%e5%ba%8f aria-label=字节顺序>字节顺序</a><ul><li><a href=#%e4%b8%bb%e6%9c%ba%e5%ad%97%e8%8a%82%e9%a1%ba%e5%ba%8f aria-label=主机字节顺序>主机字节顺序</a></li><li><a href=#%e7%bd%91%e7%bb%9c%e5%ad%97%e8%8a%82%e9%a1%ba%e5%ba%8f aria-label=网络字节顺序>网络字节顺序</a></li><li><a href=#%e4%b8%bb%e6%9c%ba%e5%ad%97%e8%8a%82%e9%a1%ba%e5%ba%8f%e5%92%8c%e7%bd%91%e7%bb%9c%e5%ad%97%e8%8a%82%e9%a1%ba%e5%ba%8f%e7%9a%84%e8%bd%ac%e6%8d%a2 aria-label=主机字节顺序和网络字节顺序的转换>主机字节顺序和网络字节顺序的转换</a></li></ul></li><li><a href=#%e8%bf%9e%e6%8e%a5%e6%9c%8d%e5%8a%a1%e5%99%a8 aria-label=连接服务器>连接服务器</a></li><li><a href=#%e7%bb%91%e5%ae%9a%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%9c%b0%e5%9d%80%e5%92%8c%e7%ab%af%e5%8f%a3 aria-label=绑定服务器地址和端口>绑定服务器地址和端口</a><ul><li><a href=#%e5%9c%b0%e5%9d%80%e5%8f%af%e9%87%8d%e7%94%a8 aria-label=地址可重用>地址可重用</a></li></ul></li><li><a href=#%e7%9b%91%e5%90%ac%e7%ab%af%e5%8f%a3 aria-label=监听端口>监听端口</a></li><li><a href=#%e6%8e%a5%e6%94%b6%e5%ae%a2%e6%88%b7%e7%ab%af%e8%bf%9e%e6%8e%a5 aria-label=接收客户端连接>接收客户端连接</a></li><li><a href=#%e4%bb%a3%e7%a0%81%e7%a4%ba%e4%be%8b aria-label=代码示例>代码示例</a><ul><li><a href=#server aria-label=server>server</a></li><li><a href=#client aria-label=client>client</a></li></ul></li></ul></li><li><a href=#%e9%ab%98%e7%ba%a7socket%e5%87%bd%e6%95%b0 aria-label=高级socket函数>高级socket函数</a><ul><li><a href=#dhcp aria-label=DHCP>DHCP</a><ul><li><a href=#%e5%88%86%e9%85%8d%e6%96%b9%e5%bc%8f aria-label=分配方式>分配方式</a></li><li><a href=#dhcp%e8%bf%87%e7%a8%8b aria-label=DHCP过程>DHCP过程</a></li></ul></li><li><a href=#%e5%9f%9f%e5%90%8d%e8%ae%bf%e9%97%ae aria-label=域名访问>域名访问</a><ul><li><a href=#%e5%9f%9f%e5%90%8d%e7%b3%bb%e7%bb%9fdns aria-label=域名系统——DNS>域名系统——DNS</a></li><li><a href=#%e5%9f%9f%e5%90%8d%e5%88%b0ip%e7%9a%84%e8%bd%ac%e6%8d%a2%e5%87%bd%e6%95%b0 aria-label=域名到IP的转换函数>域名到IP的转换函数</a></li><li><a href=#ip%e5%88%b0%e5%9f%9f%e5%90%8d%e7%9a%84%e8%bd%ac%e6%8d%a2%e5%87%bd%e6%95%b0 aria-label=IP到域名的转换函数>IP到域名的转换函数</a></li></ul></li><li><a href=#%e9%ab%98%e7%ba%a7socket%e5%87%bd%e6%95%b0-1 aria-label=高级Socket函数>高级Socket函数</a><ul><li><a href=#recv%e5%92%8csend aria-label=recv和send>recv和send</a></li><li><a href=#shutdown%e5%85%b3%e9%97%ad%e8%bf%9e%e6%8e%a5 aria-label=shutdown关闭连接>shutdown关闭连接</a></li></ul></li></ul></li><li><a href=#udp%e4%b8%8e%e5%8e%9f%e5%a7%8bsocket%e7%bc%96%e7%a8%8b aria-label=UDP与原始Socket编程>UDP与原始Socket编程</a><ul><li><a href=#udp-socket%e7%bc%96%e7%a8%8b aria-label="UDP Socket编程">UDP Socket编程</a><ul><li><a href=#recvfrom%e6%8e%a5%e5%8f%97udp%e6%95%b0%e6%8d%ae%e5%8c%85 aria-label=recvfrom：接受UDP数据包><code>recvfrom</code>：接受UDP数据包</a></li><li><a href=#sendto%e5%8f%91%e9%80%81udp%e6%95%b0%e6%8d%ae%e5%8c%85 aria-label=sendto：发送UDP数据包><code>sendto</code>：发送UDP数据包</a></li><li><a href=#udp%e6%9c%8d%e5%8a%a1%e5%99%a8 aria-label=UDP服务器>UDP服务器</a></li><li><a href=#udp%e5%ae%a2%e6%88%b7%e7%ab%af aria-label=UDP客户端>UDP客户端</a></li><li><a href=#%e6%9c%89%e8%bf%9e%e6%8e%a5%e7%9a%84udp-socket aria-label="有连接的UDP Socket">有连接的UDP Socket</a></li><li><a href=#%e4%bd%bf%e7%94%a8udp-socket%e7%9a%84%e8%af%b4%e6%98%8e aria-label="使用UDP Socket的说明">使用UDP Socket的说明</a></li><li><a href=#udp%e5%b9%bf%e6%92%ad aria-label=UDP广播>UDP广播</a><ul><li><a href=#server-1 aria-label=server>server</a></li><li><a href=#client-1 aria-label=client>client</a></li></ul></li></ul></li><li><a href=#%e5%8e%9f%e5%a7%8bsocket%e7%bc%96%e7%a8%8b aria-label=原始Socket编程>原始Socket编程</a><ul><li><a href=#%e6%a6%82%e8%bf%b0 aria-label=概述>概述</a></li><li><a href=#%e5%8f%91%e9%80%81%e6%95%b0%e6%8d%ae%e5%8c%85 aria-label=发送数据包>发送数据包</a></li><li><a href=#%e6%8e%a5%e6%94%b6%e6%95%b0%e6%8d%ae%e5%8c%85 aria-label=接收数据包>接收数据包</a></li></ul></li></ul></li><li><a href=#linux%e8%bf%9b%e7%a8%8b%e4%b8%8e%e4%bf%a1%e5%8f%b7%e6%9c%ba%e5%88%b6 aria-label=Linux进程与信号机制>Linux进程与信号机制</a><ul><li><a href=#%e6%a6%82%e8%bf%b0-1 aria-label=概述>概述</a></li><li><a href=#%e5%88%9b%e5%bb%ba%e8%bf%9b%e7%a8%8b aria-label=创建进程>创建进程</a><ul><li><a href=#%e5%88%9b%e5%bb%ba%e5%ae%88%e6%8a%a4%e8%bf%9b%e7%a8%8b aria-label=创建守护进程>创建守护进程</a></li></ul></li><li><a href=#%e4%bf%a1%e5%8f%b7%e6%9c%ba%e5%88%b6 aria-label=信号机制>信号机制</a><ul><li><a href=#%e4%bf%a1%e5%8f%b7%e5%88%86%e7%b1%bb aria-label=信号分类>信号分类</a></li><li><a href=#%e5%8f%91%e9%80%81%e4%bf%a1%e5%8f%b7 aria-label=发送信号>发送信号</a></li><li><a href=#%e6%8e%a5%e6%94%b6%e4%bf%a1%e5%8f%b7 aria-label=接收信号>接收信号</a></li><li><a href=#%e7%a4%ba%e4%be%8b aria-label=示例>示例</a></li></ul></li><li><a href=#%e8%bf%9b%e7%a8%8b%e7%bb%88%e6%ad%a2 aria-label=进程终止>进程终止</a></li><li><a href=#%e5%a4%84%e7%90%86%e5%ad%90%e8%bf%9b%e7%a8%8b%e6%ad%bb%e4%ba%a1 aria-label=处理子进程死亡>处理子进程死亡</a></li><li><a href=#%e8%bf%9b%e7%a8%8b%e5%90%8c%e6%ad%a5 aria-label=进程同步>进程同步</a></li></ul></li><li><a href=#linux%e8%bf%9b%e7%a8%8b%e9%97%b4%e9%80%9a%e4%bf%a1ipc aria-label=Linux进程间通信（IPC)>Linux进程间通信（IPC)</a><ul><li><a href=#%e7%ae%a1%e9%81%93 aria-label=管道>管道</a><ul><li><a href=#%e4%bd%bf%e7%94%a8%e7%ae%a1%e9%81%93 aria-label=使用管道>使用管道</a></li><li><a href=#%e7%a4%ba%e4%be%8b-1 aria-label=示例>示例</a></li></ul></li><li><a href=#%e5%91%bd%e5%90%8d%e7%ae%a1%e9%81%93 aria-label=命名管道>命名管道</a><ul><li><a href=#%e7%89%b9%e7%82%b9 aria-label=特点>特点</a></li><li><a href=#%e5%88%9b%e5%bb%ba aria-label=创建>创建</a></li><li><a href=#%e4%bd%bf%e7%94%a8 aria-label=使用>使用</a></li><li><a href=#%e7%a4%ba%e4%be%8b-2 aria-label=示例>示例</a></li></ul></li><li><a href=#unix%e5%9f%9fsocket aria-label=Unix域Socket>Unix域Socket</a><ul><li><a href=#%e5%91%bd%e5%90%8dunix%e5%9f%9fsocket aria-label=命名Unix域Socket>命名Unix域Socket</a></li><li><a href=#%e9%9d%9e%e5%91%bd%e5%90%8dunix%e5%9f%9fsocket aria-label=非命名Unix域Socket>非命名Unix域Socket</a></li></ul></li></ul></li><li><a href=#io%e6%a8%a1%e5%9e%8b aria-label=I/O模型>I/O模型</a><ul><li><a href=#%e9%98%bb%e5%a1%9eio%e6%a8%a1%e5%9e%8b aria-label=阻塞I/O模型>阻塞I/O模型</a></li><li><a href=#%e9%9d%9e%e9%98%bb%e5%a1%9eio%e6%a8%a1%e5%9e%8b aria-label=非阻塞I/O模型>非阻塞I/O模型</a></li><li><a href=#%e8%be%93%e5%85%a5%e8%be%93%e5%87%ba%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8io%e6%a8%a1%e5%9e%8b aria-label=输入输出多路复用I/O模型>输入输出多路复用I/O模型</a></li><li><a href=#%e4%bf%a1%e5%8f%b7%e9%a9%b1%e5%8a%a8io%e6%a8%a1%e5%9e%8b aria-label=信号驱动I/O模型>信号驱动I/O模型</a></li></ul></li><li><a href=#%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%a8%a1%e5%9e%8b aria-label=服务器模型>服务器模型</a><ul><li><a href=#%e7%bd%91%e7%bb%9c%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%88%86%e7%b1%bb aria-label=网络服务器分类>网络服务器分类</a></li><li><a href=#%e5%be%aa%e7%8e%af%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%a8%a1%e5%9e%8b aria-label=循环服务器模型>循环服务器模型</a><ul><li><a href=#udp%e5%be%aa%e7%8e%af%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%a8%a1%e5%9e%8b aria-label=UDP循环服务器模型>UDP循环服务器模型</a></li><li><a href=#tcp%e5%be%aa%e7%8e%af%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%a8%a1%e5%9e%8b aria-label=TCP循环服务器模型>TCP循环服务器模型</a></li></ul></li><li><a href=#%e5%b9%b6%e5%8f%91%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%a8%a1%e5%9e%8b aria-label=并发服务器模型>并发服务器模型</a><ul><li><a href=#ucp%e5%b9%b6%e5%8f%91%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%a8%a1%e5%9e%8b aria-label=UCP并发服务器模型>UCP并发服务器模型</a></li><li><a href=#tcp%e5%b9%b6%e5%8f%91%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%a8%a1%e5%9e%8b aria-label=TCP并发服务器模型>TCP并发服务器模型</a></li><li><a href=#linux-epoll aria-label="Linux epoll">Linux epoll</a></li></ul></li></ul></li><li><a href=#%e5%b8%a6%e5%a4%96%e6%95%b0%e6%8d%aeoob aria-label=带外数据（OOB）>带外数据（OOB）</a><ul><li><a href=#tcp%e5%b8%a6%e5%a4%96%e6%95%b0%e6%8d%ae%e5%8f%91%e9%80%81 aria-label=TCP带外数据发送>TCP带外数据发送</a></li><li><a href=#%e5%8f%91%e9%80%81tcp%e5%b8%a6%e5%a4%96%e6%95%b0%e6%8d%ae%e7%9a%84%e5%87%bd%e6%95%b0 aria-label=发送TCP带外数据的函数>发送TCP带外数据的函数</a></li><li><a href=#tcp%e6%8e%a5%e6%94%b6%e5%b8%a6%e5%a4%96%e6%95%b0%e6%8d%ae%e7%9a%84%e8%bf%87%e7%a8%8b aria-label=TCP接收带外数据的过程>TCP接收带外数据的过程</a></li><li><a href=#%e4%bb%a3%e7%a0%81 aria-label=代码>代码</a></li></ul></li><li><a href=#%e5%a4%8d%e4%b9%a0 aria-label=复习>复习</a></li></ul></div></details></div><div class=post-content><h2 id=基本socket函数>基本socket函数<a hidden class=anchor aria-hidden=true href=#基本socket函数>#</a></h2><h3 id=创建网络端点>创建网络端点<a hidden class=anchor aria-hidden=true href=#创建网络端点>#</a></h3><ul><li>创建socket描述符</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> socket (<span style=color:#66d9ef>int</span> family, <span style=color:#66d9ef>int</span> type, <span style=color:#66d9ef>int</span> protocol)
</span></span></code></pre></div><h3 id=socket地址>Socket地址<a hidden class=anchor aria-hidden=true href=#socket地址>#</a></h3><h4 id=tcpip协议的socket地址>TCP/IP协议的socket地址<a hidden class=anchor aria-hidden=true href=#tcpip协议的socket地址>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> sockaddr_in {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>short</span> 		    sin_family;    <span style=color:#75715e>/*AF_INET*/</span>
</span></span><span style=display:flex><span>        u_short 		sin_port;      <span style=color:#75715e>/*端口号，网络字节顺序*/</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> n_addr 	sin_addr;      <span style=color:#75715e>/*IP地址，网络字节顺序*/</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span>    		sin_zero[<span style=color:#ae81ff>8</span>];   <span style=color:#75715e>/*填充字节，必须为全零*/</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> in_addr {
</span></span><span style=display:flex><span>  	<span style=color:#66d9ef>union</span> {
</span></span><span style=display:flex><span>          		<span style=color:#66d9ef>struct</span> { u_char s_b1,s_b2,s_b3,s_b4; }   S_un_b;
</span></span><span style=display:flex><span>          		<span style=color:#66d9ef>struct</span> { u_short s_w1,s_w2; }   S_un_w;
</span></span><span style=display:flex><span>         		 u_long   S_addr;
</span></span><span style=display:flex><span> 	 } S_un;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=地址转换函数>地址转换函数<a hidden class=anchor aria-hidden=true href=#地址转换函数>#</a></h4><ul><li>字符串形式地址转换为网络地址形式<code>inet_aton(const char *cp,struct in_addr *inp);</code></li><li>网络地址转换为字符串地址形式<code>char* inet_ntoa(struct in_addr in);</code></li></ul><h3 id=字节顺序>字节顺序<a hidden class=anchor aria-hidden=true href=#字节顺序>#</a></h3><h4 id=主机字节顺序>主机字节顺序<a hidden class=anchor aria-hidden=true href=#主机字节顺序>#</a></h4><ul><li><code>little-endian</code>低字节在前</li><li><code>big-endian</code>高字节在前</li></ul><h4 id=网络字节顺序>网络字节顺序<a hidden class=anchor aria-hidden=true href=#网络字节顺序>#</a></h4><p>采用<code>big-endian</code>顺序</p><h4 id=主机字节顺序和网络字节顺序的转换>主机字节顺序和网络字节顺序的转换<a hidden class=anchor aria-hidden=true href=#主机字节顺序和网络字节顺序的转换>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span> <span style=color:#66d9ef>int</span> htons(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span> <span style=color:#66d9ef>int</span> hostshort)
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>int</span> htonl(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>int</span> hotlong)
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span> <span style=color:#66d9ef>int</span> ntohs(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span> <span style=color:#66d9ef>int</span> netshort)
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>int</span> ntohl(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>int</span> netlong)
</span></span></code></pre></div><h3 id=连接服务器>连接服务器<a hidden class=anchor aria-hidden=true href=#连接服务器>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> connect(<span style=color:#66d9ef>int</span> sockfd,<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>servaddr,<span style=color:#66d9ef>int</span> addrlen)
</span></span></code></pre></div><h3 id=绑定服务器地址和端口>绑定服务器地址和端口<a hidden class=anchor aria-hidden=true href=#绑定服务器地址和端口>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>bind</span>(<span style=color:#66d9ef>int</span> sockfd,<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>myaddr,<span style=color:#66d9ef>int</span> addrlen); 
</span></span></code></pre></div><h4 id=地址可重用>地址可重用<a hidden class=anchor aria-hidden=true href=#地址可重用>#</a></h4><p>在<code>bind</code>之前</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> on <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, <span style=color:#f92672>&amp;</span>on, <span style=color:#66d9ef>sizeof</span>(on));
</span></span></code></pre></div><h3 id=监听端口>监听端口<a hidden class=anchor aria-hidden=true href=#监听端口>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> listen(<span style=color:#66d9ef>int</span> sockfd,<span style=color:#66d9ef>int</span> backlog)
</span></span></code></pre></div><ul><li>sockfd－已绑定的socket描述符</li><li>backlog－以完成连接，等待接受的队列长度</li></ul><h3 id=接收客户端连接>接收客户端连接<a hidden class=anchor aria-hidden=true href=#接收客户端连接>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>accept</span>(<span style=color:#66d9ef>int</span> sockfd,<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>clientaddr,<span style=color:#66d9ef>int</span> addrlen);
</span></span></code></pre></div><h3 id=代码示例>代码示例<a hidden class=anchor aria-hidden=true href=#代码示例>#</a></h3><h4 id=server>server<a hidden class=anchor aria-hidden=true href=#server>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netinet/in.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define MAXDATASIZE 128
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define PORT 3000
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define BACKLOG 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sockfd, new_fd, nbytes, sin_size;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> buf[MAXDATASIZE];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> sockaddr_in srvaddr, clientaddr;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 1.创建网络端点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    sockfd <span style=color:#f92672>=</span> socket(AF_INET, SOCK_STREAM, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (sockfd <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;can;t create socket</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> on <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, <span style=color:#f92672>&amp;</span>on, <span style=color:#66d9ef>sizeof</span>(on));
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;reuse addr</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//填充地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    bzero(<span style=color:#f92672>&amp;</span>srvaddr, <span style=color:#66d9ef>sizeof</span>(srvaddr));
</span></span><span style=display:flex><span>    srvaddr.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>    srvaddr.sin_port <span style=color:#f92672>=</span> htons(PORT);
</span></span><span style=display:flex><span>    srvaddr.sin_addr.s_addr <span style=color:#f92672>=</span> htonl(INADDR_ANY);
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>    if(inet_aton(argv[1],&amp;srvaddr.sin_addr)==-1){
</span></span></span><span style=display:flex><span><span style=color:#75715e>            printf(&#34;addr convert error\n&#34;);
</span></span></span><span style=display:flex><span><span style=color:#75715e>            exit(1);
</span></span></span><span style=display:flex><span><span style=color:#75715e>    }
</span></span></span><span style=display:flex><span><span style=color:#75715e>    */</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2.绑定服务器地址和端口
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (bind(sockfd, (<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>srvaddr, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> sockaddr)) <span style=color:#f92672>==</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;bind error</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3. 监听端口
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (listen(sockfd, BACKLOG) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;listen error</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 4.接受客户端连接
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        sin_size <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> sockaddr_in);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ((new_fd <span style=color:#f92672>=</span> accept(sockfd, (<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>clientaddr,
</span></span><span style=display:flex><span>                             <span style=color:#f92672>&amp;</span>sin_size)) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>            printf(<span style=color:#e6db74>&#34;accept error</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;client addr:%s %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, inet_ntoa(clientaddr.sin_addr),
</span></span><span style=display:flex><span>               ntohs(clientaddr.sin_port));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 5.接收请求
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        getchar();
</span></span><span style=display:flex><span>        nbytes <span style=color:#f92672>=</span> read(new_fd, buf, MAXDATASIZE);
</span></span><span style=display:flex><span>        buf[nbytes] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;\0&#39;</span>;
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;client:%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, buf);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 6.回送响应
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        sprintf(buf, <span style=color:#e6db74>&#34;wellcome!&#34;</span>);
</span></span><span style=display:flex><span>        write(new_fd, buf, strlen(buf));
</span></span><span style=display:flex><span>        <span style=color:#75715e>//关闭socket
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        close(new_fd);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    close(sockfd);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=client>client<a hidden class=anchor aria-hidden=true href=#client>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;errno.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netdb.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netinet/in.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define MAXDATASIZE 128
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define PORT 3000
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>addr_conv</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>address, <span style=color:#66d9ef>struct</span> in_addr <span style=color:#f92672>*</span>inaddr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sockfd, nbytes;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> port <span style=color:#f92672>=</span> PORT;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> buf[MAXDATASIZE];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> sockaddr_in srvaddr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>!=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>&amp;&amp;</span> argc <span style=color:#f92672>!=</span> <span style=color:#ae81ff>3</span>) {
</span></span><span style=display:flex><span>        printf(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;usage:./client hostname|ip. Or usage:./client hostname|ip port</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>==</span> <span style=color:#ae81ff>3</span>) port <span style=color:#f92672>=</span> atoi(argv[<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 1.创建网络端点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    sockfd <span style=color:#f92672>=</span> socket(AF_INET, SOCK_STREAM, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (sockfd <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;can;t create socket</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//指定服务器地址（本地socket地址采用默认值）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    bzero(<span style=color:#f92672>&amp;</span>srvaddr, <span style=color:#66d9ef>sizeof</span>(srvaddr));
</span></span><span style=display:flex><span>    srvaddr.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>    srvaddr.sin_port <span style=color:#f92672>=</span> htons(port);
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>    if(inet_aton(&#34;127.0.0.1&#34;,&amp;srvaddr.sin_addr)==-1){
</span></span></span><span style=display:flex><span><span style=color:#75715e>            printf(&#34;addr convert error\n&#34;);
</span></span></span><span style=display:flex><span><span style=color:#75715e>            exit(1);
</span></span></span><span style=display:flex><span><span style=color:#75715e>    }
</span></span></span><span style=display:flex><span><span style=color:#75715e>    */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (addr_conv(argv[<span style=color:#ae81ff>1</span>], <span style=color:#f92672>&amp;</span>srvaddr.sin_addr) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        perror(strerror(errno));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2.连接服务器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (connect(sockfd, (<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>srvaddr, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> sockaddr)) <span style=color:#f92672>==</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;connect error</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3.发送请求
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    sprintf(buf, <span style=color:#e6db74>&#34;hello&#34;</span>);
</span></span><span style=display:flex><span>    write(sockfd, buf, strlen(buf));
</span></span><span style=display:flex><span>    sprintf(buf, <span style=color:#e6db74>&#34;hello2&#34;</span>);
</span></span><span style=display:flex><span>    write(sockfd, buf, strlen(buf));
</span></span><span style=display:flex><span>    sprintf(buf, <span style=color:#e6db74>&#34;hello3&#34;</span>);
</span></span><span style=display:flex><span>    write(sockfd, buf, strlen(buf));
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 4.接收响应
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> ((nbytes <span style=color:#f92672>=</span> read(sockfd, buf, MAXDATASIZE)) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;read error</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    buf[nbytes] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;\0&#39;</span>;
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;srv respons:%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, buf);
</span></span><span style=display:flex><span>    <span style=color:#75715e>//关闭socket
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    close(sockfd);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>addr_conv</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>address, <span style=color:#66d9ef>struct</span> in_addr <span style=color:#f92672>*</span>inaddr) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> hostent <span style=color:#f92672>*</span>he;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (inet_aton(address, inaddr) <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;call inet_aton sucess.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;call inet_aton fail.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    he <span style=color:#f92672>=</span> gethostbyname(address);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (he <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;call gethostbyname sucess.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>inaddr <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>((<span style=color:#66d9ef>struct</span> in_addr <span style=color:#f92672>*</span>)(he<span style=color:#f92672>-&gt;</span>h_addr_list[<span style=color:#ae81ff>0</span>]));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=高级socket函数>高级socket函数<a hidden class=anchor aria-hidden=true href=#高级socket函数>#</a></h2><h3 id=dhcp>DHCP<a hidden class=anchor aria-hidden=true href=#dhcp>#</a></h3><p><strong>动态主机配置协议</strong>（Dynamic Host Configuration Protocol）</p><h4 id=分配方式>分配方式<a hidden class=anchor aria-hidden=true href=#分配方式>#</a></h4><ul><li>自动分配</li><li>动态分配</li><li>人工分配</li></ul><h4 id=dhcp过程>DHCP过程<a hidden class=anchor aria-hidden=true href=#dhcp过程>#</a></h4><p><div class=render-image><img loading=lazy src=https://files.catbox.moe/exth7w.png alt></div></p><h3 id=域名访问>域名访问<a hidden class=anchor aria-hidden=true href=#域名访问>#</a></h3><h4 id=域名系统dns>域名系统——DNS<a hidden class=anchor aria-hidden=true href=#域名系统dns>#</a></h4><ul><li>域名查找过程</li></ul><p><div class=render-image><img loading=lazy src=https://files.catbox.moe/9rdt4n.png alt></div></p><h4 id=域名到ip的转换函数>域名到IP的转换函数<a hidden class=anchor aria-hidden=true href=#域名到ip的转换函数>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> hostent<span style=color:#f92672>*</span> <span style=color:#a6e22e>gethostbyname</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> hostent{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>char</span>	h_name;	        <span style=color:#75715e>/*主机正式名称*/</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>char</span>	<span style=color:#f92672>**</span>h_aliases;	<span style=color:#75715e>/*别名列表，以NULL结束*/</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> 	h_addrtype;	    <span style=color:#75715e>/*主机地址类型：AF_INET*/</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> 	h_length;	    <span style=color:#75715e>/*主机地址长度：4字节32位*/</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>char</span> 	<span style=color:#f92672>**</span>h_addr_list;	<span style=color:#75715e>/*主机网络地址列表，以NULL结束*/</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>#define 	h_addr 	h_addr_list[0]; </span><span style=color:#75715e>//主机的第一个网络地址
</span></span></span></code></pre></div><p>示例代码</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fcntl.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netdb.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/stat.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>!=</span> <span style=color:#ae81ff>2</span>) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;invalid args</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> hostent <span style=color:#f92672>*</span>he;
</span></span><span style=display:flex><span>    he <span style=color:#f92672>=</span> gethostbyname(argv[<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (he <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;h_name:%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, he<span style=color:#f92672>-&gt;</span>h_name);
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;h_length:%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, he<span style=color:#f92672>-&gt;</span>h_length);
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;h_addrtype:%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, he<span style=color:#f92672>-&gt;</span>h_addrtype);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; he<span style=color:#f92672>-&gt;</span>h_aliases[i] <span style=color:#f92672>!=</span> NULL; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            printf(<span style=color:#e6db74>&#34;h_aliases[%d]:%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, he<span style=color:#f92672>-&gt;</span>h_aliases[i]);
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;first ip:%s</span><span style=color:#ae81ff>\r\n</span><span style=color:#e6db74>&#34;</span>, inet_ntoa(<span style=color:#f92672>*</span>((<span style=color:#66d9ef>struct</span> in_addr <span style=color:#f92672>*</span>)he<span style=color:#f92672>-&gt;</span>h_addr)));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; he<span style=color:#f92672>-&gt;</span>h_addr_list[i] <span style=color:#f92672>!=</span> NULL; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            printf(<span style=color:#e6db74>&#34;ip%d:%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>                   inet_ntoa(<span style=color:#f92672>*</span>(<span style=color:#66d9ef>struct</span> in_addr <span style=color:#f92672>*</span>)he<span style=color:#f92672>-&gt;</span>h_addr_list[i]));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;gethostbyname error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, hstrerror(h_errno));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=ip到域名的转换函数>IP到域名的转换函数<a hidden class=anchor aria-hidden=true href=#ip到域名的转换函数>#</a></h4><ul><li>查询IP对应的域名</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> hostent <span style=color:#f92672>*</span><span style=color:#a6e22e>gethostbyaddr</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>addr, size_t len, in family);
</span></span></code></pre></div><ul><li>示例代码</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netdb.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netinet/in.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[]) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> in_addr addr;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    inet_aton(argv[<span style=color:#ae81ff>1</span>], <span style=color:#f92672>&amp;</span>addr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> hostent <span style=color:#f92672>*</span>he;
</span></span><span style=display:flex><span>    he <span style=color:#f92672>=</span> gethostbyaddr((<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>addr, <span style=color:#ae81ff>4</span>, AF_INET);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (he <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;h_name: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, he<span style=color:#f92672>-&gt;</span>h_name);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;gethostbyaddr error: %s&#34;</span>, hstrerror(h_errno));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=高级socket函数-1>高级Socket函数<a hidden class=anchor aria-hidden=true href=#高级socket函数-1>#</a></h3><h4 id=recv和send>recv和send<a hidden class=anchor aria-hidden=true href=#recv和send>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>recv</span>(<span style=color:#66d9ef>int</span> sockfd,<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> buf,<span style=color:#66d9ef>int</span> len, <span style=color:#66d9ef>int</span> flags);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>send</span>(<span style=color:#66d9ef>int</span> sockfd,<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> buf,<span style=color:#66d9ef>int</span> len,<span style=color:#66d9ef>int</span> flags);
</span></span></code></pre></div><ul><li>flags<ul><li><code>MSG_DONTROUTE</code>不路由——主机在本地网，不需路由。多网卡时，逐个搜索</li><li><code>MSG_OBB</code>带外数据——紧急数据</li><li><code>MSG_PEEK</code>不从缓存区移走数据——多进程共享数据，还可以用来查看缓存区数据</li><li><code>MSG_WAITALL</code>等待所有数据——发现文件结束符时（Crtl+D），函数也结束</li></ul></li></ul><h4 id=shutdown关闭连接>shutdown关闭连接<a hidden class=anchor aria-hidden=true href=#shutdown关闭连接>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>shutdown</span>(<span style=color:#66d9ef>int</span> sockfd,<span style=color:#66d9ef>int</span> howto); 
</span></span></code></pre></div><ul><li><code>howto = 0</code>对后来接收到的数据返回确认后丢弃</li><li><code>howto = 1</code>继续发送发送缓冲区未发送完的数据，然后发送FIN字段关闭写通道</li><li><code>howto = 2</code>关闭读写通道，任何进程不能再操作这个socket<ul><li>与<code>close</code>的区别<ul><li>shutdown操作连接通道，其他进程不能再使用已被关闭的通道；close操作描述符，其他进程仍然可以使用该socket描述符</li><li>close关闭应用程序与socket的接口，调用close之后进程不能再读写这个socket；shutdown可以只关闭一个通道，另一个通道仍然可以操作</li></ul></li></ul></li></ul><h2 id=udp与原始socket编程>UDP与原始Socket编程<a hidden class=anchor aria-hidden=true href=#udp与原始socket编程>#</a></h2><h3 id=udp-socket编程>UDP Socket编程<a hidden class=anchor aria-hidden=true href=#udp-socket编程>#</a></h3><p><div class=render-image><img loading=lazy src=https://files.catbox.moe/k0q0ar.png alt></div></p><h4 id=recvfrom接受udp数据包><code>recvfrom</code>：接受UDP数据包<a hidden class=anchor aria-hidden=true href=#recvfrom接受udp数据包>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>recvfrom</span>(<span style=color:#66d9ef>int</span> sockfd, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>buf, <span style=color:#66d9ef>int</span> len, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> flags,
</span></span><span style=display:flex><span>             <span style=color:#66d9ef>struct</span> socketaddr <span style=color:#f92672>*</span>from, socklen_t <span style=color:#f92672>*</span>addrlen);
</span></span></code></pre></div><h4 id=sendto发送udp数据包><code>sendto</code>：发送UDP数据包<a hidden class=anchor aria-hidden=true href=#sendto发送udp数据包>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sendto</span>(<span style=color:#66d9ef>int</span> sockfd,<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>buf,<span style=color:#66d9ef>int</span> len,<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> flags,
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>struct</span> socketaddr <span style=color:#f92672>*</span>to,<span style=color:#66d9ef>int</span>  tolen); 
</span></span></code></pre></div><h4 id=udp服务器>UDP服务器<a hidden class=anchor aria-hidden=true href=#udp服务器>#</a></h4><ul><li>服务器不接受客户端连接，只需监听端口</li><li>循环服务器，可以交替处理各个客户端数据包</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;errno.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netdb.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netinet/in.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/time.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>!=</span> <span style=color:#ae81ff>2</span>) {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;argument invalid&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>short</span> port <span style=color:#f92672>=</span> atoi(argv[<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sockfd <span style=color:#f92672>=</span> socket(AF_INET, SOCK_DGRAM, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (sockfd <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;create socket error&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    sockaddr_in addr;
</span></span><span style=display:flex><span>    bzero(<span style=color:#f92672>&amp;</span>addr, <span style=color:#66d9ef>sizeof</span>(addr));
</span></span><span style=display:flex><span>    addr.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>    addr.sin_port <span style=color:#f92672>=</span> htons(port);
</span></span><span style=display:flex><span>    addr.sin_addr.s_addr <span style=color:#f92672>=</span> htonl(INADDR_ANY);
</span></span><span style=display:flex><span>    <span style=color:#75715e>//绑定服务器地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (bind(sockfd, (<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>addr, <span style=color:#66d9ef>sizeof</span>(addr)) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;bind error&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>32</span>];
</span></span><span style=display:flex><span>        sockaddr_in client_addr;
</span></span><span style=display:flex><span>        socklen_t addr_len;
</span></span><span style=display:flex><span>        <span style=color:#75715e>//接收客户端数据包
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> recvfrom(sockfd, buf, <span style=color:#ae81ff>16</span>, <span style=color:#ae81ff>0</span>, (<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>client_addr,
</span></span><span style=display:flex><span>                         <span style=color:#f92672>&amp;</span>addr_len);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            buf[n] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;recv:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> buf <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>timeval</span> tv;
</span></span><span style=display:flex><span>            gettimeofday(<span style=color:#f92672>&amp;</span>tv, NULL);
</span></span><span style=display:flex><span>            sprintf(buf, <span style=color:#e6db74>&#34;%d %d&#34;</span>, (<span style=color:#66d9ef>int</span>)tv.tv_sec, (<span style=color:#66d9ef>int</span>)tv.tv_usec);
</span></span><span style=display:flex><span>            <span style=color:#75715e>//利用recvfron中得到的地址回送数据包
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            sendto(sockfd, buf, strlen(buf), <span style=color:#ae81ff>0</span>, (<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>client_addr,
</span></span><span style=display:flex><span>                   <span style=color:#66d9ef>sizeof</span>(client_addr));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    close(sockfd);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=udp客户端>UDP客户端<a hidden class=anchor aria-hidden=true href=#udp客户端>#</a></h4><ul><li>客户端不用建立连接，第一次调用sendto函数时，<strong>UDP协议为这个UDP socket选择一个端口号，以后的发送和接受操作均使用这个端口号</strong>。</li><li>客户端可以接收来自任何主机的数据报</li><li>客户端可能永远阻塞（服务器主机崩溃）</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;errno.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netdb.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netinet/in.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>) {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;argument invalid&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>short</span> port <span style=color:#f92672>=</span> atoi(argv[<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sockfd <span style=color:#f92672>=</span> socket(AF_INET, SOCK_DGRAM, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (sockfd <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;create socket error&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sockaddr_in addr;
</span></span><span style=display:flex><span>    bzero(<span style=color:#f92672>&amp;</span>addr, <span style=color:#66d9ef>sizeof</span>(addr));
</span></span><span style=display:flex><span>    addr.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>    addr.sin_port <span style=color:#f92672>=</span> htons(port);
</span></span><span style=display:flex><span>    addr.sin_addr.s_addr <span style=color:#f92672>=</span> htonl(INADDR_ANY);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>==</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>&amp;&amp;</span> strcmp(argv[<span style=color:#ae81ff>2</span>], <span style=color:#e6db74>&#34;-c&#34;</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//记录服务器地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        connect(sockfd, (<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>addr, <span style=color:#66d9ef>sizeof</span>(addr));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>10</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>16</span>];
</span></span><span style=display:flex><span>        sprintf(buf, <span style=color:#e6db74>&#34;%d hello&#34;</span>, getpid());
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;send:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> buf <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>==</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>&amp;&amp;</span> strcmp(argv[<span style=color:#ae81ff>2</span>], <span style=color:#e6db74>&#34;-c&#34;</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>//发送时不需要服务器地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            n <span style=color:#f92672>=</span> sendto(sockfd, buf, strlen(buf), <span style=color:#ae81ff>0</span>, NULL, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>//发送时需要服务器地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            n <span style=color:#f92672>=</span> sendto(sockfd, buf, strlen(buf), <span style=color:#ae81ff>0</span>, (<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>addr,
</span></span><span style=display:flex><span>                       <span style=color:#66d9ef>sizeof</span>(addr));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> recvfrom(sockfd, buf, <span style=color:#ae81ff>16</span>, <span style=color:#ae81ff>0</span>, NULL, NULL);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            buf[n] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;recv:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> buf <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        sleep(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    close(sockfd);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=有连接的udp-socket>有连接的UDP Socket<a hidden class=anchor aria-hidden=true href=#有连接的udp-socket>#</a></h4><ul><li>在UDP Socket上调用connect函数，但不会产生3次握手过程，只记录连接另一方的IP和端口，connect函数马上返回</li></ul><h4 id=使用udp-socket的说明>使用UDP Socket的说明<a hidden class=anchor aria-hidden=true href=#使用udp-socket的说明>#</a></h4><ul><li>UDP协议不保证数据包可靠到达（<strong>超时和重发机制</strong>）</li><li>UDP协议不保证数据报顺序到达（<strong>数据报序列号</strong>区分）</li><li>UDP协议没有流控</li></ul><h4 id=udp广播>UDP广播<a hidden class=anchor aria-hidden=true href=#udp广播>#</a></h4><h5 id=server-1>server<a hidden class=anchor aria-hidden=true href=#server-1>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstring&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sockfd;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((sockfd <span style=color:#f92672>=</span> socket(AF_INET, SOCK_DGRAM, <span style=color:#ae81ff>0</span>)) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> on <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST <span style=color:#f92672>|</span> SO_REUSEADDR, <span style=color:#f92672>&amp;</span>on,
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr_in</span> addr;
</span></span><span style=display:flex><span>    memset(<span style=color:#f92672>&amp;</span>addr, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr_in</span>));
</span></span><span style=display:flex><span>    addr.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>    addr.sin_addr.s_addr <span style=color:#f92672>=</span> inet_addr(<span style=color:#e6db74>&#34;255.255.255.255&#34;</span>);
</span></span><span style=display:flex><span>    addr.sin_port <span style=color:#f92672>=</span> htons(<span style=color:#ae81ff>8080</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> msg[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Broadcast Message: Hello!&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((n <span style=color:#f92672>=</span> sendto(sockfd, msg, strlen(msg), <span style=color:#ae81ff>0</span>, (<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>addr,
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>sizeof</span>(addr))) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;msg=%s, msgLen=%ld, sendBytes=%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, msg, strlen(msg), n);
</span></span><span style=display:flex><span>    close(sockfd);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=client-1>client<a hidden class=anchor aria-hidden=true href=#client-1>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstring&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netinet/in.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sockfd;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((sockfd <span style=color:#f92672>=</span> socket(AF_INET, SOCK_DGRAM, <span style=color:#ae81ff>0</span>)) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> on <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, <span style=color:#f92672>&amp;</span>on, <span style=color:#66d9ef>sizeof</span> on);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr_in</span> addr;
</span></span><span style=display:flex><span>    memset(<span style=color:#f92672>&amp;</span>addr, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(sockaddr_in));
</span></span><span style=display:flex><span>    addr.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>    addr.sin_port <span style=color:#f92672>=</span> htons(<span style=color:#ae81ff>8080</span>);
</span></span><span style=display:flex><span>    addr.sin_addr.s_addr <span style=color:#f92672>=</span> INADDR_ANY;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (bind(sockfd, (<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>addr, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr</span>)) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>256</span>];
</span></span><span style=display:flex><span>    socklen_t addr_len <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr_in</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((n <span style=color:#f92672>=</span> recvfrom(sockfd, buf, <span style=color:#ae81ff>256</span>, <span style=color:#ae81ff>0</span>, (<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>addr,
</span></span><span style=display:flex><span>                      <span style=color:#f92672>&amp;</span>addr_len)) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    buf[n] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;\0&#39;</span>;
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;Received: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, buf);
</span></span><span style=display:flex><span>    close(sockfd);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=原始socket编程>原始Socket编程<a hidden class=anchor aria-hidden=true href=#原始socket编程>#</a></h3><h4 id=概述>概述<a hidden class=anchor aria-hidden=true href=#概述>#</a></h4><ul><li>TCP、UDP Socket对TCP协议和UDP协议做了封装来简化编程接口，但失去了对IP数据包操作的灵活性</li><li>原始Socket直接针对IP数据包编程，具有更强的灵活性</li><li>可以编写基于IP协议的高层协议</li></ul><h4 id=发送数据包>发送数据包<a hidden class=anchor aria-hidden=true href=#发送数据包>#</a></h4><ul><li>没有调用<code>connect</code>函数绑定对方地址时必须用<code>sendto</code>或<code>sendmsg</code>发送数据包；调用<code>connect</code>绑定对方IP地址后，可以使用<code>write</code>和<code>send</code>发送数据包</li></ul><h4 id=接收数据包>接收数据包<a hidden class=anchor aria-hidden=true href=#接收数据包>#</a></h4><ul><li>UDP包和TCP包</li><li>大多数ICMP包的拷贝将传递给原始socket</li><li>其他类型的数据包的拷贝传递给匹配的socket</li><li>内核不能识别的IP数据包将传送给匹配的原始socket</li></ul><h2 id=linux进程与信号机制>Linux进程与信号机制<a hidden class=anchor aria-hidden=true href=#linux进程与信号机制>#</a></h2><h3 id=概述-1>概述<a hidden class=anchor aria-hidden=true href=#概述-1>#</a></h3><ul><li>linux进程是系统进行资源分配和调度的基本单位。</li><li>进程的状态：<ol><li>新建</li><li>运行</li><li>阻塞</li><li>就绪</li><li>完成</li></ol></li><li>按继承关系分类<ol><li>父、子、孙进程</li><li>兄弟进程</li><li>孤儿进程</li></ol></li></ul><h3 id=创建进程>创建进程<a hidden class=anchor aria-hidden=true href=#创建进程>#</a></h3><ul><li><code>pid_t fork(void);</code><ul><li>功能：创建新的进程，调用者成为父进程，产生的新进程成为子进程</li><li>返回值：<ul><li><code>> 0</code>, 子进程的id，只在父进程中返回</li><li><code>-1</code>, 调用失败</li><li><code>=0</code>, 只在子进程中返回</li></ul></li><li>头文件：<code>#include &lt;sys/types.h></code> <code>#include &lt;unistd.h></code></li></ul></li><li>fork的原理<ul><li>两次返回<ul><li>调用fork的进程（父进程）返回正整数（子进程ID）</li><li>在新创建的进程（子进程）中返回0，表示是子进程</li></ul></li><li>在调用fork时发生了什么<ul><li>系统创建新进程，并为该进程准备数据段、堆栈段和代码段</li><li>代码段使用和父进程相同的代码段</li><li>父进程的数据段和堆栈段被复制（<a href=https://zh.wikipedia.org/wiki/%E5%AF%AB%E5%85%A5%E6%99%82%E8%A4%87%E8%A3%BD>copy on write, 写入时复制</a>）给子进程<div class=render-image><img loading=lazy src=https://files.catbox.moe/6yhyeq.png alt></div></li></ul></li><li>子进程和父进程共享的内容<ul><li><strong>代码段</strong></li><li>用户标识符</li><li>环境变量</li><li><strong>打开的文件描述符(Socket描述符)</strong></li><li>根目录</li><li>当前工作目录</li><li>创建文件的模式</li><li>⚠️ 数据段和堆栈段通过复制方式共享，因此子进程或父进程修改了变量值后不会影响另一个进程，即使是全局变量。</li></ul></li><li>父子进程执行顺序随机</li></ul></li><li>执行另一个程序<ul><li><code>int execve(const char *path,char * const argv[],char *envp);</code>只有execve是真正的系统调用</li><li><code>int execl(const char *path, const char * argv,…);</code></li></ul></li><li>注意：<ol><li><code>fork()</code>和<code>exec()</code>这两个函数，前者用于并行执行，父、子进程执行相同正文中的不同部分；后者用于调用其他进程，进程执行新的正文。</li><li><code>fork()</code>以后，父、子进程共享代码段，并只重新创建数据有改变的页（段页式管理）</li><li><code>exec()</code>以后，建立新的代码段，用被调用程序的内容填充。</li><li>前者的子进程执行后续的公共代码，后者的子进程不执行后续的公共代码</li></ol></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    pid_t pid;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((pid <span style=color:#f92672>=</span> fork()) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 子进程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Son Process&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (pid <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 父进程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Father Process&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Error&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=创建守护进程>创建守护进程<a hidden class=anchor aria-hidden=true href=#创建守护进程>#</a></h4><ul><li><code>fork()</code>子进程，父进程退出</li><li>子进程建立新会话<code>setsid()</code></li><li>改变当前工作目录chdir(不是必须)</li><li>重设文件掩码(不是必须)<ul><li>子进程会继承父进程的掩码</li><li>增加子进程程序的灵活性</li><li><code>umask(0);</code></li></ul></li><li>关键文件描述符（不是必须）<ul><li>close(0), close(1), close(2)</li><li>释放资源</li></ul></li><li>执行核心工作</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdlib&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;signal.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/param.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/stat.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fcntl.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#66d9ef>const</span> <span style=color:#f92672>*</span>argv[]) {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 1. 调用fork，父进程退出，子进程继续运行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    pid_t pid <span style=color:#f92672>=</span> fork();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (pid <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (pid <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2. 调用setsid变成会长
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 会长就是一个守护进程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    setsid();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3. 忽略SIGHUP信号
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    signal(SIGHUP, SIG_IGN);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 再次fork，父进程（session的头进程）退出
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> ((pid <span style=color:#f92672>=</span> fork()) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (pid <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 4. chdir 改变当前工作目录
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    chdir(<span style=color:#e6db74>&#34;/tmp&#34;</span>);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 5. 重设文件掩码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    umask(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 6. 关闭所有打开的文件描述符
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> NOFILE; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        close(i);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 7. 为标准输入（0），标准输出（1）、标准错误输出（2）打开新的文件描述符
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> fd_rd <span style=color:#f92672>=</span> open(<span style=color:#e6db74>&#34;/dev/null&#34;</span>, O_RDONLY);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> fd_wr <span style=color:#f92672>=</span> open(<span style=color:#e6db74>&#34;/root/deamon.log&#34;</span>, O_WRONLY);
</span></span><span style=display:flex><span>    dup(fd_rd);
</span></span><span style=display:flex><span>    dup(fd_wr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 8. 处理SICHLD，避免守护进程的子进程称为僵尸进程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    signal(SIGCHLD, SIG_IGN);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 让子进程一直活着
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span> (true) {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=信号机制>信号机制<a hidden class=anchor aria-hidden=true href=#信号机制>#</a></h3><h4 id=信号分类>信号分类<a hidden class=anchor aria-hidden=true href=#信号分类>#</a></h4><ul><li>常用信号：<ul><li><code>SIGALARM</code>——计时器到时</li><li><code>SIGCHLD</code>——子进程停止时通知父进程</li><li><code>SIGKILL</code>——终止进程</li><li><code>SIGSTOP</code>——停止进程（暂停）</li><li><code>SIGINT</code>——中断字符</li></ul></li><li>可靠信号和非可靠信号</li><li>实时信号和非实时信号</li></ul><h4 id=发送信号>发送信号<a hidden class=anchor aria-hidden=true href=#发送信号>#</a></h4><ul><li><code>int kill(pid_t pid, int sig)</code></li><li><code>int raise(int sig)</code>向进程自身发送信号</li><li><code>unsigned int alarm(unsigned int seconds)</code></li><li><code>void abort()</code></li><li><code>int sigqueue(pid_t pid, int sig, const union sigval val)</code></li><li>用<code>kill</code>发送信号</li><li>用特定的键盘字符产生信号<ul><li><code>CTRL+C</code>产生<strong>SIGINT</strong></li><li><code>CTRL+BACKSPACE</code>产生<strong>SIGQUIT</strong></li></ul></li></ul><h4 id=接收信号>接收信号<a hidden class=anchor aria-hidden=true href=#接收信号>#</a></h4><ul><li><code>int sigcation(int signum, const struct sigaction *act, struct sigaction *oldact);</code></li><li><code>sigaction结构</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> sigaction {                  
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>sa_handler)(<span style=color:#66d9ef>int</span>);  			            <span style=color:#75715e>// 函数指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>sa_sigaction)(<span style=color:#66d9ef>int</span>, siginfo_t <span style=color:#f92672>*</span>, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>); <span style=color:#75715e>//函数指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	sigset_t sa_mask; 		                        <span style=color:#75715e>// 屏蔽的信号集
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>int</span> sa_flags;			                        <span style=color:#75715e>// 标志，SA_SIGINFO
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>sa_restorer)(<span style=color:#66d9ef>void</span>); 	                    <span style=color:#75715e>// 已废弃
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h4 id=示例>示例<a hidden class=anchor aria-hidden=true href=#示例>#</a></h4><p>INT信号处理</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;csignal&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>signalHandler</span>(<span style=color:#66d9ef>int</span> signum) {
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Catched signal: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> signum <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// exit(signum);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 注册信号SIGNAL和信号处理程序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    signal(SIGINT, signalHandler);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (true) {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Going to sleep...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        sleep(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=进程终止>进程终止<a hidden class=anchor aria-hidden=true href=#进程终止>#</a></h3><p><code>exit()</code></p><h3 id=处理子进程死亡>处理子进程死亡<a hidden class=anchor aria-hidden=true href=#处理子进程死亡>#</a></h3><ul><li>僵尸进程（zombie）<ul><li>子进程终止时如果父进程存在且未处理SIGCHLD信号则子进程变为僵尸进程</li><li>僵尸进程占据系统进程表项</li><li>对比孤儿进程<ul><li>子进程终止，父进程并没有调用 wait/waitpid 获取子进程的终止状态，且父进程还没有结束（子进程没有被 init 收养），那么当子进程结束后，它的进程描述符仍然保存在系统中，这就成了僵尸进程。</li><li>子进程还没有结束，但是父进程结束了，这个时候子进程失去其唯一的父进程，成为了孤儿进程。</li></ul></li></ul></li><li><strong>清理僵尸进程的方法1</strong><ul><li>忽略SIGCHLD信号（使用信号处理函数（SIG_IGN)</li><li>忽略SIGCHLD信号时，系统将清除子进程的进程表项，这种方法依赖于Linux版本的实现</li></ul></li><li>终端操作<ul><li><code>top</code>，查看动态进程状态</li><li>`ps -A -ostat, ppid, pid, cmd | grep -e &lsquo;^[Zz]&rsquo;，查看僵尸进程</li><li><code>kill -HUP xxxx</code>, 清除僵尸</li></ul></li><li><strong>清除僵尸进程的方法2</strong><ul><li>调用<code>wait</code>或<code>waitpid</code>等待子进程<ul><li><code>pid_t wait(int *status);</code>等待任意子进程终止，没有子进程终止时阻塞，如果没有子进程返回<code>-1</code></li><li><code>pid_t waitpid(int pid, int *status, int option)</code></li><li>此方法没有兼容性问题</li></ul></li></ul></li><li><strong>清除僵尸进程的方法3</strong><ul><li>捕获SIGCHLD信号</li></ul></li><li><strong>清除僵尸进程的方法4</strong><ul><li>调用<code>fork()</code>两次，使得子进程成为孤儿进程，由init管理<ul><li>这种方法第一次调用fork产生的子进程可能成为僵尸进程</li><li>这种方法第二次调用fork产生的子进程由init处理子进程退出，不会成为僵尸进程</li></ul><blockquote><p>通俗点讲，就是爷爷第一次 fork 生一个老爸，老爸出生后立刻 fork 生下儿子，这个时候老爸的任务就结束了，可以死掉了 (exit)，这个时候儿子被强大的 init 收养，爷爷爱干啥干啥，从而儿子永远不会成为僵尸进程。</p></blockquote></li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/wait.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    pid_t pid;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((pid <span style=color:#f92672>=</span> fork()) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        pid <span style=color:#f92672>=</span> fork();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (pid <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 父亲生下儿子直接退出，儿子会被收养
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            exit(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        sleep(<span style=color:#ae81ff>0.5</span>);
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;I&#39;m son after second fork.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;my parent&#39;s pid: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, getppid());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 爷爷生下父亲后直接等待为其收尸
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    waitpid(pid, NULL, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 爷爷尽情快活
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=进程同步>进程同步<a hidden class=anchor aria-hidden=true href=#进程同步>#</a></h3><p>当fork调用成功后，父子进程各做各的事情，但当父进程的工作告一段落，需要用到子进程的结果时，它就停下来调用wait，一直等到子进程运行结束，然后利用子进程的结果继续执行。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/wait.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    pid_t pc, pr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> status;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    pc <span style=color:#f92672>=</span> fork();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (pc <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;Error occured on forking.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (pc <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* 子进程的工作 */</span>
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;son</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* 父进程的工作 */</span>
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;father</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        pr <span style=color:#f92672>=</span> wait(<span style=color:#f92672>&amp;</span>status);
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* 利用子进程的结果 */</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=linux进程间通信ipc>Linux进程间通信（IPC)<a hidden class=anchor aria-hidden=true href=#linux进程间通信ipc>#</a></h2><h3 id=管道>管道<a hidden class=anchor aria-hidden=true href=#管道>#</a></h3><ul><li>单向通信，实现双向通信需创建两个管道</li><li>只适用于<strong>父子间</strong>进程通信</li></ul><h4 id=使用管道>使用管道<a hidden class=anchor aria-hidden=true href=#使用管道>#</a></h4><ol><li>用<code>pipe</code>创建两个管道<code>pipe1</code>和<code>pipe2</code></li><li><code>pipe[0]</code>读，<code>pipe[1]</code>写</li><li><code>fork()</code>创建子进程</li><li>父进程用<code>pipe1</code>写数据（关闭<code>pipe1</code>读端口），<code>pipe2</code>读数据（关闭<code>pipe2</code>写端口）</li><li>子进程用<code>pipe1</code>读数据（关闭<code>pipe1</code>写端口），<code>pipe2</code>写数据（关闭<code>pipe2</code>读端口）</li></ol><h4 id=示例-1>示例<a hidden class=anchor aria-hidden=true href=#示例-1>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;errno.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> pipe1[<span style=color:#ae81ff>2</span>], pipe2[<span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> pstr[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;parent data&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> cstr[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;child data&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>100</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (pipe(pipe1) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> pipe(pipe2) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;pipe error&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    pid_t pid <span style=color:#f92672>=</span> fork();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (pid <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 父进程,用管道1写数据,管道2读数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        close(pipe1[<span style=color:#ae81ff>0</span>]);  <span style=color:#75715e>//关闭pipe1读端口
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        close(pipe2[<span style=color:#ae81ff>1</span>]);  <span style=color:#75715e>//关闭pipe2写端口
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        write(pipe1[<span style=color:#ae81ff>1</span>], pstr, <span style=color:#66d9ef>sizeof</span>(pstr));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (read(pipe2[<span style=color:#ae81ff>0</span>], buf, <span style=color:#ae81ff>100</span>) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;parent received:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> buf <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (pid <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 子进程用管道1读数据,管道2写数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        close(pipe1[<span style=color:#ae81ff>1</span>]);  <span style=color:#75715e>//关闭pipe1写端口
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        close(pipe2[<span style=color:#ae81ff>0</span>]);  <span style=color:#75715e>//关闭pipe2读端口
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (read(pipe1[<span style=color:#ae81ff>0</span>], buf, <span style=color:#ae81ff>100</span>) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;child received:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> buf <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        write(pipe2[<span style=color:#ae81ff>1</span>], cstr, <span style=color:#66d9ef>sizeof</span>(cstr));
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;fork error&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=命名管道>命名管道<a hidden class=anchor aria-hidden=true href=#命名管道>#</a></h3><h4 id=特点>特点<a hidden class=anchor aria-hidden=true href=#特点>#</a></h4><ul><li>与一个<strong>路径名</strong>相关联，以文件形式存在于文件系统中</li><li>该文件名所对应的文件没有数据只是为了便于其他进程引用</li><li>可以在兄弟进程通信</li></ul><h4 id=创建>创建<a hidden class=anchor aria-hidden=true href=#创建>#</a></h4><p><code>int mkfifo(char *pathname, mode_t mode);</code></p><h4 id=使用>使用<a hidden class=anchor aria-hidden=true href=#使用>#</a></h4><ul><li>写进程<code>mkfifo</code>创建命名管道</li><li>写进程<code>open</code>以<strong>写阻塞</strong>方式打开管道</li><li>读进程<code>open</code>以<strong>读阻塞</strong>方式打开管道</li><li>写进程调用<code>write</code>写，读进程<code>read</code>读出数据</li></ul><h4 id=示例-2>示例<a hidden class=anchor aria-hidden=true href=#示例-2>#</a></h4><p>fifo_server.cpp</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;errno.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fcntl.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;signal.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/stat.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/time.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/wait.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define FIFO_NAME &#34;/home/fffzlfk/fifo_test&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> pstr[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;server data&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (mkfifo(FIFO_NAME, O_CREAT <span style=color:#f92672>|</span> O_EXCL) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> (errno <span style=color:#f92672>!=</span> EEXIST))
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;create fifo error&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> fd;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>&amp;&amp;</span> strcmp(argv[<span style=color:#ae81ff>1</span>], <span style=color:#e6db74>&#34;-b&#34;</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        fd <span style=color:#f92672>=</span> open(FIFO_NAME, O_WRONLY, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        fd <span style=color:#f92672>=</span> open(FIFO_NAME, O_WRONLY <span style=color:#f92672>|</span> O_NONBLOCK, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (fd <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;open success&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        perror(<span style=color:#e6db74>&#34;open fail&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> write_num <span style=color:#f92672>=</span> write(fd, pstr, <span style=color:#66d9ef>sizeof</span>(pstr));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (write_num <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (errno <span style=color:#f92672>=</span> EAGAIN) cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;write fifo error,try later:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;real write num is:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> write_num <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>fifo_client.cpp</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;errno.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fcntl.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;signal.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/stat.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/time.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/wait.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define FIFO_NAME &#34;/home/fffzlfk/fifo_test&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>1024</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> fd;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>&amp;&amp;</span> strcmp(argv[<span style=color:#ae81ff>1</span>], <span style=color:#e6db74>&#34;-b&#34;</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        fd <span style=color:#f92672>=</span> open(FIFO_NAME, O_RDONLY, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        fd <span style=color:#f92672>=</span> open(FIFO_NAME, O_RDONLY <span style=color:#f92672>|</span> O_NONBLOCK, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (fd <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;open success&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        perror(<span style=color:#e6db74>&#34;open fail&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> read_num <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>;
</span></span><span style=display:flex><span>    memset(buf, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(buf));
</span></span><span style=display:flex><span>    read_num <span style=color:#f92672>=</span> read(fd, buf, <span style=color:#ae81ff>1024</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (read_num <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (errno <span style=color:#f92672>==</span> EAGAIN) cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;no data,try later:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;real read bytes:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> read_num <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;read data:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> buf <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//删除管道文件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// unlink(FIFO_NAME);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=unix域socket>Unix域Socket<a hidden class=anchor aria-hidden=true href=#unix域socket>#</a></h3><ul><li>不是真正的网络协议</li><li>提供<strong>同一台机器</strong>的的进程间通信</li><li>是双向通道</li><li>分为命名和非命名两种</li></ul><h4 id=命名unix域socket>命名Unix域Socket<a hidden class=anchor aria-hidden=true href=#命名unix域socket>#</a></h4><ul><li>特点<ul><li>服务器可以接收多个客户端连接请求</li><li>客户端调用函数connect服务器连接<ul><li>connect使用的socket应该是<strong>已打开的UNIX域socket</strong></li><li>客户端必须拥有打开socket地址所指文件<strong>权限</strong></li><li>监听socket的连接队列满时connect立刻返回错误</li></ul></li></ul></li></ul><h4 id=非命名unix域socket>非命名Unix域Socket<a hidden class=anchor aria-hidden=true href=#非命名unix域socket>#</a></h4><ul><li>特点<ul><li>无名的</li><li><strong>全双工</strong></li><li><strong>不需要连接</strong></li><li>父子进程间通信使用socketpair</li></ul></li></ul><h2 id=io模型>I/O模型<a hidden class=anchor aria-hidden=true href=#io模型>#</a></h2><h3 id=阻塞io模型>阻塞I/O模型<a hidden class=anchor aria-hidden=true href=#阻塞io模型>#</a></h3><ul><li>产生阻塞的原因——时间片调度算法</li><li>好处——阻塞进程不占用CPU时间</li><li>产生阻塞的函数——读、写、建立连接、接受连接<ul><li>读：<code>read</code>、<code>readv</code>、<code>recv</code>、<code>recvfrom</code>和<code>recvmsg</code></li><li>写：<code>write</code>、<code>writev</code>、<code>send</code>、<code>sendto</code>和<code>sendmsg</code></li><li>建立连接：<code>connect</code></li><li>接受连接：<code>accept</code></li></ul></li><li>超时控制<ul><li>调用alarm函数设置超时</li><li>设置socket选项——设置<code>SO_RCVTIMEO</code>和<code>SO_SNDTIMEO</code>选项</li></ul></li></ul><h3 id=非阻塞io模型>非阻塞I/O模型<a hidden class=anchor aria-hidden=true href=#非阻塞io模型>#</a></h3><ul><li>设置Socket为非阻塞方式<ul><li>函数<code>fcntl</code><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> flags;
</span></span><span style=display:flex><span>flag <span style=color:#f92672>=</span> fcntl(sockfd,F_GETFL,<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>fcntl(sockfd,F_SETFL,flag<span style=color:#f92672>|</span>O_NONBLOCK);
</span></span></code></pre></div></li><li>函数<code>ioctl</code><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> on<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>ioctl(sockfd,FIONBIO,<span style=color:#f92672>&amp;</span>on);
</span></span></code></pre></div></li></ul></li><li>检查操作是否可以完成的方式（轮询）</li></ul><h3 id=输入输出多路复用io模型>输入输出多路复用I/O模型<a hidden class=anchor aria-hidden=true href=#输入输出多路复用io模型>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>select</span>(<span style=color:#66d9ef>int</span> maxfd,  <span style=color:#66d9ef>struct</span> fd_set<span style=color:#f92672>*</span> rdset,  <span style=color:#66d9ef>struct</span> fd_set<span style=color:#f92672>*</span> wrset, 
</span></span><span style=display:flex><span>		   <span style=color:#66d9ef>struct</span> fd_set<span style=color:#f92672>*</span> exset,  <span style=color:#66d9ef>struct</span> timeval<span style=color:#f92672>*</span> timeout);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> FD_SET(<span style=color:#66d9ef>int</span> fd,fd_set <span style=color:#f92672>*</span>fdset)   <span style=color:#75715e>//将fd加入到fdset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> FD_CLR(<span style=color:#66d9ef>int</span> fd,fd_set <span style=color:#f92672>*</span>fdset)   <span style=color:#75715e>//将fd从fdset里面清除
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> FD_ZERO(fd_set <span style=color:#f92672>*</span>fdset)         <span style=color:#75715e>//从fdset中清除所有的文件描述符
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> FD_ISSET(<span style=color:#66d9ef>int</span> fd,fd_set <span style=color:#f92672>*</span>fdset) <span style=color:#75715e>//判断fd是否在fdset集合中
</span></span></span></code></pre></div><p>select()可以设置超时，使长期没有文件描述符就绪时，进程可以跳出阻塞状态。select()的第一个参数 maxfd 是集合中最大的文件描述符加1，如：一个包含3个套接字描述符的集合{12，23，30}，那么 maxfd 就应该是30+1=31。</p><p>在我们调用select( )时，进程会一直阻塞到以下的一种情况发生:</p><ul><li>有文件可以读，包括出现错误；</li><li>有文件可以写，包括出现错误；</li><li>超时所设置的时间到；</li><li>被信号中断。</li></ul><h3 id=信号驱动io模型>信号驱动I/O模型<a hidden class=anchor aria-hidden=true href=#信号驱动io模型>#</a></h3><ol><li>设置SIGIO信号处理函数</li><li>设置socket描述符所有者</li><li>允许这个socket进行信号驱动I/O</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sigio_handler</span>(<span style=color:#66d9ef>int</span> signo) {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sockfd;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> on <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    signal(SIGIO, sigio_handler);
</span></span><span style=display:flex><span>    fcntl(sockfd, F_SETOWN, getpid()); <span style=color:#75715e>// 设置套接字所有者为当前进程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ioctl(sockfd, FIOASYNC, <span style=color:#f92672>&amp;</span>on);      <span style=color:#75715e>// 启动信号驱动模式
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=服务器模型>服务器模型<a hidden class=anchor aria-hidden=true href=#服务器模型>#</a></h2><h3 id=网络服务器分类>网络服务器分类<a hidden class=anchor aria-hidden=true href=#网络服务器分类>#</a></h3><ul><li>循环服务器：同一时刻只能处理一个客户端请求</li><li>并发服务器：同一时刻可以处理多个客户端请求</li><li>UDP和TCP服务器模型<ul><li>UDP服务器通常采用循环服务器模型</li><li>TCP服务器通常采用并发服务器模型</li></ul></li></ul><h3 id=循环服务器模型>循环服务器模型<a hidden class=anchor aria-hidden=true href=#循环服务器模型>#</a></h3><h4 id=udp循环服务器模型>UDP循环服务器模型<a hidden class=anchor aria-hidden=true href=#udp循环服务器模型>#</a></h4><p><div class=render-image><img loading=lazy src=https://ftp.bmp.ovh/imgs/2021/05/006763a9f8b52346.png alt></div></p><h4 id=tcp循环服务器模型>TCP循环服务器模型<a hidden class=anchor aria-hidden=true href=#tcp循环服务器模型>#</a></h4><p><div class=render-image><img loading=lazy src=https://ftp.bmp.ovh/imgs/2021/05/0ef562a30cd8c6b8.png alt></div></p><h3 id=并发服务器模型>并发服务器模型<a hidden class=anchor aria-hidden=true href=#并发服务器模型>#</a></h3><h4 id=ucp并发服务器模型>UCP并发服务器模型<a hidden class=anchor aria-hidden=true href=#ucp并发服务器模型>#</a></h4><p><div class=render-image><img loading=lazy src=https://ftp.bmp.ovh/imgs/2021/05/034f12814488cd5f.png alt></div></p><h4 id=tcp并发服务器模型>TCP并发服务器模型<a hidden class=anchor aria-hidden=true href=#tcp并发服务器模型>#</a></h4><ul><li>一个子进程对应一个客户端<ul><li>创建子进程开销大，适合长时间客户请求（如FTP）</li><li>客户端数量大、请求时间短会大大降低效率（如HTTP）<div class=render-image><img loading=lazy src=https://ftp.bmp.ovh/imgs/2021/05/05f64327a35f8e4d.png alt></div></li></ul></li><li>延迟创建子进程<ul><li>处理短请求以循环方式完成</li><li>处理时间长的请求以并发方式完成<div class=render-image><img loading=lazy src=https://ftp.bmp.ovh/imgs/2021/05/1d8fd44e6068663b.png alt></div></li></ul></li><li>预创建子进程<ul><li>数量固定<ul><li>所有进程调用accept，无连接时将睡眠</li><li>有连接到来时所有进程被唤醒</li><li>某一个进程接受连接后，其余连接继续睡眠<div class=render-image><img loading=lazy src=https://i.loli.net/2021/05/18/ctweTXfW5zx1h4E.png alt></div></li></ul></li><li>动态子进程数<ul><li>父进程与子进程通过管道通信</li><li>子进程接收连接时给父进程发1，关闭时发0</li><li>父进程收到1时，检查空闲子进程数是否小于上限，小于则创建新的子进程</li><li>父进程收到0时，检查空闲子进程数是否大于上限，大于则终止一些子进程<div class=render-image><img loading=lazy src=https://i.loli.net/2021/05/18/8IV7OS2vrqAayew.png alt></div></li></ul></li></ul></li><li>多路复用I/O<ul><li>select函数检查侦听socket是否有连接到达、已连接socket是否有数据到达、已连接socket是否可以写数据</li><li>在测试是否可读的描述符集合rdset中同时包含侦听socket和已连接socket，在测试是否可写描述符集合中包含已连接socket，就可以实现多路复用</li></ul></li></ul><h4 id=linux-epoll>Linux epoll<a hidden class=anchor aria-hidden=true href=#linux-epoll>#</a></h4><ul><li>一种多路复用模型</li><li>对比select<ul><li><p>select</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> select(maxfd<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>&amp;</span>rds, NULL, NULL, <span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> fdset_size; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (FD_ISSET(allFD[i],<span style=color:#f92672>&amp;</span>rds)) {
</span></span><span style=display:flex><span>            handleEvent(allFD[i]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>epoll</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> epoll_wait(epfd, events, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n;i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    handleEvent(events[n]);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li></ul><h2 id=带外数据oob>带外数据（OOB）<a hidden class=anchor aria-hidden=true href=#带外数据oob>#</a></h2><p>带外数据（Out Of Band）：传输层使用带外数据发送重要数据</p><p>紧急状态</p><ul><li>发送方TCP协议保证紧急状态能够立即发送</li><li>接收方通过信号<code>SIGURG</code>或<code>select</code>函数得知紧急状态</li></ul><h3 id=tcp带外数据发送>TCP带外数据发送<a hidden class=anchor aria-hidden=true href=#tcp带外数据发送>#</a></h3><ul><li>TCP只支持<strong>1字节</strong>带外数据</li><li>TCP使用URG标志位和紧急指针指明带外数据：紧急指针=带外数据位置+1<div class=render-image><img loading=lazy src=https://i.loli.net/2021/05/25/DsXykvhjlIaTzY3.png alt></div></li></ul><h3 id=发送tcp带外数据的函数>发送TCP带外数据的函数<a hidden class=anchor aria-hidden=true href=#发送tcp带外数据的函数>#</a></h3><p><code>send</code>函数和标志<code>MSG_OOB</code></p><p>一个进程已经往TCP连接的发送缓冲区写入了N个字节的普通数据，然后该进程又向这个连接写入了3字节的带外数据“abc”。此时，待发送的TCP报文段头部将被设置为URG标志，并将紧急指针设置为指向带外数据的下一字节。</p><ul><li>发送单个字节，这个字节被认为是带外数据<code>send(sockfd, "A", 1, MSG_OOB);</code></li><li>发送多个字节，只有最后一个字节被认为是带外数据<code>send(sockfd, "ABC", 3, MSG_OOB);</code>，其他数据被当作普通数据。</li></ul><h3 id=tcp接收带外数据的过程>TCP接收带外数据的过程<a hidden class=anchor aria-hidden=true href=#tcp接收带外数据的过程>#</a></h3><p>TCP接收端在收到紧急指针标志时检查紧急指针，然后根据紧急指针的位置确定带外数据的位置，并将它读入一个特殊的缓存中（1字节），称之为带外缓存。</p><ul><li>未设置<code>SO_OOBINLINE</code>选项时新到来的带外数据将覆盖未处理的带外数据。</li><li>设置了<code>SO_OOBINLINE</code>选项时新到来的带外数据不会覆盖未处理的带外数据，但未处理的带外数据将会变成普通数据。</li></ul><h3 id=代码>代码<a hidden class=anchor aria-hidden=true href=#代码>#</a></h3><ul><li><a href="https://paste.blinking.fun/?id=60ac9fb8b2b1d74df21cc730">./sigurg port</a>，读数据，带外数据在信号处理中</li><li><a href="https://paste.blinking.fun/?id=60aca00be2fa0d4db8addc63">./oobserver port</a>，接受连接并给客户机发包含带外数据的包</li><li><a href="https://paste.blinking.fun/?id=60aca054b2b1d74df21cc804">./oobclient port</a><code>-i</code>，oob_inline</li></ul><h2 id=复习>复习<a hidden class=anchor aria-hidden=true href=#复习>#</a></h2><ul><li><p>一台工作于内外网模式的主机，具有一个外网地址IP_OUTTER和一个内网地址192.168.1，内网的掩码为192.168.1.125。该主机可将外网用户的请求广播给内网用户。请设计和实现该主机程序。</p><ul><li>问题分析和方案设计<ul><li>TCP协议具有稳定可靠的特性，本题中外网通信属于单播，使用TCP协议能够具有良好性能，因此外网通信使用TCP套接字。</li><li>内网涉及到广播，适合使用UDP协议进行工作，因此内网采用UDP套接字工作。</li><li>主机采用单进程、阻塞式工作。</li></ul></li><li>编程<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstring&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netinet/in.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> port <span style=color:#f92672>=</span> <span style=color:#ae81ff>8080</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sockt, connfd, socku;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr_in</span> addr, addrX;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>2048</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((sockt <span style=color:#f92672>=</span> socket(AF_INET, SOCK_STREAM, <span style=color:#ae81ff>0</span>)) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    bzero(<span style=color:#f92672>&amp;</span>addr, <span style=color:#66d9ef>sizeof</span>(addr));
</span></span><span style=display:flex><span>    addr.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>    addr.sin_port <span style=color:#f92672>=</span> htons(port);
</span></span><span style=display:flex><span>    addr.sin_addr.s_addr <span style=color:#f92672>=</span> htonl(INADDR_ANY);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((bind(sockt, (sockaddr <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>addr, <span style=color:#66d9ef>sizeof</span>(addr))) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (listen(sockt, <span style=color:#ae81ff>5</span>) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr_in</span> cli_addr;
</span></span><span style=display:flex><span>    socklen_t sin_size <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr_in</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>        connfd <span style=color:#f92672>=</span> accept(sockt, (sockaddr <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>cli_addr, <span style=color:#f92672>&amp;</span>sin_size);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (connfd <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> read(connfd, buf, <span style=color:#ae81ff>2048</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ((socku <span style=color:#f92672>=</span> socket(AF_INET, SOCK_DGRAM, <span style=color:#ae81ff>0</span>)) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        bzero(<span style=color:#f92672>&amp;</span>addrX, <span style=color:#66d9ef>sizeof</span>(addr));
</span></span><span style=display:flex><span>        addrX.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>        addrX.sin_port <span style=color:#f92672>=</span> htons(port);
</span></span><span style=display:flex><span>        addrX.sin_addr.s_addr <span style=color:#f92672>=</span> inet_addr(<span style=color:#e6db74>&#34;192.168.1.1&#34;</span>);
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> sendto(socku, buf, n, <span style=color:#ae81ff>0</span>, (sockaddr <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>addrX, <span style=color:#66d9ef>sizeof</span>(addrX));
</span></span><span style=display:flex><span>        close(socku);
</span></span><span style=display:flex><span>        close(sockt);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><p>有一台服务器，可以为多个客户机同时提供两个整数的乘法和除法运算，请设计和实现该服务器。提示：需考虑应用层协议、僵尸进程的清除等问题。</p><ul><li>问题分析和方案设计<ul><li>本题需要同时为多个客户机服务，应采用并发方式；</li><li>对于整数、要考虑字节顺序转换；</li><li>除法要考虑除0问题；</li><li>设计服务器接收数据格式如下：<ul><li>int mType (运算类型：0-乘、1-除)</li><li>n1(整数1)，n2(整数2)</li></ul></li><li>服务器发送数据格式如下：<ul><li>int mRet(0-正确、1-错误)</li><li>n（运算结果）</li></ul></li><li>工作于TCP方式。</li></ul></li><li>编程<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sigchild_handler</span>(<span style=color:#66d9ef>int</span> sig) {
</span></span><span style=display:flex><span>    wait(NULL);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>main() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sock, connfd;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr_in</span> addr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sigaction</span> sigact;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>short</span> mRet, mType;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n, n1, n2;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>1024</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sigact.sa_handler <span style=color:#f92672>=</span> sigchild_handler;
</span></span><span style=display:flex><span>    sigact.sa_mask <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    sigact.sa_flags <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    sigaction(SIGCHILD, <span style=color:#f92672>&amp;</span>sigact, NULL);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((sock <span style=color:#f92672>=</span> socket(AF_INET, SOCK_STREAM, <span style=color:#ae81ff>0</span>))<span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    SET_ADDR_PORT;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (bind() <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (listen(sock, <span style=color:#ae81ff>5</span>) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>        connfd <span style=color:#f92672>=</span> accept();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (connfd <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (fork() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            close(sock);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> read(conndf, buf, <span style=color:#ae81ff>2048</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            mRet <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            ntoh(CharToInt);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (mType <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                n <span style=color:#f92672>=</span> hton(n1<span style=color:#f92672>*</span>n2);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (mType <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> n2 <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                n <span style=color:#f92672>=</span> hton(n1<span style=color:#f92672>/</span>n2);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                mRet <span style=color:#f92672>=</span> hton(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>                n <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            IntToChar;
</span></span><span style=display:flex><span>            write(connfd, buf, <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span><span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>            close(connfd);
</span></span><span style=display:flex><span>            exit(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    close(sock);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://fffzlfk.github.io/tags/academic/>Academic</a></li></ul><nav class=paginav><a class=prev href=https://fffzlfk.github.io/posts/go%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/><span class=title>« Prev</span><br><span>Go设计模式</span></a>
<a class=next href=https://fffzlfk.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/><span class=title>Next »</span><br><span>分布式计算</span></a></nav></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//https-fffzlfk-github-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2022 <a href=https://fffzlfk.github.io>fffzlfk's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>