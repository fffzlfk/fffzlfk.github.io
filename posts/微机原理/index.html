<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>微机原理 | fffzlfk's Blog</title><meta name=keywords content="Academic"><meta name=description content="西电微机原理"><meta name=author content="fffzlfk"><link rel=canonical href=https://fffzlfk.github.io/posts/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/><link crossorigin=anonymous href=/assets/css/stylesheet.3b1cc03af9890a9e14762cb10779f50b165a8e12a4ff763213eef0019f3771fb.css integrity="sha256-OxzAOvmJCp4UdiyxB3n1CxZajhKk/3YyE+7wAZ83cfs=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.ab916b8151320cc693135f5df9fe4b75e6e4754d8f0dff5782df332cacd1ba8e.js integrity="sha256-q5FrgVEyDMaTE19d+f5LdebkdU2PDf9Xgt8zLKzRuo4=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://fffzlfk.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://fffzlfk.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://fffzlfk.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://fffzlfk.github.io/apple_touch_icon.png><link rel=mask-icon href=https://fffzlfk.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:title" content="微机原理"><meta property="og:description" content="西电微机原理"><meta property="og:type" content="article"><meta property="og:url" content="https://fffzlfk.github.io/posts/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-10-17T21:07:26+08:00"><meta property="article:modified_time" content="2020-10-17T21:07:26+08:00"><meta property="og:site_name" content="fffzlfk's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="微机原理"><meta name=twitter:description content="西电微机原理"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://fffzlfk.github.io/posts/"},{"@type":"ListItem","position":3,"name":"微机原理","item":"https://fffzlfk.github.io/posts/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"微机原理","name":"微机原理","description":"西电微机原理","keywords":["Academic"],"articleBody":"单核处理器8086/8088 寄存器结构 通用寄存器 Reg 特殊用途 AX,AL I/O 指令的数据寄存器；乘法指令存放被乘数或积(隐含)，除法指令存放被除数或商(隐含) AH LAHF指令的目标寄存器(隐含) AL 数制转换或十进制运算指令和XLAT指令的累加器(隐含) BX 间接寻址的基址寄存器 XLAT指令的基址寄存器(隐含) CX 串操作和LOOP指令的计数器(隐含) DX 字乘法/除法指令存放乘积高16位或被除数高位或余数(隐含) 间接寻址的 I/O 端口地址 SI 串操作的源变址寄存器(隐含)、间接寻址的变址寄存器 DI 串操作的目标变址寄存器(隐含)、间接寻址的变址寄存器 BP 对堆栈区间接寻址的基址指针 SP 堆栈操作的堆栈顶部指针 标志寄存器 6个状态标志位\nCF，进位标志。本次运算最高位有进位或借位发生，则CF=1。STC（CLC）指令使CF=1（=0），CMC指令使之取反。（用于无符号数）\nPF，奇偶校验标志：低 8 位有偶数个 1 则 PF = 1\nAF：辅助进位标志\n低 4 位向高四位有进位或借位， AF = 1 （用于 BCD 计算）\nZF：全零标志\n运算结果为 0 时，ZF = 1；\nSF：符号标志\n运算结果最高位为1，SF = 1 （表示负数）\nOF：溢出标志\n运算产生溢出 （两负数相加为正）（有符号数）时， OF =1\n3 个控制标志位\nTF：单步标志 IF：中断标志：IF = 1 允许，IF=0 禁止 CPU 响应可屏蔽中断 （INTR） DF：方向标志，串操作指令的地址变化方向 主存结构 双体结构 既能实现16位存储，也可以实现8位存储。 分段结构 68320H + 1280H -------- 695A0H 芯片引脚 8086芯片引脚 8088芯片引脚 8086vs.8088 指令预取序列：4Bytes\u003c=\u003e6Bytes AD7~AD0\nAD15~AD0 =\u003e 总线传递数据更快 8088：$ \\overline{SSO} $, 8086: $ \\overline{BHE} / S7 $ 8088: $ IO/\\overline M $, 8086: $ M/\\overline{IO} $ 工作时序 时钟周期：CPU处理动作最小单位 总线周期：存储器读写、I/O读写、中断响应 指令周期：取指+执行 主存读时序分析 习题 2.2 若8086CPU工作在最小模式下：\n当CPU访问储存器时，要利用哪些信号？ $AD0 \\sim AD15、A16\\sim A19、ALE、\\overline{BHE}、DT/\\overline{R}、\\overline{DEN}、M/\\overline{IO}、\\overline{RD}、\\overline{WR}$\n当CPU访问外设端口时，要利用哪些信号？ $AD0 \\sim AD15、ALE、\\overline{BHE}、DT/\\overline{R}、\\overline{DEN}、M/\\overline{IO}、\\overline{RD}、\\overline{WR}$\n当HOLD有效并得到回应时，CPU的哪些信号置高阻？ CPU所有三态输出的地址、数据和相关控制信号。\n2.2 若8086CPU工作在最大模式下：\nS0、S1、S2可以表示哪些CPU的状态？ INTA周期、I/O读周期、I/O写周期、暂停、取值周期、存储器读周期、存储器写周期\nCPU的$ \\overline{RQ}/\\overline{GT} $信号的作用是什么？ $ \\overline{RQ}/\\overline{GT} $是裁决总线使用权的请求/允许信号\nIntel指令系统与程序设计 程序框架 STACK SEGMENT STACK DB 100 DUP(0) STACK ENDS DATA SEGMENT NUM8 DB 16,25 NUM16 DW 36,64 ARRAY8 DB 20 DUP(0) ……… ………… DATA ENDS CODE SEGMENT ASSUME CS:CODE,DS:DATA,SS:STACK START: MOV AX,DATA MOV DS,AX ………… MOV AX,4C00H INT 21H CODE ENDS END START 子程序结构\n…… CALL SUB1 …… SUB1 PROC PUSH … …… POP … RET SUB1 ENDP 数据传送、寻址、算术运算指令 数据传送 MOV指令\nMOV指令必须遵从的的规则： 两个操作数的尺寸必须一致 两个操作数不能同为操作数 目的操作数不能位CS, EIP和IP 立即数不能直接送至段寄存器 mov r/m16,sreg mov sreg,r/m16 MOV指令格式 mov reg, reg mov mem, reg mov reg, mem mov mem, imm mov reg, emm 整数的零/符号扩展\nMOVZX MOVSZ XCHG指令\n交换两个操作数的内容\n加法和减法 INC和DEC指令\ninc reg/mem dec reg/mem \u003c notice tip \u003e INC和DEC指令不影响进位标志 \u003c /notice \u003e\nADD、SUB、NEG指令\n影响的标志位：CF, ZF, SF, OF, AF, PF\n和数据相关的操作符和伪指令 OFFSET操作符\nPTR操作符\n用来重载操作数的默认尺寸 必须和标准数据类型联合使用 .data myDouble DWORD 12345678h .code mov ax, myDouble ; 错误 mov ax, WORD PTR myDouble ; ax = 5678h mov ax, WORD PTR [myDouble+2] ; ax = 1234h mov bl, BYTE PTR myDouble ; bl = 78h TYPE操作符 返回按字节计算的变量的单个元素的大小\nLENGTHOF操作符 计算数组元素的个数\nSIZEOF操作符 SIZEOF返回值=LENGTHOF返回值*TYPE返回值\n间接寻址 间接操作数(寄存器间接寻址)\nPTR与间接操作数的联合使用：\ninc [esi] ; error: operand must have size inc BYTE PTR [esi] 数组\n例：三个双字相加\n.data arrayD DWORD 10000h,20000h,30000h .code mov esi, OFFSET arrayD mov eax, [esi] add esi, 4 add eax, [esi] add esi, 4 add eax, [esi] 变址操作数(寄存器相对寻址)\n例：\n.data arrayB BYTE 10h, 20h, 30h .code mov esi, 0 mov al, [arrayB+esi] ; AL = 10h mov al, arrayB[esi] ; 同上，另一种格式 mov esi, OFFSET arrayB mov al, [esi] ; AL = 10h mov al, [esi+1] ; AL = 20h mov al, [esi+2] ; AL = 30h JMP和LOOP指令 JMP：无条件转移 LOOP:条件转移 在实地址模式下，用做默认循环计数器的是CX而不是ECX 在任何模式下，LOOPD指令都使用ECX作为循环计数器，LOOPW都使用CX作为循环计数器 循环的目的地址与当前地址只能在相距-128到+127字节的范围之内。机器指令平均在3字节左右，因此一个循环平均最多只能包含大约42条指令 循环的嵌套 .data count DWORD ? .code mov ecx, 100 L1: mov count, ecx mov ecx, 20 L2: ... ... loop L2 mov ecx, count loop L1 小结：操作数类型（寻址方式） 直接操作数（直接寻址） 变量的名字，代表变量的地址 直接偏移操作数 在变量的名字上加一个偏移量 间接操作数（寄存器间接寻址） 用方括号括起的包含数据地址的寄存器 变址操作数（寄存器相对寻址） 把常量和间接操作数结合在一起 过程 与外部库链接 程序中要用PROTO伪指令声明要调用的程序: WriteString PROTO 用一条CALL指令执行WriteString过程: call WriteString 当程序被编译时，编译器为CALL指令的目标地址留出空白，该空白将有链接器填充 连接器在链接库中查找WriteString这个名字，从库中把合适的机器指令拷贝到程序的可执行文件中，并把WriteString的地址插入到CALL指令中 堆栈操作 堆栈 压栈操作： 32位的压栈（PUSH）操作将堆栈指针减4，并将进栈数据拷贝到堆栈指针所指向的位置\n出栈操作： 出栈（POP）操作从堆栈顶端移走一个值并将其置于寄存器或变量中。在值从栈顶弹出后，堆栈指针相应增加。\n堆栈的用途：\n临时保存区域 CALL指令用堆栈保存当前过程的⚠️返回地址 调用过程时,通过堆栈:⚠️传递参数 过程内的⚠️局部变量在堆栈上创建，过程结束时，这些变量被丢弃 PUSH和POP指令 PUSH指令\n执行过程 减小ESP的值 16位操作数：ESP减2 32位操作数：ESP减4 将一个16位或32位的源操作数拷贝至堆栈上 指令格式 push r/m16\rpush r/m32\rpush imm32 保护模式下的立即数总是32位的； 在实地址模式下，如果未使用.386（或更高）处理器伪指令，默认的立即数是16位的 POP指令\n执行过程 将ESP所指向的堆栈元素拷贝到16位或32位的目的操作数中 增加ESP的值 16位操作数：ESP加2 32位操作数：ESP加4 指令格式 pop r/m16\rpop r/m32 PUSHFD和POPFD指令\n32位： PUSHFD：在堆栈压入32位EFLAGS寄存器的值 POPFD：将堆栈顶部的值弹出并送至EFLAGS寄存器 实地址模式： PUSHF：在堆栈上压入16位FLAGS寄存器的值 POPF：将堆栈顶部的值弹出并送至FLAGS寄存器 PUSHAD,PUSHA,POPAD和POPA指令\n32位： PUSHAD：将EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI按顺序压入堆栈 POPAD：按相反顺序弹出这些通用寄存器 80286： PUSHA：以用样的顺序压入AX、CX、DX、BX、SP、BP、SI、DI POPA：以相反的顺序弹出 过程的定义和使用 PROC伪指令\nSumof PROC add eax, ebx add eax, ecx ret Sumof ENDP CALL和RET指令\n调用和返回的例子 可嵌套使用\n局部标号和全局标号\nL1:: ; global label ... L2: ; local babel ... 条件处理 布尔和比较指令 AND指令：按位与 影响的标志位： 总是清除OF和CF； 根据结果修改SF，ZF，PF 主要用途：对特定的位清0 大写字母和小写字母的ASCII码之间的关系： ‘a’: 61h, 01100001b ‘A’: 41h, 01000001b OR指令：按位或 主要用途：对特定的位置1 XOR指令：按位异或 用途： 对某些位取反 判断16位或32位值的奇偶性 mov ax, 64C1h ; 0110 0100 1100 0001 xor ah, al ; PE, 奇偶位被设置 简单数据加密 将某个操作数与同样的操作数执行两次异或操作之后，其值保持不变 $$ (X\\oplus Y) \\oplus Y = X $$ NOT指令：取反 \u003c notice warning \u003e NOT指令不影响任何状态标志 \u003c /notice \u003e TEST指令：两操作数按位与，根据结果设置标志位，但不回送结果（不修改目的操作数） 用途：测试某一位是“0”还是“1” test al, 00001001b ; test bits 0 and 3 判断ZF是否等于1 影响的标志位：清除OF、CF；修改SF、ZF、PF CMP指令 功能：与减法指令一样执行减法操作，但不回送结果，只影响标志位\n影响的标志位：根据相减结果修改OF、SF、ZF、CF、AF、PF\n无符号操作数的比较\nCMP的结果 ZF CF 目的 \u003c 源 0 1 目的 \u003e 源 0 0 目的 = 源 1 0 有符号操作数的比较\nmov ax, 5 cmp ax, 10 ; CF = 1 mov si, 105 cmp si, 0 ; ZF = 0, CF = 0 mov ax, 1000 mov cx, 1000 cmp ax, cx ; ZF = 1 设置和清除单个CPU标志\ntest al, 0 ; 设置零标志 and al, 0 ; 设置零标志 or al, 0 ; 设置零标志 or al, 80h ; 设置符号标志 and al, 7Fh ; 清楚符号标志 stc ; 设置进位标志 clc ; 清除进位标志 mov al, 7Fh ; AL = +127 inc al ; AL = 80h or eax, 0 ; 清除溢出标志 条件跳转 条件结构\n使用CMP、TEST、AND之类的指令修改CPU标志\n使用条件跳转指令测试标志值，已决定是否向新的分支转移\ncmp al, 0 jz L1 ; jump if ZF = 1 ... L1: and dl, 10110000b jnz L2 ; jump if ZF = 0 ... L2: Jcond指令\n功能： 条件标志为真：分支转移到新的目标标号处 条件标志为假：执行紧跟在条件跳转指令之后的指令 格式： 例： mov ax, 5 mov ax, 5 mov ax, 5 cmp ax, 5 cmp ax, 6 mov ax, 6 je L1 j1 L1 jg L1 条件跳转指令的类型\n基于特定CPU标志值\n助记符 描述 标志值 JZ 为零则跳转 ZF = 1 JNZ 不为零则跳转 ZF = 0 JC 如果设置进位标志则跳转 CF = 1 JNC 如果未设置进位标志则跳转 CF = 0 JO 如果设置溢出标志则跳转 OF = 1 JNO 如果未设置溢出标志则跳转 OF = 0 JS 如果设置符号标志则跳转 SF = 1 JNS 如果未设置符号标志则跳转 SF = 0 JP 如果设置了奇偶标志则跳转（偶） PF = 1 JNP 如果未设置奇偶标志则跳转（奇） PF = 0 依据相等比较的跳转指令\n助记符 描述 JE 相等则跳转 JNE 不相等则不跳转 JCXZ CX = 0 则跳转 JECXZ ECX = 0 则跳转 基于无符号整数比较结果的跳转指令\nA:Above, B: Below, E:Equal\n助记府 描述 JA 大于则跳转(leftOp \u003e rightOp) JNBE 不（小于或等于）（同JA） JAE 大于或等于则跳转 (leftOp \u003e= rightOp) JNB 不小于则跳转 （同JAE） JB 小于则跳转(leftOp \u003c rightOp) JNAE 不（大于或等于）（同JB） JBE 小于或等于则跳转(leftOp \u003c= rightOp) JNA 不大于则跳转（同JBE） 基于有符号整数比较结果的跳转指令\nG: Grater, L: Less, E: Equal\n助记府 描述 JG 大于则跳转(leftOp \u003e rightOp) JNLE 不（小于或等于）（同JA） JGE 大于或等于则跳转 (leftOp \u003e= rightOp) JNL 不小于则跳转 （同JAE） JL 小于则跳转(leftOp \u003c rightOp) JNGE 不（大于或等于）（同JB） JLE 小于或等于则跳转(leftOp \u003c= rightOp) JNG 不大于则跳转（同JBE） mov al, 7Fh ; (7Fh or +127) cmp al, 80h ; (80h or -128) ja IsAbove ; no : 7F not \u003e 180h mov al, 7Fh ; (7Fh or +127) cmp al, 80h ; (80h or -128) jg IsAbove ; yes: +127 \u003e -128 条件循环指令 LOOPZ和LOOPE指令\n含义：Loop if zero，Loop if equal 二者等价 执行逻辑： ECX = ECX - 1\nif ECX \u003e 0 and ZF = 1, jump to destination LOOPNZ和LOOPNE指令\n含义：Loop if not zero， Loop if not equal 二者等价 执行逻辑： ECX = ECX - 1\nif ECX \u003e 0 and ZF = 0, jump to destination ; 扫描数组中的每个数值，直到发现正数为止 .data array SWORD -3,-6,-1,-10,10,30,40,4 sentinel SWORD 0 .code mov esi, OFFSET array mov ecx, LENGTHOF array next: test WORD PTR [esi], 8000h ; test highest bit pushfd ; push flags on stack add esi, TYPE array popfd ; pop flags from stack loopnz next ; continue jnz quit ; none found sub esi, TYPE array ; SI points to value 整数运算指令 移位和循环移位指令 \u003c notice note \u003e Shift Left Right Arithmetic Rotate Carry \u003c /notice \u003e\n移位指令\n助记符 描述 SHL 逻辑左移 SHR 逻辑右移 SAL 算数左移 SAR 算数右移 ROL 循环左移 ROR 循环右移 RCL 带进位的循环左移 RCR 带进位的循环右移 SHLD 双精度左移 SHRD 双精度右移 上述指令影响OF、CF\n逻辑移位和算术移位 循环左移ROL和循环右移ROR 带进位的循环左移RCL和右移RCR SHLD/SHRD指令\n格式：SHLD 目的操作数，源操作数，移位位数 要求至少是Intel386处理器 SHLD：双精度左移，Shift Left Double\n将目的操作数左移指定的位数，低位空出来的位用源操作数的高位填充 SHRD：双精度右移，Shift Right Double\n将目的操作数右移指定的位数，空出来的位由源操作数的低位来填充。 格式：\n助记符 目的操作数，移位位数\nSHL reg, imm8 SAL mem, imm8 ROR reg, CL RCL mem, CL 8088/8086要求imm8必须等于1；80286以上，imm8可以为“任意”整数 CL方式可用于任何Intel x86处理器 乘法和除法指令 MUL指令\n格式（操作数为乘数）：\nMUL r/m8\nMUL r/m16\nMUL r/m32 功能：无符号乘法。将8位、16位或32位的操作数与AL、AX或EAX相乘 被乘数 乘数 积 CF = 1的条件 AL r/m8 AX AH $\\neq$ 0 AX r/m16 DX:AX DX $\\neq$ 0 EAX r/m32 EDX:EAX EDX $\\neq$ 0 IMUL指令：有符号乘法\n如果累积的高半部分不是低半部分的符号扩展（换而言之就是低半部分不足够表示累积），则设置CF和OF\n例：\nmov al, 48 ; 48D = 30H mov bl, 4 imul bl ; AX = 00C0h, OF = 1 mov al, -4 mov bl, 4 imul bl ; AX = FFF0h, OF = 0 mov ax, 48 mov bx, 4 imul ax ; DX:AX = 000000C0h, OF = 1 DIV指令：无符号除法\n被除数 除数 商 余数 AX r/m8 AL AH DX:AX r/m16 AX DX EDX:EAX r/m32 EAX EDX 有符号整数除法\nCBW, CWD, CDQ指令 CBW(Convert Byte to Word): 将AL中的符号位扩展到AH CWD(Convert Word to Doubleword): 将AX中的符号位扩展到DX CDQ(Convert DoubleWord QuadWord): 将EAX中的符号位扩展到EDX IDIV指令：有符号数整数的除法运算\n例： .data byteVal SBYTE -48 .code mov al, byteVal cbw ; extend AL into AH mov bl, 5 idiv bl ; AL = -9, AH = -3 .data wordVal SWORD -5000 .code mov ax, wordVal cwd ; extend AX into DX mov bx, 256 idiv bx ; AX = -19, DX = -136 除法溢出 当除法产生的商太大而无法容纳在目的操作数中的时候，将导致除法溢出，使CPU触发一个中断，当前程序被终止 试图除以0也会发生相同的情况 解决办法 使用32位的除数来减小除法溢出的可能性 测试除数，如果除数等于0则跳过除法指令 扩展加法和减法 ADC指令：扩展加法\n目的操作数 + 源操作数 + 进位标志-\u003e目的操作数 SBB指令：扩展减法\n目的操作数 + 源操作数 - 进位标志-\u003e目的操作数 ASCII和压缩十进制算数 AAA：加法之后进行ASCII码调整 mov ag, 0 mov al, '8' ; AX = 0038h add al, '2' ; AX = 006Ah aaa ; AX = 0100h or ax, 3030h ; AX = 3130h = '10' AAS：减法之后进行ASCII码调整 AAM：乘法之后进行ASCII码调整 AAD：除法之后进行ASCII码调整 压缩的十进制整数 DAA指令：将ADD或ADC指令执行后AL中的结果转换成压缩的十进制格式 DAS指令：将SUB或SBB指令执行后AL中的结果转换成压缩的十进制格式 例： mov al, 35h add al, 48h ; AL = 7Dh daa ; AL = 83h mov bl, 48h mov al, 85h sub al, bl ; AL = 3Dh das ; AL = 37h 字符串与数组 基本字符串操作指令 指令 描述 MOVSB, MOVSW, MOVSD 移动字符串数据：拷贝DS:(E)SI寻址的内存操作数至ES:(E)DI CMPSB, SMPSW, CMPSD 比较字符串：比较内存中由DS:(E)SI寻址和ES:(E)DI寻址的字符串。源-目的 SCASB, SCASW, SCASD 扫描字符串：扫描ES:(E)DI指向的内存字符串查找与累加器匹配的值 STOSB, STOSW, STOSD 存储字符串：将累加器内容存储到由ES:(E)DI寻址的内存中 LODSB, LODSW, LODSD 将字符串数据装入累加器：将由DS:(E)SI寻址的内存单元装入累加器中 使用重复前缀\n字符串操作指令每次只能处理一个内存值。 通过增加一个重复前缀，字符串指令就会使用ECX作为计数器进行重复 —— 实现用一条指令处理整个数组。 可以使用的重复前缀 REP ECX \u003e 0时重复 REPZ, REPE 当ZF＝1且ECX＞0时重复 REPNE, REPNZ 当ZF＝0且ECX＞0时重复 方向标志：简单字符串指令使用方向标志来决定ESI和EDI是自动增加还是自动减少。 方向标志位 DF＝0：ESI、EDI 自动增加； 方向标志位 DF＝1：ESI、EDI 自动减少。 方向标志可以通过CLD和STD指令改变： CLD\t; 清除方向标志 STD\t; 设置方向标志 MOVSB、MOVSW 和 MOVSD 指令\n.data source DWORD 20 DUP(0FFFFFFFFh) target DWORD 20 DUP(?) .code cld\t; direction = forward mov ecx,LENGTHOF source\t; set REP counter mov esi,OFFSET source\t; ESI points to source mov edi,OFFSET target\t; EDI points to target rep movsd\t; copy doublewords CMPSB、CMPSW 和 CMPSD 指令\n隐含执行：源-目的，这与 CMP 指令相反\nmov esi,OFFSET source mov edi,OFFSET target cld\t; direction = up mov ecx,count\t; repetition counter repe cmpsd\t; repeat while equal SCASB、SCASW 和 SCASD 指令\n将AL/AX/EAX中的值同目标内存(由DI寻址)中的字节、字或双字相比较。 例:扫描一个匹配字符：在字符串变量alpha中查找字母“F” .data alpha BYTE \"ABCDEFGH\",0 .code mov edi,OFFSET alpha\t; EDI points to the string mov al,'F'\t; search for the letter F mov ecx,LENGTHOF alpha ; set the search count cld\t; direction = up repne scasb\t; repeat while not equal jnz quit\t; quit if letter not found dec edi\t; found: back up EDI quit: STOSB、STOSW 和 STOSD 指令\n将AL/AX/EAX的内容存储在EDI指向的内存单元中，同时EDI的值根据方向标志增加或减少。可与REP前缀联合使用。 例：将string1的每个字节初始化为0FFh。 .data count = 100 string1 BYTE count DUP(?) .code mov al,0FFh\t; value to be stored mov edi,OFFSET string1 ; ES:DI points to target mov ecx,count\t; character count cld\t; direction = forward rep stosb\t; fill with contents of AL LODSB、LODSW 和 LODSD 指令\n从ESI指向的内存位置向AL/AX/EAX中装入一个值，同时ESI的值根据方向标志增加或减少。 一般不与REP前缀联合使用。 二维数组 基址变址操作数：将两个寄存器的值相加(称为基址寄存器、变址寄存器)来产生偏移地址 保护模式程序中，可使用任意两个32位通用寄存器 实地址模式下，16位寄存器允许的组合是：[bx+si], [bx+di], [bp+si], [bp+di]\n⚠️应尽量避免使用BP寄存器，除非要访问堆栈操作数 .data array WORD 1000h,2000h,3000h .code mov ebx,OFFSET array mov esi,2 mov ax,[ebx+esi]\t; AX = 2000h 表格的例子 相对基址变址操作数:有效地址偏移＝偏移＋基址寄存器＋变址寄存器 几种常见的格式： [base + index + displacement] displacement[base + index] displacement[base][index] 偏移(Displacement)：变量的名字；常量表达式 基址、变址： 保护模式：任意32位寄存器 实地址模式：BX、BP；SI、DI 表格的例子：tableB[ebx + esi] 习题 3.8 在DATA为首地址的内存区域中存放100个无符号数，试编写程序找出其中最大的数，并将其放在KVFF中。\nstack segment stack db 512 dup(?) stack ends data segment nums db 170, 248, 69, 67, 81, 104, 76, 178, 226, 201 db 234, 230, 194, 85, 206, 92, 63, 28, 211, 237, 195, 240, 225 db 126, 117, 173, 162, 78, 179, 252, 9, 202, 23, 152, 125, 32, 16 db 86, 165, 27, 190, 137, 37, 172, 13, 228, 112, 146, 75, 225, 65 db 92, 150, 38, 77, 43, 233, 94, 88, 118, 60, 127, 214, 69, 44, 25 db 134, 137, 154, 209, 167, 32, 174, 13, 178, 65, 74, 35, 234, 95 db 70, 179, 98, 140, 185, 159, 14, 114, 105, 239, 137, 147, 227, 238 db 228, 198, 135, 220, 203, 255 KVFF db ? data ends code segment assume CS:code, DS:data, SS:stack start: mov ax, data mov ds, ax mov dl, 0 mov si, OFFSET nums mov cx, 100 comp: cmp dl, BYTE PTR [si] jb exch L: inc si loop comp mov KVFF, dl mov ah, 4ch int 21h exch: mov dl, BYTE PTR [si] jmp L code ends end start 3.13 试编写程序，给从内存40000H到4BFFFH的每个单元均写入55H，并逐个单元读出比较。若写入的与读出的完全一致，则将AL置7EH，否则将AL置81H。\nstack segment stack db 512 dup(?) stack ends code segment assume cs:code, ss:stack start: mov ax, 4000h mov ds, ax mov si, 0000h mov cx, 0BFFFh write: mov BYTE PTR [si], 55h inc si loop write mov si, 0000h mov cx, 0BFFFh read: cmp BYTE PTR [si], 55h jnz not_equal equal: inc si loop read mov al, 7eh mov ax, 4c00h int 21h not_equal: mov al, 81h mov ax, 4c00h int 21h code ends end start 总线技术 总线概述 总线的分类 按连接的层次 片内总线 元件级总线 系统总线（内总线） 通信总线（外总线、I/O总线） 按数据传输位数 并行总线 串行总线 标准化总线 内总线 ISA总线(Industry Stanrard Architechure) ISA特点 支持8位、16位操作 将将XT与AT总线的运行速度提升至8MHz 更强调I/O处理能力：64KB的I/O空间、11级硬件中断、7级DMA通道 地址、数据多路复用 是多主控设备总线、带处理器的智能卡都可以成为ISA的主控设备 曾广泛流行，支持的厂商众多 信号定义 数据总线为16位（支持8位、16位操作） 提速：$ \\overline{0WS} $，零等待状态，也叫$ \\overline{NOWS} $（No Wait State） 升位：$ \\overline{MEMCS16},\\overline{IOCS16} $ 位数可选：$ \\overline{SBHE} $ 寻址能力达到16MB，地址、数据线不复用 中断扩充为11个（PC/XT位6个） DMA扩充为7个（PC/XT位4个） ISA是一种多主控总线：$\\overline{MASTER} $ 速度：CLK(B20, Output)\n4.77MHz-\u003e8.33MHz-\u003e12MHz PCI总线(Peripheral Component Interconnect Local Bus) PCI总线的特点 不依赖于处理器 扩充性好、多总线共存 具有自动配置能力，支持即插即用（PnP） 数据、地址奇偶校验功能 数据宽度32位，可扩展为64位；2.0版本支持33MHz时钟，2.1版本增加了对66MHz总线操作的支持 信号复用，支持无限读写突发操作 支持多主控设备 适应性广 并行总线操作 信号定义 PCI总线定义的信号可分为九类 系统信号 数据和地址信号 接口控制信号 仲裁信号 错误报告信号 中断信号 高速缓存支持信号 64位扩展信号 JTAG信号 PCI总线定义的信号也可分为必备和可选两大类 主控设备需要49个必备信号\n目标设备需要47必备信号 可选信号线共51个，主要用于 64位扩展 中断请求 高速缓存支持 等 PCIE总线（PCI Express） 外总线（通信总线） RS-232C串行通信接口 特点 串行异步总线 传输信号线少 定义了20多个信号线 实际应用中一般只用到3至7条 传输距离较远。一般为15米 采用不归零编码（NRZ）和负逻辑：逻辑1为-15V至-3V，逻辑0为+3V至+15V 采用非平衡传输方式，即单端通信 传输速率较低 电气特性、引脚功能：25针/9针 D型连接器 信号 传送信息信号\nTxD：发送数据线 (DTE-\u003eDCE)\nRxD：接收数据线 (DTE\u003c-DCE) 联络信号\nRTS：请求发送 (DTE-\u003eDCE)\nCTS：清楚发送 (DTE\u003c-DCE)\nDTR：DTE准备就绪 (DTE-\u003eDCE)\nDSR：SCE准备就绪 (DTE\u003c-DCE)\nDCD：数据载波检测 (DTE\u003c-DCE)\nRI：振铃指示 (DTE\u003c-DCE) 电平 数据信号 控制信号 逻辑1 -3~-15V（传号） +3~+15V（接通，ON状态） 逻辑0 +3~+15V（空号） -3~-15V（断开，OFF状态） （一般为12V） 例：信息格式\n传送ASCII码“C”（43H） RS-232的应用 使用Modem连接 软硬件系统调试：控制台、超级终端 直接连接：计算机（DTE）\u003c-\u003e 计算机（DTE） 交叉连接方式 三线经济方式 RS423、RS422、RS485： RS423：单端输出、差分接收（非平衡传输） 1200米 1Kbps 90米 100Kbps RS422、RS485：差分输出、差分接收（平衡差分传输） 1200米 100Kbps 100米 1Mbps 12米 10Mbps USB总线（Universal Serial Bus） USB总线各版本参数比较 翻转不归零（NRZ-I）编码 当数据为0时，电平翻转；数据为1时，电平不翻转 比特填充技术：当数据中出现连续6个'1’时就必须插入1个'0’ 发送数据：并行数据-\u003e串行数据，比特填充，NRZI编码 接收数据：NRZI解码，去除填充比特，转换成并行数据 8b/10b编码 传送的信息以每8比特为一组被编码为一个10比特的数据；接收端将10比特数据解码还原为8比特数据 目的：使得整个比特流中尽量保持了0和1的平衡 SATA、PCI-Express也使用了8b/10b编码 USB3.2使用128b/132b编码 对USB的需求 当时PC机I/O模式的缺点 PC外设日益丰富，接口、扩展槽有限；种类日益繁多的接口电缆线 I/O资源分配(I/O空间、IRQ、DMA)-\u003e接口卡一多，上述资源可能耗尽 热插拔、PnP的需求 USB2.0的特点/优点 单一接口类型 每个USB总线支持127个外设 整个USB系统只用一个端口、一个中断-\u003e节省系统资源 支持热插拔、动态加载驱动程序；带电拔出后自动回收资源；PnP，自动配置 三种速率，适应不同类型外设 设备供电 四种传输类型 控制传输 同步传输 中断传输 批量传输 USB3.0 ATA总线 PATA SATA 总线的驱动和控制 总线竞争与负载 总线竞争：同一总线上，同一时刻，有两个或两个以上的器件输出其状态 TTL：此时总线上会是一种不高不低的非TTL电平，严重时会烧坏器件 对集电极开路输出：线与逻辑（Open Collector） 用三态电路严格，控制逻辑 总线的负载 直流负载 输出高电平时，驱动门的$ I_{OH} \\ge \\sum_{i=1}^{N}{IH_i} $ 输出高电平时，驱动门的$ I_{OL} \\ge \\sum_{i=1}^{N}{IL_i} $ 交流负载：$ C_P \\ge (\\sum_{i=1}^{N}{C_{Ii}+$电路板布线引入的电容$+$传输线引入的电容}) $ 总线驱动设计 几种常用的芯片\n单向驱动器（三态输出） 双向驱动器（三态输出） 锁存器（三态输出） 系统总线的驱动与控制\n扩展插件板（卡）的板内驱动\n例题\n某内存板，板内地址为A0000H～FFFFFH，试画出板内双向数据总线驱动与控制电路。 防止总线竞争原则：只有当CPU读本电路板内的内存地址时，才允许双向驱动器指向系统总线的三态门是导通的。 对板内内存地址进行分析，找出地址特征。A0000H～FFFFFH 设计译码电路，用来控制双向数据总线驱动器，使之满足防止总线竞争原则。 某微型机电路板上有内存C0000H～EFFFFH和接口A000H～BFFFH，试画出该电路板板内双向数据总线驱动与控制电路。（P128，例4.3） 防止总线竞争原则：只有当CPU读板内内存或读板内接口时，才允许双向数据驱动器指向系统总线的三态门是导通的。 地址分析（内存地址、接口地址） 画驱动与控制电路 几种可供选择的译码方式 基本门电路 译码器，如74LS138 译码PROM CPLD、FPGA 采用8086 CPU的微机系统，其主存地址范围为C0000H～C7FFFH，由4块大小为8k8b的芯片构成主存板，试画出板内双向数据总线驱动控制电路及单向信号驱动电路。 主存地址分析 双向数据总线驱动控制电路\u000b及单向信号驱动电路 总线设计中的工程问题 总线交叉串扰 减少总线长度 增加总线间的距离 降低总线上的负载 降低总线信号的工作频率 两条信号线之间加一条地线 减少总线的平行走向 圆滑脉冲信号的边缘 采用双绞线 总线的延时 尽量减少总线长度 采用延时小、输出输出电容小、驱动能力强的元器件 需要同步的信号线，布线时候应匹配长度 总线信号的反射 在满足系统功能的前提下，降低传输信号的频率 尽量使信号源内阻、总线特性阻抗、负载阻抗三者相匹配 限制总线长度 PC中的总线 8086微处理器16位微机：ISA总线 总线信号依据8086处理器信号定义 8086处理器与ISA总线可以实现直接对接 利用ISA总线可以直接读写主存或I/O接口 80386微处理器32位微机：与CPU无关的PCI总线 PCI总线具有较快的数据传输速率 PCI总线支持即插即用和热插拔 基于PCI总线的微机系统还支持多总线结构，进而使系统具有一定的并行操作能力 存储技术 概述 存储器的分类 主要性能指标 容量 速度：存取时间 成本：价格 常用存储器芯片及连接使用 静态随机读/写存储器（SRAM）及接口设计 静态随机读写存储器（Static Random Access Memory\n分类\n同步型 异步型 异步SRAM\n典型芯片：6264（8K $\\times $ 8bit） 引线 工作过程、时序 写入时序 读出时序 连接使用 全地址译码与部分地址译码 SRAM 6264全地址译码连接 SRAM 6264部分地址译码连接 译码电路的选择 利用译码芯片 使用ROM作译码器\n现在要用4片6264构成一个存储容量为32KB的存储器，其地址空间为E0000H～E7FFFH。用一块512×4的PROM芯片63S241作为ROM译码器 利用数字比较器作译码器 利用PLD做译码器 存取时间 控制信号的连接：8088/8086 最小模式、最大模式$ M/\\overline{IO},\\overline{RD},\\overline{WR} =\u003e \\overline{MEMR},\\overline{MEMW} $ 例：已知8088微处理器时钟为4.77MHz，地址延时时间$t_{da}＝110ns$，存储系统各种附加的延时时$t_D$＝200ns。问：用存取周期为250ns的存储芯片能否满足系统要求？\n$$ \\begin{align} t(R,W)+t_{da}+t_D \u0026{\\le} 3T \\cr t(R,W) \u0026{\\le} 3T－ t_{da}－ t_{D} \\cr 3×210－200－110 \u0026＝ 320ns \\cr \\end{align} $$ 为存储器提供的存取时间\n存储器要求的存取时间为250ns → 能满足系统要求 只读存储器（ROM）及接口设计 EPROM（紫外线可擦除只读存储器）：2764芯片（8K$\\times 8bit）\n引线 A12~A0 D7~D0 $\\overline{CE}$：片选 $\\overline{OE}$：数据输出允许 $\\overline{PGM}$：编程时：编程脉冲输入；读时：“1” 连接：若利用全地址译码将EPROM 2764接在首地址为A0000H的内存区，试画连接图 编程 擦除：紫外线 15～20min → 每单元内容均为FFH EPROM编程 EEPROM\n典型EERROM芯片介绍：98C64A 优点：可单字节随机读写（不需擦除，直接读写） 缺点：存储密度高，单位成本高 连接使用：将55H写满98C64A 闪存EEPROM：FLASH\nNOR型 独立数据、地址总线，可以随机快速读取 读操作速度快，擦除、编程速度慢 NAND型 以页(256或512B)为单位读/编程 以块(4K、8K、16K)为单位擦除（最多4ms） 串行读取快、随机读取慢 其他存储器 双端口存储器 先进先出（FIFO）存储器 铁电存储器（FRAM） Intel 16/32位微机系统的主存设计（SRAM部分） 8086、8088处理器的内存接口 存储器SRAM 6116（$ 2K\\times 8bit）$ 与8088的8位总线连接\nSRAM 6116与8086的16位总线连接\n$ \\overline{A0}$选偶地址 $ \\overline{BHE} $选奇地址 存储器的字扩充 存储器的位扩充 6264与8086系统总线的连接 80386、80486的内存接口 与内存接口相关的信号 地址信号A2～A31共30个地址信号，其编码可寻址1G个32位的存储单元。这里没有A0和A1，这两个信号已在80386、80486内部译码，用于产生4个体选择信号。 体选择信号$ \\overline{BE0}～\\overline{BE3} $ 32位的数据信号D0～D31分为4个字节，分别是D0～D7、D8～D15、D16～D23 和 D24～D31。 控制信号$ M/\\overline{IO} $ $D/\\overline{C}$（数据/控制）信号，低电平为处理器中止或正在响应中断，高电平表示正在传送数据； $W/\\overline{R}$（读/写）信号，低电平表示读内存或接口，高电平表示写内存或接口 Pentium处理器的内存组织 动态随机读/写存储器（DRAM）及接口设计 简单异步DRAM 引线 地址线复用：先输入行地址，再输入列地址 $\\overline{WE}$写允许 $D_{IN}、D_{OUT} $ 工作方式及时序 读操作 写操作 提前写 读变写 刷新：2-4ms刷新一次 连接使用/接口设计 行列信号的形成 读写 刷新 同步动态存储器SDRAM 概述\nSDR SDRAM（Single Data Rate Synchronous Dynamic RAM）：单倍速率同步动态随机存储器 只在时钟的上升沿传输命令、地址和数据 DDR(Double Date Rate) 时钟上升沿、下降沿各传送一次数据 从DDR2开始，接口的频率开始高于存储单元的核心频率 SDRAM和标准DRAM的主要不同 同步和异步 内部组织结构 SDRAM内部分体 标准的DRAM可以看成内部只有一个体的SDRAM 读写方式不同 SDRAM具有突发读写能力 突发(Burst)是指在同一行中相邻的存储单元连续进行数据传输的方式。 连续传输所涉及到的存储单元(列)的数量就是突发长度(Burst Lengths，BL) 智能化 在SDRAM芯片内部设置有模式寄存器 一般的标准DRAM只有一种工作模式 典型的SDRAM芯片(三星K4S511632D(32M×16 bit SDRAM))\n引线 地址输入 行地址：RA0~RA12 列地址：CA0~CA9 bank地址输入 数据输入/输出 输出允许 常用指标 容量：存储单元×体×每单元存储位数 时钟周期 存取时间 CAS的延迟时间（Cas latency） 综合性能的评价：总延迟时间=系统时钟周期×CL模式数+存取时间 时序 SDRAM控制器\n实现方式 以南北桥芯片组为主要核心的PC机系统 某些为微处理器中集成了SDRAM控制器 设计与CPU或系统总线连接的独立SDRAM控制器，SDRAM芯片连接在SDRAM控制器上 SDRAM的基本操作 对SDRAM的访问的三种情况 当前访问的行所在的存储体中，行缓冲器是关闭的 发送激活命令 发送读写命令和列地址 读写延迟中等 当前访问的行的数据，刚好保存在相应存储体的行缓冲器中 直接发送读/写命令和列地址 读写延迟最小 当前访问的行所在的存储体中，行缓冲器打开，存的是另一个行的数据 先发送Percharge或Precharge All命令关闭行缓冲器 再发送激活命令激活该行 最后发送读/写和列地址 读/写延迟最大 SDRAM控制器的基本组成 连续内存地址映射 交错内存地址映射：将连续的逻辑地址映射到不同的存储体中 SDRAM的控制优化 行关闭优先策略（Close-Page Policy）：行激活、列读/写、预充电 行打开优先策略（Open-Page Policy） 访问请求空间局部性很好，大大减少读写延迟 访问请求空间分布很分散，造成较大读写延迟 DDR SDRAM DDR SDRAM与SDRAM的不同 初始化 时钟 数据选取脉冲 写入延时 突发长度和写入掩码 DDR SDRAM，突发长度只有2、4、8，没有SDRAM的随机存取的操作和全页触发方式；同时，突发长度的定义不再指所连续寻址的存储单元数量，而是指连续的传输周期数 对于突发写入，如果其中有不想存取的数据，仍可以使用DM信号进行屏蔽 延迟锁定回路 习题 5.5 已有两片6116，现在欲将它们连接到8088系统中去，其地址范围为40000H~40FFFH，试画连接电路图，写入某数据并读出与之比较；如有错，则在DL中写入01H；若每个单元均对，则在DL中写入EEH，试编写此检测程序。\n5.10 将4片6264连接到8086系统总线上，要求内存地址范围为7000H~77FFFH，画出连接图。\n5.16 现有容量为32K×4bit的SRAM芯片。\n在8086系统中，利用这样的芯片构成从88000H～97FFFH的内存，画出最大模式下包括总线驱动在内的此芯片与系统总线的连接图（译码器件自行选择）\n输入输出技术 I/O概述 基本输入/输出方法 程序控制I/O方式 无条件传送方式：输入接口、输出接口 查询方式：单外设、多外设 中断防守 DMA（直接存储器）方式 I/O接口概述 I/O接口能做什么 提供信息通道 进行数据格式转换 CPU和外设速度匹配 负载匹配 时序匹配 总线隔离 提供中断、DMA能力 外设接口与端口 统一编址的优点 CPUduiI/O端口的读写操作可是使用全部存储器的读/写数据操作指令 内存与外设地址的分配可以用统一的分配图 不需要专门的输入、输出操作指令 统一编址的缺点 使得系统中实际可以直接寻址的内存单元数减少 给检修、维护增加了难度 一般系统中I/O端口数远小于内存单元数，所以统一编址使得指令代码较长，读/写执行时间也较长 Motorola的M68系列采用统一编址，Intel的86x86系列CPU采用独立编址方式 I/O端口地址译码 基本的并行输入（三态门）/输出（锁存器）接口 并行输入接口 并行输出接口 程序查询I/O方式 无条件传送方式 查询方式 多外设的查询控制 中断方式 8086/8088中断系统 中断源类型 与中断有关的控制线：$ NMI、INTR、\\overline{INTA} $ 8088系统中的中断源 内部中断 除法溢出：类型号为0 单步中断：类型号为1 断点中断：类型号为3 溢出中断：类型号为4 软件中断：即INT n指令 外部中断 非屏蔽中断NMI：类型号为2，不可用软件屏蔽，CPU必须响应它 可屏蔽中断INTR：类型号由PIC提供。IF=1时CPU才能响应它 中断向量表（IVT） 用于存放各类中断服务程序的入口地址（段和偏移） 表的地址位于内存的00000H~003FFH，大小为1KB，共256个入口 每个入口占4 Bytes 中断向量在IVT中的存放地址 = 4 * 中断类型号 可编程中断控制器8259 8259内部结构 中断请求寄存器IRR 中断服务寄存器ISR 中断屏蔽寄存器IMR 中断优先权判别电路 引脚功能 8259工作方式\n中断结束方式 非自动：在中断程序中提供EOI命令 自动：无需EOI命令、第2个$\\overline{INTA}$后沿 缓冲方式：缓冲、非缓冲 嵌套方式 一般嵌套：单片使用；级联方式从属 特殊嵌套：级联方式主控制器 屏蔽方式：一般屏蔽、特殊屏蔽 优先级规定：固定优先级、循环优先级 8259级联 8259编程使用\n内部寄存器的寻址方法 初始化命令字ICW 注意 写ICW1意味着重新初始化8259 写ICW1后，8259的状态如下 清除ISR和IMR（全0） 将中断优先级设置为初始状态 设置为一般屏蔽方式 采用非自动中断结束方式 状态读出逻辑预置为读IRR ICW1：初始化字 ICW2：中断向量码 ICW3：级联控制字 ICW4：中断结束方式字 操作命令字OCW OCW1：中断屏蔽字 OCW2：中断结束和优先级循环 OCW3：屏蔽方式和读出控制字 中断方式及实现方法 连接8259 编写中断初始化程序 初始化8259 设置中断向量表 中断服务程序框架 直接存取器（DMA）方式 DMA工作过程 通过特殊硬件DMA控制器实现，传输速率高 外设直接与存储器进行数据交换，CPU不再作为中介者 总线由DMA控制器（DMAC）进行控制，CPU放弃总线控制权，内存/外设的地址和读写控制信号均由DMAC提供 习题 6.6 叙述8086/88软件中断指令INT n的执行过程\nCPU取INT n指令，经指令译码获知这是一条中断指令，且该软件中断的中断向量码为n 将PSW、CS、IP压入堆栈保护起来，并关中断 $ n \\times 4 $ 得到中断向量表地址，从该地址开始的顺序两个字节的内容送IP，下两个字节的内容送CS，即$n \\times 4\\to IP,(n\\times4+2)\\to CS $ 开始执行中断服务程序。（中断服务程序的入口地址早已填入中断向量表中） 中断服务程序的最后一条指令IRET，从堆栈恢复IP、CS、PSW，中断返回 6.8 输入接口地址为04E5H，输出接口地址为E504H。 编程序： 若输入接口的bit3、bit4和bit7同时为1，将以DATA为首地址的10个内存数据连续由输出接口输出，若不满足条件则等待\n6.9 若：系统只有一片8259，8259地址为E010H和E011H，允许8个中断源边沿触发，不需要缓冲，以一般嵌套方式工作，中断向量为40H，非自动EOI方式\n编写初始化程序 若允许中断嵌套，编写中断服务程序框架，包括返回前发送EOI命令。中断服务程序名称为IPROC40 编程序，将上述中断处理程序的入口地址填入中断向量表 常用接口器件 计算机和外设之间如何通过接口传送数据（非DMA） 可编程并行接口8255 内部结构及外部总线 8255的工作方式 工作方式0：基本输入输出方式 A口（PA0~PA7）：输入（无锁存能力）或输出（有锁存能力） B口（PB0~PB7）：输入（无锁存能力）或输出（有锁存能力） C口（PC4~PC7）：输入（无锁存能力）或输出（有锁存能力） C口（PC0~PC3）：输入（无锁存能力）或输出（有锁存能力） 工作方式1：选通输入输出方式 工作方式2：双向输入输出方式（仅A口） PC3-PC7：A口方式2下的控制线 PC0-PC2：输入或输出或B口方式1下的控制线 B口：方式0或方式1 8255的方式控制字及状态字 控制字 状态字 8255的寻址及连接使用 8255的初始化及应用举例 方式0——打印机接口 方式1——打印机接口 程序查询方式 中断方式 可编程定时器8253 工作方式 方式0：计数结束产生中断 方式1：可编程单稳 方式2：频率发生器 方式3：方波发生器 方式4：软件触发选通 方式5：硬件触发选通 8253的控制字 习题 7.1 若8253芯片可利用8088的外设接口地址为D0D0H～D0D3H，试画出电路连接图。设加到8253上的时钟信号为2MHz。 若利用计数器0、1和2产生周期为100μs的对称方波以及每1s、10s产生一个负脉冲，试说明8253如何连接，并编写初始化程序。 7.2 若8255芯片可占用的地址为FE00～FEFFH，试画出它与8086总线的连接图。 A/D变换器的引线及工作时序图如下，试将此A/D变换器与8255相连接，并编写包括初始化程序在内的、变换一次数据并将数据放在DATA中的程序 7.3 说明8253的6种工作方式。若如加到8235上的时钟频率为0.5MHz，则一个计数器的最长定时时间是多少？若要求美10min产生一次定时中断，试提出解决方案\n方式0：计数结束中断，输出一个正跳变 方式1：硬件可重复触发的单稳态触发器，输出一个宽度可调的负脉冲 方式2：比率发生器，输出序列负脉冲 方式3：方波发生器 方式4：软件触发延时选通脉冲发生器 方式5：硬件触发延时选通脉冲发生器 加到8253上的时钟频率是0.5MHz，则一个计数器的最长定时时间是$\\frac {65536} {0.5\\times 10^6}=0.131072 s$（初值为0）\n计数器0和计数器1都工作于方式3（循环计数，产生周期性方波），两个计数器串联，计数器0的输出作为计数器1的时钟，计数器1的输出作为cpu中断信号用于产生定时中断。设计数器0的计数值=30000，计数器1的计数值=10000，则每计数30000×10000=3×1e8次，也即每2μs×3×108=600s=10min 产生一次定时中断\n基于总线的I/O接口设计 基于ISA总线的I/O接口设计 LED接口 接口电路 用通用并行接口芯片作接口 用LED译码器作接口：DM9368 利用上图电路中的4个数码管，实现将存储单元 BUF中的4位十六进制数加以显示，并每经过1秒，重新读取BUF单元数据，更新显示，则控制程序如下： 动态显示的接口电路 用通用接口芯片 用专用接口芯片：MM74C912/917 键盘接口 非编码式键盘 ","wordCount":"2663","inLanguage":"en","datePublished":"2020-10-17T21:07:26+08:00","dateModified":"2020-10-17T21:07:26+08:00","author":{"@type":"Person","name":"fffzlfk"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://fffzlfk.github.io/posts/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/"},"publisher":{"@type":"Organization","name":"fffzlfk's Blog","logo":{"@type":"ImageObject","url":"https://fffzlfk.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://fffzlfk.github.io accesskey=h title="fffzlfk's Blog (Alt + H)"><img src=https://fffzlfk.github.io/android-chrome-512x512.png alt aria-label=logo height=35>fffzlfk's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://github.com/fffzlfk title=GitHub><span>GitHub</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://fffzlfk.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://fffzlfk.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://fffzlfk.github.io/about/ title=About><span>About</span></a></li><li><a href=https://fffzlfk.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://travellings.link/ title=Travellings><span>Travellings</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://fffzlfk.github.io>Home</a>&nbsp;»&nbsp;<a href=https://fffzlfk.github.io/posts/>Posts</a></div><h1 class=post-title>微机原理</h1><div class=post-meta><span title='2020-10-17 21:07:26 +0800 +0800'>October 17, 2020</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;fffzlfk&nbsp;|&nbsp;<a href=https://github.com/fffzlfk/fffzlfk.github.io/blob/master/content/posts/%e5%be%ae%e6%9c%ba%e5%8e%9f%e7%90%86.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8d%95%e6%a0%b8%e5%a4%84%e7%90%86%e5%99%a880868088 aria-label=单核处理器8086/8088>单核处理器8086/8088</a><ul><li><a href=#%e5%af%84%e5%ad%98%e5%99%a8%e7%bb%93%e6%9e%84 aria-label=寄存器结构>寄存器结构</a><ul><li><a href=#%e9%80%9a%e7%94%a8%e5%af%84%e5%ad%98%e5%99%a8 aria-label=通用寄存器>通用寄存器</a></li><li><a href=#%e6%a0%87%e5%bf%97%e5%af%84%e5%ad%98%e5%99%a8 aria-label=标志寄存器>标志寄存器</a></li></ul></li><li><a href=#%e4%b8%bb%e5%ad%98%e7%bb%93%e6%9e%84 aria-label=主存结构>主存结构</a><ul><li><a href=#%e5%8f%8c%e4%bd%93%e7%bb%93%e6%9e%84 aria-label=双体结构>双体结构</a></li><li><a href=#%e5%88%86%e6%ae%b5%e7%bb%93%e6%9e%84 aria-label=分段结构>分段结构</a></li></ul></li><li><a href=#%e8%8a%af%e7%89%87%e5%bc%95%e8%84%9a aria-label=芯片引脚>芯片引脚</a><ul><li><a href=#8086%e8%8a%af%e7%89%87%e5%bc%95%e8%84%9a aria-label=8086芯片引脚>8086芯片引脚</a></li><li><a href=#8088%e8%8a%af%e7%89%87%e5%bc%95%e8%84%9a aria-label=8088芯片引脚>8088芯片引脚</a></li><li><a href=#8086vs8088 aria-label=8086vs.8088>8086vs.8088</a></li></ul></li><li><a href=#%e5%b7%a5%e4%bd%9c%e6%97%b6%e5%ba%8f aria-label=工作时序>工作时序</a></li><li><a href=#%e4%b9%a0%e9%a2%98 aria-label=习题>习题</a><ul><li><a href=#22 aria-label=2.2>2.2</a></li><li><a href=#22-1 aria-label=2.2>2.2</a></li></ul></li></ul></li><li><a href=#intel%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f%e4%b8%8e%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1 aria-label=Intel指令系统与程序设计>Intel指令系统与程序设计</a><ul><li><a href=#%e7%a8%8b%e5%ba%8f%e6%a1%86%e6%9e%b6 aria-label=程序框架>程序框架</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e4%bc%a0%e9%80%81%e5%af%bb%e5%9d%80%e7%ae%97%e6%9c%af%e8%bf%90%e7%ae%97%e6%8c%87%e4%bb%a4 aria-label=数据传送、寻址、算术运算指令>数据传送、寻址、算术运算指令</a><ul><li><a href=#%e6%95%b0%e6%8d%ae%e4%bc%a0%e9%80%81 aria-label=数据传送>数据传送</a></li><li><a href=#%e5%8a%a0%e6%b3%95%e5%92%8c%e5%87%8f%e6%b3%95 aria-label=加法和减法>加法和减法</a></li><li><a href=#%e5%92%8c%e6%95%b0%e6%8d%ae%e7%9b%b8%e5%85%b3%e7%9a%84%e6%93%8d%e4%bd%9c%e7%ac%a6%e5%92%8c%e4%bc%aa%e6%8c%87%e4%bb%a4 aria-label=和数据相关的操作符和伪指令>和数据相关的操作符和伪指令</a></li><li><a href=#%e9%97%b4%e6%8e%a5%e5%af%bb%e5%9d%80 aria-label=间接寻址>间接寻址</a></li><li><a href=#jmp%e5%92%8cloop%e6%8c%87%e4%bb%a4 aria-label=JMP和LOOP指令>JMP和LOOP指令</a></li><li><a href=#%e5%b0%8f%e7%bb%93%e6%93%8d%e4%bd%9c%e6%95%b0%e7%b1%bb%e5%9e%8b%e5%af%bb%e5%9d%80%e6%96%b9%e5%bc%8f aria-label=小结：操作数类型（寻址方式）>小结：操作数类型（寻址方式）</a></li></ul></li><li><a href=#%e8%bf%87%e7%a8%8b aria-label=过程>过程</a><ul><li><a href=#%e4%b8%8e%e5%a4%96%e9%83%a8%e5%ba%93%e9%93%be%e6%8e%a5 aria-label=与外部库链接>与外部库链接</a></li><li><a href=#%e5%a0%86%e6%a0%88%e6%93%8d%e4%bd%9c aria-label=堆栈操作>堆栈操作</a></li><li><a href=#%e8%bf%87%e7%a8%8b%e7%9a%84%e5%ae%9a%e4%b9%89%e5%92%8c%e4%bd%bf%e7%94%a8 aria-label=过程的定义和使用>过程的定义和使用</a></li></ul></li><li><a href=#%e6%9d%a1%e4%bb%b6%e5%a4%84%e7%90%86 aria-label=条件处理>条件处理</a><ul><li><a href=#%e5%b8%83%e5%b0%94%e5%92%8c%e6%af%94%e8%be%83%e6%8c%87%e4%bb%a4 aria-label=布尔和比较指令>布尔和比较指令</a></li><li><a href=#%e6%9d%a1%e4%bb%b6%e8%b7%b3%e8%bd%ac aria-label=条件跳转>条件跳转</a></li><li><a href=#%e6%9d%a1%e4%bb%b6%e5%be%aa%e7%8e%af%e6%8c%87%e4%bb%a4 aria-label=条件循环指令>条件循环指令</a></li></ul></li><li><a href=#%e6%95%b4%e6%95%b0%e8%bf%90%e7%ae%97%e6%8c%87%e4%bb%a4 aria-label=整数运算指令>整数运算指令</a><ul><li><a href=#%e7%a7%bb%e4%bd%8d%e5%92%8c%e5%be%aa%e7%8e%af%e7%a7%bb%e4%bd%8d%e6%8c%87%e4%bb%a4 aria-label=移位和循环移位指令>移位和循环移位指令</a></li><li><a href=#%e4%b9%98%e6%b3%95%e5%92%8c%e9%99%a4%e6%b3%95%e6%8c%87%e4%bb%a4 aria-label=乘法和除法指令>乘法和除法指令</a></li><li><a href=#%e6%89%a9%e5%b1%95%e5%8a%a0%e6%b3%95%e5%92%8c%e5%87%8f%e6%b3%95 aria-label=扩展加法和减法>扩展加法和减法</a></li><li><a href=#ascii%e5%92%8c%e5%8e%8b%e7%bc%a9%e5%8d%81%e8%bf%9b%e5%88%b6%e7%ae%97%e6%95%b0 aria-label=ASCII和压缩十进制算数>ASCII和压缩十进制算数</a></li></ul></li><li><a href=#%e5%ad%97%e7%ac%a6%e4%b8%b2%e4%b8%8e%e6%95%b0%e7%bb%84 aria-label=字符串与数组>字符串与数组</a><ul><li><a href=#%e5%9f%ba%e6%9c%ac%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%93%8d%e4%bd%9c%e6%8c%87%e4%bb%a4 aria-label=基本字符串操作指令>基本字符串操作指令</a></li><li><a href=#%e4%ba%8c%e7%bb%b4%e6%95%b0%e7%bb%84 aria-label=二维数组>二维数组</a></li></ul></li><li><a href=#%e4%b9%a0%e9%a2%98-1 aria-label=习题>习题</a><ul><li><a href=#38 aria-label=3.8>3.8</a></li><li><a href=#313 aria-label=3.13>3.13</a></li></ul></li></ul></li><li><a href=#%e6%80%bb%e7%ba%bf%e6%8a%80%e6%9c%af aria-label=总线技术>总线技术</a><ul><li><a href=#%e6%80%bb%e7%ba%bf%e6%a6%82%e8%bf%b0 aria-label=总线概述>总线概述</a><ul><li><a href=#%e6%80%bb%e7%ba%bf%e7%9a%84%e5%88%86%e7%b1%bb aria-label=总线的分类>总线的分类</a></li></ul></li><li><a href=#%e6%a0%87%e5%87%86%e5%8c%96%e6%80%bb%e7%ba%bf aria-label=标准化总线>标准化总线</a><ul><li><a href=#%e5%86%85%e6%80%bb%e7%ba%bf aria-label=内总线>内总线</a></li><li><a href=#%e5%a4%96%e6%80%bb%e7%ba%bf%e9%80%9a%e4%bf%a1%e6%80%bb%e7%ba%bf aria-label=外总线（通信总线）>外总线（通信总线）</a></li></ul></li><li><a href=#%e6%80%bb%e7%ba%bf%e7%9a%84%e9%a9%b1%e5%8a%a8%e5%92%8c%e6%8e%a7%e5%88%b6 aria-label=总线的驱动和控制>总线的驱动和控制</a><ul><li><a href=#%e6%80%bb%e7%ba%bf%e7%ab%9e%e4%ba%89%e4%b8%8e%e8%b4%9f%e8%bd%bd aria-label=总线竞争与负载>总线竞争与负载</a></li><li><a href=#%e6%80%bb%e7%ba%bf%e9%a9%b1%e5%8a%a8%e8%ae%be%e8%ae%a1 aria-label=总线驱动设计>总线驱动设计</a></li></ul></li><li><a href=#%e6%80%bb%e7%ba%bf%e8%ae%be%e8%ae%a1%e4%b8%ad%e7%9a%84%e5%b7%a5%e7%a8%8b%e9%97%ae%e9%a2%98 aria-label=总线设计中的工程问题>总线设计中的工程问题</a><ul><li><a href=#%e6%80%bb%e7%ba%bf%e4%ba%a4%e5%8f%89%e4%b8%b2%e6%89%b0 aria-label=总线交叉串扰>总线交叉串扰</a></li><li><a href=#%e6%80%bb%e7%ba%bf%e7%9a%84%e5%bb%b6%e6%97%b6 aria-label=总线的延时>总线的延时</a></li><li><a href=#%e6%80%bb%e7%ba%bf%e4%bf%a1%e5%8f%b7%e7%9a%84%e5%8f%8d%e5%b0%84 aria-label=总线信号的反射>总线信号的反射</a></li></ul></li><li><a href=#pc%e4%b8%ad%e7%9a%84%e6%80%bb%e7%ba%bf aria-label=PC中的总线>PC中的总线</a><ul><li><a href=#8086%e5%be%ae%e5%a4%84%e7%90%86%e5%99%a816%e4%bd%8d%e5%be%ae%e6%9c%baisa%e6%80%bb%e7%ba%bf aria-label=8086微处理器16位微机：ISA总线>8086微处理器16位微机：ISA总线</a></li><li><a href=#80386%e5%be%ae%e5%a4%84%e7%90%86%e5%99%a832%e4%bd%8d%e5%be%ae%e6%9c%ba%e4%b8%8ecpu%e6%97%a0%e5%85%b3%e7%9a%84pci%e6%80%bb%e7%ba%bf aria-label=80386微处理器32位微机：与CPU无关的PCI总线>80386微处理器32位微机：与CPU无关的PCI总线</a></li></ul></li></ul></li><li><a href=#%e5%ad%98%e5%82%a8%e6%8a%80%e6%9c%af aria-label=存储技术>存储技术</a><ul><li><a href=#%e6%a6%82%e8%bf%b0 aria-label=概述>概述</a><ul><li><a href=#%e5%ad%98%e5%82%a8%e5%99%a8%e7%9a%84%e5%88%86%e7%b1%bb aria-label=存储器的分类>存储器的分类</a></li><li><a href=#%e4%b8%bb%e8%a6%81%e6%80%a7%e8%83%bd%e6%8c%87%e6%a0%87 aria-label=主要性能指标>主要性能指标</a></li></ul></li><li><a href=#%e5%b8%b8%e7%94%a8%e5%ad%98%e5%82%a8%e5%99%a8%e8%8a%af%e7%89%87%e5%8f%8a%e8%bf%9e%e6%8e%a5%e4%bd%bf%e7%94%a8 aria-label=常用存储器芯片及连接使用>常用存储器芯片及连接使用</a><ul><li><a href=#%e9%9d%99%e6%80%81%e9%9a%8f%e6%9c%ba%e8%af%bb%e5%86%99%e5%ad%98%e5%82%a8%e5%99%a8sram%e5%8f%8a%e6%8e%a5%e5%8f%a3%e8%ae%be%e8%ae%a1 aria-label=静态随机读/写存储器（SRAM）及接口设计>静态随机读/写存储器（SRAM）及接口设计</a></li><li><a href=#%e5%8f%aa%e8%af%bb%e5%ad%98%e5%82%a8%e5%99%a8rom%e5%8f%8a%e6%8e%a5%e5%8f%a3%e8%ae%be%e8%ae%a1 aria-label=只读存储器（ROM）及接口设计>只读存储器（ROM）及接口设计</a></li><li><a href=#%e5%85%b6%e4%bb%96%e5%ad%98%e5%82%a8%e5%99%a8 aria-label=其他存储器>其他存储器</a></li></ul></li><li><a href=#intel-1632%e4%bd%8d%e5%be%ae%e6%9c%ba%e7%b3%bb%e7%bb%9f%e7%9a%84%e4%b8%bb%e5%ad%98%e8%ae%be%e8%ae%a1sram%e9%83%a8%e5%88%86 aria-label="Intel 16/32位微机系统的主存设计（SRAM部分）">Intel 16/32位微机系统的主存设计（SRAM部分）</a><ul><li><a href=#80868088%e5%a4%84%e7%90%86%e5%99%a8%e7%9a%84%e5%86%85%e5%ad%98%e6%8e%a5%e5%8f%a3 aria-label=8086、8088处理器的内存接口>8086、8088处理器的内存接口</a></li><li><a href=#8038680486%e7%9a%84%e5%86%85%e5%ad%98%e6%8e%a5%e5%8f%a3 aria-label=80386、80486的内存接口>80386、80486的内存接口</a></li><li><a href=#pentium%e5%a4%84%e7%90%86%e5%99%a8%e7%9a%84%e5%86%85%e5%ad%98%e7%bb%84%e7%bb%87 aria-label=Pentium处理器的内存组织>Pentium处理器的内存组织</a></li></ul></li><li><a href=#%e5%8a%a8%e6%80%81%e9%9a%8f%e6%9c%ba%e8%af%bb%e5%86%99%e5%ad%98%e5%82%a8%e5%99%a8dram%e5%8f%8a%e6%8e%a5%e5%8f%a3%e8%ae%be%e8%ae%a1 aria-label=动态随机读/写存储器（DRAM）及接口设计>动态随机读/写存储器（DRAM）及接口设计</a><ul><li><a href=#%e7%ae%80%e5%8d%95%e5%bc%82%e6%ad%a5dram aria-label=简单异步DRAM>简单异步DRAM</a></li><li><a href=#%e5%90%8c%e6%ad%a5%e5%8a%a8%e6%80%81%e5%ad%98%e5%82%a8%e5%99%a8sdram aria-label=同步动态存储器SDRAM>同步动态存储器SDRAM</a></li><li><a href=#ddr-sdram aria-label="DDR SDRAM">DDR SDRAM</a></li></ul></li><li><a href=#%e4%b9%a0%e9%a2%98-2 aria-label=习题>习题</a><ul><li><a href=#55 aria-label=5.5>5.5</a></li><li><a href=#510 aria-label=5.10>5.10</a></li><li><a href=#516 aria-label=5.16>5.16</a></li></ul></li></ul></li><li><a href=#%e8%be%93%e5%85%a5%e8%be%93%e5%87%ba%e6%8a%80%e6%9c%af aria-label=输入输出技术>输入输出技术</a><ul><li><a href=#io%e6%a6%82%e8%bf%b0 aria-label=I/O概述>I/O概述</a><ul><li><a href=#%e5%9f%ba%e6%9c%ac%e8%be%93%e5%85%a5%e8%be%93%e5%87%ba%e6%96%b9%e6%b3%95 aria-label=基本输入/输出方法>基本输入/输出方法</a></li><li><a href=#io%e6%8e%a5%e5%8f%a3%e6%a6%82%e8%bf%b0 aria-label=I/O接口概述>I/O接口概述</a></li><li><a href=#io%e7%ab%af%e5%8f%a3%e5%9c%b0%e5%9d%80%e8%af%91%e7%a0%81 aria-label=I/O端口地址译码>I/O端口地址译码</a></li><li><a href=#%e5%9f%ba%e6%9c%ac%e7%9a%84%e5%b9%b6%e8%a1%8c%e8%be%93%e5%85%a5%e4%b8%89%e6%80%81%e9%97%a8%e8%be%93%e5%87%ba%e9%94%81%e5%ad%98%e5%99%a8%e6%8e%a5%e5%8f%a3 aria-label=基本的并行输入（三态门）/输出（锁存器）接口>基本的并行输入（三态门）/输出（锁存器）接口</a></li></ul></li><li><a href=#%e7%a8%8b%e5%ba%8f%e6%9f%a5%e8%af%a2io%e6%96%b9%e5%bc%8f aria-label=程序查询I/O方式>程序查询I/O方式</a><ul><li><a href=#%e6%97%a0%e6%9d%a1%e4%bb%b6%e4%bc%a0%e9%80%81%e6%96%b9%e5%bc%8f aria-label=无条件传送方式>无条件传送方式</a></li><li><a href=#%e6%9f%a5%e8%af%a2%e6%96%b9%e5%bc%8f aria-label=查询方式>查询方式</a></li></ul></li><li><a href=#%e4%b8%ad%e6%96%ad%e6%96%b9%e5%bc%8f aria-label=中断方式>中断方式</a><ul><li><a href=#80868088%e4%b8%ad%e6%96%ad%e7%b3%bb%e7%bb%9f aria-label=8086/8088中断系统>8086/8088中断系统</a></li><li><a href=#%e5%8f%af%e7%bc%96%e7%a8%8b%e4%b8%ad%e6%96%ad%e6%8e%a7%e5%88%b6%e5%99%a88259 aria-label=可编程中断控制器8259>可编程中断控制器8259</a></li><li><a href=#%e4%b8%ad%e6%96%ad%e6%96%b9%e5%bc%8f%e5%8f%8a%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%b3%95 aria-label=中断方式及实现方法>中断方式及实现方法</a></li></ul></li><li><a href=#%e7%9b%b4%e6%8e%a5%e5%ad%98%e5%8f%96%e5%99%a8dma%e6%96%b9%e5%bc%8f aria-label=直接存取器（DMA）方式>直接存取器（DMA）方式</a><ul><li><a href=#dma%e5%b7%a5%e4%bd%9c%e8%bf%87%e7%a8%8b aria-label=DMA工作过程>DMA工作过程</a></li></ul></li><li><a href=#%e4%b9%a0%e9%a2%98-3 aria-label=习题>习题</a><ul><li><a href=#66 aria-label=6.6>6.6</a></li><li><a href=#68 aria-label=6.8>6.8</a></li><li><a href=#69 aria-label=6.9>6.9</a></li></ul></li></ul></li><li><a href=#%e5%b8%b8%e7%94%a8%e6%8e%a5%e5%8f%a3%e5%99%a8%e4%bb%b6 aria-label=常用接口器件>常用接口器件</a><ul><li><a href=#%e5%8f%af%e7%bc%96%e7%a8%8b%e5%b9%b6%e8%a1%8c%e6%8e%a5%e5%8f%a38255 aria-label=可编程并行接口8255>可编程并行接口8255</a><ul><li><a href=#%e5%86%85%e9%83%a8%e7%bb%93%e6%9e%84%e5%8f%8a%e5%a4%96%e9%83%a8%e6%80%bb%e7%ba%bf aria-label=内部结构及外部总线>内部结构及外部总线</a></li><li><a href=#8255%e7%9a%84%e5%b7%a5%e4%bd%9c%e6%96%b9%e5%bc%8f aria-label=8255的工作方式>8255的工作方式</a></li><li><a href=#8255%e7%9a%84%e6%96%b9%e5%bc%8f%e6%8e%a7%e5%88%b6%e5%ad%97%e5%8f%8a%e7%8a%b6%e6%80%81%e5%ad%97 aria-label=8255的方式控制字及状态字>8255的方式控制字及状态字</a></li><li><a href=#8255%e7%9a%84%e5%af%bb%e5%9d%80%e5%8f%8a%e8%bf%9e%e6%8e%a5%e4%bd%bf%e7%94%a8 aria-label=8255的寻址及连接使用>8255的寻址及连接使用</a></li><li><a href=#8255%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96%e5%8f%8a%e5%ba%94%e7%94%a8%e4%b8%be%e4%be%8b aria-label=8255的初始化及应用举例>8255的初始化及应用举例</a></li></ul></li><li><a href=#%e5%8f%af%e7%bc%96%e7%a8%8b%e5%ae%9a%e6%97%b6%e5%99%a88253 aria-label=可编程定时器8253>可编程定时器8253</a><ul><li><a href=#%e5%b7%a5%e4%bd%9c%e6%96%b9%e5%bc%8f aria-label=工作方式>工作方式</a></li><li><a href=#8253%e7%9a%84%e6%8e%a7%e5%88%b6%e5%ad%97 aria-label=8253的控制字>8253的控制字</a></li></ul></li><li><a href=#%e4%b9%a0%e9%a2%98-4 aria-label=习题>习题</a><ul><li><a href=#71 aria-label=7.1>7.1</a></li><li><a href=#72 aria-label=7.2>7.2</a></li><li><a href=#73 aria-label=7.3>7.3</a></li></ul></li></ul></li><li><a href=#%e5%9f%ba%e4%ba%8e%e6%80%bb%e7%ba%bf%e7%9a%84io%e6%8e%a5%e5%8f%a3%e8%ae%be%e8%ae%a1 aria-label=基于总线的I/O接口设计>基于总线的I/O接口设计</a><ul><li><a href=#%e5%9f%ba%e4%ba%8eisa%e6%80%bb%e7%ba%bf%e7%9a%84io%e6%8e%a5%e5%8f%a3%e8%ae%be%e8%ae%a1 aria-label=基于ISA总线的I/O接口设计>基于ISA总线的I/O接口设计</a><ul><li><a href=#led%e6%8e%a5%e5%8f%a3 aria-label=LED接口>LED接口</a></li><li><a href=#%e9%94%ae%e7%9b%98%e6%8e%a5%e5%8f%a3 aria-label=键盘接口>键盘接口</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h2 id=单核处理器80868088>单核处理器8086/8088<a hidden class=anchor aria-hidden=true href=#单核处理器80868088>#</a></h2><h3 id=寄存器结构>寄存器结构<a hidden class=anchor aria-hidden=true href=#寄存器结构>#</a></h3><p><div class=render-image><img loading=lazy src=/images/%e5%af%84%e5%ad%98%e5%99%a8%e7%bb%93%e6%9e%84.svg alt></div></p><h4 id=通用寄存器>通用寄存器<a hidden class=anchor aria-hidden=true href=#通用寄存器>#</a></h4><table><thead><tr><th>Reg</th><th>特殊用途</th></tr></thead><tbody><tr><td>AX,AL</td><td><strong>I/O 指令的数据寄存器</strong>；乘法指令存放<strong>被乘数或积</strong>(隐含)，除法指令存放被除数或商(隐含)</td></tr><tr><td>AH</td><td>LAHF指令的目标寄存器(隐含)</td></tr><tr><td>AL</td><td>数制转换或十进制运算指令和XLAT指令的累加器(隐含)</td></tr><tr><td>BX</td><td><strong>间接寻址的基址寄存器</strong> XLAT指令的基址寄存器(隐含)</td></tr><tr><td>CX</td><td>串操作和<strong>LOOP指令的计数器</strong>(隐含)</td></tr><tr><td>DX</td><td>字乘法/除法指令存放<strong>乘积高16位</strong>或<strong>被除数高位</strong>或<strong>余数</strong>(隐含) 间接寻址的 <strong>I/O 端口地址</strong></td></tr><tr><td>SI</td><td>串操作的源变址寄存器(隐含)、<strong>间接寻址的变址寄存器</strong></td></tr><tr><td>DI</td><td>串操作的目标变址寄存器(隐含)、<strong>间接寻址的变址寄存器</strong></td></tr><tr><td>BP</td><td>对<strong>堆栈区间接寻址的基址指针</strong></td></tr><tr><td>SP</td><td><strong>堆栈操作的堆栈顶部指针</strong></td></tr></tbody></table><h4 id=标志寄存器>标志寄存器<a hidden class=anchor aria-hidden=true href=#标志寄存器>#</a></h4><ul><li><p>6个状态标志位</p><ul><li><p><strong>CF，进位标志</strong>。本次运算最高位<strong>有进位或借位发生，则CF=1</strong>。<strong>STC（CLC）指令使CF=1（=0），CMC指令使之取反。</strong>（用于无符号数）</p></li><li><p>PF，奇偶校验标志：低 8 位有偶数个 1 则 PF = 1</p></li><li><p><strong>AF：辅助进位标志</strong></p><p>低 4 位向高四位有进位或借位， AF = 1 （用于 BCD 计算）</p></li><li><p><strong>ZF：全零标志</strong></p><p>运算结果为 0 时，ZF = 1；</p></li><li><p><strong>SF：符号标志</strong></p><p>运算结果最高位为1，SF = 1 （表示负数）</p></li><li><p><strong>OF：溢出标志</strong></p><p>运算产生溢出 （两负数相加为正）（有符号数）时， OF =1</p></li></ul></li><li><p>3 个控制标志位</p><ul><li>TF：单步标志</li><li>IF：<strong>中断标志</strong>：IF = 1 允许，<strong>IF=0 禁止 CPU 响应可屏蔽中断</strong> （INTR）</li><li>DF：方向标志，串操作指令的地址变化方向</li></ul></li></ul><h3 id=主存结构>主存结构<a hidden class=anchor aria-hidden=true href=#主存结构>#</a></h3><h4 id=双体结构>双体结构<a hidden class=anchor aria-hidden=true href=#双体结构>#</a></h4><p>既能实现16位存储，也可以实现8位存储。<div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/10/18/0XiVTf.png alt></div></p><h4 id=分段结构>分段结构<a hidden class=anchor aria-hidden=true href=#分段结构>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>68320</span><span style=color:#a6e22e>H</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>+</span> <span style=color:#960050;background-color:#1e0010>1280</span><span style=color:#a6e22e>H</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>--------</span>
</span></span><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>695</span><span style=color:#a6e22e>A0H</span>
</span></span></code></pre></div><h3 id=芯片引脚>芯片引脚<a hidden class=anchor aria-hidden=true href=#芯片引脚>#</a></h3><h4 id=8086芯片引脚>8086芯片引脚<a hidden class=anchor aria-hidden=true href=#8086芯片引脚>#</a></h4><p><div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/10/18/0XZYA1.jpg alt></div></p><p><div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/10/18/0XZ0je.jpg alt></div></p><h4 id=8088芯片引脚>8088芯片引脚<a hidden class=anchor aria-hidden=true href=#8088芯片引脚>#</a></h4><p><div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/10/18/0XexRf.png alt></div></p><p><div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/10/18/0Xejit.png alt></div></p><p><div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/10/18/0XevJP.png alt></div></p><h4 id=8086vs8088>8086vs.8088<a hidden class=anchor aria-hidden=true href=#8086vs8088>#</a></h4><ol><li>指令预取序列：4Bytes&lt;=>6Bytes</li><li>AD7~AD0<br>AD15~AD0 => 总线传递数据更快</li><li>8088：$ \overline{SSO} $, 8086: $ \overline{BHE} / S7 $</li><li>8088: $ IO/\overline M $, 8086: $ M/\overline{IO} $</li></ol><h3 id=工作时序>工作时序<a hidden class=anchor aria-hidden=true href=#工作时序>#</a></h3><ol><li>时钟周期：CPU处理动作最小单位</li><li>总线周期：存储器读写、I/O读写、中断响应</li><li>指令周期：取指+执行</li></ol><p>主存读时序分析<div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/10/18/0XnNhq.png alt></div></p><h3 id=习题>习题<a hidden class=anchor aria-hidden=true href=#习题>#</a></h3><h4 id=22>2.2<a hidden class=anchor aria-hidden=true href=#22>#</a></h4><p>若8086CPU工作在最小模式下：</p><ol><li>当CPU访问储存器时，要利用哪些信号？</li></ol><blockquote><p>$AD0 \sim AD15、A16\sim A19、ALE、\overline{BHE}、DT/\overline{R}、\overline{DEN}、M/\overline{IO}、\overline{RD}、\overline{WR}$</p></blockquote><ol start=2><li>当CPU访问外设端口时，要利用哪些信号？</li></ol><blockquote><p>$AD0 \sim AD15、ALE、\overline{BHE}、DT/\overline{R}、\overline{DEN}、M/\overline{IO}、\overline{RD}、\overline{WR}$</p></blockquote><ol start=3><li>当HOLD有效并得到回应时，CPU的哪些信号置高阻？</li></ol><blockquote><p>CPU所有三态输出的地址、数据和相关控制信号。</p></blockquote><h4 id=22-1>2.2<a hidden class=anchor aria-hidden=true href=#22-1>#</a></h4><p>若8086CPU工作在最大模式下：</p><ol><li>S0、S1、S2可以表示哪些CPU的状态？</li></ol><blockquote><p>INTA周期、I/O读周期、I/O写周期、暂停、取值周期、存储器读周期、存储器写周期</p></blockquote><ol start=2><li>CPU的$ \overline{RQ}/\overline{GT} $信号的作用是什么？</li></ol><blockquote><p>$ \overline{RQ}/\overline{GT} $是裁决总线使用权的请求/允许信号</p></blockquote><h2 id=intel指令系统与程序设计>Intel指令系统与程序设计<a hidden class=anchor aria-hidden=true href=#intel指令系统与程序设计>#</a></h2><h3 id=程序框架>程序框架<a hidden class=anchor aria-hidden=true href=#程序框架>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>STACK</span>  <span style=color:#66d9ef>SEGMENT</span> <span style=color:#66d9ef>STACK</span>
</span></span><span style=display:flex><span>       <span style=color:#a6e22e>DB</span> <span style=color:#ae81ff>100</span> <span style=color:#66d9ef>DUP</span>(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>STACK</span>  <span style=color:#66d9ef>ENDS</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>DATA</span>   <span style=color:#66d9ef>SEGMENT</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>NUM8</span>   <span style=color:#66d9ef>DB</span> <span style=color:#ae81ff>16</span>,<span style=color:#ae81ff>25</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>NUM16</span>  <span style=color:#66d9ef>DW</span> <span style=color:#ae81ff>36</span>,<span style=color:#ae81ff>64</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ARRAY8</span> <span style=color:#66d9ef>DB</span> <span style=color:#ae81ff>20</span> <span style=color:#66d9ef>DUP</span>(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>………</span>  <span style=color:#960050;background-color:#1e0010>…………</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>DATA</span>   <span style=color:#66d9ef>ENDS</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>CODE</span>   <span style=color:#66d9ef>SEGMENT</span>
</span></span><span style=display:flex><span>       <span style=color:#a6e22e>ASSUME</span> <span style=color:#66d9ef>CS</span>:<span style=color:#66d9ef>CODE</span>,<span style=color:#66d9ef>DS</span>:<span style=color:#66d9ef>DATA</span>,<span style=color:#66d9ef>SS</span>:<span style=color:#66d9ef>STACK</span>
</span></span><span style=display:flex><span>START: <span style=color:#a6e22e>MOV</span> <span style=color:#66d9ef>AX</span>,<span style=color:#66d9ef>DATA</span>
</span></span><span style=display:flex><span>       <span style=color:#a6e22e>MOV</span> <span style=color:#66d9ef>DS</span>,<span style=color:#66d9ef>AX</span>
</span></span><span style=display:flex><span>        <span style=color:#960050;background-color:#1e0010>…………</span>
</span></span><span style=display:flex><span>       <span style=color:#a6e22e>MOV</span> <span style=color:#66d9ef>AX</span>,<span style=color:#ae81ff>4</span><span style=color:#66d9ef>C00H</span>
</span></span><span style=display:flex><span>       <span style=color:#a6e22e>INT</span> <span style=color:#ae81ff>21</span><span style=color:#66d9ef>H</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>CODE</span>   <span style=color:#66d9ef>ENDS</span>
</span></span><span style=display:flex><span>       <span style=color:#a6e22e>END</span> <span style=color:#66d9ef>START</span>
</span></span></code></pre></div><p>子程序结构</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>     <span style=color:#960050;background-color:#1e0010>……</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>CALL</span> <span style=color:#66d9ef>SUB1</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>……</span>    
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>SUB1</span> <span style=color:#66d9ef>PROC</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>PUSH</span> <span style=color:#960050;background-color:#1e0010>…</span>
</span></span><span style=display:flex><span>     <span style=color:#960050;background-color:#1e0010>……</span>
</span></span><span style=display:flex><span>     <span style=color:#a6e22e>POP</span> <span style=color:#960050;background-color:#1e0010>…</span>
</span></span><span style=display:flex><span>     <span style=color:#a6e22e>RET</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>SUB1</span> <span style=color:#66d9ef>ENDP</span>
</span></span></code></pre></div><h3 id=数据传送寻址算术运算指令>数据传送、寻址、算术运算指令<a hidden class=anchor aria-hidden=true href=#数据传送寻址算术运算指令>#</a></h3><h4 id=数据传送>数据传送<a hidden class=anchor aria-hidden=true href=#数据传送>#</a></h4><ul><li><p><strong>MOV指令</strong></p><ul><li>MOV指令必须遵从的的规则：<ol><li>两个操作数的尺寸必须一致</li><li>两个操作数不能同为操作数</li><li>目的操作数不能位CS, EIP和IP</li><li>立即数不能直接送至段寄存器</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>r</span><span style=color:#960050;background-color:#1e0010>/</span><span style=color:#66d9ef>m16</span>,<span style=color:#66d9ef>sreg</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>sreg</span>,<span style=color:#66d9ef>r</span><span style=color:#960050;background-color:#1e0010>/</span><span style=color:#66d9ef>m16</span>
</span></span></code></pre></div></li><li>MOV指令格式<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>reg</span>, <span style=color:#66d9ef>reg</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>mem</span>, <span style=color:#66d9ef>reg</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>reg</span>, <span style=color:#66d9ef>mem</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>mem</span>, <span style=color:#66d9ef>imm</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>reg</span>, <span style=color:#66d9ef>emm</span>
</span></span></code></pre></div></li></ul></li><li><p><strong>整数的零/符号扩展</strong></p><ol><li>MOVZX</li><li>MOVSZ</li></ol></li><li><p><strong>XCHG指令</strong></p><p>交换两个操作数的内容</p></li></ul><h4 id=加法和减法>加法和减法<a hidden class=anchor aria-hidden=true href=#加法和减法>#</a></h4><ul><li><p><strong>INC和DEC指令</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>inc</span> <span style=color:#66d9ef>reg</span><span style=color:#960050;background-color:#1e0010>/</span><span style=color:#66d9ef>mem</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>dec</span> <span style=color:#66d9ef>reg</span><span style=color:#960050;background-color:#1e0010>/</span><span style=color:#66d9ef>mem</span>
</span></span></code></pre></div><p>&lt; notice tip >
INC和DEC指令不影响进位标志
&lt; /notice ></p></li><li><p><strong>ADD、SUB、NEG指令</strong></p><p>影响的标志位：CF, ZF, SF, OF, AF, PF</p></li></ul><h4 id=和数据相关的操作符和伪指令>和数据相关的操作符和伪指令<a hidden class=anchor aria-hidden=true href=#和数据相关的操作符和伪指令>#</a></h4><ul><li><p><strong>OFFSET操作符</strong></p></li><li><p><strong>PTR操作符</strong></p><ul><li>用来重载操作数的默认尺寸</li><li>必须和标准数据类型联合使用</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>.data</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>myDouble</span> <span style=color:#66d9ef>DWORD</span> <span style=color:#ae81ff>12345678</span><span style=color:#66d9ef>h</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>.code</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ax</span>, <span style=color:#66d9ef>myDouble</span>              <span style=color:#75715e>; 错误
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ax</span>, <span style=color:#66d9ef>WORD</span> <span style=color:#66d9ef>PTR</span> <span style=color:#66d9ef>myDouble</span>     <span style=color:#75715e>; ax = 5678h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ax</span>, <span style=color:#66d9ef>WORD</span> <span style=color:#66d9ef>PTR</span> [<span style=color:#66d9ef>myDouble</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#ae81ff>2</span>] <span style=color:#75715e>; ax = 1234h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>bl</span>, <span style=color:#66d9ef>BYTE</span> <span style=color:#66d9ef>PTR</span> <span style=color:#66d9ef>myDouble</span>     <span style=color:#75715e>; bl = 78h
</span></span></span></code></pre></div></li><li><p><strong>TYPE操作符</strong>
返回按字节计算的变量的单个元素的大小</p></li><li><p><strong>LENGTHOF操作符</strong>
计算数组元素的个数</p></li><li><p><strong>SIZEOF操作符</strong>
SIZEOF返回值=LENGTHOF返回值*TYPE返回值</p></li></ul><h4 id=间接寻址>间接寻址<a hidden class=anchor aria-hidden=true href=#间接寻址>#</a></h4><ul><li><p><strong>间接操作数(寄存器间接寻址)</strong></p><p>PTR与间接操作数的联合使用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>inc</span> [<span style=color:#66d9ef>esi</span>]     <span style=color:#75715e>; error: operand must have size
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>inc</span> <span style=color:#66d9ef>BYTE</span> <span style=color:#66d9ef>PTR</span> [<span style=color:#66d9ef>esi</span>]
</span></span></code></pre></div></li><li><p><strong>数组</strong><br>例：三个双字相加</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>.data</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>arrayD</span> <span style=color:#66d9ef>DWORD</span> <span style=color:#ae81ff>10000</span><span style=color:#66d9ef>h</span>,<span style=color:#ae81ff>20000</span><span style=color:#66d9ef>h</span>,<span style=color:#ae81ff>30000</span><span style=color:#66d9ef>h</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>.code</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>esi</span>, <span style=color:#66d9ef>OFFSET</span> <span style=color:#66d9ef>arrayD</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>eax</span>, [<span style=color:#66d9ef>esi</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>add</span> <span style=color:#66d9ef>esi</span>, <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>add</span> <span style=color:#66d9ef>eax</span>, [<span style=color:#66d9ef>esi</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>add</span> <span style=color:#66d9ef>esi</span>, <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>add</span> <span style=color:#66d9ef>eax</span>, [<span style=color:#66d9ef>esi</span>]
</span></span></code></pre></div></li><li><p><strong>变址操作数(寄存器相对寻址)</strong><br>例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>.data</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>arrayB</span> <span style=color:#66d9ef>BYTE</span> <span style=color:#ae81ff>10</span><span style=color:#66d9ef>h</span>, <span style=color:#ae81ff>20</span><span style=color:#66d9ef>h</span>, <span style=color:#ae81ff>30</span><span style=color:#66d9ef>h</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>.code</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>esi</span>, <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>al</span>, [<span style=color:#66d9ef>arrayB</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#66d9ef>esi</span>]  <span style=color:#75715e>; AL = 10h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>al</span>, <span style=color:#66d9ef>arrayB</span>[<span style=color:#66d9ef>esi</span>]   <span style=color:#75715e>; 同上，另一种格式
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>esi</span>, <span style=color:#66d9ef>OFFSET</span> <span style=color:#66d9ef>arrayB</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>al</span>, [<span style=color:#66d9ef>esi</span>]         <span style=color:#75715e>; AL = 10h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>al</span>, [<span style=color:#66d9ef>esi</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#ae81ff>1</span>]       <span style=color:#75715e>; AL = 20h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>al</span>, [<span style=color:#66d9ef>esi</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#ae81ff>2</span>]       <span style=color:#75715e>; AL = 30h
</span></span></span></code></pre></div></li></ul><h4 id=jmp和loop指令>JMP和LOOP指令<a hidden class=anchor aria-hidden=true href=#jmp和loop指令>#</a></h4><ul><li><strong>JMP</strong>：无条件转移</li><li><strong>LOOP</strong>:条件转移<ul><li>在实地址模式下，用做默认循环计数器的是CX而不是ECX</li><li>在任何模式下，LOOPD指令都使用ECX作为循环计数器，LOOPW都使用CX作为循环计数器</li><li>循环的目的地址与当前地址只能在相距-128到+127字节的范围之内。机器指令平均在3字节左右，因此一个循环平均最多只能包含大约42条指令</li><li>循环的嵌套<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>.data</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>count</span> <span style=color:#66d9ef>DWORD</span> <span style=color:#960050;background-color:#1e0010>?</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>.code</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ecx</span>, <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>L1: <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>count</span>, <span style=color:#66d9ef>ecx</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ecx</span>, <span style=color:#ae81ff>20</span>
</span></span><span style=display:flex><span>L2: <span style=color:#a6e22e>...</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>...</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>loop</span> <span style=color:#66d9ef>L2</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ecx</span>, <span style=color:#66d9ef>count</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>loop</span> <span style=color:#66d9ef>L1</span>
</span></span></code></pre></div></li></ul></li></ul><h4 id=小结操作数类型寻址方式>小结：操作数类型（寻址方式）<a hidden class=anchor aria-hidden=true href=#小结操作数类型寻址方式>#</a></h4><ul><li><strong>直接操作数（直接寻址）</strong>
变量的名字，代表变量的地址</li><li><strong>直接偏移操作数</strong>
在变量的名字上加一个偏移量</li><li><strong>间接操作数（寄存器间接寻址）</strong>
用方括号括起的包含数据地址的寄存器</li><li><strong>变址操作数（寄存器相对寻址）</strong>
把常量和间接操作数结合在一起</li></ul><h3 id=过程>过程<a hidden class=anchor aria-hidden=true href=#过程>#</a></h3><h4 id=与外部库链接>与外部库链接<a hidden class=anchor aria-hidden=true href=#与外部库链接>#</a></h4><ol><li>程序中要用PROTO伪指令声明要调用的程序:
WriteString PROTO</li><li>用一条CALL指令执行WriteString过程:
call WriteString</li><li>当程序被编译时，编译器为CALL指令的目标地址留出空白，该空白将有链接器填充</li><li>连接器在链接库中查找WriteString这个名字，从库中把合适的机器指令拷贝到程序的可执行文件中，并把WriteString的地址插入到CALL指令中</li></ol><h4 id=堆栈操作>堆栈操作<a hidden class=anchor aria-hidden=true href=#堆栈操作>#</a></h4><ul><li><strong>堆栈</strong><ul><li><p>压栈操作：
32位的压栈（PUSH）操作将堆栈指针减4，并将进栈数据拷贝到堆栈指针所指向的位置</p></li><li><p>出栈操作：
出栈（POP）操作从堆栈顶端移走一个值并将其置于寄存器或变量中。在值从栈顶弹出后，堆栈指针相应增加。</p><p><div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/10/21/B92cgU.jpg alt></div></p></li><li><p>堆栈的用途：</p><ul><li>临时保存区域</li><li>CALL指令用堆栈保存当前过程的⚠️返回地址</li><li>调用过程时,通过堆栈:⚠️传递参数</li><li>过程内的⚠️局部变量在堆栈上创建，过程结束时，这些变量被丢弃</li></ul></li></ul></li><li><strong>PUSH和POP指令</strong><ul><li><p>PUSH指令</p><ul><li>执行过程<ul><li>减小ESP的值<ul><li>16位操作数：ESP减2</li><li>32位操作数：ESP减4</li></ul></li><li>将一个16位或32位的源操作数拷贝至堆栈上</li></ul></li><li>指令格式<pre tabindex=0><code>push r/m16
push r/m32
push imm32
</code></pre></li><li>保护模式下的立即数总是32位的；
在实地址模式下，如果未使用.386（或更高）处理器伪指令，默认的立即数是16位的</li></ul></li><li><p>POP指令</p><ul><li>执行过程<ul><li>将ESP所指向的堆栈元素拷贝到16位或32位的目的操作数中</li><li>增加ESP的值<ul><li>16位操作数：ESP加2</li><li>32位操作数：ESP加4</li></ul></li><li>指令格式<pre tabindex=0><code>pop r/m16
pop r/m32
</code></pre></li></ul></li></ul></li><li><p>PUSHFD和POPFD指令</p><ul><li>32位：<ul><li>PUSHFD：在堆栈压入32位EFLAGS寄存器的值</li><li>POPFD：将堆栈顶部的值弹出并送至EFLAGS寄存器</li></ul></li><li>实地址模式：<ul><li>PUSHF：在堆栈上压入16位FLAGS寄存器的值</li><li>POPF：将堆栈顶部的值弹出并送至FLAGS寄存器</li></ul></li></ul></li><li><p>PUSHAD,PUSHA,POPAD和POPA指令</p><ul><li>32位：<ul><li>PUSHAD：将EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI按顺序压入堆栈</li><li>POPAD：按相反顺序弹出这些通用寄存器</li></ul></li><li>80286：<ul><li>PUSHA：以用样的顺序压入AX、CX、DX、BX、SP、BP、SI、DI</li><li>POPA：以相反的顺序弹出</li></ul></li></ul></li></ul></li></ul><h4 id=过程的定义和使用>过程的定义和使用<a hidden class=anchor aria-hidden=true href=#过程的定义和使用>#</a></h4><ul><li><p><strong>PROC伪指令</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>Sumof</span> <span style=color:#66d9ef>PROC</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>add</span> <span style=color:#66d9ef>eax</span>, <span style=color:#66d9ef>ebx</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>add</span> <span style=color:#66d9ef>eax</span>, <span style=color:#66d9ef>ecx</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ret</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Sumof</span> <span style=color:#66d9ef>ENDP</span>
</span></span></code></pre></div></li><li><p><strong>CALL和RET指令</strong></p><ul><li><p>调用和返回的例子<div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/10/21/B97DL6.png alt></div></p></li><li><p>可嵌套使用</p></li><li><p>局部标号和全局标号</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>L1:<span style=color:#960050;background-color:#1e0010>:</span>      <span style=color:#75715e>; global label
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>...</span>
</span></span><span style=display:flex><span>L2:       <span style=color:#75715e>; local babel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>...</span>
</span></span></code></pre></div></li></ul></li></ul><h3 id=条件处理>条件处理<a hidden class=anchor aria-hidden=true href=#条件处理>#</a></h3><h4 id=布尔和比较指令>布尔和比较指令<a hidden class=anchor aria-hidden=true href=#布尔和比较指令>#</a></h4><ul><li><strong>AND指令</strong>：按位与<ul><li>影响的标志位：<ul><li>总是清除OF和CF；</li><li>根据结果修改SF，ZF，PF</li></ul></li><li>主要用途：对特定的位清0</li><li>大写字母和小写字母的ASCII码之间的关系：<ul><li>&lsquo;a&rsquo;: 61h, 01100001b</li><li>&lsquo;A&rsquo;: 41h, 01000001b</li></ul></li></ul></li><li><strong>OR指令</strong>：按位或<ul><li>主要用途：对特定的位置1</li></ul></li><li><strong>XOR指令</strong>：按位异或<ul><li>用途：<ul><li>对某些位取反</li><li>判断16位或32位值的奇偶性<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ax</span>, <span style=color:#ae81ff>64</span><span style=color:#66d9ef>C1h</span>     <span style=color:#75715e>; 0110 0100 1100 0001
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>xor</span> <span style=color:#66d9ef>ah</span>, <span style=color:#66d9ef>al</span>        <span style=color:#75715e>; PE, 奇偶位被设置
</span></span></span></code></pre></div></li><li>简单数据加密
将某个操作数与同样的操作数执行两次异或操作之后，其值保持不变
$$ (X\oplus Y) \oplus Y = X $$</li></ul></li></ul></li><li><strong>NOT指令</strong>：取反
&lt; notice warning >
<strong>NOT指令不影响任何状态标志</strong>
&lt; /notice ></li><li><strong>TEST指令</strong>：两操作数按位<strong>与</strong>，根据结果设置标志位，但<strong>不回送结果</strong>（不修改目的操作数）<ul><li>用途：测试某一位是“0”还是“1”<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>test</span> <span style=color:#66d9ef>al</span>, <span style=color:#ae81ff>00001001</span><span style=color:#66d9ef>b</span>   <span style=color:#75715e>; test bits 0 and 3
</span></span></span></code></pre></div>判断ZF是否等于1</li><li>影响的标志位：清除OF、CF；修改SF、ZF、PF</li></ul></li><li><strong>CMP指令</strong><ul><li><p>功能：与减法指令一样执行减法操作，但<strong>不回送</strong>结果，只<strong>影响标志位</strong></p></li><li><p>影响的标志位：根据相减结果修改OF、SF、ZF、CF、AF、PF</p></li><li><p>无符号操作数的比较</p><table><thead><tr><th>CMP的结果</th><th>ZF</th><th>CF</th></tr></thead><tbody><tr><td>目的 &lt; 源</td><td>0</td><td>1</td></tr><tr><td>目的 > 源</td><td>0</td><td>0</td></tr><tr><td>目的 = 源</td><td>1</td><td>0</td></tr></tbody></table></li><li><p>有符号操作数的比较</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ax</span>, <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>cmp</span> <span style=color:#66d9ef>ax</span>, <span style=color:#ae81ff>10</span>  <span style=color:#75715e>; CF = 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>si</span>, <span style=color:#ae81ff>105</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>cmp</span> <span style=color:#66d9ef>si</span>, <span style=color:#ae81ff>0</span>   <span style=color:#75715e>; ZF = 0, CF = 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ax</span>, <span style=color:#ae81ff>1000</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>cx</span>, <span style=color:#ae81ff>1000</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>cmp</span> <span style=color:#66d9ef>ax</span>, <span style=color:#66d9ef>cx</span>  <span style=color:#75715e>; ZF = 1
</span></span></span></code></pre></div></li><li><p>设置和清除单个CPU标志</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>test</span> <span style=color:#66d9ef>al</span>, <span style=color:#ae81ff>0</span>   <span style=color:#75715e>; 设置零标志
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>and</span> <span style=color:#66d9ef>al</span>, <span style=color:#ae81ff>0</span>    <span style=color:#75715e>; 设置零标志
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>or</span> <span style=color:#66d9ef>al</span>, <span style=color:#ae81ff>0</span>     <span style=color:#75715e>; 设置零标志
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>or</span> <span style=color:#66d9ef>al</span>, <span style=color:#ae81ff>80</span><span style=color:#66d9ef>h</span>   <span style=color:#75715e>; 设置符号标志
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>and</span> <span style=color:#66d9ef>al</span>, <span style=color:#ae81ff>7</span><span style=color:#66d9ef>Fh</span>  <span style=color:#75715e>; 清楚符号标志
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>stc</span>          <span style=color:#75715e>; 设置进位标志
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>clc</span>          <span style=color:#75715e>; 清除进位标志
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>al</span>, <span style=color:#ae81ff>7</span><span style=color:#66d9ef>Fh</span>  <span style=color:#75715e>; AL = +127
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>inc</span> <span style=color:#66d9ef>al</span>       <span style=color:#75715e>; AL = 80h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>or</span> <span style=color:#66d9ef>eax</span>, <span style=color:#ae81ff>0</span>    <span style=color:#75715e>; 清除溢出标志
</span></span></span></code></pre></div></li></ul></li></ul><h4 id=条件跳转>条件跳转<a hidden class=anchor aria-hidden=true href=#条件跳转>#</a></h4><ul><li><p><strong>条件结构</strong></p><ul><li><p>使用CMP、TEST、AND之类的指令修改CPU标志</p></li><li><p>使用条件跳转指令测试标志值，已决定是否向新的分支转移</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>    <span style=color:#a6e22e>cmp</span> <span style=color:#66d9ef>al</span>, <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>jz</span>  <span style=color:#66d9ef>L1</span>      <span style=color:#75715e>; jump if ZF = 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>L1:
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>    <span style=color:#a6e22e>and</span> <span style=color:#66d9ef>dl</span>, <span style=color:#ae81ff>10110000</span><span style=color:#66d9ef>b</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>jnz</span> <span style=color:#66d9ef>L2</span>            <span style=color:#75715e>; jump if ZF = 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>...</span>
</span></span><span style=display:flex><span>L2:    
</span></span></code></pre></div></li></ul></li><li><p><strong>Jcond指令</strong></p><ul><li>功能：<ul><li>条件标志为真：分支转移到新的目标标号处</li><li>条件标志为假：执行紧跟在条件跳转指令之后的指令</li></ul></li><li>格式：
例：<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ax</span>, <span style=color:#ae81ff>5</span>     <span style=color:#66d9ef>mov</span> <span style=color:#66d9ef>ax</span>, <span style=color:#ae81ff>5</span>     <span style=color:#66d9ef>mov</span> <span style=color:#66d9ef>ax</span>, <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>cmp</span> <span style=color:#66d9ef>ax</span>, <span style=color:#ae81ff>5</span>     <span style=color:#66d9ef>cmp</span> <span style=color:#66d9ef>ax</span>, <span style=color:#ae81ff>6</span>     <span style=color:#66d9ef>mov</span> <span style=color:#66d9ef>ax</span>, <span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>je</span> <span style=color:#66d9ef>L1</span>         <span style=color:#66d9ef>j1</span> <span style=color:#66d9ef>L1</span>         <span style=color:#66d9ef>jg</span> <span style=color:#66d9ef>L1</span>
</span></span></code></pre></div></li></ul></li><li><p>条件跳转指令的类型</p><ul><li><p>基于特定CPU<strong>标志值</strong></p><table><thead><tr><th>助记符</th><th>描述</th><th>标志值</th></tr></thead><tbody><tr><td>JZ</td><td>为零则跳转</td><td>ZF = 1</td></tr><tr><td>JNZ</td><td>不为零则跳转</td><td>ZF = 0</td></tr><tr><td>JC</td><td>如果设置进位标志则跳转</td><td>CF = 1</td></tr><tr><td>JNC</td><td>如果未设置进位标志则跳转</td><td>CF = 0</td></tr><tr><td>JO</td><td>如果设置溢出标志则跳转</td><td>OF = 1</td></tr><tr><td>JNO</td><td>如果未设置溢出标志则跳转</td><td>OF = 0</td></tr><tr><td>JS</td><td>如果设置符号标志则跳转</td><td>SF = 1</td></tr><tr><td>JNS</td><td>如果未设置符号标志则跳转</td><td>SF = 0</td></tr><tr><td>JP</td><td>如果设置了奇偶标志则跳转（偶）</td><td>PF = 1</td></tr><tr><td>JNP</td><td>如果未设置奇偶标志则跳转（奇）</td><td>PF = 0</td></tr></tbody></table></li><li><p>依据<strong>相等</strong>比较的跳转指令</p><table><thead><tr><th>助记符</th><th>描述</th></tr></thead><tbody><tr><td>JE</td><td>相等则跳转</td></tr><tr><td>JNE</td><td>不相等则不跳转</td></tr><tr><td>JCXZ</td><td>CX = 0 则跳转</td></tr><tr><td>JECXZ</td><td>ECX = 0 则跳转</td></tr></tbody></table></li><li><p>基于<strong>无符号整数</strong>比较结果的跳转指令</p><blockquote><p>A:Above, B: Below, E:Equal</p></blockquote><table><thead><tr><th>助记府</th><th>描述</th></tr></thead><tbody><tr><td>JA</td><td>大于则跳转(leftOp > rightOp)</td></tr><tr><td>JNBE</td><td>不（小于或等于）（同JA）</td></tr><tr><td>JAE</td><td>大于或等于则跳转 (leftOp >= rightOp)</td></tr><tr><td>JNB</td><td>不小于则跳转 （同JAE）</td></tr><tr><td>JB</td><td>小于则跳转(leftOp &lt; rightOp)</td></tr><tr><td>JNAE</td><td>不（大于或等于）（同JB）</td></tr><tr><td>JBE</td><td>小于或等于则跳转(leftOp &lt;= rightOp)</td></tr><tr><td>JNA</td><td>不大于则跳转（同JBE）</td></tr></tbody></table></li><li><p>基于<strong>有符号整数</strong>比较结果的跳转指令</p><blockquote><p>G: Grater, L: Less, E: Equal</p></blockquote><table><thead><tr><th>助记府</th><th>描述</th></tr></thead><tbody><tr><td>JG</td><td>大于则跳转(leftOp > rightOp)</td></tr><tr><td>JNLE</td><td>不（小于或等于）（同JA）</td></tr><tr><td>JGE</td><td>大于或等于则跳转 (leftOp >= rightOp)</td></tr><tr><td>JNL</td><td>不小于则跳转 （同JAE）</td></tr><tr><td>JL</td><td>小于则跳转(leftOp &lt; rightOp)</td></tr><tr><td>JNGE</td><td>不（大于或等于）（同JB）</td></tr><tr><td>JLE</td><td>小于或等于则跳转(leftOp &lt;= rightOp)</td></tr><tr><td>JNG</td><td>不大于则跳转（同JBE）</td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>al</span>, <span style=color:#ae81ff>7</span><span style=color:#66d9ef>Fh</span>     <span style=color:#75715e>; (7Fh or +127)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>cmp</span> <span style=color:#66d9ef>al</span>, <span style=color:#ae81ff>80</span><span style=color:#66d9ef>h</span>     <span style=color:#75715e>; (80h or -128)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>ja</span> <span style=color:#66d9ef>IsAbove</span>      <span style=color:#75715e>; no : 7F not &gt; 180h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>al</span>, <span style=color:#ae81ff>7</span><span style=color:#66d9ef>Fh</span>     <span style=color:#75715e>; (7Fh or +127)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>cmp</span> <span style=color:#66d9ef>al</span>, <span style=color:#ae81ff>80</span><span style=color:#66d9ef>h</span>     <span style=color:#75715e>; (80h or -128)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>jg</span> <span style=color:#66d9ef>IsAbove</span>      <span style=color:#75715e>; yes: +127 &gt; -128
</span></span></span></code></pre></div></li></ul></li></ul><h4 id=条件循环指令>条件循环指令<a hidden class=anchor aria-hidden=true href=#条件循环指令>#</a></h4><ul><li><p><strong>LOOPZ和LOOPE指令</strong></p><ul><li>含义：Loop if zero，Loop if equal</li><li>二者等价</li><li>执行逻辑：
ECX = ECX - 1<br>if ECX > 0 and ZF = 1, jump to destination</li></ul></li><li><p><strong>LOOPNZ和LOOPNE指令</strong></p><ul><li>含义：Loop if not zero， Loop if not equal</li><li>二者等价</li><li>执行逻辑：
ECX = ECX - 1<br>if ECX > 0 and ZF = 0, jump to destination</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#75715e>; 扫描数组中的每个数值，直到发现正数为止
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>.data</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>array</span> <span style=color:#66d9ef>SWORD</span> -<span style=color:#ae81ff>3</span>,-<span style=color:#ae81ff>6</span>,-<span style=color:#ae81ff>1</span>,-<span style=color:#ae81ff>10</span>,<span style=color:#ae81ff>10</span>,<span style=color:#ae81ff>30</span>,<span style=color:#ae81ff>40</span>,<span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>sentinel</span> <span style=color:#66d9ef>SWORD</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>.code</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>esi</span>, <span style=color:#66d9ef>OFFSET</span> <span style=color:#66d9ef>array</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ecx</span>, <span style=color:#66d9ef>LENGTHOF</span> <span style=color:#66d9ef>array</span>
</span></span><span style=display:flex><span>next: <span style=color:#a6e22e>test</span> <span style=color:#66d9ef>WORD</span> <span style=color:#66d9ef>PTR</span> [<span style=color:#66d9ef>esi</span>], <span style=color:#ae81ff>8000</span><span style=color:#66d9ef>h</span> <span style=color:#75715e>; test highest bit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>pushfd</span>                     <span style=color:#75715e>; push flags on stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>add</span> <span style=color:#66d9ef>esi</span>, <span style=color:#66d9ef>TYPE</span> <span style=color:#66d9ef>array</span>        
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>popfd</span>                      <span style=color:#75715e>; pop flags from stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>loopnz</span> <span style=color:#66d9ef>next</span>                <span style=color:#75715e>; continue
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>jnz</span> <span style=color:#66d9ef>quit</span>                   <span style=color:#75715e>; none found
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>sub</span> <span style=color:#66d9ef>esi</span>, <span style=color:#66d9ef>TYPE</span> <span style=color:#66d9ef>array</span>        <span style=color:#75715e>; SI points to value
</span></span></span></code></pre></div></li></ul><h3 id=整数运算指令>整数运算指令<a hidden class=anchor aria-hidden=true href=#整数运算指令>#</a></h3><h4 id=移位和循环移位指令>移位和循环移位指令<a hidden class=anchor aria-hidden=true href=#移位和循环移位指令>#</a></h4><p>&lt; notice note >
<strong>S</strong>hift
<strong>L</strong>eft
<strong>R</strong>ight
<strong>A</strong>rithmetic
<strong>R</strong>otate
<strong>C</strong>arry
&lt; /notice ></p><ul><li><p>移位指令</p><table><thead><tr><th>助记符</th><th>描述</th></tr></thead><tbody><tr><td>SHL</td><td>逻辑左移</td></tr><tr><td>SHR</td><td>逻辑右移</td></tr><tr><td>SAL</td><td>算数左移</td></tr><tr><td>SAR</td><td>算数右移</td></tr><tr><td>ROL</td><td>循环左移</td></tr><tr><td>ROR</td><td>循环右移</td></tr><tr><td>RCL</td><td>带进位的循环左移</td></tr><tr><td>RCR</td><td>带进位的循环右移</td></tr><tr><td>SHLD</td><td>双精度左移</td></tr><tr><td>SHRD</td><td>双精度右移</td></tr></tbody></table></li><li><p>上述指令影响<strong>OF、CF</strong></p></li><li><p><strong>逻辑移位和算术移位</strong><div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/10/21/BPG8pt.png alt></div></p></li><li><p><strong>循环左移ROL和循环右移ROR</strong><div class=render-image><img loading=lazy src="src=%22https://s1.ax1x.com/2020/10/21/BPG1fI.png" alt></div><div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/10/21/BPGQkd.png alt></div></p></li><li><p><strong>带进位的循环左移RCL和右移RCR</strong><div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/10/21/BPGltA.png alt></div></p></li><li><p><strong>SHLD/SHRD指令</strong></p><ul><li>格式：<strong>SHLD 目的操作数，源操作数，移位位数</strong></li><li>要求至少是Intel386处理器</li><li>SHLD：双精度左移，<strong>Sh</strong>ift <strong>L</strong>eft <strong>D</strong>ouble<br>将目的操作数左移指定的位数，低位空出来的位用源操作数的高位填充</li><li>SHRD：双精度右移，<strong>Sh</strong>ift <strong>R</strong>ight <strong>D</strong>ouble<br>将目的操作数右移指定的位数，空出来的位由源操作数的低位来填充。</li></ul></li><li><p>格式：<br><strong>助记符 目的操作数，移位位数</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>SHL</span> <span style=color:#66d9ef>reg</span>, <span style=color:#66d9ef>imm8</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>SAL</span> <span style=color:#66d9ef>mem</span>, <span style=color:#66d9ef>imm8</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ROR</span> <span style=color:#66d9ef>reg</span>, <span style=color:#66d9ef>CL</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>RCL</span> <span style=color:#66d9ef>mem</span>, <span style=color:#66d9ef>CL</span>
</span></span></code></pre></div><ul><li>8088/8086要求imm8必须等于1；80286以上，imm8可以为“任意”整数</li><li>CL方式可用于任何Intel x86处理器</li></ul></li></ul><h4 id=乘法和除法指令>乘法和除法指令<a hidden class=anchor aria-hidden=true href=#乘法和除法指令>#</a></h4><ul><li><p><strong>MUL指令</strong></p><ul><li>格式（操作数为乘数）：<br>MUL r/m8<br>MUL r/m16<br>MUL r/m32</li><li>功能：无符号乘法。将8位、16位或32位的操作数与AL、AX或EAX相乘<table><thead><tr><th>被乘数</th><th>乘数</th><th>积</th><th>CF = 1的条件</th></tr></thead><tbody><tr><td>AL</td><td>r/m8</td><td>AX</td><td>AH $\neq$ 0</td></tr><tr><td>AX</td><td>r/m16</td><td>DX:AX</td><td>DX $\neq$ 0</td></tr><tr><td>EAX</td><td>r/m32</td><td>EDX:EAX</td><td>EDX $\neq$ 0</td></tr></tbody></table></li></ul></li><li><p><strong>IMUL指令</strong>：有符号乘法<br>如果累积的高半部分<strong>不是低半部分的符号扩展（换而言之就是低半部分不足够表示累积）</strong>，则设置CF和OF<br>例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>al</span>, <span style=color:#ae81ff>48</span>      <span style=color:#75715e>; 48D = 30H
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>bl</span>, <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>imul</span> <span style=color:#66d9ef>bl</span>         <span style=color:#75715e>; AX = 00C0h, OF = 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>al</span>, -<span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>bl</span>, <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>imul</span> <span style=color:#66d9ef>bl</span>         <span style=color:#75715e>; AX = FFF0h, OF = 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ax</span>, <span style=color:#ae81ff>48</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>bx</span>, <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>imul</span> <span style=color:#66d9ef>ax</span>         <span style=color:#75715e>; DX:AX = 000000C0h, OF = 1
</span></span></span></code></pre></div></li><li><p><strong>DIV指令</strong>：无符号除法</p><table><thead><tr><th>被除数</th><th>除数</th><th>商</th><th>余数</th></tr></thead><tbody><tr><td>AX</td><td>r/m8</td><td>AL</td><td>AH</td></tr><tr><td>DX:AX</td><td>r/m16</td><td>AX</td><td>DX</td></tr><tr><td>EDX:EAX</td><td>r/m32</td><td>EAX</td><td>EDX</td></tr></tbody></table></li><li><p><strong>有符号整数除法</strong></p><ul><li>CBW, CWD, CDQ指令<ul><li>CBW(Convert Byte to Word): 将AL中的符号位扩展到AH</li><li>CWD(Convert Word to Doubleword): 将AX中的符号位扩展到DX</li><li>CDQ(Convert DoubleWord QuadWord): 将EAX中的符号位扩展到EDX</li></ul></li><li>IDIV指令：有符号数整数的除法运算<br>例：<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>.data</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>byteVal</span> <span style=color:#66d9ef>SBYTE</span> -<span style=color:#ae81ff>48</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>.code</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>al</span>, <span style=color:#66d9ef>byteVal</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>cbw</span>               <span style=color:#75715e>; extend AL into AH
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>bl</span>, <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>idiv</span> <span style=color:#66d9ef>bl</span>           <span style=color:#75715e>; AL = -9, AH = -3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>.data</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>wordVal</span> <span style=color:#66d9ef>SWORD</span> -<span style=color:#ae81ff>5000</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>.code</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ax</span>, <span style=color:#66d9ef>wordVal</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>cwd</span>               <span style=color:#75715e>; extend AX into DX
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>bx</span>, <span style=color:#ae81ff>256</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>idiv</span> <span style=color:#66d9ef>bx</span>           <span style=color:#75715e>; AX = -19, DX = -136
</span></span></span></code></pre></div></li><li>除法溢出<ul><li>当除法产生的商太大而无法容纳在目的操作数中的时候，将导致除法溢出，使CPU触发一个中断，当前程序被终止</li><li>试图除以0也会发生相同的情况</li><li>解决办法<ul><li>使用32位的除数来减小除法溢出的可能性</li><li>测试除数，如果除数等于0则跳过除法指令</li></ul></li></ul></li></ul></li></ul><h4 id=扩展加法和减法>扩展加法和减法<a hidden class=anchor aria-hidden=true href=#扩展加法和减法>#</a></h4><ul><li><strong>ADC指令</strong>：扩展加法<br>目的操作数 + 源操作数 + 进位标志->目的操作数</li><li><strong>SBB指令</strong>：扩展减法<br>目的操作数 + 源操作数 - 进位标志->目的操作数</li></ul><h4 id=ascii和压缩十进制算数>ASCII和压缩十进制算数<a hidden class=anchor aria-hidden=true href=#ascii和压缩十进制算数>#</a></h4><ul><li><strong>AAA</strong>：<strong>加</strong>法之后进行ASCII码调整<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ag</span>, <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>al</span>, <span style=color:#960050;background-color:#1e0010>&#39;</span><span style=color:#ae81ff>8</span><span style=color:#960050;background-color:#1e0010>&#39;</span>       <span style=color:#75715e>; AX = 0038h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>add</span> <span style=color:#66d9ef>al</span>, <span style=color:#960050;background-color:#1e0010>&#39;</span><span style=color:#ae81ff>2</span><span style=color:#960050;background-color:#1e0010>&#39;</span>       <span style=color:#75715e>; AX = 006Ah
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>aaa</span>               <span style=color:#75715e>; AX = 0100h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>or</span> <span style=color:#66d9ef>ax</span>, <span style=color:#ae81ff>3030</span><span style=color:#66d9ef>h</span>      <span style=color:#75715e>; AX = 3130h = &#39;10&#39;
</span></span></span></code></pre></div></li><li><strong>AAS</strong>：<strong>减</strong>法之后进行ASCII码调整</li><li><strong>AAM</strong>：<strong>乘</strong>法之后进行ASCII码调整</li><li><strong>AAD</strong>：<strong>除</strong>法之后进行ASCII码调整</li><li>压缩的十进制整数<ul><li><strong>DAA指令</strong>：将ADD或ADC指令执行后AL中的结果转换成压缩的十进制格式</li><li><strong>DAS指令</strong>：将SUB或SBB指令执行后AL中的结果转换成压缩的十进制格式</li><li>例：<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>al</span>, <span style=color:#ae81ff>35</span><span style=color:#66d9ef>h</span>     
</span></span><span style=display:flex><span><span style=color:#66d9ef>add</span> <span style=color:#66d9ef>al</span>, <span style=color:#ae81ff>48</span><span style=color:#66d9ef>h</span>     <span style=color:#75715e>; AL = 7Dh
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>daa</span>             <span style=color:#75715e>; AL = 83h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>bl</span>, <span style=color:#ae81ff>48</span><span style=color:#66d9ef>h</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>al</span>, <span style=color:#ae81ff>85</span><span style=color:#66d9ef>h</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>sub</span> <span style=color:#66d9ef>al</span>, <span style=color:#66d9ef>bl</span>      <span style=color:#75715e>; AL = 3Dh
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>das</span>             <span style=color:#75715e>; AL = 37h
</span></span></span></code></pre></div></li></ul></li></ul><h3 id=字符串与数组>字符串与数组<a hidden class=anchor aria-hidden=true href=#字符串与数组>#</a></h3><h4 id=基本字符串操作指令>基本字符串操作指令<a hidden class=anchor aria-hidden=true href=#基本字符串操作指令>#</a></h4><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>MOVSB, MOVSW, MOVSD</td><td><strong>移动字符串数据</strong>：拷贝DS:(E)SI寻址的内存操作数至ES:(E)DI</td></tr><tr><td>CMPSB, SMPSW, CMPSD</td><td><strong>比较字符串</strong>：比较内存中由DS:(E)SI寻址和ES:(E)DI寻址的字符串。源-目的</td></tr><tr><td>SCASB, SCASW, SCASD</td><td><strong>扫描字符串</strong>：扫描ES:(E)DI指向的内存字符串查找与累加器匹配的值</td></tr><tr><td>STOSB, STOSW, STOSD</td><td><strong>存储字符串</strong>：将累加器内容存储到由ES:(E)DI寻址的内存中</td></tr><tr><td>LODSB, LODSW, LODSD</td><td><strong>将字符串数据装入累加器</strong>：将由DS:(E)SI寻址的内存单元装入累加器中</td></tr></tbody></table><ul><li><p><strong>使用重复前缀</strong></p><ul><li>字符串操作指令每次只能处理一个内存值。</li><li>通过增加一个重复前缀，字符串指令就会使用ECX作为计数器进行重复 —— 实现用一条指令处理整个数组。</li><li>可以使用的重复前缀<table><thead><tr><th>REP</th><th>ECX > 0时重复</th></tr></thead><tbody><tr><td>REPZ, REPE</td><td>当ZF＝1且ECX＞0时重复</td></tr><tr><td>REPNE, REPNZ</td><td>当ZF＝0且ECX＞0时重复</td></tr></tbody></table></li><li>方向标志：简单字符串指令使用方向标志来决定ESI和EDI是自动增加还是自动减少。<ul><li>方向标志位 DF＝0：ESI、EDI 自动增加；</li><li>方向标志位 DF＝1：ESI、EDI 自动减少。</li></ul></li><li>方向标志可以通过CLD和STD指令改变：<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>CLD</span>	<span style=color:#75715e>; 清除方向标志
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>STD</span>	<span style=color:#75715e>; 设置方向标志
</span></span></span></code></pre></div></li></ul></li><li><p><strong>MOVSB、MOVSW 和 MOVSD 指令</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>.data</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>source</span> <span style=color:#66d9ef>DWORD</span> <span style=color:#ae81ff>20</span> <span style=color:#66d9ef>DUP</span>(<span style=color:#ae81ff>0</span><span style=color:#66d9ef>FFFFFFFFh</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>target</span> <span style=color:#66d9ef>DWORD</span> <span style=color:#ae81ff>20</span> <span style=color:#66d9ef>DUP</span>(<span style=color:#960050;background-color:#1e0010>?</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>.code</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>cld</span>					       <span style=color:#75715e>; direction = forward
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ecx</span>,<span style=color:#66d9ef>LENGTHOF</span> <span style=color:#66d9ef>source</span>	<span style=color:#75715e>; set REP counter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>esi</span>,<span style=color:#66d9ef>OFFSET</span> <span style=color:#66d9ef>source</span>		<span style=color:#75715e>; ESI points to source
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>edi</span>,<span style=color:#66d9ef>OFFSET</span> <span style=color:#66d9ef>target</span>		<span style=color:#75715e>; EDI points to target
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rep</span> <span style=color:#a6e22e>movsd</span>			      	<span style=color:#75715e>; copy doublewords
</span></span></span></code></pre></div></li><li><p><strong>CMPSB、CMPSW 和 CMPSD 指令</strong><br>隐含执行：源-目的，这与 CMP 指令相反</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>mov</span>  <span style=color:#66d9ef>esi</span>,<span style=color:#66d9ef>OFFSET</span> <span style=color:#66d9ef>source</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span>  <span style=color:#66d9ef>edi</span>,<span style=color:#66d9ef>OFFSET</span> <span style=color:#66d9ef>target</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>cld</span>				    <span style=color:#75715e>; direction = up
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>mov</span>  <span style=color:#66d9ef>ecx</span>,<span style=color:#66d9ef>count</span>	<span style=color:#75715e>; repetition counter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rep</span><span style=color:#a6e22e>e</span> <span style=color:#66d9ef>cmpsd</span>		  	<span style=color:#75715e>; repeat while equal
</span></span></span></code></pre></div></li><li><p><strong>SCASB、SCASW 和 SCASD 指令</strong></p><ul><li>将AL/AX/EAX中的值同目标内存(由DI寻址)中的字节、字或双字相比较。</li><li>例:扫描一个匹配字符：在字符串变量alpha中查找字母“F”<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>.data</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>alpha</span> <span style=color:#66d9ef>BYTE</span> <span style=color:#960050;background-color:#1e0010>&#34;</span><span style=color:#66d9ef>ABCDEFGH</span><span style=color:#960050;background-color:#1e0010>&#34;</span>,<span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>.code</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>edi</span>,<span style=color:#66d9ef>OFFSET</span> <span style=color:#66d9ef>alpha</span>	 <span style=color:#75715e>; EDI points to the string
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>al</span>,<span style=color:#960050;background-color:#1e0010>&#39;</span><span style=color:#66d9ef>F</span><span style=color:#960050;background-color:#1e0010>&#39;</span>		 <span style=color:#75715e>; search for the letter F
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ecx</span>,<span style=color:#66d9ef>LENGTHOF</span> <span style=color:#66d9ef>alpha</span> <span style=color:#75715e>; set the search count
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>cld</span>				 <span style=color:#75715e>; direction = up
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>rep</span><span style=color:#a6e22e>ne</span> <span style=color:#66d9ef>scasb</span>		 <span style=color:#75715e>; repeat while not equal
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>jnz</span> <span style=color:#66d9ef>quit</span>			 <span style=color:#75715e>; quit if letter not found
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>dec</span> <span style=color:#66d9ef>edi</span>			 <span style=color:#75715e>; found: back up EDI
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>quit:
</span></span></code></pre></div></li></ul></li><li><p><strong>STOSB、STOSW 和 STOSD 指令</strong></p><ul><li>将AL/AX/EAX的内容存储在EDI指向的内存单元中，同时EDI的值根据方向标志增加或减少。可与REP前缀联合使用。</li><li>例：将string1的每个字节初始化为0FFh。<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>.data</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>count</span> <span style=color:#960050;background-color:#1e0010>=</span> <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>string1</span> <span style=color:#66d9ef>BYTE</span> <span style=color:#66d9ef>count</span> <span style=color:#66d9ef>DUP</span>(<span style=color:#960050;background-color:#1e0010>?</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>.code</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>al</span>,<span style=color:#ae81ff>0</span><span style=color:#66d9ef>FFh</span>		  <span style=color:#75715e>; value to be stored
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>edi</span>,<span style=color:#66d9ef>OFFSET</span> <span style=color:#66d9ef>string1</span>  <span style=color:#75715e>; ES:DI points to target
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ecx</span>,<span style=color:#66d9ef>count</span>		  <span style=color:#75715e>; character count
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>cld</span>				  <span style=color:#75715e>; direction = forward
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>rep</span> <span style=color:#a6e22e>stosb</span>			  <span style=color:#75715e>; fill with contents of AL
</span></span></span></code></pre></div></li></ul></li><li><p><strong>LODSB、LODSW 和 LODSD 指令</strong></p><ul><li>从ESI指向的内存位置向AL/AX/EAX中装入一个值，同时ESI的值根据方向标志增加或减少。</li><li>一般不与REP前缀联合使用。</li></ul></li></ul><h4 id=二维数组>二维数组<a hidden class=anchor aria-hidden=true href=#二维数组>#</a></h4><ul><li><strong>基址变址操作数</strong>：将两个寄存器的值相加(称为基址寄存器、变址寄存器)来产生偏移地址<ul><li>保护模式程序中，可使用任意两个32位通用寄存器</li><li>实地址模式下，16位寄存器允许的组合是：<strong>[bx+si], [bx+di], [bp+si], [bp+di]</strong><br>⚠️应尽量避免使用BP寄存器，除非要访问堆栈操作数</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>.data</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>array</span> <span style=color:#66d9ef>WORD</span> <span style=color:#ae81ff>1000</span><span style=color:#66d9ef>h</span>,<span style=color:#ae81ff>2000</span><span style=color:#66d9ef>h</span>,<span style=color:#ae81ff>3000</span><span style=color:#66d9ef>h</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>.code</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ebx</span>,<span style=color:#66d9ef>OFFSET</span> <span style=color:#66d9ef>array</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>esi</span>,<span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ax</span>,[<span style=color:#66d9ef>ebx</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#66d9ef>esi</span>]	<span style=color:#75715e>; AX = 2000h
</span></span></span></code></pre></div><ul><li>表格的例子<div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/10/26/BKU6nf.png alt></div></li></ul></li><li><strong>相对基址变址操作数</strong>:有效地址偏移＝偏移＋基址寄存器＋变址寄存器<ul><li>几种常见的格式：<ul><li><strong>[base + index + displacement]</strong></li><li><strong>displacement[base + index]</strong></li><li><strong>displacement[base][index]</strong></li></ul></li><li>偏移(Displacement)：变量的名字；常量表达式</li><li>基址、变址：<ul><li>保护模式：任意32位寄存器</li><li>实地址模式：BX、BP；SI、DI</li></ul></li><li>表格的例子：tableB[ebx + esi]</li></ul></li></ul><h3 id=习题-1>习题<a hidden class=anchor aria-hidden=true href=#习题-1>#</a></h3><h4 id=38>3.8<a hidden class=anchor aria-hidden=true href=#38>#</a></h4><p>在DATA为首地址的内存区域中存放100个无符号数，试编写程序找出其中最大的数，并将其放在KVFF中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>stack</span> <span style=color:#66d9ef>segment</span> <span style=color:#66d9ef>stack</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>db</span> <span style=color:#ae81ff>512</span> <span style=color:#66d9ef>dup</span>(<span style=color:#960050;background-color:#1e0010>?</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>stack</span> <span style=color:#66d9ef>ends</span> 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>segment</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>nums</span> <span style=color:#66d9ef>db</span> <span style=color:#ae81ff>170</span>, <span style=color:#ae81ff>248</span>, <span style=color:#ae81ff>69</span>, <span style=color:#ae81ff>67</span>, <span style=color:#ae81ff>81</span>, <span style=color:#ae81ff>104</span>, <span style=color:#ae81ff>76</span>, <span style=color:#ae81ff>178</span>, <span style=color:#ae81ff>226</span>, <span style=color:#ae81ff>201</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>db</span> <span style=color:#ae81ff>234</span>, <span style=color:#ae81ff>230</span>, <span style=color:#ae81ff>194</span>, <span style=color:#ae81ff>85</span>, <span style=color:#ae81ff>206</span>, <span style=color:#ae81ff>92</span>, <span style=color:#ae81ff>63</span>, <span style=color:#ae81ff>28</span>, <span style=color:#ae81ff>211</span>, <span style=color:#ae81ff>237</span>, <span style=color:#ae81ff>195</span>, <span style=color:#ae81ff>240</span>, <span style=color:#ae81ff>225</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>db</span> <span style=color:#ae81ff>126</span>, <span style=color:#ae81ff>117</span>, <span style=color:#ae81ff>173</span>, <span style=color:#ae81ff>162</span>, <span style=color:#ae81ff>78</span>, <span style=color:#ae81ff>179</span>, <span style=color:#ae81ff>252</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>202</span>, <span style=color:#ae81ff>23</span>, <span style=color:#ae81ff>152</span>, <span style=color:#ae81ff>125</span>, <span style=color:#ae81ff>32</span>, <span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>db</span> <span style=color:#ae81ff>86</span>, <span style=color:#ae81ff>165</span>, <span style=color:#ae81ff>27</span>, <span style=color:#ae81ff>190</span>, <span style=color:#ae81ff>137</span>, <span style=color:#ae81ff>37</span>, <span style=color:#ae81ff>172</span>, <span style=color:#ae81ff>13</span>, <span style=color:#ae81ff>228</span>, <span style=color:#ae81ff>112</span>, <span style=color:#ae81ff>146</span>, <span style=color:#ae81ff>75</span>, <span style=color:#ae81ff>225</span>, <span style=color:#ae81ff>65</span> 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>db</span> <span style=color:#ae81ff>92</span>, <span style=color:#ae81ff>150</span>, <span style=color:#ae81ff>38</span>, <span style=color:#ae81ff>77</span>, <span style=color:#ae81ff>43</span>, <span style=color:#ae81ff>233</span>, <span style=color:#ae81ff>94</span>, <span style=color:#ae81ff>88</span>, <span style=color:#ae81ff>118</span>, <span style=color:#ae81ff>60</span>, <span style=color:#ae81ff>127</span>, <span style=color:#ae81ff>214</span>, <span style=color:#ae81ff>69</span>, <span style=color:#ae81ff>44</span>, <span style=color:#ae81ff>25</span> 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>db</span> <span style=color:#ae81ff>134</span>, <span style=color:#ae81ff>137</span>, <span style=color:#ae81ff>154</span>, <span style=color:#ae81ff>209</span>, <span style=color:#ae81ff>167</span>, <span style=color:#ae81ff>32</span>, <span style=color:#ae81ff>174</span>, <span style=color:#ae81ff>13</span>, <span style=color:#ae81ff>178</span>, <span style=color:#ae81ff>65</span>, <span style=color:#ae81ff>74</span>, <span style=color:#ae81ff>35</span>, <span style=color:#ae81ff>234</span>, <span style=color:#ae81ff>95</span> 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>db</span> <span style=color:#ae81ff>70</span>, <span style=color:#ae81ff>179</span>, <span style=color:#ae81ff>98</span>, <span style=color:#ae81ff>140</span>, <span style=color:#ae81ff>185</span>, <span style=color:#ae81ff>159</span>, <span style=color:#ae81ff>14</span>, <span style=color:#ae81ff>114</span>, <span style=color:#ae81ff>105</span>, <span style=color:#ae81ff>239</span>, <span style=color:#ae81ff>137</span>, <span style=color:#ae81ff>147</span>, <span style=color:#ae81ff>227</span>, <span style=color:#ae81ff>238</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>db</span> <span style=color:#ae81ff>228</span>, <span style=color:#ae81ff>198</span>, <span style=color:#ae81ff>135</span>, <span style=color:#ae81ff>220</span>, <span style=color:#ae81ff>203</span>, <span style=color:#ae81ff>255</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>KVFF</span> <span style=color:#66d9ef>db</span> <span style=color:#960050;background-color:#1e0010>?</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>data</span> <span style=color:#66d9ef>ends</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>code</span> <span style=color:#66d9ef>segment</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>assume</span> <span style=color:#66d9ef>CS</span>:<span style=color:#66d9ef>code</span>, <span style=color:#66d9ef>DS</span>:<span style=color:#66d9ef>data</span>, <span style=color:#66d9ef>SS</span>:<span style=color:#66d9ef>stack</span>
</span></span><span style=display:flex><span>start:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ax</span>, <span style=color:#66d9ef>data</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ds</span>, <span style=color:#66d9ef>ax</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>dl</span>, <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>si</span>, <span style=color:#66d9ef>OFFSET</span> <span style=color:#66d9ef>nums</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>cx</span>, <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>comp:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cmp</span> <span style=color:#66d9ef>dl</span>, <span style=color:#66d9ef>BYTE</span> <span style=color:#66d9ef>PTR</span> [<span style=color:#66d9ef>si</span>]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>jb</span>  <span style=color:#66d9ef>exch</span>
</span></span><span style=display:flex><span>L:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>inc</span> <span style=color:#66d9ef>si</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>loop</span> <span style=color:#66d9ef>comp</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>KVFF</span>, <span style=color:#66d9ef>dl</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ah</span>, <span style=color:#ae81ff>4</span><span style=color:#66d9ef>ch</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>int</span> <span style=color:#ae81ff>21</span><span style=color:#66d9ef>h</span>
</span></span><span style=display:flex><span>exch:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>dl</span>, <span style=color:#66d9ef>BYTE</span> <span style=color:#66d9ef>PTR</span> [<span style=color:#66d9ef>si</span>]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>jmp</span> <span style=color:#66d9ef>L</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>code</span> <span style=color:#66d9ef>ends</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>end</span> <span style=color:#66d9ef>start</span>
</span></span></code></pre></div><h4 id=313>3.13<a hidden class=anchor aria-hidden=true href=#313>#</a></h4><p>试编写程序，给从内存40000H到4BFFFH的每个单元均写入55H，并逐个单元读出比较。若写入的与读出的完全一致，则将AL置7EH，否则将AL置81H。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>stack</span> <span style=color:#66d9ef>segment</span> <span style=color:#66d9ef>stack</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>db</span> <span style=color:#ae81ff>512</span> <span style=color:#66d9ef>dup</span>(<span style=color:#960050;background-color:#1e0010>?</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>stack</span> <span style=color:#66d9ef>ends</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>code</span> <span style=color:#66d9ef>segment</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>assume</span> <span style=color:#66d9ef>cs</span>:<span style=color:#66d9ef>code</span>, <span style=color:#66d9ef>ss</span>:<span style=color:#66d9ef>stack</span>
</span></span><span style=display:flex><span>start:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ax</span>, <span style=color:#ae81ff>4000</span><span style=color:#66d9ef>h</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ds</span>, <span style=color:#66d9ef>ax</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>si</span>, <span style=color:#ae81ff>0000</span><span style=color:#66d9ef>h</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>cx</span>, <span style=color:#ae81ff>0</span><span style=color:#66d9ef>BFFFh</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>write:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>BYTE</span> <span style=color:#66d9ef>PTR</span> [<span style=color:#66d9ef>si</span>], <span style=color:#ae81ff>55</span><span style=color:#66d9ef>h</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>inc</span> <span style=color:#66d9ef>si</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>loop</span> <span style=color:#66d9ef>write</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>si</span>, <span style=color:#ae81ff>0000</span><span style=color:#66d9ef>h</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>cx</span>, <span style=color:#ae81ff>0</span><span style=color:#66d9ef>BFFFh</span>
</span></span><span style=display:flex><span>read:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cmp</span> <span style=color:#66d9ef>BYTE</span> <span style=color:#66d9ef>PTR</span> [<span style=color:#66d9ef>si</span>], <span style=color:#ae81ff>55</span><span style=color:#66d9ef>h</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>jnz</span>  <span style=color:#66d9ef>not_equal</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>equal:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>inc</span> <span style=color:#66d9ef>si</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>loop</span> <span style=color:#66d9ef>read</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>al</span>, <span style=color:#ae81ff>7</span><span style=color:#66d9ef>eh</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ax</span>, <span style=color:#ae81ff>4</span><span style=color:#66d9ef>c00h</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>int</span> <span style=color:#ae81ff>21</span><span style=color:#66d9ef>h</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>not_equal:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>al</span>, <span style=color:#ae81ff>81</span><span style=color:#66d9ef>h</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ax</span>, <span style=color:#ae81ff>4</span><span style=color:#66d9ef>c00h</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>int</span> <span style=color:#ae81ff>21</span><span style=color:#66d9ef>h</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>code</span> <span style=color:#66d9ef>ends</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>end</span> <span style=color:#66d9ef>start</span>
</span></span></code></pre></div><h2 id=总线技术>总线技术<a hidden class=anchor aria-hidden=true href=#总线技术>#</a></h2><h3 id=总线概述>总线概述<a hidden class=anchor aria-hidden=true href=#总线概述>#</a></h3><h4 id=总线的分类>总线的分类<a hidden class=anchor aria-hidden=true href=#总线的分类>#</a></h4><ul><li>按连接的层次<ul><li>片内总线</li><li>元件级总线</li><li>系统总线（内总线）</li><li>通信总线（外总线、I/O总线）<div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/11/01/B00gX9.png alt></div></li></ul></li><li>按数据传输位数<ul><li>并行总线</li><li>串行总线</li></ul></li></ul><h3 id=标准化总线>标准化总线<a hidden class=anchor aria-hidden=true href=#标准化总线>#</a></h3><h4 id=内总线>内总线<a hidden class=anchor aria-hidden=true href=#内总线>#</a></h4><ul><li><strong>ISA总线</strong>(Industry Stanrard Architechure)<ul><li>ISA特点<ul><li>支持8位、16位操作</li><li>将将XT与AT总线的运行速度提升至8MHz</li><li>更强调I/O处理能力：64KB的I/O空间、11级硬件中断、7级DMA通道</li><li>地址、数据多路复用</li><li>是多主控设备总线、带处理器的智能卡都可以成为ISA的主控设备</li><li>曾广泛流行，支持的厂商众多</li></ul></li><li>信号定义<ul><li>数据总线为16位（支持8位、16位操作）<ul><li>提速：$ \overline{0WS} $，零等待状态，也叫$ \overline{NOWS} $（No Wait State）</li><li>升位：$ \overline{MEMCS16},\overline{IOCS16} $</li><li>位数可选：$ \overline{SBHE} $</li></ul></li><li>寻址能力达到16MB，地址、数据线不复用</li><li>中断扩充为11个（PC/XT位6个）</li><li>DMA扩充为7个（PC/XT位4个）</li><li>ISA是一种多主控总线：$\overline{MASTER} $</li><li>速度：CLK(B20, Output)<br>4.77MHz->8.33MHz->12MHz</li></ul></li></ul></li><li><strong>PCI总线</strong>(Peripheral Component Interconnect Local Bus)<ul><li>PCI总线的特点<ul><li>不依赖于处理器</li><li>扩充性好、多总线共存</li><li>具有自动配置能力，支持即插即用（PnP）</li><li>数据、地址奇偶校验功能</li><li>数据宽度32位，可扩展为64位；2.0版本支持33MHz时钟，2.1版本增加了对66MHz总线操作的支持</li><li>信号复用，支持无限读写突发操作</li><li>支持多主控设备</li><li>适应性广</li><li>并行总线操作</li></ul></li><li>信号定义<ul><li>PCI总线定义的信号可分为九类<ul><li>系统信号</li><li>数据和地址信号</li><li>接口控制信号</li><li>仲裁信号</li><li>错误报告信号</li><li>中断信号</li><li>高速缓存支持信号</li><li>64位扩展信号</li><li>JTAG信号</li></ul></li><li>PCI总线定义的信号也可分为必备和可选两大类<ul><li>主控设备需要49个必备信号<br>目标设备需要47必备信号</li><li>可选信号线共51个，主要用于<ul><li>64位扩展</li><li>中断请求</li><li>高速缓存支持 等</li></ul></li></ul></li></ul></li></ul></li><li><strong>PCIE总线</strong>（PCI Express）</li></ul><h4 id=外总线通信总线>外总线（通信总线）<a hidden class=anchor aria-hidden=true href=#外总线通信总线>#</a></h4><ul><li><strong>RS-232C串行通信接口</strong><ul><li>特点<ul><li><strong>串行异步</strong>总线</li><li>传输信号线少<ul><li>定义了20多个信号线</li><li>实际应用中一般只用到3至7条</li></ul></li><li>传输距离较远。一般为<strong>15米</strong></li><li>采用不归零编码（NRZ）和负逻辑：逻辑1为-15V至-3V，逻辑0为+3V至+15V</li><li>采用非平衡传输方式，即<strong>单端通信</strong></li><li>传输速率较低</li></ul></li><li>电气特性、引脚功能：25针/9针 D型连接器<ul><li>信号<ul><li>传送信息信号<br>TxD：发送数据线 (DTE->DCE)<br>RxD：接收数据线 (DTE&lt;-DCE)</li><li>联络信号<br>RTS：请求发送 (DTE->DCE)<br>CTS：清楚发送 (DTE&lt;-DCE)<br>DTR：DTE准备就绪 (DTE->DCE)<br>DSR：SCE准备就绪 (DTE&lt;-DCE)<br>DCD：数据载波检测 (DTE&lt;-DCE)<br>RI：振铃指示 (DTE&lt;-DCE)</li></ul></li><li>电平<table><thead><tr><th></th><th>数据信号</th><th>控制信号</th></tr></thead><tbody><tr><td>逻辑1</td><td>-3~-15V（传号）</td><td>+3~+15V（接通，ON状态）</td></tr><tr><td>逻辑0</td><td>+3~+15V（空号）</td><td>-3~-15V（断开，OFF状态）</td></tr><tr><td></td><td>（一般为12V）</td><td></td></tr></tbody></table></li><li>例：信息格式<br>传送ASCII码“C”（43H）<div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/11/02/Br1M4J.png alt></div></li></ul></li><li>RS-232的应用<ul><li>使用Modem连接</li><li>软硬件系统调试：控制台、超级终端</li><li>直接连接：计算机（DTE）&lt;-> 计算机（DTE）<ul><li>交叉连接方式</li><li>三线经济方式</li></ul></li></ul></li><li>RS423、RS422、RS485：<ul><li>RS423：单端输出、差分接收（非平衡传输）<ul><li>1200米 1Kbps</li><li>90米 100Kbps</li></ul></li><li>RS422、RS485：差分输出、差分接收（平衡差分传输）<ul><li>1200米 100Kbps</li><li>100米 1Mbps</li><li>12米 10Mbps</li></ul></li></ul></li></ul></li><li><strong>USB总线</strong>（Universal Serial Bus）<ul><li>USB总线各版本参数比较<div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/11/02/BrdoY6.png alt></div><ul><li>翻转不归零（NRZ-I）编码<ul><li>当数据为0时，电平翻转；数据为1时，电平不翻转</li><li>比特填充技术：当数据中出现连续6个'1&rsquo;时就必须插入1个'0&rsquo;</li><li>发送数据：并行数据->串行数据，比特填充，NRZI编码</li><li>接收数据：NRZI解码，去除填充比特，转换成并行数据</li></ul></li><li>8b/10b编码<ul><li>传送的信息以每8比特为一组被编码为一个10比特的数据；接收端将10比特数据解码还原为8比特数据</li><li>目的：使得整个比特流中尽量保持了0和1的平衡</li><li>SATA、PCI-Express也使用了8b/10b编码</li><li>USB3.2使用128b/132b编码</li></ul></li></ul></li><li>对USB的需求<ul><li>当时PC机I/O模式的缺点<ul><li>PC外设日益丰富，接口、扩展槽有限；种类日益繁多的接口电缆线</li><li>I/O资源分配(I/O空间、IRQ、DMA)->接口卡一多，上述资源可能耗尽</li><li>热插拔、PnP的需求</li></ul></li><li>USB2.0的特点/优点<ul><li>单一接口类型</li><li>每个USB总线支持127个外设</li><li>整个USB系统只用一个端口、一个中断->节省系统资源</li><li>支持热插拔、动态加载驱动程序；带电拔出后自动回收资源；PnP，自动配置</li><li>三种速率，适应不同类型外设</li><li>设备供电</li><li>四种传输类型<ul><li>控制传输</li><li>同步传输</li><li>中断传输</li><li>批量传输</li></ul></li></ul></li></ul></li><li>USB3.0</li></ul></li><li><strong>ATA总线</strong><ul><li>PATA</li><li>SATA</li></ul></li></ul><h3 id=总线的驱动和控制>总线的驱动和控制<a hidden class=anchor aria-hidden=true href=#总线的驱动和控制>#</a></h3><h4 id=总线竞争与负载>总线竞争与负载<a hidden class=anchor aria-hidden=true href=#总线竞争与负载>#</a></h4><ul><li><strong>总线竞争</strong>：同一总线上，同一时刻，有两个或两个以上的器件输出其状态<ul><li>TTL：此时总线上会是一种不高不低的非TTL电平，严重时会烧坏器件<div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/11/10/BbHwOf.png alt></div></li><li>对集电极开路输出：线与逻辑（Open Collector）<div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/11/10/BbHBm8.png alt></div></li><li>用三态电路严格，控制逻辑<div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/11/10/BbHd6P.png alt></div></li></ul></li><li><strong>总线的负载</strong><ul><li>直流负载<ul><li>输出高电平时，驱动门的$ I_{OH} \ge \sum_{i=1}^{N}{IH_i} $</li><li>输出高电平时，驱动门的$ I_{OL} \ge \sum_{i=1}^{N}{IL_i} $</li></ul></li><li>交流负载：$ C_P \ge (\sum_{i=1}^{N}{C_{Ii}+$电路板布线引入的电容$+$传输线引入的电容}) $<div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/11/10/BbOi9J.png alt></div></li></ul></li></ul><h4 id=总线驱动设计>总线驱动设计<a hidden class=anchor aria-hidden=true href=#总线驱动设计>#</a></h4><ul><li><p>几种常用的芯片</p><ul><li>单向驱动器（三态输出）<div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/11/10/BbXoWQ.png alt></div></li><li>双向驱动器（三态输出）<div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/11/10/BbXTzj.png alt></div></li><li>锁存器（三态输出）<div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/11/10/BbXIJg.png alt></div></li></ul></li><li><p>系统总线的驱动与控制</p></li><li><p>扩展插件板（卡）的板内驱动</p></li><li><p><strong>例题</strong></p><ul><li>某内存板，板内地址为A0000H～FFFFFH，试画出板内双向数据总线驱动与控制电路。<ul><li>防止总线竞争原则：只有当CPU读本电路板内的内存地址时，才允许双向驱动器指向系统总线的三态门是导通的。</li><li>对板内内存地址进行分析，找出地址特征。A0000H～FFFFFH<div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/11/10/BbzM6J.jpg alt></div></li><li>设计译码电路，用来控制双向数据总线驱动器，使之满足防止总线竞争原则。<div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/11/10/Bqp3i6.jpg alt></div></li></ul></li><li>某微型机电路板上有内存C0000H～EFFFFH和接口A000H～BFFFH，试画出该电路板板内双向数据总线驱动与控制电路。（P128，例4.3）<ul><li>防止总线竞争原则：只有当CPU读板内内存或读板内接口时，才允许双向数据驱动器指向系统总线的三态门是导通的。</li><li>地址分析（内存地址、接口地址）<div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/11/10/Bq9DB9.jpg alt></div></li><li>画驱动与控制电路<div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/11/10/BqCF3T.jpg alt></div><ul><li>几种可供选择的译码方式<ul><li>基本门电路</li><li>译码器，如74LS138</li><li>译码PROM</li><li>CPLD、FPGA</li></ul></li></ul></li></ul></li><li>采用8086 CPU的微机系统，其主存地址范围为C0000H～C7FFFH，由4块大小为8k8b的芯片构成主存板，试画出板内双向数据总线驱动控制电路及单向信号驱动电路。<ul><li>主存地址分析<div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/11/10/BqEuUH.jpg alt></div></li><li>双向数据总线驱动控制电路及单向信号驱动电路<div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/11/10/BqkuLD.jpg alt></div></li></ul></li></ul></li></ul><h3 id=总线设计中的工程问题>总线设计中的工程问题<a hidden class=anchor aria-hidden=true href=#总线设计中的工程问题>#</a></h3><h4 id=总线交叉串扰>总线交叉串扰<a hidden class=anchor aria-hidden=true href=#总线交叉串扰>#</a></h4><ul><li>减少总线长度</li><li>增加总线间的距离</li><li>降低总线上的负载</li><li>降低总线信号的工作频率</li><li>两条信号线之间加一条地线</li><li>减少总线的平行走向</li><li>圆滑脉冲信号的边缘</li><li>采用双绞线</li></ul><h4 id=总线的延时>总线的延时<a hidden class=anchor aria-hidden=true href=#总线的延时>#</a></h4><ul><li>尽量减少总线长度</li><li>采用延时小、输出输出电容小、驱动能力强的元器件</li><li>需要同步的信号线，布线时候应匹配长度</li></ul><h4 id=总线信号的反射>总线信号的反射<a hidden class=anchor aria-hidden=true href=#总线信号的反射>#</a></h4><ul><li>在满足系统功能的前提下，降低传输信号的频率</li><li>尽量使信号源内阻、总线特性阻抗、负载阻抗三者相匹配</li><li>限制总线长度</li></ul><h3 id=pc中的总线>PC中的总线<a hidden class=anchor aria-hidden=true href=#pc中的总线>#</a></h3><h4 id=8086微处理器16位微机isa总线>8086微处理器16位微机：ISA总线<a hidden class=anchor aria-hidden=true href=#8086微处理器16位微机isa总线>#</a></h4><ul><li>总线信号依据8086处理器信号定义</li><li>8086处理器与ISA总线可以实现直接对接</li><li>利用ISA总线可以直接读写主存或I/O接口</li></ul><h4 id=80386微处理器32位微机与cpu无关的pci总线>80386微处理器32位微机：与CPU无关的PCI总线<a hidden class=anchor aria-hidden=true href=#80386微处理器32位微机与cpu无关的pci总线>#</a></h4><ul><li>PCI总线具有较快的数据传输速率</li><li>PCI总线支持即插即用和热插拔</li><li>基于PCI总线的微机系统还支持多总线结构，进而使系统具有一定的并行操作能力</li></ul><h2 id=存储技术>存储技术<a hidden class=anchor aria-hidden=true href=#存储技术>#</a></h2><h3 id=概述>概述<a hidden class=anchor aria-hidden=true href=#概述>#</a></h3><h4 id=存储器的分类>存储器的分类<a hidden class=anchor aria-hidden=true href=#存储器的分类>#</a></h4><p><div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/11/11/BvPyrV.jpg alt></div></p><h4 id=主要性能指标>主要性能指标<a hidden class=anchor aria-hidden=true href=#主要性能指标>#</a></h4><ul><li>容量</li><li>速度：存取时间</li><li>成本：价格</li></ul><h3 id=常用存储器芯片及连接使用>常用存储器芯片及连接使用<a hidden class=anchor aria-hidden=true href=#常用存储器芯片及连接使用>#</a></h3><h4 id=静态随机读写存储器sram及接口设计>静态随机读/写存储器（SRAM）及接口设计<a hidden class=anchor aria-hidden=true href=#静态随机读写存储器sram及接口设计>#</a></h4><ul><li><p>静态随机读写存储器（Static Random Access Memory</p></li><li><p>分类</p><ul><li>同步型</li><li>异步型</li></ul></li><li><p><strong>异步SRAM</strong></p><ul><li><strong>典型芯片</strong>：6264（8K $\times $ 8bit）<ul><li>引线<div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/11/11/BvAofe.jpg alt></div></li><li>工作过程、时序<ul><li>写入时序<div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/11/11/BvEWcj.jpg alt></div></li><li>读出时序<div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/11/11/BvEfjs.jpg alt></div></li></ul></li></ul></li><li><strong>连接使用</strong><ul><li>全地址译码与部分地址译码<ul><li>SRAM 6264全地址译码连接<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/11/BvV6q1.jpg alt></div></li><li>SRAM 6264部分地址译码连接<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/11/BvVyrR.jpg alt></div></li></ul></li><li>译码电路的选择<ul><li>利用译码芯片<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/11/BveU9U.jpg alt></div><div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/11/Bvea3F.jpg alt></div></li><li>使用ROM作译码器<br>现在要用4片6264构成一个存储容量为32KB的存储器，其地址空间为E0000H～E7FFFH。用一块512×4的PROM芯片63S241作为ROM译码器<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/11/BvljJI.gif alt></div></li><li>利用数字比较器作译码器<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/11/Bv10TH.jpg alt></div></li><li>利用PLD做译码器</li></ul></li></ul></li><li>存取时间<ul><li>控制信号的连接：8088/8086 最小模式、最大模式$ M/\overline{IO},\overline{RD},\overline{WR} => \overline{MEMR},\overline{MEMW} $</li><li>例：已知8088微处理器时钟为4.77MHz，地址延时时间$t_{da}＝110ns$，存储系统各种附加的延时时$t_D$＝200ns。问：用存取周期为250ns的存储芯片能否满足系统要求？<br>$$
\begin{align}
t(R,W)+t_{da}+t_D &{\le} 3T \cr
t(R,W) &{\le} 3T－ t_{da}－ t_{D} \cr
3×210－200－110 &＝ 320ns \cr
\end{align}
$$
为存储器提供的存取时间<br>存储器要求的存取时间为250ns → 能满足系统要求</li></ul></li></ul></li></ul><h4 id=只读存储器rom及接口设计>只读存储器（ROM）及接口设计<a hidden class=anchor aria-hidden=true href=#只读存储器rom及接口设计>#</a></h4><ul><li><p><strong>EPROM</strong>（紫外线可擦除只读存储器）：2764芯片（8K$\times 8bit）</p><ul><li>引线<ul><li>A12~A0</li><li>D7~D0</li><li>$\overline{CE}$：片选</li><li>$\overline{OE}$：数据输出允许</li><li>$\overline{PGM}$：编程时：编程脉冲输入；读时：“1”</li></ul></li><li>连接：若利用全地址译码将EPROM 2764接在首地址为A0000H的内存区，试画连接图<div class=render-image><img loading=lazy src=https://i.postimg.cc/434VS3rF/1.jpg alt></div></li><li>编程<ul><li>擦除：紫外线 15～20min → 每单元内容均为FFH</li><li>EPROM编程<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/11/BvwFJS.jpg alt></div><div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/11/Bvwii8.jpg alt></div><div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/11/BvwCIf.jpg alt></div></li></ul></li></ul></li><li><p><strong>EEPROM</strong></p><ul><li>典型EERROM芯片介绍：98C64A<ul><li>优点：可单字节随机读写（不需擦除，直接读写）</li><li>缺点：存储密度高，单位成本高</li></ul></li><li>连接使用：将55H写满98C64A<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/16/Dkq6XR.jpg alt></div><div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/16/DkO9PO.jpg alt></div></li></ul></li><li><p><strong>闪存EEPROM：FLASH</strong></p><ul><li>NOR型<ul><li>独立数据、地址总线，可以随机<strong>快速读取</strong></li><li><strong>读操作速度快，擦除、编程速度慢</strong></li></ul></li><li>NAND型<ul><li>以<strong>页</strong>(256或512B)为单位读/编程</li><li>以<strong>块</strong>(4K、8K、16K)为单位擦除（最多4ms）</li><li>串行读取快、<strong>随机读取慢</strong></li></ul></li></ul></li></ul><h4 id=其他存储器>其他存储器<a hidden class=anchor aria-hidden=true href=#其他存储器>#</a></h4><ul><li>双端口存储器</li><li>先进先出（FIFO）存储器</li><li>铁电存储器（FRAM）</li></ul><h3 id=intel-1632位微机系统的主存设计sram部分>Intel 16/32位微机系统的主存设计（SRAM部分）<a hidden class=anchor aria-hidden=true href=#intel-1632位微机系统的主存设计sram部分>#</a></h3><h4 id=80868088处理器的内存接口>8086、8088处理器的内存接口<a hidden class=anchor aria-hidden=true href=#80868088处理器的内存接口>#</a></h4><ul><li><p>存储器SRAM 6116（$ 2K\times 8bit）$ 与8088的8位总线连接</p></li><li><p>SRAM 6116与8086的16位总线连接</p><ul><li>$ \overline{A0}$选偶地址</li><li>$ \overline{BHE} $选奇地址</li></ul></li><li><p>存储器的字扩充<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/11/BvYiPH.jpg alt></div></p></li><li><p>存储器的位扩充<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/11/BvYnZ8.jpg alt></div></p><ul><li>6264与8086系统总线的连接<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/11/BvYfFe.jpg alt></div></li></ul></li></ul><h4 id=8038680486的内存接口>80386、80486的内存接口<a hidden class=anchor aria-hidden=true href=#8038680486的内存接口>#</a></h4><ul><li>与内存接口相关的信号<ul><li>地址信号<strong>A2～A31</strong>共30个地址信号，其编码可寻址1G个32位的存储单元。这里没有A0和A1，这两个信号已在80386、80486内部译码，用于产生4个体选择信号。</li><li>体选择信号$ \overline{BE0}～\overline{BE3} $</li><li>32位的数据信号<strong>D0～D31</strong>分为4个字节，分别是D0～D7、D8～D15、D16～D23 和 D24～D31。</li><li>控制信号$ M/\overline{IO} $</li><li>$D/\overline{C}$（数据/控制）信号，低电平为<strong>处理器中止或正在响应中断</strong>，高电平表示正在<strong>传送数据</strong>；</li><li>$W/\overline{R}$（读/写）信号，低电平表示读内存或接口，高电平表示写内存或接口<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/11/BvNJET.jpg alt></div></li></ul></li></ul><h4 id=pentium处理器的内存组织>Pentium处理器的内存组织<a hidden class=anchor aria-hidden=true href=#pentium处理器的内存组织>#</a></h4><h3 id=动态随机读写存储器dram及接口设计>动态随机读/写存储器（DRAM）及接口设计<a hidden class=anchor aria-hidden=true href=#动态随机读写存储器dram及接口设计>#</a></h3><h4 id=简单异步dram>简单异步DRAM<a hidden class=anchor aria-hidden=true href=#简单异步dram>#</a></h4><ul><li>引线<ul><li>地址线复用：先输入行地址，再输入列地址</li><li>$\overline{WE}$写允许</li><li>$D_{IN}、D_{OUT} $</li></ul></li><li>工作方式及时序<ul><li>读操作<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/16/DATxuq.jpg alt></div></li><li>写操作<ul><li>提前写<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/16/DA718H.jpg alt></div></li><li>读变写<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/16/DAX0iV.jpg alt></div></li></ul></li></ul></li><li>刷新：2-4ms刷新一次</li><li>连接使用/接口设计<ul><li>行列信号的形成<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/16/DAjcp8.jpg alt></div></li><li>读写</li><li>刷新<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/16/DAvEBd.jpg alt></div></li></ul></li></ul><h4 id=同步动态存储器sdram>同步动态存储器SDRAM<a hidden class=anchor aria-hidden=true href=#同步动态存储器sdram>#</a></h4><ul><li><p>概述</p><ul><li>SDR SDRAM（Single Data Rate Synchronous Dynamic RAM）：单倍速率同步动态随机存储器<ul><li>只在时钟的上升沿传输命令、地址和数据</li></ul></li><li>DDR(Double Date Rate)<ul><li>时钟上升沿、下降沿各传送一次数据</li><li>从DDR2开始，接口的频率开始高于存储单元的核心频率<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/20/DM4yZ9.jpg alt></div></li></ul></li><li>SDRAM和标准DRAM的主要不同<ul><li>同步和异步</li><li>内部组织结构<ul><li>SDRAM内部分体</li><li>标准的DRAM可以看成内部只有一个体的SDRAM</li></ul></li><li>读写方式不同<ul><li>SDRAM具有突发读写能力<ul><li>突发(Burst)是指在同一行中相邻的存储单元连续进行数据传输的方式。</li><li>连续传输所涉及到的存储单元(列)的数量就是突发长度(Burst Lengths，BL)</li></ul></li></ul></li><li>智能化<ul><li>在SDRAM芯片内部设置有<strong>模式寄存器</strong></li><li>一般的标准DRAM只有一种工作模式</li></ul></li></ul></li></ul></li><li><p>典型的SDRAM芯片(三星K4S511632D(32M×16 bit SDRAM))</p><ul><li>引线<ul><li>地址输入<ul><li>行地址：RA0~RA12</li><li>列地址：CA0~CA9</li></ul></li><li>bank地址输入</li><li>数据输入/输出</li><li>输出允许</li></ul></li><li>常用指标<ul><li>容量：存储单元×体×每单元存储位数</li><li>时钟周期</li><li>存取时间</li><li>CAS的延迟时间（Cas latency）</li><li>综合性能的评价：总延迟时间=系统时钟周期×CL模式数+存取时间</li></ul></li><li>时序<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/22/D87VQs.jpg alt></div></li></ul></li><li><p>SDRAM控制器</p><ul><li>实现方式<ul><li>以<strong>南北桥芯片组</strong>为主要核心的PC机系统</li><li>某些为微处理器中<strong>集成</strong>了SDRAM控制器</li><li><strong>设计</strong>与CPU或系统总线连接的独立SDRAM控制器，SDRAM芯片连接在SDRAM控制器上</li></ul></li><li>SDRAM的基本操作<ul><li>对SDRAM的访问的三种情况<ul><li>当前访问的行所在的存储体中，<strong>行缓冲器</strong>是关闭的<ul><li>发送<strong>激活</strong>命令</li><li>发送<strong>读写</strong>命令和<strong>列地址</strong></li><li>读写延迟中等</li></ul></li><li>当前访问的行的数据，刚好保存在相应存储体的<strong>行缓冲器</strong>中<ul><li>直接发送<strong>读/写命令</strong>和<strong>列地址</strong></li><li>读写延迟最小</li></ul></li><li>当前访问的行所在的存储体中，<strong>行缓冲器打开</strong>，<strong>存的是另一个行的数据</strong><ul><li>先发送<strong>Percharge</strong>或<strong>Precharge All</strong>命令关闭行缓冲器</li><li>再发送<strong>激活</strong>命令激活该行</li><li>最后发送<strong>读/写</strong>和<strong>列地址</strong></li><li><strong>读/写</strong>延迟最大</li></ul></li></ul></li></ul></li><li>SDRAM控制器的基本组成<ul><li>连续内存地址映射<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/22/DGNatg.jpg alt></div></li><li>交错内存地址映射：将连续的逻辑地址映射到不同的存储体中<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/22/DGNWh4.jpg alt></div></li></ul></li><li>SDRAM的控制优化<ul><li>行关闭优先策略（Close-Page Policy）：行激活、列读/写、预充电</li><li>行打开优先策略（Open-Page Policy）<ul><li>访问请求<strong>空间局部性很好</strong>，大大<strong>减少读写延迟</strong></li><li>访问请求<strong>空间分布很分散</strong>，造成<strong>较大读写延迟</strong></li></ul></li></ul></li></ul></li></ul><h4 id=ddr-sdram>DDR SDRAM<a hidden class=anchor aria-hidden=true href=#ddr-sdram>#</a></h4><ul><li>DDR SDRAM与SDRAM的不同<ul><li>初始化</li><li>时钟</li><li>数据选取脉冲</li><li>写入延时</li><li><strong>突发长度和写入掩码</strong><ul><li>DDR SDRAM，突发长度只有2、4、8，没有SDRAM的<strong>随机存取的操作</strong>和<strong>全页触发方式</strong>；同时，突发长度的定义不再指所连续寻址的存储单元数量，而是指<strong>连续的传输周期数</strong></li><li>对于突发写入，如果其中有不想存取的数据，仍可以使用<strong>DM信号进行屏蔽</strong></li></ul></li><li>延迟锁定回路</li></ul></li></ul><h3 id=习题-2>习题<a hidden class=anchor aria-hidden=true href=#习题-2>#</a></h3><h4 id=55>5.5<a hidden class=anchor aria-hidden=true href=#55>#</a></h4><p>已有两片6116，现在欲将它们连接到8088系统中去，其地址范围为40000H~40FFFH，试画连接电路图，写入某数据并读出与之比较；如有错，则在DL中写入01H；若每个单元均对，则在DL中写入EEH，试编写此检测程序。</p><p><div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/18/DnMO7F.png alt></div><div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/18/DnQy4J.png alt></div><div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/18/DnMvtJ.png alt></div><div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/18/DnMxh9.png alt></div></p><h4 id=510>5.10<a hidden class=anchor aria-hidden=true href=#510>#</a></h4><p>将4片6264连接到8086系统总线上，要求内存地址范围为7000H~77FFFH，画出连接图。</p><p><div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/18/DnMjk4.png alt></div><div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/18/DnQSpR.png alt></div></p><h4 id=516>5.16<a hidden class=anchor aria-hidden=true href=#516>#</a></h4><p>现有容量为32K×4bit的SRAM芯片。<br>在8086系统中，利用这样的芯片构成从88000H～97FFFH的内存，画出最大模式下包括总线驱动在内的此芯片与系统总线的连接图（译码器件自行选择）</p><p><div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/18/DnIgJK.png alt></div><div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/18/DnIyIx.png alt></div><div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/18/DnIci6.png alt></div></p><h2 id=输入输出技术>输入输出技术<a hidden class=anchor aria-hidden=true href=#输入输出技术>#</a></h2><h3 id=io概述>I/O概述<a hidden class=anchor aria-hidden=true href=#io概述>#</a></h3><h4 id=基本输入输出方法>基本输入/输出方法<a hidden class=anchor aria-hidden=true href=#基本输入输出方法>#</a></h4><ul><li><strong>程序控制</strong>I/O方式<ul><li><strong>无条件</strong>传送方式：输入接口、输出接口</li><li><strong>查询</strong>方式：单外设、多外设</li><li><strong>中断</strong>防守</li></ul></li><li><strong>DMA</strong>（直接存储器）方式</li></ul><h4 id=io接口概述>I/O接口概述<a hidden class=anchor aria-hidden=true href=#io接口概述>#</a></h4><ul><li>I/O接口能做什么<ul><li>提供信息通道</li><li>进行数据格式转换</li><li>CPU和外设速度匹配</li><li>负载匹配</li><li>时序匹配</li><li>总线隔离</li><li>提供中断、DMA能力</li></ul></li><li>外设接口与端口<ul><li>统一编址的优点<ul><li>CPUduiI/O端口的读写操作可是使用全部<strong>存储器</strong>的读/写数据操作指令</li><li>内存与外设地址的分配可以用统一的分配图</li><li>不需要专门的<strong>输入、输出</strong>操作<strong>指令</strong></li></ul></li><li>统一编址的缺点<ul><li>使得系统中<strong>实际</strong>可以<strong>直接寻址的内存单元数减少</strong></li><li>给<strong>检修、维护</strong>增加了难度</li><li>一般系统中I/O端口数远小于内存单元数，所以统一编址使得<strong>指令代码较长</strong>，<strong>读/写执行时间也较长</strong></li><li>Motorola的M68系列采用<strong>统一编址</strong>，Intel的86x86系列CPU采用<strong>独立编址</strong>方式</li></ul></li></ul></li></ul><h4 id=io端口地址译码>I/O端口地址译码<a hidden class=anchor aria-hidden=true href=#io端口地址译码>#</a></h4><p><div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/23/DYDNqJ.jpg alt></div></p><h4 id=基本的并行输入三态门输出锁存器接口>基本的并行输入（三态门）/输出（锁存器）接口<a hidden class=anchor aria-hidden=true href=#基本的并行输入三态门输出锁存器接口>#</a></h4><ul><li>并行输入接口<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/23/DYrKyD.jpg alt></div></li><li>并行输出接口<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/23/DYsd9x.jpg alt></div></li></ul><h3 id=程序查询io方式>程序查询I/O方式<a hidden class=anchor aria-hidden=true href=#程序查询io方式>#</a></h3><h4 id=无条件传送方式>无条件传送方式<a hidden class=anchor aria-hidden=true href=#无条件传送方式>#</a></h4><h4 id=查询方式>查询方式<a hidden class=anchor aria-hidden=true href=#查询方式>#</a></h4><p><div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/23/DYyBin.jpg alt></div></p><p><div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/23/DYfU1A.jpg alt></div><div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/23/DYfa6I.jpg alt></div><div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/23/DYfdXt.jpg alt></div></p><ul><li>多外设的查询控制<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/23/DYhZHf.jpg alt></div><div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/23/DYhVDP.jpg alt></div></li></ul><h3 id=中断方式>中断方式<a hidden class=anchor aria-hidden=true href=#中断方式>#</a></h3><h4 id=80868088中断系统>8086/8088中断系统<a hidden class=anchor aria-hidden=true href=#80868088中断系统>#</a></h4><ul><li>中断源类型<ul><li>与中断有关的控制线：$ NMI、INTR、\overline{INTA} $</li><li>8088系统中的中断源<ul><li>内部中断<ul><li><strong>除法溢出</strong>：类型号为<strong>0</strong></li><li><strong>单步中断</strong>：类型号为<strong>1</strong></li><li><strong>断点中断</strong>：类型号为<strong>3</strong></li><li><strong>溢出中断</strong>：类型号为<strong>4</strong></li><li><strong>软件中断</strong>：即INT n指令</li></ul></li><li>外部中断<ul><li>非屏蔽中断<strong>NMI</strong>：类型号为<strong>2</strong>，不可用软件屏蔽，CPU必须响应它</li><li>可屏蔽中断<strong>INTR</strong>：类型号由<em>PIC</em>提供。IF=1时CPU才能响应它</li></ul></li></ul></li></ul></li><li>中断向量表（IVT）<ul><li>用于存放各类中断服务程序的入口地址（段和偏移）</li><li>表的地址位于内存的00000H~003FFH，大小为1KB，共256个入口</li><li>每个入口占4 Bytes</li><li>中断向量在IVT中的存放地址 = 4 * 中断类型号</li></ul></li></ul><h4 id=可编程中断控制器8259>可编程中断控制器8259<a hidden class=anchor aria-hidden=true href=#可编程中断控制器8259>#</a></h4><ul><li><p>8259内部结构<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/25/DdpJoV.jpg alt></div></p><ul><li>中断请求寄存器IRR</li><li>中断服务寄存器ISR</li><li>中断屏蔽寄存器IMR</li><li>中断优先权判别电路</li></ul></li><li><p>引脚功能<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/25/DdCoPf.jpg alt></div></p></li><li><p>8259工作方式</p><ul><li>中断结束方式<ul><li>非自动：在中断程序中提供EOI命令</li><li>自动：无需EOI命令、第2个$\overline{INTA}$后沿</li></ul></li><li>缓冲方式：缓冲、非缓冲</li><li>嵌套方式<ul><li>一般嵌套：单片使用；级联方式从属</li><li>特殊嵌套：级联方式主控制器</li></ul></li><li>屏蔽方式：一般屏蔽、特殊屏蔽</li><li>优先级规定：固定优先级、循环优先级<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/25/DdFhZ9.jpg alt></div></li></ul></li><li><p>8259级联<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/25/DdEdqe.jpg alt></div></p></li><li><p>8259编程使用</p><ul><li>内部寄存器的寻址方法<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/25/DdVbtA.jpg alt></div></li><li>初始化命令字ICW<ul><li>注意<ul><li>写ICW1意味着重新初始化8259</li><li>写ICW1后，8259的状态如下<ul><li>清除ISR和IMR（全0）</li><li>将中断<strong>优先级</strong>设置为初始状态</li><li>设置为<strong>一般屏蔽</strong>方式</li><li>采用<strong>非自动中断结束</strong>方式</li><li>状态读出逻辑预置为读IRR</li></ul></li></ul></li><li>ICW1：初始化字<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/25/DdeDIJ.jpg alt></div></li><li>ICW2：中断向量码<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/25/DdmVwF.jpg alt></div></li><li>ICW3：级联控制字<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/25/Ddmflq.jpg alt></div></li><li>ICW4：中断结束方式字<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/25/DduMqK.jpg alt></div></li></ul></li><li>操作命令字OCW<ul><li>OCW1：中断屏蔽字<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/25/DdQ0Z6.jpg alt></div></li><li>OCW2：中断结束和优先级循环<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/25/DdlQld.jpg alt></div></li><li>OCW3：屏蔽方式和读出控制字<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/25/Dd1w4O.jpg alt></div></li></ul></li></ul></li></ul><h4 id=中断方式及实现方法>中断方式及实现方法<a hidden class=anchor aria-hidden=true href=#中断方式及实现方法>#</a></h4><ul><li>连接8259<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/25/Dd1bbq.jpg alt></div></li><li>编写中断初始化程序<ul><li>初始化8259<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/25/Dd8Vwq.jpg alt></div><div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/25/Dd8Emn.jpg alt></div><div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/25/Dd8kOs.jpg alt></div></li><li>设置中断向量表<div class=render-image><img loading=lazy src=https://i.postimg.cc/MKC6z9jn/1.jpg alt></div></li><li>中断服务程序框架<div class=render-image><img loading=lazy src=https://i.postimg.cc/MZhHG6CZ/1.jpg alt></div></li></ul></li></ul><h3 id=直接存取器dma方式>直接存取器（DMA）方式<a hidden class=anchor aria-hidden=true href=#直接存取器dma方式>#</a></h3><h4 id=dma工作过程>DMA工作过程<a hidden class=anchor aria-hidden=true href=#dma工作过程>#</a></h4><ul><li>通过特殊硬件<strong>DMA控制器</strong>实现，传输速率高</li><li>外设<strong>直接</strong>与存储器进行数据交换，CPU不再作为中介者</li><li>总线由DMA控制器（DMAC）进行控制，CPU放弃总线控制权，内存/外设的<strong>地址</strong>和<strong>读写控制信号</strong>均由DMAC提供</li></ul><p><div class=render-image><img loading=lazy src=https://i.postimg.cc/dttHLFrX/1.jpg alt></div></p><h3 id=习题-3>习题<a hidden class=anchor aria-hidden=true href=#习题-3>#</a></h3><h4 id=66>6.6<a hidden class=anchor aria-hidden=true href=#66>#</a></h4><p>叙述8086/88软件中断指令INT n的执行过程</p><ul><li>CPU<strong>取INT n指令</strong>，经指令译码获知这是一条中断指令，且该软件中断的中断向量码为n</li><li>将<strong>PSW、CS、IP</strong>压入<strong>堆栈</strong>保护起来，并<strong>关中断</strong></li><li>$ n \times 4 $ 得到中断向量表地址，从该地址开始的顺序两个字节的内容送IP，下两个字节的内容送CS，即$n \times 4\to IP,(n\times4+2)\to CS $</li><li>开始执行<strong>中断服务</strong>程序。（中断服务程序的入口地址早已填入中断向量表中）</li><li>中断服务程序的最后一条指令IRET，从堆栈恢复IP、CS、PSW，<strong>中断返回</strong></li></ul><h4 id=68>6.8<a hidden class=anchor aria-hidden=true href=#68>#</a></h4><p>输入接口地址为04E5H，输出接口地址为E504H。
编程序：
若输入接口的bit3、bit4和bit7同时为1，将以DATA为首地址的10个内存数据连续由输出接口输出，若不满足条件则等待</p><p><div class=render-image><img loading=lazy src=https://i.postimg.cc/xCzqpjjx/Fia-VVso5-Pa9-EP-Ano3fe0-AOcni-Xj.png alt></div></p><h4 id=69>6.9<a hidden class=anchor aria-hidden=true href=#69>#</a></h4><p>若：系统只有一片8259，8259地址为E010H和E011H，允许8个中断源边沿触发，不需要缓冲，以一般嵌套方式工作，中断向量为40H，非自动EOI方式</p><ol><li>编写初始化程序<div class=render-image><img loading=lazy src=https://i.postimg.cc/pLqTWWWT/6-9-1.png alt></div><div class=render-image><img loading=lazy src=https://i.postimg.cc/zfvf3svk/6-9-2.png alt></div></li><li>若允许中断嵌套，编写中断服务程序框架，包括返回前发送EOI命令。中断服务程序名称为IPROC40<div class=render-image><img loading=lazy src=https://i.postimg.cc/76TYnSgG/6-9-3.png alt></div></li><li>编程序，将上述中断处理程序的入口地址填入中断向量表<div class=render-image><img loading=lazy src=https://i.postimg.cc/HLNkM671/6-9-4.png alt></div></li></ol><h2 id=常用接口器件>常用接口器件<a hidden class=anchor aria-hidden=true href=#常用接口器件>#</a></h2><p>计算机和外设之间如何通过接口传送数据（非DMA）<div class=render-image><img loading=lazy src=https://i.postimg.cc/ZqQ3YDm0/1.jpg alt></div><div class=render-image><img loading=lazy src=https://i.postimg.cc/QCGT19H3/2.jpg alt></div><div class=render-image><img loading=lazy src=https://i.postimg.cc/C5GfNhqf/3.jpg alt></div></p><h3 id=可编程并行接口8255>可编程并行接口8255<a hidden class=anchor aria-hidden=true href=#可编程并行接口8255>#</a></h3><h4 id=内部结构及外部总线>内部结构及外部总线<a hidden class=anchor aria-hidden=true href=#内部结构及外部总线>#</a></h4><p><div class=render-image><img loading=lazy src=https://i.postimg.cc/rFbLJ1qx/1.jpg alt></div></p><h4 id=8255的工作方式>8255的工作方式<a hidden class=anchor aria-hidden=true href=#8255的工作方式>#</a></h4><ul><li>工作方式0：基本输入输出方式<ul><li>A口（PA0~PA7）：输入（无锁存能力）或输出（有锁存能力）</li><li>B口（PB0~PB7）：输入（无锁存能力）或输出（有锁存能力）</li><li>C口（PC4~PC7）：输入（无锁存能力）或输出（有锁存能力）</li><li>C口（PC0~PC3）：输入（无锁存能力）或输出（有锁存能力）</li></ul></li><li>工作方式1：选通输入输出方式<div class=render-image><img loading=lazy src=https://i.postimg.cc/yNRQH94q/1.jpg alt></div></li><li>工作方式2：双向输入输出方式（仅A口）<ul><li>PC3-PC7：A口方式2下的控制线</li><li>PC0-PC2：输入或输出或B口方式1下的控制线</li><li>B口：方式0或方式1</li></ul></li></ul><h4 id=8255的方式控制字及状态字>8255的方式控制字及状态字<a hidden class=anchor aria-hidden=true href=#8255的方式控制字及状态字>#</a></h4><ul><li>控制字<div class=render-image><img loading=lazy src=https://i.postimg.cc/SK7yKnC5/1.jpg alt></div></li><li>状态字<div class=render-image><img loading=lazy src=https://i.postimg.cc/nz2BqcbS/1.jpg alt></div></li></ul><h4 id=8255的寻址及连接使用>8255的寻址及连接使用<a hidden class=anchor aria-hidden=true href=#8255的寻址及连接使用>#</a></h4><p><div class=render-image><img loading=lazy src=https://i.postimg.cc/QxJkp31T/1.jpg alt></div></p><h4 id=8255的初始化及应用举例>8255的初始化及应用举例<a hidden class=anchor aria-hidden=true href=#8255的初始化及应用举例>#</a></h4><ul><li>方式0——打印机接口<div class=render-image><img loading=lazy src=https://i.postimg.cc/bwY0gB9F/2.jpg alt></div><div class=render-image><img loading=lazy src=https://i.postimg.cc/Qd6QyJ6N/3.jpg alt></div><div class=render-image><img loading=lazy src=https://i.postimg.cc/hGfLWQwL/4.jpg alt></div></li><li>方式1——打印机接口<div class=render-image><img loading=lazy src=https://i.postimg.cc/ZqGVwLRB/1.jpg alt></div><div class=render-image><img loading=lazy src=https://i.postimg.cc/tTFDwVZr/2.jpg alt></div><ul><li>程序查询方式<div class=render-image><img loading=lazy src=https://i.postimg.cc/T1GQ6YnT/3.jpg alt></div></li><li>中断方式<div class=render-image><img loading=lazy src=https://i.postimg.cc/hGfLWQwL/4.jpg alt></div></li></ul></li></ul><h3 id=可编程定时器8253>可编程定时器8253<a hidden class=anchor aria-hidden=true href=#可编程定时器8253>#</a></h3><h4 id=工作方式>工作方式<a hidden class=anchor aria-hidden=true href=#工作方式>#</a></h4><ul><li>方式0：计数结束产生中断<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/12/07/DzF7lt.jpg alt></div></li><li>方式1：可编程单稳<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/12/07/DzFIfA.jpg alt></div></li><li>方式2：频率发生器<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/12/07/DzFTSI.jpg alt></div></li><li>方式3：方波发生器<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/12/07/DzF4FH.jpg alt></div></li><li>方式4：软件触发选通<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/12/07/DzF5Yd.jpg alt></div></li><li>方式5：硬件触发选通<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/12/07/DzFbOf.jpg alt></div></li></ul><h4 id=8253的控制字>8253的控制字<a hidden class=anchor aria-hidden=true href=#8253的控制字>#</a></h4><p><div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/12/07/Dzkju6.jpg alt></div></p><h3 id=习题-4>习题<a hidden class=anchor aria-hidden=true href=#习题-4>#</a></h3><h4 id=71>7.1<a hidden class=anchor aria-hidden=true href=#71>#</a></h4><p>若8253芯片可利用8088的外设接口地址为D0D0H～D0D3H，试画出电路连接图。设加到8253上的时钟信号为2MHz。
若利用计数器0、1和2产生周期为100μs的对称方波以及每1s、10s产生一个负脉冲，试说明8253如何连接，并编写初始化程序。<div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/12/07/DzAZb8.jpg alt></div><div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/12/07/DzAmVS.jpg alt></div></p><h4 id=72>7.2<a hidden class=anchor aria-hidden=true href=#72>#</a></h4><ul><li>若8255芯片可占用的地址为FE00～FEFFH，试画出它与8086总线的连接图。</li><li>A/D变换器的引线及工作时序图如下，试将此A/D变换器与8255相连接，并编写包括初始化程序在内的、变换一次数据并将数据放在DATA中的程序</li></ul><p><div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/12/07/DzANaF.jpg alt></div><div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/12/07/DzAtVU.jpg alt></div></p><h4 id=73>7.3<a hidden class=anchor aria-hidden=true href=#73>#</a></h4><p>说明8253的6种工作方式。若如加到8235上的时钟频率为0.5MHz，则一个计数器的最长定时时间是多少？若要求美10min产生一次定时中断，试提出解决方案</p><ul><li>方式0：计数结束中断，输出一个正跳变</li><li>方式1：硬件可重复触发的单稳态触发器，输出一个宽度可调的负脉冲</li><li>方式2：比率发生器，输出序列负脉冲</li><li>方式3：方波发生器</li><li>方式4：软件触发延时选通脉冲发生器</li><li>方式5：硬件触发延时选通脉冲发生器</li></ul><p>加到8253上的时钟频率是0.5MHz，则一个计数器的最长定时时间是$\frac {65536} {0.5\times 10^6}=0.131072 s$（初值为0）</p><p>计数器0和计数器1都工作于方式3（循环计数，产生周期性方波），两个计数器串联，计数器0的输出作为计数器1的时钟，计数器1的输出作为cpu中断信号用于产生定时中断。设计数器0的计数值=30000，计数器1的计数值=10000，则每计数30000×10000=3×1e8次，也即每2μs×3×108=600s=10min 产生一次定时中断</p><h2 id=基于总线的io接口设计>基于总线的I/O接口设计<a hidden class=anchor aria-hidden=true href=#基于总线的io接口设计>#</a></h2><h3 id=基于isa总线的io接口设计>基于ISA总线的I/O接口设计<a hidden class=anchor aria-hidden=true href=#基于isa总线的io接口设计>#</a></h3><h4 id=led接口>LED接口<a hidden class=anchor aria-hidden=true href=#led接口>#</a></h4><ul><li>接口电路<ul><li>用通用并行接口芯片作接口<div class=render-image><img loading=lazy src=https://i.postimg.cc/zfmQgSpJ/1.jpg alt></div><div class=render-image><img loading=lazy src=https://i.postimg.cc/T2FNFv5k/1.jpg alt></div></li><li>用LED译码器作接口：DM9368<div class=render-image><img loading=lazy src=https://i.postimg.cc/TYvqndDX/1.jpg alt></div><div class=render-image><img loading=lazy src=https://i.postimg.cc/PqJmdNB1/1.jpg alt></div>利用上图电路中的4个数码管，实现将存储单元 BUF中的4位十六进制数加以显示，并每经过1秒，重新读取BUF单元数据，更新显示，则控制程序如下：<div class=render-image><img loading=lazy src=https://i.postimg.cc/NFky6w3g/8.jpg alt></div></li></ul></li><li>动态显示的接口电路<ul><li>用通用接口芯片<div class=render-image><img loading=lazy src=https://i.postimg.cc/52Y41Vs6/1.jpg alt></div></li><li>用专用接口芯片：MM74C912/917<div class=render-image><img loading=lazy src=https://i.postimg.cc/pTV3WQPq/1.jpg alt></div><div class=render-image><img loading=lazy src=https://i.postimg.cc/pLZgg1Hp/1.jpg alt></div></li></ul></li></ul><h4 id=键盘接口>键盘接口<a hidden class=anchor aria-hidden=true href=#键盘接口>#</a></h4><ul><li>非编码式键盘<div class=render-image><img loading=lazy src=https://i.postimg.cc/rw0rH7W9/1.jpg alt></div></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://fffzlfk.github.io/tags/academic/>Academic</a></li></ul><nav class=paginav><a class=prev href=https://fffzlfk.github.io/posts/sql/><span class=title>« Prev</span><br><span>SQL</span></a>
<a class=next href=https://fffzlfk.github.io/posts/c++%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E6%9E%90/><span class=title>Next »</span><br><span>C++(临时对象的分析)</span></a></nav></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//https-fffzlfk-github-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2022 <a href=https://fffzlfk.github.io>fffzlfk's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>