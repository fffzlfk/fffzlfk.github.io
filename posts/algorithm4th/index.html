<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=zh-cn dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>算法（第四版） - fffzlfk's Blog</title>
<meta name=theme-color><meta name=description content="The solution of algs4&rsquo;s exercise"><meta name=author content="fffzlfk"><link rel="preload stylesheet" as=style href=https://fffzlfk.github.io/main.min.css><link rel=preload as=image href=https://fffzlfk.github.io/theme.svg><link rel=preload as=image href="https://avatars.githubusercontent.com/u/44939690?v=4"><link rel=preload as=image href=https://fffzlfk.github.io/github.svg><link rel=preload as=image href=https://fffzlfk.github.io/instagram.svg><link rel=preload as=image href=https://fffzlfk.github.io/rss.svg><link rel=stylesheet href=/css/fonts.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",()=>renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1}))</script><link rel=icon href=https://fffzlfk.github.io/favicon.ico><link rel=apple-touch-icon href=https://fffzlfk.github.io/apple-touch-icon.png><meta name=generator content="Hugo 0.147.4"><meta itemprop=name content="算法（第四版）"><meta itemprop=description content="The solution of algs4’s exercise"><meta itemprop=datePublished content="2020-10-09T00:00:00+00:00"><meta itemprop=dateModified content="2020-10-09T00:00:00+00:00"><meta itemprop=wordCount content="7592"><meta itemprop=keywords content="Java,Academic"><meta property="og:url" content="https://fffzlfk.github.io/posts/algorithm4th/"><meta property="og:site_name" content="fffzlfk's Blog"><meta property="og:title" content="算法（第四版）"><meta property="og:description" content="The solution of algs4’s exercise"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-10-09T00:00:00+00:00"><meta property="article:modified_time" content="2020-10-09T00:00:00+00:00"><meta property="article:tag" content="Java"><meta property="article:tag" content="Academic"><meta name=twitter:card content="summary"><meta name=twitter:title content="算法（第四版）"><meta name=twitter:description content="The solution of algs4’s exercise"><link rel=canonical href=https://fffzlfk.github.io/posts/algorithm4th/></head><body class="bg-(--bg) text-black antialiased duration-200 ease-out [-webkit-tap-highlight-color:transparent] dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-(--w) px-8 whitespace-nowrap lg:justify-center"><div class="relative z-50 flex items-center ltr:mr-auto rtl:ml-auto"><a class="-translate-y-[1px] text-2xl font-medium" href=https://fffzlfk.github.io/>fffzlfk's Blog</a><div class="btn-dark text-[0px] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden ltr:-mr-8 rtl:-ml-8" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full flex-col justify-center bg-(--bg) pb-16 duration-200 select-none lg:static lg:h-auto lg:flex-row lg:bg-transparent! lg:pb-0 lg:transition-none"><nav class="mt-12 flex justify-center space-x-10 lg:mt-0 lg:items-center ltr:lg:ml-14 rtl:space-x-reverse rtl:lg:mr-14 dark:invert"><a class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/fffzlfk target=_blank rel=me>github</a>
<a class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./instagram.svg) href=https://instagram.com/fffzlfk target=_blank rel=me>instagram</a>
<a class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./rss.svg) href=https://fffzlfk.github.io/index.xml target=_blank rel=alternate>rss</a></nav></div></header><main class="prose prose-neutral dark:prose-invert relative mx-auto min-h-[calc(100vh-9rem)] max-w-(--w) px-8 pt-14 pb-16"><article><header class=mb-14><h1 class="my-0! pb-2.5">算法（第四版）</h1><div class="text-xs antialiased opacity-60"><time>Oct 9, 2020</time></div></header><section><h2 id=union-find>Union-Find</h2><h3 id=quickfind>quickfind</h3><h4 id=java-implementation>Java implementation</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>QuickFindUF</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> id;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> count;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>QuickFindUF</span>(<span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>        id <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>n<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            id<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>        count <span style=color:#f92672>=</span> n;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>count</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> count;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>find</span>(<span style=color:#66d9ef>int</span> p) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> id<span style=color:#f92672>[</span>p<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>connected</span>(<span style=color:#66d9ef>int</span> p, <span style=color:#66d9ef>int</span> q) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> find(p) <span style=color:#f92672>==</span> find(q);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>union</span>(<span style=color:#66d9ef>int</span> p, <span style=color:#66d9ef>int</span> q) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> pid <span style=color:#f92672>=</span> find(p);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> qid <span style=color:#f92672>=</span> find(q);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (pid <span style=color:#f92672>!=</span> qid) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> id.<span style=color:#a6e22e>length</span>; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (id<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>==</span> pid) {
</span></span><span style=display:flex><span>                    id<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> qid;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        count<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Scanner in <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Scanner(System.<span style=color:#a6e22e>in</span>);
</span></span><span style=display:flex><span>        QuickFindUF uf <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> QuickFindUF(10);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (in.<span style=color:#a6e22e>hasNext</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> p <span style=color:#f92672>=</span> in.<span style=color:#a6e22e>nextInt</span>(), q <span style=color:#f92672>=</span> in.<span style=color:#a6e22e>nextInt</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (uf.<span style=color:#a6e22e>connected</span>(p, q)) <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            uf.<span style=color:#a6e22e>union</span>(p, q);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=analysis>analysis</h4><p>The find() operation is certainly quick, as it only accesses the id[] array once in order to complete the operation. But quick-find is typically not useful for large problems because union() needs to scan through the whole id[] array for each input pair.</p><h3 id=quick-union>quick-union</h3><h4 id=implementation>implementation</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Scanner;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>QuickUnionUF</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> id;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> count;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>QuickUnionUF</span>(<span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>        id <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>n<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            id<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>        count <span style=color:#f92672>=</span> n;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>count</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> count;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>find</span>(<span style=color:#66d9ef>int</span> p) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (p <span style=color:#f92672>!=</span> id<span style=color:#f92672>[</span>p<span style=color:#f92672>]</span>) {
</span></span><span style=display:flex><span>            p <span style=color:#f92672>=</span> id<span style=color:#f92672>[</span>p<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> p;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>connected</span>(<span style=color:#66d9ef>int</span> p, <span style=color:#66d9ef>int</span> q) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> find(p) <span style=color:#f92672>==</span> find(q);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>union</span>(<span style=color:#66d9ef>int</span> p, <span style=color:#66d9ef>int</span> q) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> pRoot <span style=color:#f92672>=</span> find(p);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> qRoot <span style=color:#f92672>=</span> find(q);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (pRoot <span style=color:#f92672>!=</span> qRoot) {
</span></span><span style=display:flex><span>            id<span style=color:#f92672>[</span>pRoot<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> qRoot;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        count<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Scanner in <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Scanner(System.<span style=color:#a6e22e>in</span>);
</span></span><span style=display:flex><span>        QuickUnionUF uf <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> QuickUnionUF(10);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (in.<span style=color:#a6e22e>hasNext</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> p <span style=color:#f92672>=</span> in.<span style=color:#a6e22e>nextInt</span>(), q <span style=color:#f92672>=</span> in.<span style=color:#a6e22e>nextInt</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (uf.<span style=color:#a6e22e>connected</span>(p, q)) <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            uf.<span style=color:#a6e22e>union</span>(p, q);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=quick-union-worst-case>quick-union worst case</h4><p><img src=https://s1.ax1x.com/2020/11/01/B0Esk8.png alt></p><h3 id=weighted-quick-union>Weighted quick-union</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Scanner;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WeightedQuickUnionUF</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> id;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> sz;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> count;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>WeightedQuickUnionUF</span>(<span style=color:#66d9ef>int</span> N) {
</span></span><span style=display:flex><span>        count <span style=color:#f92672>=</span> N;
</span></span><span style=display:flex><span>        id <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>N<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        sz <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>N<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> N; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            id<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> N; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            sz<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 1;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>find</span>(<span style=color:#66d9ef>int</span> p) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (p <span style=color:#f92672>!=</span> id<span style=color:#f92672>[</span>p<span style=color:#f92672>]</span>) {
</span></span><span style=display:flex><span>            id<span style=color:#f92672>[</span>p<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> id<span style=color:#f92672>[</span>id<span style=color:#f92672>[</span>p<span style=color:#f92672>]]</span>; <span style=color:#75715e>// path compression by halving</span>
</span></span><span style=display:flex><span>            p <span style=color:#f92672>=</span> id<span style=color:#f92672>[</span>p<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> p;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>connected</span>(<span style=color:#66d9ef>int</span> p, <span style=color:#66d9ef>int</span> q) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> find(p) <span style=color:#f92672>==</span> find(q);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>union</span>(<span style=color:#66d9ef>int</span> p, <span style=color:#66d9ef>int</span> q) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> find(p);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> find(q);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>==</span> j) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (sz<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>&lt;</span> sz<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span>) {
</span></span><span style=display:flex><span>            id<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> j;
</span></span><span style=display:flex><span>            sz<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span> <span style=color:#f92672>+=</span> sz<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            id<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>            sz<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>+=</span> sz<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        count<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Scanner in <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Scanner(System.<span style=color:#a6e22e>in</span>);
</span></span><span style=display:flex><span>        WeightedQuickUnionUF uf <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> WeightedQuickUnionUF(10);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (in.<span style=color:#a6e22e>hasNext</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> p <span style=color:#f92672>=</span> in.<span style=color:#a6e22e>nextInt</span>(), q <span style=color:#f92672>=</span> in.<span style=color:#a6e22e>nextInt</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (uf.<span style=color:#a6e22e>connected</span>(p, q)) <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            uf.<span style=color:#a6e22e>union</span>(p, q);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=performance-characteristics-of-union-find-algorithms>Performance characteristics of union-find algorithms</h3><table><thead><tr><th>algorithm</th><th>constructor</th><th>union</th><th>find</th></tr></thead><tbody><tr><td>quick-find</td><td>N</td><td>N</td><td>1</td></tr><tr><td>quick-union</td><td>N</td><td>tree height</td><td>tree height</td></tr><tr><td>weighted quick-union</td><td>N</td><td>lgN</td><td>lgN</td></tr><tr><td>weighted quick-union with path compression</td><td>N</td><td>very, very nearly, but not quite 1</td><td>same as union</td></tr><tr><td>impossible</td><td>N</td><td>1</td><td>1</td></tr></tbody></table><h2 id=analysis-of-algorithms>Analysis of Algorithms</h2><h3 id=scientific-method>Scientific method</h3><p>The very same approach that scientists use to understand the natural world is effective for studying the running time of programs.</p><ul><li><em>Observe</em> some feature of the natural world, generally with precise measurement.</li><li><em>Hypothesize</em> a model that is consistent with observations.</li><li><em>Predict</em> events using the hypothesis.</li><li><em>Verify</em> the predictions by making further observations.</li><li><em>Valitate</em> by repeating until the hypothesis and observations agree.</li></ul><h3 id=mathematical-models>Mathematical models</h3><ul><li><em>Tilde approximations.</em> We use tilde approximations, where we throw away low-order terms that complicate formulas. We write <em>~f(N)</em> to represent any function that when divided by <em>f(N)</em> approaches 1 as <em>N</em> grows. We write <em>g(N)~f(N)</em> to indicate that <em>g(N)/f(N)</em> approaches 1 as <em>N</em> grows.</li><li><em>Order-of-growth classifications.</em> Most often, we work with tilde approximations of the form <em>g(N)~af(N)</em> where $ f(N) = N^b log_c N $ and refer to f(N) as the The order of growth of g(N). We use just a few structural primitives (statements, conditionals, loops, nesting, and method calls) to implement algorithms, so very often the order of growth of the cost is one of just a few functions of the problem size N.</li></ul><table><thead><tr><th>function</th><th>tilde approximation</th><th>order of growth</th></tr></thead><tbody><tr><td>$ \frac{N^3}{6}-\frac{N^2}{2}+\frac N 3 $</td><td>$~\frac{N^3}{6} $</td><td>$N^3$</td></tr><tr><td>$ \frac{N^3}{2}-\frac N 2$</td><td>$ ~\frac{N^2}{2} $</td><td>$N^2$</td></tr><tr><td>$lgN+1 $</td><td>$~lgN$</td><td>$lgN$</td></tr><tr><td>3</td><td>~3</td><td>1</td></tr></tbody></table><ul><li><em>Cost model.</em> We focus attention on properties of algorithms by articulating a cost model that defines the basic operations. For example, an appropriate cost model for the 3-sum problem is the number of times we access an array entry, for read or write.</li></ul><h3 id=commonly-used-notations-in-the-theory-of-algorithms>Commonly-used Notations in the Theory of Algorithms</h3><table><thead><tr><th>notation</th><th>provides</th><th>example</th><th>shorthand for</th><th>used to</th></tr></thead><tbody><tr><td>Big Theta</td><td>asympatotic order of growth</td><td>$ \Theta (N^2) $</td><td>$\frac 1 2 N^2, 5N^2+22NlogN+3N$</td><td>classify algorithms</td></tr><tr><td>Big Oh</td><td>$\Theta (N^2)$and smaller</td><td>$O(N^2)$</td><td>$10N^2,\ 100N, 22NlogN+3N $</td><td>develop upper bounds</td></tr><tr><td>Big Omega</td><td>$\Theta (N^2)$and larger</td><td>$\Omega (N^2)$</td><td>$\frac 1 2 N^2, N^5, N^3+22NlogN+3N $</td><td>develop lower bounds</td></tr></tbody></table><h3 id=146>1.4.6</h3><p>Give the order of growth (as a function of N ) of the running times of each of the following code fragments:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>int</span> sum <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> N; n <span style=color:#f92672>&gt;</span> 0; n <span style=color:#f92672>/=</span> 2)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>      sum<span style=color:#f92672>++</span>;
</span></span></code></pre></div><p>$$ N+\frac N 2+\frac N 4+\frac N 8+&mldr;+1=2N-1\ \ \sim 2N $$
所以是线性</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>int</span> sum <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1 i <span style=color:#f92672>&lt;</span> N; i <span style=color:#f92672>*=</span> 2)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> 0; j <span style=color:#f92672>&lt;</span> i; j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    sum<span style=color:#f92672>++</span>;
</span></span></code></pre></div><p>$$ 1+2+4+8+&mldr;+2^{\lfloor lgN \rfloor}=2^{\lfloor lgN \rfloor + 1}-1\ \ \sim 2N$$
所以是线性</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>int</span> sum <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1 i <span style=color:#f92672>&lt;</span> N; i <span style=color:#f92672>*=</span> 2)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> 0; j <span style=color:#f92672>&lt;</span> N; j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    sum<span style=color:#f92672>++</span>;
</span></span></code></pre></div><p>$$ NlgN $$ 线性对数</p><h3 id=1415>1.4.15</h3><p>Faster 3-sum. As a warmup, develop an implementation TwoSumFaster that uses a linear algorithm to count the pairs that sum to zero after the array is sorted (in stead of the binary-search-based linearithmic algorithm). Then apply a similar idea to develop a quadratic algorithm for the 3-sum problem.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>twoSumFaster</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> a) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> lo <span style=color:#f92672>=</span> 0, hi <span style=color:#f92672>=</span> a.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> 1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> cnt <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (lo <span style=color:#f92672>&lt;</span> hi) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (a<span style=color:#f92672>[</span>lo<span style=color:#f92672>]</span> <span style=color:#f92672>+</span> a<span style=color:#f92672>[</span>hi<span style=color:#f92672>]</span> <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>            cnt<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            lo<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            hi<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (a<span style=color:#f92672>[</span>lo<span style=color:#f92672>]</span> <span style=color:#f92672>+</span> a<span style=color:#f92672>[</span>hi<span style=color:#f92672>]</span> <span style=color:#f92672>&gt;</span> 0)
</span></span><span style=display:flex><span>            hi<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            lo<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> cnt;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>threeSumFaster</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> a) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> cnt <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> a.<span style=color:#a6e22e>length</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> lo <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> 1, hi <span style=color:#f92672>=</span> a.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> 1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (lo <span style=color:#f92672>&lt;</span> hi) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (a<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>+</span> a<span style=color:#f92672>[</span>lo<span style=color:#f92672>]</span> <span style=color:#f92672>+</span> a<span style=color:#f92672>[</span>hi<span style=color:#f92672>]</span> <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>                cnt<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                lo<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                hi<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (a<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>+</span> a<span style=color:#f92672>[</span>lo<span style=color:#f92672>]</span> <span style=color:#f92672>+</span> a<span style=color:#f92672>[</span>hi<span style=color:#f92672>]</span> <span style=color:#f92672>&gt;</span> 0)
</span></span><span style=display:flex><span>                hi<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                lo<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> cnt;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=megersort>MegerSort</h2><h3 id=implementation-1>Implementation</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Merge</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isSorted</span>(Comparable<span style=color:#f92672>[]</span> a, <span style=color:#66d9ef>int</span> lo, <span style=color:#66d9ef>int</span> hi) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> lo <span style=color:#f92672>+</span> 1; i <span style=color:#f92672>&lt;=</span> hi; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (less(a<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>, a<span style=color:#f92672>[</span>i <span style=color:#f92672>-</span> 1<span style=color:#f92672>]</span>)) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>less</span>(Comparable v, Comparable w) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> v.<span style=color:#a6e22e>compareTo</span>(w) <span style=color:#f92672>&lt;</span> 0;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>merge</span>(Comparable<span style=color:#f92672>[]</span> a, Comparable<span style=color:#f92672>[]</span> aux, <span style=color:#66d9ef>int</span> lo, <span style=color:#66d9ef>int</span> mid, <span style=color:#66d9ef>int</span> hi) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>assert</span> isSorted(a, lo, mid);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>assert</span> isSorted(a, mid <span style=color:#f92672>+</span> 1, hi);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> lo; k <span style=color:#f92672>&lt;=</span> hi; k<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            aux<span style=color:#f92672>[</span>k<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> a<span style=color:#f92672>[</span>k<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> lo, j <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> 1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> lo; k <span style=color:#f92672>&lt;=</span> hi; k<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&gt;</span> mid) a<span style=color:#f92672>[</span>k<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> aux<span style=color:#f92672>[</span>j<span style=color:#f92672>++]</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (j <span style=color:#f92672>&gt;</span> hi) a<span style=color:#f92672>[</span>k<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> aux<span style=color:#f92672>[</span>i<span style=color:#f92672>++]</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (less(aux<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span>, aux<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>)) a<span style=color:#f92672>[</span>k<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> aux<span style=color:#f92672>[</span>j<span style=color:#f92672>++]</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> a<span style=color:#f92672>[</span>k<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> aux<span style=color:#f92672>[</span>i<span style=color:#f92672>++]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>assert</span> isSorted(a, lo, hi);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(Comparable<span style=color:#f92672>[]</span> a, Comparable<span style=color:#f92672>[]</span> aux, <span style=color:#66d9ef>int</span> lo, <span style=color:#66d9ef>int</span> hi) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (hi <span style=color:#f92672>&lt;=</span> lo) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> lo <span style=color:#f92672>+</span> (hi <span style=color:#f92672>-</span> lo) <span style=color:#f92672>/</span> 2;
</span></span><span style=display:flex><span>        sort(aux, a, lo, mid);
</span></span><span style=display:flex><span>        sort(aux, a, mid<span style=color:#f92672>+</span>1, hi);
</span></span><span style=display:flex><span>        merge(a, aux, lo, mid, hi);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(Comparable<span style=color:#f92672>[]</span> a) {
</span></span><span style=display:flex><span>        Comparable<span style=color:#f92672>[]</span> aux <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Comparable<span style=color:#f92672>[</span>a.<span style=color:#a6e22e>length</span><span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        sort(a, aux, 0, a.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> 1);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> N <span style=color:#f92672>=</span> StdIn.<span style=color:#a6e22e>readInt</span>();
</span></span><span style=display:flex><span>        Comparable<span style=color:#f92672>[]</span> a <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Comparable<span style=color:#f92672>[</span>N<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> N; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            a<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> StdRandom.<span style=color:#a6e22e>uniform</span>(<span style=color:#f92672>-</span>10000,10000);
</span></span><span style=display:flex><span>        Stopwatch stopwatch <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Stopwatch();
</span></span><span style=display:flex><span>        sort(a);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>var</span> i : a) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>print</span>(i <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; &#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>();
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(stopwatch.<span style=color:#a6e22e>elapsedTime</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=empirical-analysis>Empirical analysis</h3><p>The number of compares $C(N)$ and array accesses $A(N)$ to mergesort an array of size N satisfy the recurrences:<br>$$ C(N) \le C(\lceil{\frac N 2}\rceil) + C(\lfloor{\frac N 2}\rfloor) + N\ \ for N > 1,with \ C(1)=0. $$
$$
A(N) \le A(\lceil{\frac N 2}\rceil) + A(\lfloor{\frac N 2}\rfloor) + 6N\ \ for N > 1,with \ A(1)=0.
$$
we solve the recurrence when $ N $ is a power of 2.
$$ D(N) = 2D(\frac N 2) + N, for N > 1, with\ D(1) = 0. $$</p><h4 id=divide-and-conquer-recurrence>Divide-and-conquer recurrence:</h4><ol><li><p>proof by picture</p><p><img src=/img/merge-pic.png alt></p></li><li><p>proof by expansion</p><p>$$
\begin{aligned}
D(N)&=2D(N/2)+N \cr
{D(N)} /{N} &= 2D(N / 2)/N + 1\cr
&= D(N/2)/(N/2)+1 \cr
&= D(N/4)/(N/4) + 1 + 1\cr
&= D(N/8)/(N/8) + 1 + 1 + 1\cr
&mldr;\cr
&= D(N/N)/(N/N)+1+1+&mldr;+1\cr
&= lgN
\end{aligned}
$$</p></li><li><p>proof by induction</p><ul><li>Base case: $N = 1$</li><li>Induction hypothesis: $D(N)=Nlg(N)$.</li><li>Goal: showthat $ D(2N) = (2N)lg(2N).$</li></ul><p>$$
\begin{aligned}
D(2N) &= 2D(N)+2N \cr
&= 2NlgN+2N \cr
&= 2N(lgN+1) \cr
&= 2Nlg(2N)
\end{aligned}
$$</p></li></ol><h3 id=practical-improvements>practical improvements</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(Comparable<span style=color:#f92672>[]</span> a, Comparable<span style=color:#f92672>[]</span> aux, <span style=color:#66d9ef>int</span> lo, <span style=color:#66d9ef>int</span> hi) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Use insertion sort for samll subarrays.</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> CUTOFF <span style=color:#f92672>=</span> 7;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (hi <span style=color:#f92672>&lt;=</span> lo <span style=color:#f92672>+</span> CUTOFF <span style=color:#f92672>-</span> 1) {
</span></span><span style=display:flex><span>        Insertion.<span style=color:#a6e22e>sort</span>(a, lo, hi);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> lo <span style=color:#f92672>+</span> (hi <span style=color:#f92672>-</span> lo) <span style=color:#f92672>/</span> 2;
</span></span><span style=display:flex><span>    sort(a, aux, lo, mid);
</span></span><span style=display:flex><span>    sort(a, aux, mid <span style=color:#f92672>+</span> 1, hi);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Stop if already sorted.</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>less(a<span style=color:#f92672>[</span>mid<span style=color:#f92672>+</span>1<span style=color:#f92672>]</span>, a<span style=color:#f92672>[</span>mid<span style=color:#f92672>]</span>)) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    merge(a, aux, lo, mid, hi);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Eliminate the copy to the auxiliary array.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>merge</span>(Comparable<span style=color:#f92672>[]</span> a,Comparable<span style=color:#f92672>[]</span> aux, <span style=color:#66d9ef>int</span> lo, <span style=color:#66d9ef>int</span> mid, <span style=color:#66d9ef>int</span> hi) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> lo, j <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> 1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> lo; k <span style=color:#f92672>&lt;=</span> hi; k<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&gt;</span> mid) aux<span style=color:#f92672>[</span>k<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> a<span style=color:#f92672>[</span>j<span style=color:#f92672>++]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (j <span style=color:#f92672>&gt;</span> hi) aux<span style=color:#f92672>[</span>k<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> a<span style=color:#f92672>[</span>i<span style=color:#f92672>++]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (less(a<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span>, a<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>)) aux<span style=color:#f92672>[</span>k<span style=color:#f92672>]</span> <span style=color:#f92672>=</span>a<span style=color:#f92672>[</span>j<span style=color:#f92672>++]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> aux<span style=color:#f92672>[</span>k<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> a<span style=color:#f92672>[</span>i<span style=color:#f92672>++]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(Comparable<span style=color:#f92672>[]</span> a,Comparable<span style=color:#f92672>[]</span> aux, <span style=color:#66d9ef>int</span> lo, <span style=color:#66d9ef>int</span> hi) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (hi <span style=color:#f92672>&lt;=</span> lo) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> lo <span style=color:#f92672>+</span> (hi <span style=color:#f92672>-</span> lo) <span style=color:#f92672>/</span> 2;
</span></span><span style=display:flex><span>    <span style=color:#75715e>//switch soles of aux[] and a[]</span>
</span></span><span style=display:flex><span>    sort(aux, a, lo, mid);
</span></span><span style=display:flex><span>    sort(aux, a, mid<span style=color:#f92672>+</span>1, hi);
</span></span><span style=display:flex><span>    merge(a, aux, lo, mid, hi);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=bottom-up-mergesort>Bottom-up mergesort</h3><h4 id=implementation-2>Implementation</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>merge</span>(Comparable<span style=color:#f92672>[]</span> a, Comparable<span style=color:#f92672>[]</span> aux, <span style=color:#66d9ef>int</span> lo, <span style=color:#66d9ef>int</span> mid, <span style=color:#66d9ef>int</span> hi) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> lo; k <span style=color:#f92672>&lt;=</span> hi; k<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        aux<span style=color:#f92672>[</span>k<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> a<span style=color:#f92672>[</span>k<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> lo, j <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> 1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> lo; k <span style=color:#f92672>&lt;=</span> hi; k<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&gt;</span> mid) a<span style=color:#f92672>[</span>k<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> aux<span style=color:#f92672>[</span>j<span style=color:#f92672>++]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (j <span style=color:#f92672>&gt;</span> hi) a<span style=color:#f92672>[</span>k<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> aux<span style=color:#f92672>[</span>i<span style=color:#f92672>++]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (less(aux<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span>, aux<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>)) a<span style=color:#f92672>[</span>k<span style=color:#f92672>]=</span> aux<span style=color:#f92672>[</span>j<span style=color:#f92672>++]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> a<span style=color:#f92672>[</span>k<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> aux<span style=color:#f92672>[</span>i<span style=color:#f92672>++]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(Comparable<span style=color:#f92672>[]</span> a) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> N <span style=color:#f92672>=</span> a.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>    Comparable<span style=color:#f92672>[]</span> aux <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Comparable<span style=color:#f92672>[</span>N<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> sz <span style=color:#f92672>=</span> 1; sz <span style=color:#f92672>&lt;</span> N; sz <span style=color:#f92672>=</span> sz <span style=color:#f92672>+</span> sz)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> lo <span style=color:#f92672>=</span> 0; lo <span style=color:#f92672>&lt;</span> N <span style=color:#f92672>-</span> sz; lo <span style=color:#f92672>+=</span>sz <span style=color:#f92672>+</span> sz)
</span></span><span style=display:flex><span>            merge(a, aux, lo, lo <span style=color:#f92672>+</span> sz <span style=color:#f92672>-</span>1,Math.<span style=color:#a6e22e>min</span>(lo<span style=color:#f92672>+</span>sz<span style=color:#f92672>+</span>sz<span style=color:#f92672>-</span>1, N<span style=color:#f92672>-</span>1));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> N <span style=color:#f92672>=</span> StdIn.<span style=color:#a6e22e>readInt</span>();
</span></span><span style=display:flex><span>    Comparable<span style=color:#f92672>[]</span> a <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Comparable<span style=color:#f92672>[</span>N<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> N; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        a<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> StdRandom.<span style=color:#a6e22e>uniform</span>(<span style=color:#f92672>-</span>1000010000);
</span></span><span style=display:flex><span>    Stopwatch stopwatch <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Stopwatch();
</span></span><span style=display:flex><span>    sort(a);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>var</span> i : a) {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>print</span>(i <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; &#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>();
</span></span><span style=display:flex><span>    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(stopwatch.<span style=color:#a6e22e>elapsedTim</span>());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=sorting-complexity>Sorting Complexity</h3><ul><li>Model of computation: decision tree.</li><li>Cost model: # compares.</li><li>Upper bound: $\sim NlgN $from mergesort</li><li>Lower bound: ?</li><li>Optimal algorithm: ?</li></ul><h4 id=compare-based-lower-bound-for-sorting>Compare-based lower bound for sorting</h4><ul><li><p>Proposition. Any Compare-based sorting algorothm must use at least $lg(N!)\sim NlogN $(Stirling formula) compares in the worst-case.</p></li><li><p>Pf.</p><ul><li>Assume array consists of $N$ distinct values $a_1$ through $ a_n $.</li><li>Worst case dictated by height $h$ of decision tree.</li><li>Binary tree of height $h$ has at most $2^h$ leaves.</li><li>$N! $different orderings $\Rightarrow$ at least $ N!$ leaves.</li></ul><p>$$
\begin{aligned}
2^h \ge ＃leaves \ge N! \cr
\Rightarrow h \ge lg(N!)\sim NlgN
\end{aligned}$$</p></li></ul><h3 id=stability>Stability</h3><ul><li>Insertion sort is <strong>stable</strong>: Equal items never move fast each other.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insertionSort</span>(Comparable<span style=color:#f92672>[]</span> a) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> N <span style=color:#f92672>=</span> a.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> N; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> i; j <span style=color:#f92672>&gt;</span> 0 <span style=color:#f92672>&amp;&amp;</span> less(a<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span>, a<span style=color:#f92672>[</span>j <span style=color:#f92672>-</span> 1<span style=color:#f92672>]</span>); j<span style=color:#f92672>--</span>)
</span></span><span style=display:flex><span>            exch(a, j, j <span style=color:#f92672>-</span> 1);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li>Selection sort is <strong>not</strong> stable: Long-distance exchange might move an item past some equal item.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>selectionSort</span>(Comparable<span style=color:#f92672>[]</span> a) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> N <span style=color:#f92672>=</span> a.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> N; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> min <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> 1; j <span style=color:#f92672>&lt;</span> N; j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (less(a<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span>, a<span style=color:#f92672>[</span>min<span style=color:#f92672>]</span>))
</span></span><span style=display:flex><span>                min <span style=color:#f92672>=</span> j;
</span></span><span style=display:flex><span>        exch(a, i, min);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li>Shellsort is <strong>not</strong> stable: Long-distence exchange.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>shellSort</span>(Comparable<span style=color:#f92672>[]</span> a) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> N <span style=color:#f92672>=</span> a.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> h <span style=color:#f92672>=</span> 1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (h <span style=color:#f92672>&lt;</span> N <span style=color:#f92672>/</span> 3) h <span style=color:#f92672>=</span> 3 <span style=color:#f92672>*</span> h <span style=color:#f92672>+</span> 1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (h <span style=color:#f92672>&gt;=</span> 1) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> h; i <span style=color:#f92672>&lt;</span> N; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> i; j <span style=color:#f92672>&gt;</span> h <span style=color:#f92672>&amp;&amp;</span> less(a<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span>, a<span style=color:#f92672>[</span>j <span style=color:#f92672>-</span> h<span style=color:#f92672>]</span>); j <span style=color:#f92672>-=</span> h)
</span></span><span style=display:flex><span>                exch(a, j, j <span style=color:#f92672>-</span> h);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        h <span style=color:#f92672>/=</span> 3;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li>Mergesort is <strong>stable</strong>.: Suffices to verify that merge operation is table.</li></ul><h3 id=222>2.2.2</h3><p>Give traces, in the style of the trace given with Algorithm 2.4, showing how the
keys E A S Y Q U E S T I O N are sorted with top-down mergesort.</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th>a[]</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>lo</td><td>mid</td><td>hi</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td></tr><tr><td></td><td></td><td></td><td>E</td><td>A</td><td>S</td><td>Y</td><td>Q</td><td>U</td><td>E</td><td>S</td><td>T</td><td>I</td><td>O</td><td>N</td></tr><tr><td>0</td><td>0</td><td>1</td><td><strong>A</strong></td><td><strong>E</strong></td><td>S</td><td>Y</td><td>Q</td><td>U</td><td>E</td><td>S</td><td>T</td><td>I</td><td>O</td><td>N</td></tr><tr><td>0</td><td>1</td><td>2</td><td><strong>A</strong></td><td><strong>E</strong></td><td><strong>S</strong></td><td>Y</td><td>Q</td><td>U</td><td>E</td><td>S</td><td>T</td><td>I</td><td>O</td><td>N</td></tr><tr><td>3</td><td>3</td><td>4</td><td>A</td><td>E</td><td>S</td><td><strong>Q</strong></td><td><strong>Y</strong></td><td>U</td><td>E</td><td>S</td><td>T</td><td>I</td><td>O</td><td>N</td></tr><tr><td>3</td><td>4</td><td>5</td><td>A</td><td>E</td><td>S</td><td><strong>Q</strong></td><td><strong>U</strong></td><td><strong>Y</strong></td><td>E</td><td>S</td><td>T</td><td>I</td><td>O</td><td>N</td></tr><tr><td>0</td><td>2</td><td>5</td><td><strong>A</strong></td><td><strong>E</strong></td><td><strong>Q</strong></td><td><strong>S</strong></td><td><strong>U</strong></td><td><strong>Y</strong></td><td>E</td><td>S</td><td>T</td><td>I</td><td>O</td><td>N</td></tr><tr><td>6</td><td>6</td><td>7</td><td>A</td><td>E</td><td>Q</td><td>S</td><td>U</td><td>Y</td><td><strong>E</strong></td><td><strong>S</strong></td><td>T</td><td>I</td><td>O</td><td>N</td></tr><tr><td>6</td><td>7</td><td>8</td><td>A</td><td>E</td><td>Q</td><td>S</td><td>U</td><td>Y</td><td><strong>E</strong></td><td><strong>S</strong></td><td><strong>T</strong></td><td>I</td><td>O</td><td>N</td></tr><tr><td>9</td><td>9</td><td>10</td><td>A</td><td>E</td><td>Q</td><td>S</td><td>U</td><td>Y</td><td>E</td><td>S</td><td>T</td><td><strong>I</strong></td><td><strong>O</strong></td><td>N</td></tr><tr><td>9</td><td>10</td><td>11</td><td>A</td><td>E</td><td>Q</td><td>S</td><td>U</td><td>Y</td><td>E</td><td>S</td><td>T</td><td><strong>I</strong></td><td><strong>N</strong></td><td><strong>O</strong></td></tr><tr><td>6</td><td>8</td><td>11</td><td>A</td><td>E</td><td>Q</td><td>S</td><td>U</td><td>Y</td><td><strong>E</strong></td><td><strong>I</strong></td><td><strong>N</strong></td><td><strong>O</strong></td><td><strong>S</strong></td><td><strong>T</strong></td></tr><tr><td>0</td><td>5</td><td>11</td><td><strong>A</strong></td><td><strong>E</strong></td><td><strong>E</strong></td><td><strong>I</strong></td><td><strong>N</strong></td><td><strong>O</strong></td><td><strong>Q</strong></td><td><strong>S</strong></td><td><strong>S</strong></td><td><strong>T</strong></td><td><strong>U</strong></td><td><strong>Y</strong></td></tr><tr><td></td><td></td><td></td><td>A</td><td>E</td><td>E</td><td>I</td><td>N</td><td>O</td><td>Q</td><td>S</td><td>S</td><td>T</td><td>U</td><td>Y</td></tr></tbody></table><h3 id=223>2.2.3</h3><p>Answer Exercise 2.2.2 for bottom-up mergesort.</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th>a[]</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>lo</td><td>mid</td><td>hi</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td></tr><tr><td></td><td></td><td></td><td>E</td><td>A</td><td>S</td><td>Y</td><td>Q</td><td>U</td><td>E</td><td>S</td><td>T</td><td>I</td><td>O</td><td>N</td></tr><tr><td>0</td><td>0</td><td>1</td><td><strong>A</strong></td><td><strong>E</strong></td><td>S</td><td>Y</td><td>Q</td><td>U</td><td>E</td><td>S</td><td>T</td><td>I</td><td>O</td><td>N</td></tr><tr><td>2</td><td>2</td><td>3</td><td>A</td><td>E</td><td><strong>S</strong></td><td><strong>Y</strong></td><td>Q</td><td>U</td><td>E</td><td>S</td><td>T</td><td>I</td><td>O</td><td>N</td></tr><tr><td>4</td><td>4</td><td>5</td><td>A</td><td>E</td><td>S</td><td>Y</td><td><strong>Q</strong></td><td><strong>U</strong></td><td>E</td><td>S</td><td>T</td><td>I</td><td>O</td><td>N</td></tr><tr><td>6</td><td>6</td><td>7</td><td>A</td><td>E</td><td>S</td><td>Y</td><td>Q</td><td>U</td><td><strong>E</strong></td><td><strong>S</strong></td><td>T</td><td>I</td><td>O</td><td>N</td></tr><tr><td>8</td><td>8</td><td>9</td><td>A</td><td>E</td><td>S</td><td>Y</td><td>Q</td><td>U</td><td>E</td><td>S</td><td><strong>I</strong></td><td><strong>T</strong></td><td>O</td><td>N</td></tr><tr><td>10</td><td>10</td><td>11</td><td>A</td><td>E</td><td>S</td><td>Y</td><td>Q</td><td>U</td><td>E</td><td>S</td><td>I</td><td>T</td><td><strong>N</strong></td><td><strong>O</strong></td></tr><tr><td>0</td><td>1</td><td>3</td><td><strong>A</strong></td><td><strong>E</strong></td><td><strong>S</strong></td><td><strong>Y</strong></td><td>Q</td><td>U</td><td>E</td><td>S</td><td>I</td><td>T</td><td>N</td><td>O</td></tr><tr><td>4</td><td>5</td><td>7</td><td>A</td><td>E</td><td>S</td><td>Y</td><td><strong>E</strong></td><td><strong>Q</strong></td><td><strong>S</strong></td><td><strong>U</strong></td><td>I</td><td>T</td><td>N</td><td>O</td></tr><tr><td>8</td><td>9</td><td>11</td><td>A</td><td>E</td><td>S</td><td>Y</td><td>E</td><td>Q</td><td>S</td><td>U</td><td><strong>I</strong></td><td><strong>N</strong></td><td><strong>O</strong></td><td><strong>T</strong></td></tr><tr><td>0</td><td>3</td><td>7</td><td><strong>A</strong></td><td><strong>E</strong></td><td><strong>E</strong></td><td><strong>Q</strong></td><td><strong>S</strong></td><td><strong>S</strong></td><td><strong>U</strong></td><td><strong>Y</strong></td><td><strong>I</strong></td><td>N</td><td>O</td><td>T</td></tr><tr><td>0</td><td>7</td><td>11</td><td><strong>A</strong></td><td><strong>E</strong></td><td><strong>E</strong></td><td><strong>I</strong></td><td><strong>N</strong></td><td><strong>O</strong></td><td><strong>Q</strong></td><td><strong>S</strong></td><td><strong>S</strong></td><td><strong>T</strong></td><td><strong>U</strong></td><td><strong>Y</strong></td></tr><tr><td></td><td></td><td></td><td>A</td><td>E</td><td>E</td><td>I</td><td>N</td><td>O</td><td>Q</td><td>S</td><td>S</td><td>T</td><td>U</td><td>Y</td></tr></tbody></table><h3 id=224>2.2.4</h3><p>Does the abstract in-place merge produce proper output if and only if the two input subarrays are in sorted order? Prove your answer, or provide a counterexample.(是否当且仅当两个输入的数组都有序时原地归并的抽象方法才能得到正确的结果？证明你的结论，或者给出一个反例。)</p><ul><li>是的，只有当两个输入数组都有序时采用原地归并才能得到正确的结果。</li><li>反例：数组1：[4, 2, 3],数组2：[1, 5, 8];<br>按归并算法归并后得到[1,4,2,3,5,8]; 可以看到归并后元素的相对位置不变，故得到错误的结果。</li></ul><h3 id=225>2.2.5</h3><p>Give the sequence of subarray sizes in the merges performed by both the top-down and the bottom-up mergesort algorithms, for N = 39.
(当输入数组的大小N=39时，给出自顶向下和自底向上的归并排序中各归并子数组的大小及顺序。)</p><h4 id=自顶向下>自顶向下</h4><p>2, 3, 2, 5, 2, 3, 2, 5, 10, 2, 3, 2, 5, 2, 3, 2, 5, 10, 20, 2, 3, 2, 5, 2, 3, 2, 5, 10, 2, 3, 2, 5, 2, 2, 4, 9, 19, 39</p><h4 id=自底向上>自底向上</h4><p>2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 8, 8, 8, 8, 7, 16, 16, 32, 39</p><h2 id=quicksort>QuickSort</h2><h3 id=quicksort-1>quicksort</h3><p>Basic plan:</p><ul><li><strong>Shuffle</strong> the array</li><li><strong>Partition</strong> so that, for some j<ul><li>entry a[j] in place</li><li>no larger entry to the left of j</li><li>no smaller entry to the right of j</li></ul></li><li><strong>Sort</strong> each piece recursively.</li></ul><h4 id=java-implementation-1>Java implementation</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Quick</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>less</span>(Comparable v, Comparable w) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> v.<span style=color:#a6e22e>compareTo</span>(w) <span style=color:#f92672>&lt;</span> 0;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>exch</span>(Comparable<span style=color:#f92672>[]</span> a, <span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> j) {
</span></span><span style=display:flex><span>        Comparable t <span style=color:#f92672>=</span> a<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        a<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> a<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        a<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> t;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>partition</span>(Comparable<span style=color:#f92672>[]</span> a, <span style=color:#66d9ef>int</span> lo, <span style=color:#66d9ef>int</span> hi) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> lo, j <span style=color:#f92672>=</span> hi <span style=color:#f92672>+</span> 1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (less(a<span style=color:#f92672>[++</span>i<span style=color:#f92672>]</span>, a<span style=color:#f92672>[</span>lo<span style=color:#f92672>]</span>))
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>==</span> hi) <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (less(a<span style=color:#f92672>[</span>lo<span style=color:#f92672>]</span>, a<span style=color:#f92672>[--</span>j<span style=color:#f92672>]</span>))
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (j <span style=color:#f92672>==</span> lo) <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&gt;=</span> j) <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            exch(a, i, j);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        exch(a, lo, j);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> j;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(Comparable<span style=color:#f92672>[]</span> a) {
</span></span><span style=display:flex><span>        StdRandom.<span style=color:#a6e22e>shuffle</span>(a);
</span></span><span style=display:flex><span>        sort(a, 0, a.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> 1);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(Comparable<span style=color:#f92672>[]</span> a, <span style=color:#66d9ef>int</span> lo, <span style=color:#66d9ef>int</span> hi) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (lo <span style=color:#f92672>&gt;=</span> hi) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> partition(a, lo, hi);
</span></span><span style=display:flex><span>        sort(a, lo, j <span style=color:#f92672>-</span> 1);
</span></span><span style=display:flex><span>        sort(a, j <span style=color:#f92672>+</span> 1, hi);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=average-case-analysis>average-case analysis</h3><p>$C_N $ satisfies the recurrence $C_0 = C_1=0$ and for $ N\ge 2 $:<br>$$ C_N = (N + 1) + (\frac{C_0+C_{N-1}}{N})+ (\frac{C_1+C_{N-2}}{N})+ &mldr; +(\frac{C_{N-1}+C_{0{N}}}) $$</p><ul><li><p>Multiply both sides by N and collect terms:
$$ NC_N = N(N+1)+2(C_0+C_1+&mldr;+C_{N-1}) $$</p></li><li><p>Substract this from the same equation for $N - 1$:
$$ NC_N-(N-1)C_{N-1}=2N+2C_{N-1} $$</p></li><li><p>Rearrage terms and devide by $N(N+1)$:
$$ \frac{C_N}{N+1} = \frac{C_{N-1{N}}} + \frac{2}{N+1} $$</p></li><li><p>Repeatedly apply above equation:
$$
\begin{aligned}
\frac{C_N}{N+1} &= \frac{C_{N-1}}{N}+\frac{2}{N+1} \cr
&= \frac{C_{N-2}}{N-1}+\frac{2}{N}+\frac{2}{N+1} \cr
&= \frac{C_{N-3}}{N-2}+\frac{2}{N-1}+\frac{2}{N}+\frac{2}{N+1} \cr
&= \frac 2 3 + \frac 2 4 + \frac 2 5 +&mldr;+\frac 2 {N+1}
\end{aligned}
$$</p></li><li><p>Approximate sum by an integral:
$$
\begin{aligned}
C_N &= 2(N+1)(\frac 1 3 + \frac 1 4 + \frac 1 5 +&mldr;+ \frac{1}{N+1}) \cr
& \sim 2(N+1) \int_{3}^{N+1}{\frac{1}{x}dx}
\end{aligned}
$$</p></li><li><p>Finally, the desired result:
$$ C_N \sim 2(N+1)lnN \sim 1.39NlgN $$</p></li></ul><h3 id=3-way-quicksort>3-way quicksort</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> threeWayQuickSort(T a[], <span style=color:#66d9ef>int</span> lo, <span style=color:#66d9ef>int</span> hi) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (hi <span style=color:#f92672>&lt;=</span> lo) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> lt <span style=color:#f92672>=</span> lo, gt <span style=color:#f92672>=</span> hi;
</span></span><span style=display:flex><span>    T v <span style=color:#f92672>=</span> a[lo];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> lo;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;=</span> gt) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (a[i] <span style=color:#f92672>&lt;</span> v)
</span></span><span style=display:flex><span>            swap(a[lt<span style=color:#f92672>++</span>], a[i<span style=color:#f92672>++</span>]);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (a[i] <span style=color:#f92672>&gt;</span> v)
</span></span><span style=display:flex><span>            swap(a[gt<span style=color:#f92672>--</span>], a[i]);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    threeWayQuickSort(a, lo, lt <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    threeWayQuickSort(a, gt <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, hi);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=231>2.3.1</h3><p>Show, in the style of the trace given with partition(), how that method patitions the array E A S Y Q U E S T I O N.</p><table><thead><tr><th>i</th><th>j</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th></tr></thead><tbody><tr><td>0</td><td>12</td><td>E</td><td>A</td><td>S</td><td>Y</td><td>Q</td><td>U</td><td>E</td><td>S</td><td>T</td><td>I</td><td>O</td><td>N</td></tr><tr><td>2</td><td>6</td><td>E</td><td>A</td><td>S</td><td>Y</td><td>Q</td><td>U</td><td>E</td><td>S</td><td>T</td><td>I</td><td>O</td><td>N</td></tr><tr><td>2</td><td>6</td><td>E</td><td>A</td><td><strong>E</strong></td><td>Y</td><td>Q</td><td>U</td><td><strong>S</strong></td><td>S</td><td>T</td><td>I</td><td>O</td><td>N</td></tr><tr><td>3</td><td>2</td><td>E</td><td>A</td><td>E</td><td>Y</td><td>Q</td><td>U</td><td>S</td><td>S</td><td>T</td><td>I</td><td>O</td><td>N</td></tr><tr><td></td><td>2</td><td><strong>E</strong></td><td>A</td><td><strong>E</strong></td><td>Y</td><td>Q</td><td>U</td><td>S</td><td>S</td><td>T</td><td>I</td><td>O</td><td>N</td></tr></tbody></table><h3 id=232>2.3.2</h3><p>Show, in the style of the quicksort trace given in this section, how quicksort sorts the array E A S Y Q U E S T I O N (for the purposes of this exercise, ignore the initial shuffle).</p><p><img src=https://s1.ax1x.com/2020/10/27/BlExEV.png alt></p><h3 id=233>2.3.3</h3><p>What is the maximum number of times during the execution of Quick.sort() that the largest item can be exchanged, for an array of length N ?
(对于长度为N的数组，在Quick.sort()执行时，其最大的元素最多会被交换多少次？)</p><p>在Quick.sort()中，一个元素被交换可分为两种情况：</p><ol><li>该元素是枢轴，在partition最后一步和j交换</li><li>该元素在本次partition中不是枢轴，出现在了枢轴错的一侧，需要被交换到另一侧</li></ol><ul><li>如果该元素是枢轴，那么在交换后它的位置就固定下来了，之后不再涉及交换，因此要使交换次数最大，这个元素应该是在每次partition时都位于枢轴错误的一侧，因为是最大的元素，所以应该总是在枢轴的左侧。</li><li>为了使得partition的次数尽可能的多，需要使得每次移动的距离短，这里我们先考虑每次移动一位，如数组[5,9,1,6,7]：<ul><li>枢轴为5，交换后变为[5,1,9,6,7]</li><li>枢轴交换，变为[1,5,9,6,7]</li><li>我们发现在下一次partition中最大元素9会成为枢轴，不再被交换</li></ul></li><li>所以考虑每次移动两位，如数组[2,10,4,1,6,3,8,5,7,9]<ul><li>枢轴为2，交换后[2,1,4,10,6,3,8,5,7,9]</li><li>枢轴交换，变为[1,2,4,10,6,3,8,5,7,9]</li><li>枢轴为4，交换后[1,2,4,3,6,10,8,5,7,9]</li><li>枢轴交换，变为[1,2,3,4,6,10,8,5,7,9]</li><li>枢轴为6，交换后[1,2,3,4,6,5,8,10,7,9]</li><li>枢轴交换，变为[1,2,3,4,5,6,8,10,7,9]</li><li>枢轴为8，交换后[1,2,3,4,5,6,8,7,10,9]</li><li>枢轴交换，变为[1,2,3,4,5,6,7,8,10,9]</li><li>枢轴为10，交换后[1,2,3,4,5,6,7,8,9,10]</li></ul></li><li>在上面这个N=10的数组中，“10”这个最大的元素一共被交换了5次，所以我们可以认为对于N个元素的数组，在执行Quick.sort()时最大元素最多会被交换N/2次。</li></ul><h3 id=234>2.3.4</h3><p>Suppose that the initial random shuffle is omitted. Give six arrays of ten elements
for which Quick.sort() uses the worst-case number of compares.</p><p>如果始终选第一个元素作为枢轴的话，要使比较次数达到最坏情况的话，输入数组应为升序。比较次数达到$ N + N-1 + N-2 + N-3 +&mldr;+1 = \frac{N(N+1)}{2} \sim N^2/2 $
例如：</p><ul><li>[1,2,3,4,5,6,7,8,9,10]</li><li>[2,4,6,8,10,12,14,16,18,20]</li><li>[-1,1,3,5,7,9,11,13,15,17]</li><li>[10,20,30,40,50,60,70,80,90,100]</li><li>[5,10,15,20,25,30,35,40,45,50]</li><li>[0,2,3,4,6,7,8,9,10,12]</li></ul><h3 id=235>2.3.5</h3><p>Give a code fragment that sorts an array that is known to consist of items having
just two distinct keys.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(Comparable<span style=color:#f92672>[]</span> a) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> lo <span style=color:#f92672>=</span> 0, hi <span style=color:#f92672>=</span> a.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> 1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;=</span> hi) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> tmp <span style=color:#f92672>=</span> a<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>.<span style=color:#a6e22e>compareTo</span>(a<span style=color:#f92672>[</span>lo<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (tmp <span style=color:#f92672>&lt;</span> 0) exch(a, lo<span style=color:#f92672>++</span>, i<span style=color:#f92672>++</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (tmp <span style=color:#f92672>&gt;</span> 0) exch(a, i, hi<span style=color:#f92672>--</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=priority-queues>Priority Queues</h2><h3 id=api>API</h3><p><img src=https://s1.ax1x.com/2020/11/05/BWuxX9.png alt></p><h3 id=binary-heap>binary-heap</h3><h4 id=java-implementation-2>Java implementation</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MaxPQ</span><span style=color:#f92672>&lt;</span>Key <span style=color:#66d9ef>extends</span> Comparable<span style=color:#f92672>&lt;</span>Key<span style=color:#f92672>&gt;&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Key<span style=color:#f92672>[]</span> pq;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> N <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>MaxPQ</span>(<span style=color:#66d9ef>int</span> maxN) {
</span></span><span style=display:flex><span>        pq <span style=color:#f92672>=</span> (Key<span style=color:#f92672>[]</span>) <span style=color:#66d9ef>new</span> Comparable<span style=color:#f92672>[</span>maxN <span style=color:#f92672>+</span> 1<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isEmpty</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> N <span style=color:#f92672>==</span> 0;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>size</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> N;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert</span>(Key v) {
</span></span><span style=display:flex><span>        pq<span style=color:#f92672>[++</span>N<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> v;
</span></span><span style=display:flex><span>        swim(N);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Key <span style=color:#a6e22e>delMax</span>() {
</span></span><span style=display:flex><span>        Key max <span style=color:#f92672>=</span> pq<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        exch(1, N<span style=color:#f92672>--</span>);
</span></span><span style=display:flex><span>        sink(1);
</span></span><span style=display:flex><span>        pq<span style=color:#f92672>[</span>N<span style=color:#f92672>+</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> max;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>less</span>(<span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> j) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> pq<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>.<span style=color:#a6e22e>compareTo</span>(pq<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span>) <span style=color:#f92672>&lt;</span> 0;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>exch</span>(<span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> j) {
</span></span><span style=display:flex><span>        Key tmp <span style=color:#f92672>=</span> pq<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        pq<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> pq<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        pq<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> tmp;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>swim</span>(<span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (k <span style=color:#f92672>&gt;</span> 1 <span style=color:#f92672>&amp;&amp;</span> less(k <span style=color:#f92672>/</span> 2, k)) {
</span></span><span style=display:flex><span>            exch(k <span style=color:#f92672>/</span> 2, k);
</span></span><span style=display:flex><span>            k <span style=color:#f92672>/=</span> 2;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sink</span>(<span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (2 <span style=color:#f92672>*</span> k <span style=color:#f92672>&lt;=</span> N) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> 2 <span style=color:#f92672>*</span> k;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (j <span style=color:#f92672>&lt;</span> N <span style=color:#f92672>&amp;&amp;</span> less(j, j <span style=color:#f92672>+</span> 1)) j<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>less(k, j)) <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            exch(k, j);
</span></span><span style=display:flex><span>            k <span style=color:#f92672>=</span> j;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=heapsort>heapsort</h3><h4 id=basic-plan-for-in-place-sort>Basic plan for in-place sort</h4><ul><li>Create max-heap with all N keys.</li><li>Repatedly remove the maximum key.</li></ul><h4 id=java-implementation-3>Java implementation</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Heap</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(Comparable<span style=color:#f92672>[]</span> a) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> N <span style=color:#f92672>=</span> a.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> N <span style=color:#f92672>/</span> 2; k <span style=color:#f92672>&gt;=</span> 1; k<span style=color:#f92672>--</span>)
</span></span><span style=display:flex><span>            sink(a, k, N);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (N <span style=color:#f92672>&gt;</span> 1) {
</span></span><span style=display:flex><span>            exch(a, 1, N);
</span></span><span style=display:flex><span>            sink(a, 1, <span style=color:#f92672>--</span>N);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>less</span>(Comparable a<span style=color:#f92672>[]</span>, <span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> j) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> a<span style=color:#f92672>[</span>i <span style=color:#f92672>-</span> 1<span style=color:#f92672>]</span>.<span style=color:#a6e22e>compareTo</span>(a<span style=color:#f92672>[</span>j <span style=color:#f92672>-</span> 1<span style=color:#f92672>]</span>) <span style=color:#f92672>&lt;</span> 0;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>exch</span>(Comparable a<span style=color:#f92672>[]</span>, <span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> j) {
</span></span><span style=display:flex><span>        Comparable t <span style=color:#f92672>=</span> a<span style=color:#f92672>[</span>i <span style=color:#f92672>-</span> 1<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        a<span style=color:#f92672>[</span>i <span style=color:#f92672>-</span> 1<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> a<span style=color:#f92672>[</span>j <span style=color:#f92672>-</span> 1<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        a<span style=color:#f92672>[</span>j <span style=color:#f92672>-</span> 1<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> t;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sink</span>(Comparable<span style=color:#f92672>[]</span> a, <span style=color:#66d9ef>int</span> k, <span style=color:#66d9ef>int</span> N) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (2 <span style=color:#f92672>*</span> k <span style=color:#f92672>&lt;=</span> N) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> 2 <span style=color:#f92672>*</span> k;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (j <span style=color:#f92672>&lt;</span> N <span style=color:#f92672>&amp;&amp;</span> less(a, j, j <span style=color:#f92672>+</span> 1)) j<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>less(a, k, j)) <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            exch(a, k, j);
</span></span><span style=display:flex><span>            k <span style=color:#f92672>=</span> j;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=mathematical-analysis>mathematical analysis</h4><ul><li><p>Proposition. Heap construction uses $ \le 2N $ compares and exchanges.</p></li><li><p>Proposition. Heapsort uses $ \le 2NlgN $ compares and exchanges.</p></li><li><p>Significance. In-place sorting algorithm with $ NlgN $ worst-case.</p><ul><li>Mergesort: no, linear extra space.</li><li>Quicksort: no, quadratic time in worst case.</li><li>Heapsort: yes!</li></ul></li><li><p>Bottom line. Heapsort is optimal for both time and space but:</p><ul><li>Inner loop longer than quicksort&rsquo;s.</li><li>Makes poor use of cache memory.</li><li>Not stable.</li></ul></li></ul><h4 id=sorting-algorithms-summary>sorting-algorithms: summary</h4><p><img src=https://s1.ax1x.com/2020/11/06/BWX9N6.png alt></p><h3 id=242>2.4.2</h3><p>Criticize the following idea: To implement find the maximum in constant time, why not use a stack or a queue, but keep track of the maximum value inserted so far, then return that value for find the maximum?</p><p>如果用这种方法，当最大元素被删除之后，不能在常量时间内更新最大元素</p><h3 id=243>2.4.3</h3><p>Provide priority-queue implementations that support insert and remove the maximum, one for each of the following underlying data structures: unordered array, ordered array, unordered linked list, and linked list. Give a table of the worst-case bounds for each operation for each of your four implementations.</p><h4 id=数组实现>数组实现</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ArrayPQ</span><span style=color:#f92672>&lt;</span>Key <span style=color:#66d9ef>extends</span> Comparable<span style=color:#f92672>&lt;</span>Key<span style=color:#f92672>&gt;&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> Key<span style=color:#f92672>[]</span> pq;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>ArrayPQ</span>(<span style=color:#66d9ef>int</span> capacity) {
</span></span><span style=display:flex><span>        pq <span style=color:#f92672>=</span> (Key<span style=color:#f92672>[]</span>) <span style=color:#66d9ef>new</span> Comparable<span style=color:#f92672>[</span>capacity<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isEmpty</span>() {<span style=color:#66d9ef>return</span> n <span style=color:#f92672>==</span> 0;}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>size</span>() {<span style=color:#66d9ef>return</span> n;}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert</span>(Key x);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> Key <span style=color:#a6e22e>delMax</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>less</span>(<span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> j) {<span style=color:#66d9ef>return</span> pq<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>.<span style=color:#a6e22e>compareTo</span>(pq<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span>) <span style=color:#f92672>&lt;</span> 0; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>exch</span>(<span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> j) {
</span></span><span style=display:flex><span>        Key t <span style=color:#f92672>=</span> pq<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        pq<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> pq<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        pq<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> t;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        OrderedArrayMaxPQ pq <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> OrderedArrayMaxPQ(10);
</span></span><span style=display:flex><span>        pq.<span style=color:#a6e22e>insert</span>(<span style=color:#e6db74>&#34;this&#34;</span>);
</span></span><span style=display:flex><span>        pq.<span style=color:#a6e22e>insert</span>(<span style=color:#e6db74>&#34;is&#34;</span>);
</span></span><span style=display:flex><span>        pq.<span style=color:#a6e22e>insert</span>(<span style=color:#e6db74>&#34;a&#34;</span>);
</span></span><span style=display:flex><span>        pq.<span style=color:#a6e22e>insert</span>(<span style=color:#e6db74>&#34;test&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>pq.<span style=color:#a6e22e>isEmpty</span>())
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(pq.<span style=color:#a6e22e>delMax</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UnorderedArrayMaxPQ</span><span style=color:#f92672>&lt;</span>Key <span style=color:#66d9ef>extends</span> Comparable<span style=color:#f92672>&lt;</span>Key<span style=color:#f92672>&gt;&gt;</span> <span style=color:#66d9ef>extends</span> ArrayPQ<span style=color:#f92672>&lt;</span>Key<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>UnorderedArrayMaxPQ</span>(<span style=color:#66d9ef>int</span> capacity) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>(capacity);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert</span>(Key x) {
</span></span><span style=display:flex><span>        pq<span style=color:#f92672>[</span>n<span style=color:#f92672>++]</span> <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Key <span style=color:#a6e22e>delMax</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> max <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (less(max, i)) max <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>            exch(max, n<span style=color:#f92672>-</span>1);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> pq<span style=color:#f92672>[--</span>n<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OrderedArrayMaxPQ</span><span style=color:#f92672>&lt;</span>Key <span style=color:#66d9ef>extends</span> Comparable<span style=color:#f92672>&lt;</span>Key<span style=color:#f92672>&gt;&gt;</span> <span style=color:#66d9ef>extends</span> ArrayPQ<span style=color:#f92672>&lt;</span>Key<span style=color:#f92672>&gt;</span>{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>OrderedArrayMaxPQ</span>(<span style=color:#66d9ef>int</span> capacity) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>(capacity);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert</span>(Key x) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> n <span style=color:#f92672>-</span> 1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&gt;=</span> 0 <span style=color:#f92672>&amp;&amp;</span> x.<span style=color:#a6e22e>compareTo</span>(pq<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>) <span style=color:#f92672>&lt;</span> 0) {
</span></span><span style=display:flex><span>            pq<span style=color:#f92672>[</span>i<span style=color:#f92672>+</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> pq<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>            i<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        pq<span style=color:#f92672>[</span>i<span style=color:#f92672>+</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span>        n<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Key <span style=color:#a6e22e>delMax</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> pq<span style=color:#f92672>[--</span>n<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=链表实现>链表实现</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LinkedListPQ</span><span style=color:#f92672>&lt;</span>Key <span style=color:#66d9ef>extends</span> Comparable<span style=color:#f92672>&lt;</span>Key<span style=color:#f92672>&gt;&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> LinkedList<span style=color:#f92672>&lt;</span>Key<span style=color:#f92672>&gt;</span> pq;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>LinkedListPQ</span>() {
</span></span><span style=display:flex><span>        pq <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LinkedList<span style=color:#f92672>&lt;</span>Key<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isEmpty</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> pq.<span style=color:#a6e22e>size</span>() <span style=color:#f92672>==</span> 0;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>size</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> pq.<span style=color:#a6e22e>size</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert</span>(Key x);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> Key <span style=color:#a6e22e>delMax</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>less</span>(Key a, Key b) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> a.<span style=color:#a6e22e>compareTo</span>(b) <span style=color:#f92672>&lt;</span> 0;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        UnorderedLinkedMaxPQ pq <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> UnorderedLinkedMaxPQ();
</span></span><span style=display:flex><span>        pq.<span style=color:#a6e22e>insert</span>(<span style=color:#e6db74>&#34;this&#34;</span>);
</span></span><span style=display:flex><span>        pq.<span style=color:#a6e22e>insert</span>(<span style=color:#e6db74>&#34;is&#34;</span>);
</span></span><span style=display:flex><span>        pq.<span style=color:#a6e22e>insert</span>(<span style=color:#e6db74>&#34;a&#34;</span>);
</span></span><span style=display:flex><span>        pq.<span style=color:#a6e22e>insert</span>(<span style=color:#e6db74>&#34;test&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>pq.<span style=color:#a6e22e>isEmpty</span>())
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(pq.<span style=color:#a6e22e>delMax</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UnorderedLinkedMaxPQ</span><span style=color:#f92672>&lt;</span>Key <span style=color:#66d9ef>extends</span> Comparable<span style=color:#f92672>&lt;</span>Key<span style=color:#f92672>&gt;&gt;</span> <span style=color:#66d9ef>extends</span> LinkedListPQ<span style=color:#f92672>&lt;</span>Key<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert</span>(Key x) {
</span></span><span style=display:flex><span>        pq.<span style=color:#a6e22e>addLast</span>(x);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Key <span style=color:#a6e22e>delMax</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> idx <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> max <span style=color:#f92672>=</span> pq.<span style=color:#a6e22e>getFirst</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>var</span> e : pq) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (less(max, e)) {
</span></span><span style=display:flex><span>                max <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>                idx <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        pq.<span style=color:#a6e22e>remove</span>(idx);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> max;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OrderedLinkedMaxPQ</span><span style=color:#f92672>&lt;</span>Key <span style=color:#66d9ef>extends</span> Comparable<span style=color:#f92672>&lt;</span>Key<span style=color:#f92672>&gt;&gt;</span> <span style=color:#66d9ef>extends</span> LinkedListPQ<span style=color:#f92672>&lt;</span>Key<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>OrderedLinkedMaxPQ</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert</span>(Key x) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>        Iterator it <span style=color:#f92672>=</span> pq.<span style=color:#a6e22e>iterator</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (it.<span style=color:#a6e22e>hasNext</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (less(x, (Key) it.<span style=color:#a6e22e>next</span>())) <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        pq.<span style=color:#a6e22e>add</span>(i, x);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(i <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;  eee &#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Key <span style=color:#a6e22e>delMax</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> pq.<span style=color:#a6e22e>removeLast</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=the-worst-case-bounds>the worst-case bounds</h4><table><thead><tr><th></th><th>insert()</th><th>delMax()</th></tr></thead><tbody><tr><td>无序数组</td><td>1</td><td>N</td></tr><tr><td>有序数组</td><td>N</td><td>1</td></tr><tr><td>无序链表</td><td>1</td><td>N</td></tr><tr><td>有序链表</td><td>N</td><td>1</td></tr></tbody></table><h3 id=245>2.4.5</h3><p>Give the heap that results when the keys E A S Y Q U E S T I O N are inserted in that order into an initially empty max-oriented heap.</p><p><img src=https://s1.ax1x.com/2020/11/06/BhYuEF.jpg alt></p><h3 id=247>2.4.7</h3><p>The largest item in a heap must appear in position 1, and the second largest must be in position 2 or position 3. Give the list of positions in a heap of size 31 where the kth largest (i) can appear, and (ii) cannot appear, for k=2, 3, 4 (assuming the values to be distinct).</p><ul><li>k = 2：可能出现在2，3；不可能出现在1, 4~31</li><li>k = 3：可能出现在2，3，4，5，6，7；不可能出现在1,8~31</li><li>k = 4：可能出现在2，3，4，5，6，7，8，9，10，11，12，13，14，15，不可能出现在1，16~31</li></ul><p>第k大元素只可能出现在深度不大于k的位置($ position \le 2^k-1 ,k \ge 2$)</p><h3 id=249>2.4.9</h3><p>Draw all of the different heaps that can be made from the five keys A B C D E, then draw all of the different heaps that can be made from the five keys A A A B B.</p><h4 id=a-b-c-d-e>A B C D E</h4><ul><li>最大堆
<img src=https://s1.ax1x.com/2020/11/06/BhwOIK.jpg alt></li><li>最小堆
<img src=https://s1.ax1x.com/2020/11/06/BhwjPO.jpg alt></li></ul><h4 id=a-a-a-b-b>A A A B B</h4><p><img src=https://s1.ax1x.com/2020/11/06/BhBAmR.jpg alt></p><h3 id=2411>2.4.11</h3><p>Suppose that your application will have a huge number of insert operations, but only a few remove the maximum operations. Which priority-queue implementation do you think would be most effective: heap, unordered array, or ordered array?</p><p>因为有大量的insert操作和很少的delMax操作，而heap, unordered array, ordered array实现的Priority Queue insert操作的花费时间的数量级分别为lgN, 1, N, 所以unordered array是最有效的。</p><h3 id=2412>2.4.12</h3><p>Suppose that your application will have a huge number of find the maximum operations, but a relatively small number of insert and remove the maximum operations. Which priority-queue implementation do you think would be most effective: heap, unordered array, or ordered array?</p><p>大量的查找最大元素，heap和ordered array查找最大元素都是常量时间，但heap插入和删除最大元素都是lgN，而ordered array插入和删除分别是N和常量时间，综合下来，heap是最有效的。</p><h2 id=undirected-graphs>UNDIRECTED GRAPHS</h2><h3 id=depth-first-search>depth-first-search</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DepthFirstPaths</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span><span style=color:#f92672>[]</span> marked;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> edgeTo;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> s;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>DepthFirstPaths</span>(Graph G,<span style=color:#66d9ef>int</span> s) {
</span></span><span style=display:flex><span>        marked <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>boolean</span><span style=color:#f92672>[</span>G.<span style=color:#a6e22e>V</span>()<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        edgeTo <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>G.<span style=color:#a6e22e>V</span>()<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        Arrays.<span style=color:#a6e22e>fill</span>(marked, <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>s</span> <span style=color:#f92672>=</span> s;
</span></span><span style=display:flex><span>        dfs(G, s);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dfs</span>(Graph G, <span style=color:#66d9ef>int</span> v) {
</span></span><span style=display:flex><span>        marked<span style=color:#f92672>[</span>v<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> w : G.<span style=color:#a6e22e>adj</span>(v)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>marked<span style=color:#f92672>[</span>w<span style=color:#f92672>]</span>) {
</span></span><span style=display:flex><span>                dfs(G, w);
</span></span><span style=display:flex><span>                edgeTo<span style=color:#f92672>[</span>w<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> v;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>hasPathTo</span>(<span style=color:#66d9ef>int</span> v) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> marked<span style=color:#f92672>[</span>v<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Iterable<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>pathTo</span>(<span style=color:#66d9ef>int</span> v) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>hasPathTo(v)) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        Stack<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> path <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Stack<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> v; x <span style=color:#f92672>!=</span> s; x <span style=color:#f92672>=</span> edgeTo<span style=color:#f92672>[</span>x<span style=color:#f92672>]</span>)
</span></span><span style=display:flex><span>            path.<span style=color:#a6e22e>push</span>(x);
</span></span><span style=display:flex><span>        path.<span style=color:#a6e22e>push</span>(s);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> path;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> V <span style=color:#f92672>=</span> StdIn.<span style=color:#a6e22e>readInt</span>();
</span></span><span style=display:flex><span>        Graph g <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Graph(V);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> E <span style=color:#f92672>=</span> StdIn.<span style=color:#a6e22e>readInt</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> E; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            g.<span style=color:#a6e22e>addEdge</span>(StdIn.<span style=color:#a6e22e>readInt</span>(), StdIn.<span style=color:#a6e22e>readInt</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        DepthFirstPaths dfp <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> DepthFirstPaths(g, 0);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>var</span> i : dfp.<span style=color:#a6e22e>pathTo</span>(3)) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(i);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=breadth-first-search>breadth-first-search</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BreadthFirstPaths</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span><span style=color:#f92672>[]</span> marked;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> edgeTo;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> s;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>BreadthFirstPaths</span>(Graph G, <span style=color:#66d9ef>int</span> s) {
</span></span><span style=display:flex><span>        marked <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>boolean</span><span style=color:#f92672>[</span>G.<span style=color:#a6e22e>V</span>()<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        edgeTo <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>G.<span style=color:#a6e22e>V</span>()<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>s</span> <span style=color:#f92672>=</span> s;
</span></span><span style=display:flex><span>        bfs(G, s);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>bfs</span>(Graph G, <span style=color:#66d9ef>int</span> s) {
</span></span><span style=display:flex><span>        Queue<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> Q <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Queue<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        Q.<span style=color:#a6e22e>enqueue</span>(s);
</span></span><span style=display:flex><span>        marked<span style=color:#f92672>[</span>s<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>Q.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> v <span style=color:#f92672>=</span> Q.<span style=color:#a6e22e>dequeue</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> w : G.<span style=color:#a6e22e>adj</span>(v)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>marked<span style=color:#f92672>[</span>w<span style=color:#f92672>]</span>) {
</span></span><span style=display:flex><span>                    Q.<span style=color:#a6e22e>enqueue</span>(w);
</span></span><span style=display:flex><span>                    marked<span style=color:#f92672>[</span>w<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                    edgeTo<span style=color:#f92672>[</span>w<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> v;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>hasPathTo</span>(<span style=color:#66d9ef>int</span> v) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> marked<span style=color:#f92672>[</span>v<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Iterable<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>pathTo</span>(<span style=color:#66d9ef>int</span> v) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>hasPathTo(v)) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        Stack<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> path <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Stack<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> v; i <span style=color:#f92672>!=</span> s; i <span style=color:#f92672>=</span> edgeTo<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>)
</span></span><span style=display:flex><span>            path.<span style=color:#a6e22e>push</span>(i);
</span></span><span style=display:flex><span>        path.<span style=color:#a6e22e>push</span>(s);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> path;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> V <span style=color:#f92672>=</span> StdIn.<span style=color:#a6e22e>readInt</span>();
</span></span><span style=display:flex><span>        Graph g <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Graph(V);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> E <span style=color:#f92672>=</span> StdIn.<span style=color:#a6e22e>readInt</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> E; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            g.<span style=color:#a6e22e>addEdge</span>(StdIn.<span style=color:#a6e22e>readInt</span>(), StdIn.<span style=color:#a6e22e>readInt</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        BreadthFirstPaths bfp <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> BreadthFirstPaths(g, 0);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>var</span> i : bfp.<span style=color:#a6e22e>pathTo</span>(3)) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(i);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=connected-components>connected components</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CC</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span><span style=color:#f92672>[]</span> marked;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> id;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> count;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>CC</span>(Graph G) {
</span></span><span style=display:flex><span>        marked <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>boolean</span><span style=color:#f92672>[</span>G.<span style=color:#a6e22e>V</span>()<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        id <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>G.<span style=color:#a6e22e>V</span>()<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> v <span style=color:#f92672>=</span> 0; v <span style=color:#f92672>&lt;</span> G.<span style=color:#a6e22e>V</span>(); v<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>marked<span style=color:#f92672>[</span>v<span style=color:#f92672>]</span>) {
</span></span><span style=display:flex><span>                dfs(G, v);
</span></span><span style=display:flex><span>                count<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>count</span>() { <span style=color:#66d9ef>return</span> count; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>id</span>(<span style=color:#66d9ef>int</span> v) { <span style=color:#66d9ef>return</span> id<span style=color:#f92672>[</span>v<span style=color:#f92672>]</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dfs</span>(Graph G, <span style=color:#66d9ef>int</span> v) {
</span></span><span style=display:flex><span>        marked<span style=color:#f92672>[</span>v<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        id<span style=color:#f92672>[</span>v<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> count;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> w : G.<span style=color:#a6e22e>adj</span>(v)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>marked<span style=color:#f92672>[</span>w<span style=color:#f92672>]</span>)
</span></span><span style=display:flex><span>                dfs(G, w);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Graph G <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Graph(StdIn.<span style=color:#a6e22e>readInt</span>());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> E <span style=color:#f92672>=</span> StdIn.<span style=color:#a6e22e>readInt</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> E; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            G.<span style=color:#a6e22e>addEdge</span>(StdIn.<span style=color:#a6e22e>readInt</span>(), StdIn.<span style=color:#a6e22e>readInt</span>());
</span></span><span style=display:flex><span>        CC cc <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CC(G);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(cc.<span style=color:#a6e22e>count</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=minimum-spanning-trees>Minimum Spanning Trees</h2><h3 id=greedy-algorithm>Greedy algorithm</h3><h4 id=cut-property>Cut property</h4><ul><li><p>Def: A <strong>cut</strong> in a graph is a partition of its vertices into two(nonempty) sets.</p></li><li><p>Def: A <strong>Crossing edge</strong> connects a vertex in one set with a vertex in the other.</p></li><li><p><strong>Cut property</strong>. Give any cut, the crossing edge of min weight is in the MST</p><ul><li>Pf. Suppose the min-weight crossing edge <em>e</em> is not in the MST<ul><li>Adding <em>e</em> to the MST creates a cycle</li><li>Some other edge <em>f</em> in cycle must be a crossing edge</li><li>Removing <em>f</em> and adding <em>e</em> is also a spanning tree</li><li>Since weight of <em>e</em> is less than the weight of <em>f</em>,that spanning tree is lower weight</li><li>Contradiction</li></ul></li></ul></li></ul><h3 id=kruskals-algorithm>Kruskal&rsquo;s algorithm</h3><p>Consider edges in ascending order of weight.</p><ul><li>Add next edge to tree <em>T</em> unless so doing would create a cycle.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>KruskalMST</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Queue<span style=color:#f92672>&lt;</span>Edge<span style=color:#f92672>&gt;</span> mst <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Queue<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>double</span> weight;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>KruskalMST</span>(EdgeWeightedGraph G) {
</span></span><span style=display:flex><span>        weight <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>        MinPQ<span style=color:#f92672>&lt;</span>Edge<span style=color:#f92672>&gt;</span> pq <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MinPQ<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>var</span> e : G.<span style=color:#a6e22e>edges</span>()) {
</span></span><span style=display:flex><span>            pq.<span style=color:#a6e22e>insert</span>(e);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        UF uf <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> UF(G.<span style=color:#a6e22e>V</span>());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>pq.<span style=color:#a6e22e>isEmpty</span>() <span style=color:#f92672>&amp;&amp;</span> mst.<span style=color:#a6e22e>size</span>() <span style=color:#f92672>&lt;</span> G.<span style=color:#a6e22e>V</span>() <span style=color:#f92672>-</span> 1) {
</span></span><span style=display:flex><span>            Edge e <span style=color:#f92672>=</span> pq.<span style=color:#a6e22e>delMin</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> v <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>either</span>(), w <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>other</span>(v);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>uf.<span style=color:#a6e22e>connected</span>(v, w)) {
</span></span><span style=display:flex><span>                uf.<span style=color:#a6e22e>union</span>(v, w);
</span></span><span style=display:flex><span>                mst.<span style=color:#a6e22e>enqueue</span>(e);
</span></span><span style=display:flex><span>                weight <span style=color:#f92672>+=</span> e.<span style=color:#a6e22e>weight</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Iterable<span style=color:#f92672>&lt;</span>Edge<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>edges</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> mst;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>weight</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> weight;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=prims-algorithm>Prim&rsquo;s algorithm</h3><ul><li>Start with vertex 0 and greedy grow tree <em>T</em></li><li>Add to <em>T</em> the min weight with exactly one endpoint in <em>T</em></li><li>Repeat until <em>V</em>-1 edges</li></ul><h4 id=lazyprim-implementation>LazyPrim Implementation</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LazyPrimMST</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span><span style=color:#f92672>[]</span> marked;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Queue<span style=color:#f92672>&lt;</span>Edge<span style=color:#f92672>&gt;</span> mst;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> MinPQ<span style=color:#f92672>&lt;</span>Edge<span style=color:#f92672>&gt;</span> pq;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>LazyPrimMST</span>(EdgeWeightedGraph G) {
</span></span><span style=display:flex><span>        pq <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MinPQ<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        mst <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Queue<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        marked <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>boolean</span><span style=color:#f92672>[</span>G.<span style=color:#a6e22e>V</span>()<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        visit(G, 0);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>pq.<span style=color:#a6e22e>isEmpty</span>() <span style=color:#f92672>&amp;&amp;</span> mst.<span style=color:#a6e22e>size</span>() <span style=color:#f92672>&lt;</span> G.<span style=color:#a6e22e>V</span>() <span style=color:#f92672>-</span> 1) {
</span></span><span style=display:flex><span>            Edge e <span style=color:#f92672>=</span> pq.<span style=color:#a6e22e>delMin</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> v <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>either</span>(), w <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>other</span>(v);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (marked<span style=color:#f92672>[</span>v<span style=color:#f92672>]</span> <span style=color:#f92672>&amp;&amp;</span> marked<span style=color:#f92672>[</span>w<span style=color:#f92672>]</span>) <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            mst.<span style=color:#a6e22e>enqueue</span>(e);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>marked<span style=color:#f92672>[</span>v<span style=color:#f92672>]</span>) visit(G, v);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>marked<span style=color:#f92672>[</span>w<span style=color:#f92672>]</span>) visit(G, w);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>visit</span>(EdgeWeightedGraph G, <span style=color:#66d9ef>int</span> v) {
</span></span><span style=display:flex><span>        marked<span style=color:#f92672>[</span>v<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (Edge e : G.<span style=color:#a6e22e>adj</span>(v)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>marked<span style=color:#f92672>[</span>e.<span style=color:#a6e22e>other</span>(v)<span style=color:#f92672>]</span>) {
</span></span><span style=display:flex><span>                pq.<span style=color:#a6e22e>insert</span>(e);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Iterable<span style=color:#f92672>&lt;</span>Edge<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>mst</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> mst;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=indexed-priority-queue-implementation>Indexed priority queue implementation</h4><ul><li>Start as same code as MinPQ</li><li>Maintain parallel arrays keys[], pq[], and qp[] so that:<ul><li>keys[i] is the priority of i</li><li>pq[i] is the index of the key in heap position i</li><li>qp[i] is the heap position of the key with index i</li></ul></li><li>Use swim(qp[i]) implement decreaseKey(i, key).
<img src=https://s3.ax1x.com/2020/11/26/DBAWWR.png alt></li></ul><h4 id=eagerprim-implementation>EagerPrim Implementation</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> edu.princeton.cs.algs4.*;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PrimMST</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Edge<span style=color:#f92672>[]</span> edgeTo;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>double</span><span style=color:#f92672>[]</span> distTo;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span><span style=color:#f92672>[]</span> marked;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> IndexMinPQ<span style=color:#f92672>&lt;</span>Double<span style=color:#f92672>&gt;</span> pq;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>PrimMST</span>(EdgeWeightedGraph G) {
</span></span><span style=display:flex><span>        edgeTo <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Edge<span style=color:#f92672>[</span>G.<span style=color:#a6e22e>V</span>()<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        distTo <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>double</span><span style=color:#f92672>[</span>G.<span style=color:#a6e22e>V</span>()<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        marked <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>boolean</span><span style=color:#f92672>[</span>G.<span style=color:#a6e22e>V</span>()<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> v <span style=color:#f92672>=</span> 0; v <span style=color:#f92672>&lt;</span> G.<span style=color:#a6e22e>V</span>(); v<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            distTo<span style=color:#f92672>[</span>v<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> Double.<span style=color:#a6e22e>POSITIVE_INFINITY</span>;
</span></span><span style=display:flex><span>        pq <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> IndexMinPQ<span style=color:#f92672>&lt;&gt;</span>(G.<span style=color:#a6e22e>V</span>());
</span></span><span style=display:flex><span>        distTo<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0.<span style=color:#a6e22e>0</span>;
</span></span><span style=display:flex><span>        pq.<span style=color:#a6e22e>insert</span>(0, 0.<span style=color:#a6e22e>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>pq.<span style=color:#a6e22e>isEmpty</span>())
</span></span><span style=display:flex><span>            visit(G, pq.<span style=color:#a6e22e>delMin</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>visit</span>(EdgeWeightedGraph G, <span style=color:#66d9ef>int</span> v) {
</span></span><span style=display:flex><span>        marked<span style=color:#f92672>[</span>v<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (Edge e : G.<span style=color:#a6e22e>adj</span>(v)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> w <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>other</span>(v);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (marked<span style=color:#f92672>[</span>w<span style=color:#f92672>]</span>) <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (e.<span style=color:#a6e22e>weight</span>() <span style=color:#f92672>&lt;</span> distTo<span style=color:#f92672>[</span>w<span style=color:#f92672>]</span>) {
</span></span><span style=display:flex><span>                edgeTo<span style=color:#f92672>[</span>w<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>                distTo<span style=color:#f92672>[</span>w<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>weight</span>();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (pq.<span style=color:#a6e22e>contains</span>(w)) pq.<span style=color:#a6e22e>change</span>(w, distTo<span style=color:#f92672>[</span>w<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span> pq.<span style=color:#a6e22e>insert</span>(w, distTo<span style=color:#f92672>[</span>w<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Iterable<span style=color:#f92672>&lt;</span>Edge<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>edges</span>() {
</span></span><span style=display:flex><span>        Queue<span style=color:#f92672>&lt;</span>Edge<span style=color:#f92672>&gt;</span> mst  <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Queue<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> v <span style=color:#f92672>=</span> 0; v <span style=color:#f92672>&lt;</span> edgeTo.<span style=color:#a6e22e>length</span>; v<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            Edge e <span style=color:#f92672>=</span> edgeTo<span style=color:#f92672>[</span>v<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (e <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                mst.<span style=color:#a6e22e>enqueue</span>(e);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> mst;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>weight</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> weight <span style=color:#f92672>=</span> 0.<span style=color:#a6e22e>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (Edge e : edges()) {
</span></span><span style=display:flex><span>            weight <span style=color:#f92672>+=</span> e.<span style=color:#a6e22e>weight</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> weight;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=432>4.3.2</h3><p>Draw all of the MSTs of graph depicted at right (all edge weights are equal).</p><p><img src=https://s3.ax1x.com/2020/11/24/DtaE4K.png alt></p><p><img src=https://i.postimg.cc/jSSvhPHK/4-3-2.jpg alt></p><h3 id=433>4.3.3</h3><p>Show that if a graph’s edges all have distinct weights, the MST is unique</p><ul><li>假设无向图G有两棵不同的最小生成树T1和T2</li><li>e是在T1或T2中（但不是同时在两棵树中）最小权值的边，不妨假设e在T1中</li><li>将e添加到T2中会创建一个环C</li><li>在C中至少存在一条边f（但不在T1中，否则会产生环）</li><li>因为e是在T1或T2中（但不是同时在两棵树中）最小权值的边，并且每条边权值都不同</li><li>所以有e.weight &lt; f.weight</li><li>用e代替f，将会产生比原来T2权值更小的生成树，产生了矛盾</li></ul><h3 id=4313>4.3.13</h3><p>Give a counterexample that shows why the following strategy does not necessarily
find the MST: ‘Start with any vertex as a single-vertex MST, then add V-1 edges
to it, always taking next a min-weight edge incident to the vertex most recently added to the MST.’</p><p><img src=https://i.postimg.cc/cL2PZRSL/4-3-13.png alt></p><h2 id=shortest-paths>Shortest Paths</h2><h3 id=shortest-paths-properties>shortest-paths properties</h3><h4 id=data-structures-for-single-source-shortest-paths>Data structures for single-source shortest paths</h4><ul><li><strong>Goal.</strong> Find the shortest-paths from <em>s</em> to every other vertex.</li><li><strong>Observation.</strong> A shortest-paths tree (SPT) solution exists. Why?</li><li><strong>Consequence.</strong> Can represent the SPT with two vertex-indexed arrays:<ul><li>distTo[v] is length of shortest path from <em>s</em> to <em>v</em></li><li>edgeTo[v] is last edge on shortest path from <em>s</em> to <em>v</em></li></ul></li></ul><h4 id=edge-relaxation>Edge relaxation</h4><ul><li>Relax edge <em>e = v->w</em><ul><li>distTo[v] is length of shortest known path from s to v</li><li>distTo[w] is length of shortest known path from s to w</li><li>edgeTo[w] is last edge on shortest known path from s to w</li><li>if e = v->w gives shorter path to w through v, update both distTo[w] and edgeTo[w]
<img src=https://i.postimg.cc/fTbTm0tQ/1.jpg alt></li></ul></li></ul><h4 id=shortest-paths-optimality-conditions>Shortest-paths optimality conditions</h4><ul><li><strong>Proposition.</strong> Let <em>G</em> be an edge-weighted digraph. Then distTo[] are the shortest path distances from s iff:<ul><li>distTo[s] = 0</li><li>For each vertex v, distTo[v] is the length of some path from s to v</li><li>For each edge e = v->w, distTo[w] &lt;= distTo[v] + e.weight().</li></ul></li><li><strong>Pf.</strong><ul><li>suppose that distTo[w] > distTo[v] + e.weight() for some edge e = v->w.</li><li>Then, e gives a path from s to w (through v) of length less than distTo[w].<ul><li>distTo[v1] &lt;= distTo[v0] + e1.weight()</li><li>distTo[v2] &lt;= distTo[v1] + e2.weight()</li><li>&mldr;</li><li>distTo[vk] &lt;= distTo[v(k-1)] + ek.weight()</li></ul></li><li>Add inequalities; simplify; and substitude distTo[v0] = distTo[s] = 0: distTo[w] = distTo[vk] &lt;= e1.weight() + e2.weight() + &mldr; + ek.weight()</li><li>Thus, distTo[w] is the weight of shortest path to w</li></ul></li></ul><h4 id=genertic-shortest-paths-algorithm>Genertic shortest-paths algorithm</h4><ul><li><strong>Proposition.</strong> Genertic algorithm computes SPT(if it exists) from s.</li><li><strong>Pf sketch</strong><ul><li>Throughout algorithm, distTo[v] is the length of a simple path from s to <em>v</em> (and edgeTo[v] is last edge on path)</li><li>Each successful relaxation decreases distTo[v] from some v</li><li>The entry distTo[v] can decrease at most a finite number of times</li></ul></li><li><strong>Efficient implementataions</strong> How to choose which edge to relax?<ul><li>Ex 1. Dijkstra&rsquo;s algorithm (nonnegative weights)</li><li>Ex 2. Topological sort algorithm (no directed cycles)</li><li>Ex 3. Bellman-Ford algorithm (no negative cycles)</li></ul></li></ul><h3 id=dijkstras-algorithm>Dijkstra&rsquo;s algorithm</h3><h4 id=dijkstras-algorithm-demo>Dijkstra&rsquo;s algorithm Demo</h4><p><img src=https://i.postimg.cc/mD7ZT0Xb/pic.gif alt></p><h4 id=correctness-proof>correctness proof</h4><ul><li><p><strong>Proposition.</strong> Dijkstra&rsquo;s algorithm computes a SPT in any edge-weighted diagraph with nonnegative weights.</p></li><li><p><strong>Pf.</strong></p><ul><li>Each edge e = v->w is relaxed exactly once (when v is relaxed), leaving distTo[w] &lt;= distTo[v] + e.weight()</li><li>Inequality hold until algorithm terminates because:<ul><li>distTo[w] cannot increase &lt;- distTo[] values are monotone decreasing</li><li>distTo[v] will not change &lt;- we choose lowest distTo[] value at each step (and edge weights are nonnegative)</li></ul></li><li>Thus, opun termination, shortest-paths optimality conditions hold</li></ul></li></ul><h4 id=java-implementation-4>Java implementation</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DijkstraSP</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> DirectedEdge<span style=color:#f92672>[]</span> edgeTo;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>double</span><span style=color:#f92672>[]</span> distTo;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> IndexMinPQ<span style=color:#f92672>&lt;</span>Double<span style=color:#f92672>&gt;</span> pq;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>DijkstraSP</span>(EdgeWeightedDigraph G, <span style=color:#66d9ef>int</span> s) {
</span></span><span style=display:flex><span>        edgeTo <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> DirectedEdge<span style=color:#f92672>[</span>G.<span style=color:#a6e22e>V</span>()<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        distTo <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>double</span><span style=color:#f92672>[</span>G.<span style=color:#a6e22e>V</span>()<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        pq <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> IndexMinPQ<span style=color:#f92672>&lt;</span>Double<span style=color:#f92672>&gt;</span>(G.<span style=color:#a6e22e>V</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> v <span style=color:#f92672>=</span> 0; v <span style=color:#f92672>&lt;</span> G.<span style=color:#a6e22e>V</span>(); v<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            distTo<span style=color:#f92672>[</span>v<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> Double.<span style=color:#a6e22e>POSITIVE_INFINITY</span>;
</span></span><span style=display:flex><span>        distTo<span style=color:#f92672>[</span>s<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0.<span style=color:#a6e22e>0</span>;
</span></span><span style=display:flex><span>        pq.<span style=color:#a6e22e>insert</span>(s, 0.<span style=color:#a6e22e>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>pq.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> v <span style=color:#f92672>=</span> pq.<span style=color:#a6e22e>delMin</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (DirectedEdge e : G.<span style=color:#a6e22e>adj</span>(v))
</span></span><span style=display:flex><span>                relax(e);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>relax</span>(DirectedEdge e) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> v <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>from</span>(), w <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>to</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (distTo<span style=color:#f92672>[</span>w<span style=color:#f92672>]</span> <span style=color:#f92672>&gt;</span> distTo<span style=color:#f92672>[</span>v<span style=color:#f92672>]</span> <span style=color:#f92672>+</span> e.<span style=color:#a6e22e>weight</span>()) {
</span></span><span style=display:flex><span>            distTo<span style=color:#f92672>[</span>w<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> distTo<span style=color:#f92672>[</span>v<span style=color:#f92672>]</span> <span style=color:#f92672>+</span> e.<span style=color:#a6e22e>weight</span>();
</span></span><span style=display:flex><span>            edgeTo<span style=color:#f92672>[</span>w<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (pq.<span style=color:#a6e22e>contains</span>(w)) pq.<span style=color:#a6e22e>decreaseKey</span>(w, distTo<span style=color:#f92672>[</span>w<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> pq.<span style=color:#a6e22e>insert</span>(w, distTo<span style=color:#f92672>[</span>w<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>distTo</span>(<span style=color:#66d9ef>int</span> v) { <span style=color:#66d9ef>return</span> distTo<span style=color:#f92672>[</span>v<span style=color:#f92672>]</span>; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Iterable<span style=color:#f92672>&lt;</span>DirectedEdge<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>pathTo</span>(<span style=color:#66d9ef>int</span> v) {
</span></span><span style=display:flex><span>        Stack<span style=color:#f92672>&lt;</span>DirectedEdge<span style=color:#f92672>&gt;</span> path <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Stack<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (DirectedEdge e <span style=color:#f92672>=</span> edgeTo<span style=color:#f92672>[</span>v<span style=color:#f92672>]</span>; e <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>; e <span style=color:#f92672>=</span> edgeTo<span style=color:#f92672>[</span>e.<span style=color:#a6e22e>from</span>()<span style=color:#f92672>]</span>)
</span></span><span style=display:flex><span>            path.<span style=color:#a6e22e>push</span>(e);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> path;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=edge-weighted-dags>edge-weighted DAGs</h3><h4 id=acyclic-shortest-paths-demo>Acyclic shortest paths demo</h4><p><img src=https://i.postimg.cc/j5bbc9gh/ezgif-4-83690900591b.gif alt></p><h4 id=shortest-paths-in-edge-weighted-dags>Shortest paths in edge-weighted DAGs</h4><ul><li><strong>Proposition.</strong> Topological sort algorithm computes SPT in any (edge weights can be negative!) edge-weighted DAG in time proportional to <em>E + V</em></li><li><strong>Pf.</strong><ul><li>Each edge e = v->w is relaxed exactly once (when v is relaxed), leaving distTo[w] &lt;= distTo[v] + e.weight()</li><li>Inequality holds until algorithm terminates because:<ul><li>distTo[w] cannot increase &lt;- distTo[] values are monotone decreasing</li><li>distTo[v] will not change &lt;- because of topological order, no edge pointing to v will be relaxed after v is relaxed</li></ul></li><li>Thus, upon termination, shortest-paths optimality conditions hold</li></ul></li></ul><h4 id=java-implementation-5>Java Implementation</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AcyclicSP</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> DirectedEdge<span style=color:#f92672>[]</span> edgeTo;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>double</span><span style=color:#f92672>[]</span> distTo;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>AcyclicSP</span>(EdgeWeightedDigraph G, <span style=color:#66d9ef>int</span> s) {
</span></span><span style=display:flex><span>        edgeTo <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> DirectedEdge<span style=color:#f92672>[</span>G.<span style=color:#a6e22e>V</span>()<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        distTo <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>double</span><span style=color:#f92672>[</span>G.<span style=color:#a6e22e>V</span>()<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> v <span style=color:#f92672>=</span> 0; v <span style=color:#f92672>&lt;</span> G.<span style=color:#a6e22e>V</span>(); v<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            distTo<span style=color:#f92672>[</span>v<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> Double.<span style=color:#a6e22e>POSITIVE_INFINITY</span>;
</span></span><span style=display:flex><span>        distTo<span style=color:#f92672>[</span>s<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0.<span style=color:#a6e22e>0</span>;
</span></span><span style=display:flex><span>        Topological topological <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Topological(G);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> v : topological.<span style=color:#a6e22e>order</span>())
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (DirectedEdge e : G.<span style=color:#a6e22e>adj</span>(v))
</span></span><span style=display:flex><span>                relax(e);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>relax</span>(DirectedEdge e) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> v <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>from</span>(), w <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>to</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (distTo<span style=color:#f92672>[</span>w<span style=color:#f92672>]</span> <span style=color:#f92672>&gt;</span> distTo<span style=color:#f92672>[</span>v<span style=color:#f92672>]</span> <span style=color:#f92672>+</span> e.<span style=color:#a6e22e>weight</span>()) {
</span></span><span style=display:flex><span>            distTo<span style=color:#f92672>[</span>w<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> distTo<span style=color:#f92672>[</span>v<span style=color:#f92672>]</span> <span style=color:#f92672>+</span> e.<span style=color:#a6e22e>weight</span>();
</span></span><span style=display:flex><span>            edgeTo<span style=color:#f92672>[</span>w<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Iterable<span style=color:#f92672>&lt;</span>DirectedEdge<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>pathTo</span>(<span style=color:#66d9ef>int</span> v) {
</span></span><span style=display:flex><span>        Stack<span style=color:#f92672>&lt;</span>DirectedEdge<span style=color:#f92672>&gt;</span> path <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Stack<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (DirectedEdge e <span style=color:#f92672>=</span> edgeTo<span style=color:#f92672>[</span>v<span style=color:#f92672>]</span>; e <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>; e <span style=color:#f92672>=</span> edgeTo<span style=color:#f92672>[</span>e.<span style=color:#a6e22e>from</span>()<span style=color:#f92672>]</span>)
</span></span><span style=display:flex><span>            path.<span style=color:#a6e22e>push</span>(e);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> path;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=negative-weights>negative weights</h3><ul><li><strong>Def.</strong> A negative cycle is a directed cycle whose sum of edge weights is negative.</li><li><strong>Proposition.</strong> A SPT exists iff no negative cycles.</li></ul><h4 id=bellman-ford-algorithm-analysis>Bellman-Ford algorithm: analysis</h4><ul><li><p>Initialize distTo[s] = 0 and distTo[v] = $ \infty $ for all other vertices.</p></li><li><p>Repeat V times:</p><ul><li>Relax each edge.</li></ul></li><li><p><strong>Proposition.</strong> Dynamic programming algorithm computes SPT in any edge-weighted digraph with no negative cycles in time proportional to $E\times V$</p></li><li><p><strong>Pf idea.</strong> After pass i, found shortest path containing at most i edges.</p></li></ul><h4 id=bellman-ford-algorithm-practical-improvement>Bellman-Ford algorithm: practical improvement</h4><ul><li><p><strong>Observation.</strong> If distTo[v] does not change during pass i, no need to relax any edge pointing from v in pass i+1.</p></li><li><p><strong>FIFO implementation.</strong> Maintain queue of vertices whose distTo[] changed.</p></li><li><p><strong>Overall effect.</strong></p><ul><li>The running time is still proportional to $E \times V $ in worst case.</li><li>But much faster than that in practice.</li></ul></li></ul><h4 id=bellman-ford-java-implementation>Bellman-Ford Java implementation</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BellmanFordSP</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>double</span><span style=color:#f92672>[]</span> distTo;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> DirectedEdge<span style=color:#f92672>[]</span> edgeTo;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Queue<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> queue;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span><span style=color:#f92672>[]</span> onQueue;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>BellmanFordSP</span>(EdgeWeightedDigraph G, <span style=color:#66d9ef>int</span> s) {
</span></span><span style=display:flex><span>        distTo <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>double</span><span style=color:#f92672>[</span>G.<span style=color:#a6e22e>V</span>()<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        onQueue <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>boolean</span><span style=color:#f92672>[</span>G.<span style=color:#a6e22e>V</span>()<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        edgeTo <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> DirectedEdge<span style=color:#f92672>[</span>G.<span style=color:#a6e22e>V</span>()<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> v <span style=color:#f92672>=</span> 0; v <span style=color:#f92672>&lt;</span> G.<span style=color:#a6e22e>V</span>(); v<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            distTo<span style=color:#f92672>[</span>v<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> Double.<span style=color:#a6e22e>POSITIVE_INFINITY</span>;
</span></span><span style=display:flex><span>        distTo<span style=color:#f92672>[</span>s<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0.<span style=color:#a6e22e>0</span>;
</span></span><span style=display:flex><span>        queue <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Queue<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        queue.<span style=color:#a6e22e>enqueue</span>(s);
</span></span><span style=display:flex><span>        onQueue<span style=color:#f92672>[</span>s<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>queue.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> v <span style=color:#f92672>=</span> queue.<span style=color:#a6e22e>dequeue</span>();
</span></span><span style=display:flex><span>            onQueue<span style=color:#f92672>[</span>v<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            relax(G, v);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>relax</span>(EdgeWeightedDigraph G, <span style=color:#66d9ef>int</span> v) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (DirectedEdge e : G.<span style=color:#a6e22e>adj</span>(v)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> w <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>to</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (distTo<span style=color:#f92672>[</span>w<span style=color:#f92672>]</span> <span style=color:#f92672>&gt;</span> distTo<span style=color:#f92672>[</span>v<span style=color:#f92672>]</span> <span style=color:#f92672>+</span> e.<span style=color:#a6e22e>weight</span>()) {
</span></span><span style=display:flex><span>                distTo<span style=color:#f92672>[</span>w<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> distTo<span style=color:#f92672>[</span>v<span style=color:#f92672>]</span> <span style=color:#f92672>+</span> e.<span style=color:#a6e22e>weight</span>();
</span></span><span style=display:flex><span>                edgeTo<span style=color:#f92672>[</span>w<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>onQueue<span style=color:#f92672>[</span>w<span style=color:#f92672>]</span>) {
</span></span><span style=display:flex><span>                    queue.<span style=color:#a6e22e>enqueue</span>(w);
</span></span><span style=display:flex><span>                    onQueue<span style=color:#f92672>[</span>w<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Iterable<span style=color:#f92672>&lt;</span>DirectedEdge<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>pathTo</span>(<span style=color:#66d9ef>int</span> v) {
</span></span><span style=display:flex><span>        Stack<span style=color:#f92672>&lt;</span>DirectedEdge<span style=color:#f92672>&gt;</span> path <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Stack<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (DirectedEdge e <span style=color:#f92672>=</span> edgeTo<span style=color:#f92672>[</span>v<span style=color:#f92672>]</span>; e <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>; e <span style=color:#f92672>=</span> edgeTo<span style=color:#f92672>[</span>e.<span style=color:#a6e22e>from</span>()<span style=color:#f92672>]</span>)
</span></span><span style=display:flex><span>            path.<span style=color:#a6e22e>push</span>(e);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> path;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=single-source-shortest-path-implementation-cost-summary>Single source shortest-path implementation: cost summary</h4><table><thead><tr><th>algorithm</th><th>restriction</th><th>typical case</th><th>worst case</th><th>extra case</th></tr></thead><tbody><tr><td>topological sort</td><td>no directed cycles</td><td>E + V</td><td>E + V</td><td>V</td></tr><tr><td>Dijkstra (binary heap)</td><td>no negative weights</td><td>ElogV</td><td>ElogV</td><td>V</td></tr><tr><td>Bellman-Ford</td><td>no negative cycles</td><td>EV</td><td>EV</td><td>V</td></tr><tr><td>Bellman-Ford(queue-based)</td><td>no negative cycles</td><td>E + V</td><td>EV</td><td>V</td></tr></tbody></table><h3 id=441>4.4.1</h3><p>True or false. Adding a constant to every edge weight does not change the solution to the single-source shortest-paths problem.</p><p>False. 假设一条最短路径的长度是15, 且一共有五条边，而另外一条简单路径的长度为20，由两条边组成，当每条边的权值都增加5之后，原来长度15的路径长度变为40，原来长度为20的路径长度变为30，可以看到最短路径改变了。</p><h3 id=445>4.4.5</h3><p>Change the direction of edge 0->2 in tinyEWD.txt (see page 644). Draw two different
SPTs that are rooted at 2 for this modified edge-weighted digraph.
<img src=https://i.postimg.cc/fL7gcsnN/graph.png alt></p><h3 id=459>4.5.9</h3><p>The table below, from an old published road map, purports to give the length of the shortest routes connecting the cities. It contains an error. Correct the table. Also, add a table that shows how to achieve the shortest routes.</p><p><img src=https://i.postimg.cc/bv8TXN6S/Snipaste-2020-12-04-21-48-19.jpg alt></p><table><thead><tr><th></th><th>Providence</th><th>Westerly</th><th>New London</th><th>Norwich</th></tr></thead><tbody><tr><td>Providence</td><td></td><td>53</td><td>54</td><td>48</td></tr><tr><td>Westerly</td><td>53</td><td></td><td>18</td><td>30</td></tr><tr><td>New London</td><td>54</td><td>18</td><td></td><td>12</td></tr><tr><td>Norwich</td><td>48</td><td>30</td><td>12</td><td></td></tr></tbody></table><p>给Providence、Westerly、New London、Norwich 分别编号为0、1、2、3</p><p>最短路径：</p><table><thead><tr><th></th><th>Providence</th><th>Westerly</th><th>New London</th><th>Norwich</th></tr></thead><tbody><tr><td>Providence</td><td></td><td>0-1</td><td>0-2</td><td>0-3</td></tr><tr><td>Westerly</td><td>1-0</td><td></td><td>1-2</td><td>1-2、2-3</td></tr><tr><td>New London</td><td>2-0</td><td>2-1</td><td></td><td>2-3</td></tr><tr><td>Norwich</td><td>3-0</td><td>3-2、2-1</td><td>3-2</td><td></td></tr></tbody></table><h2 id=string-sorts>String sorts</h2><h3 id=key-indexed-counting>key-indexed counting</h3><ul><li><p><strong>Proposition.</strong> Key-indexed counting uses $ ~ 11N+4R $ array accesses to sort a <em>N</em> items whose keys are integers between <em>0</em> and <em>R-1</em>.</p></li><li><p><strong>Proposition.</strong> Key-indexed counting uses extra space proportional to <em>N + R</em></p></li><li><p><strong>Stable.</strong></p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CountingSort</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> a, <span style=color:#66d9ef>int</span> R) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> N <span style=color:#f92672>=</span> a.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> count <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>R<span style=color:#f92672>+</span>1<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> aux <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>N<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> N; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            count<span style=color:#f92672>[</span>a<span style=color:#f92672>[</span>i<span style=color:#f92672>]+</span>1<span style=color:#f92672>]++</span>; <span style=color:#75715e>// count[a[i]+1] = count[a[i+1]] + 1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> r <span style=color:#f92672>=</span> 0; r <span style=color:#f92672>&lt;</span> R; r<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            count<span style=color:#f92672>[</span>r<span style=color:#f92672>+</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>+=</span> count<span style=color:#f92672>[</span>r<span style=color:#f92672>]</span>; <span style=color:#75715e>// 第一个位置</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> N; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            aux<span style=color:#f92672>[</span>count<span style=color:#f92672>[</span>a<span style=color:#f92672>[</span>i<span style=color:#f92672>]]++]</span> <span style=color:#f92672>=</span> a<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>; <span style=color:#75715e>// aux[count[a[i]] = count[a[i]]+1] = a[i]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> N; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            a<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> aux<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        String s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;dacffbdbfbea&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> a <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>s.<span style=color:#a6e22e>length</span>()<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> a.<span style=color:#a6e22e>length</span>; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            a<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> s.<span style=color:#a6e22e>charAt</span>(i)<span style=color:#f92672>-</span><span style=color:#e6db74>&#39;a&#39;</span>;
</span></span><span style=display:flex><span>        sort(a, 26);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>var</span> e : a) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%c &#34;</span>, e<span style=color:#f92672>+</span><span style=color:#e6db74>&#39;a&#39;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=lsd-radix-sort>LSD radix sort</h3><h4 id=least-significant-digit-first-string-sort>Least-significant-digit-first string sort</h4><ul><li>Consider characters from right to left.</li><li>Stably sort using dth character as the key (using key-indexed counting).</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LSD</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(String<span style=color:#f92672>[]</span> a, <span style=color:#66d9ef>int</span> W) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> R <span style=color:#f92672>=</span> 256;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> N <span style=color:#f92672>=</span> a.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>        String<span style=color:#f92672>[]</span> aux <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> String<span style=color:#f92672>[</span>N<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> d <span style=color:#f92672>=</span> W<span style=color:#f92672>-</span>1; d <span style=color:#f92672>&gt;=</span> 0; d<span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> count <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>R<span style=color:#f92672>+</span>1<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> N; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>                count<span style=color:#f92672>[</span>a<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>.<span style=color:#a6e22e>charAt</span>(d)<span style=color:#f92672>+</span>1<span style=color:#f92672>]++</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> r <span style=color:#f92672>=</span> 0; r <span style=color:#f92672>&lt;</span> R; r<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>                count<span style=color:#f92672>[</span>r<span style=color:#f92672>+</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>+=</span> count<span style=color:#f92672>[</span>r<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> N; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>                aux<span style=color:#f92672>[</span>count<span style=color:#f92672>[</span>a<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>.<span style=color:#a6e22e>charAt</span>(d)<span style=color:#f92672>]++]</span> <span style=color:#f92672>=</span> a<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> N; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>                a<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> aux<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        In in <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> In(<span style=color:#e6db74>&#34;D:\\Java_test\\test1\\src\\StringSort\\strings.txt&#34;</span>);
</span></span><span style=display:flex><span>        String<span style=color:#f92672>[]</span> a <span style=color:#f92672>=</span> in.<span style=color:#a6e22e>readAllStrings</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> N <span style=color:#f92672>=</span> a.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> w <span style=color:#f92672>=</span> a<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>.<span style=color:#a6e22e>length</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1; i <span style=color:#f92672>&lt;</span> N; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>assert</span> a<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>.<span style=color:#a6e22e>length</span>() <span style=color:#f92672>==</span> w : <span style=color:#e6db74>&#34;String must have fixed length&#34;</span>;
</span></span><span style=display:flex><span>        sort(a, w);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>var</span> e : a)
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(e);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=summary-of-the-performence-of-sorting-algorithms>Summary of the performence of sorting algorithms</h4><p><img src=https://i.postimg.cc/mkM2KqMV/Snipaste-2020-12-04-21-48-19.jpg alt></p><h3 id=msd-radix-sort>MSD radix sort</h3><h4 id=most-significant-digit-first-srting-sort>Most-significant-digit-first srting sort</h4><ul><li>Partition array into <em>R</em> pieces according to first character (using key-indexed counting).</li><li>Recursively sort all strings that start with each character (key-indexed counts delineate subarrays to sort).</li></ul><h4 id=implementation-3>Implementation</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MSD</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> R <span style=color:#f92672>=</span> 256;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(String<span style=color:#f92672>[]</span> a) {
</span></span><span style=display:flex><span>        String<span style=color:#f92672>[]</span> aux <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> String<span style=color:#f92672>[</span>a.<span style=color:#a6e22e>length</span><span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        sort(a, aux, 0, a.<span style=color:#a6e22e>length</span><span style=color:#f92672>-</span>1, 0);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(String<span style=color:#f92672>[]</span> a, String<span style=color:#f92672>[]</span> aux, <span style=color:#66d9ef>int</span> lo, <span style=color:#66d9ef>int</span> hi, <span style=color:#66d9ef>int</span> d) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (hi <span style=color:#f92672>&lt;=</span> lo) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> count <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>R<span style=color:#f92672>+</span>2<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> lo; i <span style=color:#f92672>&lt;=</span> hi; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            count<span style=color:#f92672>[</span>charAt(a<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>, d)<span style=color:#f92672>+</span>2<span style=color:#f92672>]++</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> r <span style=color:#f92672>=</span> 0; r <span style=color:#f92672>&lt;</span> R <span style=color:#f92672>+</span> 1; r<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            count<span style=color:#f92672>[</span>r<span style=color:#f92672>+</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>+=</span> count<span style=color:#f92672>[</span>r<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> lo; i <span style=color:#f92672>&lt;=</span> hi; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            aux<span style=color:#f92672>[</span>count<span style=color:#f92672>[</span>charAt(a<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>, d)<span style=color:#f92672>+</span>1<span style=color:#f92672>]++]</span> <span style=color:#f92672>=</span> a<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> lo; i <span style=color:#f92672>&lt;=</span> hi; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            a<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> aux<span style=color:#f92672>[</span>i <span style=color:#f92672>-</span> lo<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> r <span style=color:#f92672>=</span> 0; r <span style=color:#f92672>&lt;</span> R; r<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            sort(a, aux, lo<span style=color:#f92672>+</span>count<span style=color:#f92672>[</span>r<span style=color:#f92672>]</span>, lo<span style=color:#f92672>+</span>count<span style=color:#f92672>[</span>r<span style=color:#f92672>+</span>1<span style=color:#f92672>]-</span>1, d<span style=color:#f92672>+</span>1);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>charAt</span>(String s, <span style=color:#66d9ef>int</span> d) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (s.<span style=color:#a6e22e>length</span>() <span style=color:#f92672>&gt;</span> d) <span style=color:#66d9ef>return</span> s.<span style=color:#a6e22e>charAt</span>(d);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>1;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        In in <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> In(<span style=color:#e6db74>&#34;D:\\Java_test\\test1\\src\\StringSort\\strings.txt&#34;</span>);
</span></span><span style=display:flex><span>        String<span style=color:#f92672>[]</span> a <span style=color:#f92672>=</span> in.<span style=color:#a6e22e>readAllStrings</span>();
</span></span><span style=display:flex><span>        sort(a);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>var</span> e : a)
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(e);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=suffix-arrays>suffix arrays</h3><h4 id=longest-repeated-substring-java-implementation>Longest repeated substring: Java implementation</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LRS</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> String <span style=color:#a6e22e>lrs</span>(String s) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> N <span style=color:#f92672>=</span> s.<span style=color:#a6e22e>length</span>();
</span></span><span style=display:flex><span>        String<span style=color:#f92672>[]</span> suffixes <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> String<span style=color:#f92672>[</span>N<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> N; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            suffixes<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> s.<span style=color:#a6e22e>substring</span>(i, N);
</span></span><span style=display:flex><span>        Arrays.<span style=color:#a6e22e>sort</span>(suffixes);
</span></span><span style=display:flex><span>        String lrs <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> N <span style=color:#f92672>-</span> 1; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> len <span style=color:#f92672>=</span> lcp(suffixes<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>, suffixes<span style=color:#f92672>[</span>i<span style=color:#f92672>+</span>1<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (len <span style=color:#f92672>&gt;</span> lrs.<span style=color:#a6e22e>length</span>())
</span></span><span style=display:flex><span>                lrs <span style=color:#f92672>=</span> suffixes<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>.<span style=color:#a6e22e>substring</span>(0, len);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> lrs;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lcp</span>(String s, String t) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>min</span>(s.<span style=color:#a6e22e>length</span>(), t.<span style=color:#a6e22e>length</span>());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (s.<span style=color:#a6e22e>charAt</span>(i) <span style=color:#f92672>!=</span> t.<span style=color:#a6e22e>charAt</span>(i)) <span style=color:#66d9ef>return</span> i;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> n;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        String s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;aacaagtttacaagc&#34;</span>;
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(lrs(s));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] ltr:mr-1.5 rtl:ml-1.5 dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://fffzlfk.github.io/tags/java>Java</a><a class="mb-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] ltr:mr-1.5 rtl:ml-1.5 dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://fffzlfk.github.io/tags/academic>Academic</a></footer><div class="giscus mt-24"></div><script src=https://giscus.app/client.js data-repo=fffzlfk/fffzlfk.github.io data-repo-id=R_kgDOG4ERGw data-category=Q&amp;A data-category-id=DIC_kwDOG4ERG84CBP5t data-mapping=pathname data-strict=1 data-reactions-enabled=0 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class="mx-auto flex h-[4.5rem] max-w-(--w) items-center px-8 text-xs tracking-wider uppercase opacity-60"><div class=mr-auto>&copy;2025
<a class=link href=https://fffzlfk.github.io/>fffzlfk's Blog</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>powered by hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>hugo-paper</a></footer></body></html>