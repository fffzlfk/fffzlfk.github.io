<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=zh-cn dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>OpenCV Sobel Derivatives - fffzlfk's Blog</title>
<meta name=theme-color><meta name=description content="理论


在之前的两个教程中，我们已经看到了卷积的应用实例。最重要的卷积之一是计算图像中的导数（或对它们的近似值）


为什么图像中的导数计算可能是重要的？让我们设想一下，我们要检测图像中存在的边缘。比如说：

你可以很容易地注意到，在一个边缘，像素强度的变化是很明显的。一个表达变化的好方法是使用导数。梯度的高变化表示图像中的一个重大变化。


为了更加形象，让我们假设我们有一个一维图像。在下面的图中，一个边缘由强度的 &ldquo;跳跃 &ldquo;来表示：



如果我们取第一个导数，可以更容易地看到边缘的 &ldquo;跳跃&rdquo;（实际上，这里出现的是一个最大值）：



因此，从上面的解释中，我们可以推断出，检测图像中的边缘的方法可以通过定位梯度高于其邻居的像素位置（或者概括地说，高于一个阈值）来进行。


更详细的解释，请参考Bradski和Kaehler的《Learning OpenCV》。


Sobel 算子

Sobel算子是一个离散的微分算子，它计算图像强度函数的梯度的近似值。
Sobel算子结合了Gaussian smoothing和微分。

Formulation
假设要操作的图像为 $I$:

我们计算两个导数：

水平变化：这是通过用奇数大小的内核 $G_x$ 对 $I$ 进行卷积计算的。例如，对于内核大小为 $3$ ， $G_x$ 将被计算为：
$$
G_x=\begin{bmatrix}
-1 & 0 & +1\\
-2 & 0 & +2\\
-1 & 0 & +1
\end{bmatrix} * I
$$
垂直变化：这是通过用奇数大小的内核 $G_y$ 对 $I$ 进行卷积计算的。例如，对于内核大小为 $3$ ， $G_y$ 将被计算为：
$$
G_y = \begin{bmatrix}
-1 & -2 & -1\\
0 & 0 & 0\\
+1 & +2 & + 1
\end{bmatrix} * I
$$


在图像的每一点上，我们通过结合上述两个结果计算出该点的梯度近似值：
$$
G = \sqrt{G_{x}^{2}+G_{y}^{2}}
$$
有时会使用以下更简单的方程式：
$$
G = |G_x|+|G_y|
$$


当核的大小为 $3$ 时，上面显示的 Sobel核可能会产生明显的不准确（毕竟， Sobel 只是一个导数的近似值）。OpenCV通过使用 Scharr() 函数来解决这种大小为 $3$ 的核的不精确性。这和标准的 Sobel 函数一样快，但比它更准确。它可以实现以下内核
$$
G_x=\begin{bmatrix}
-3 & 0 & +3\\
-10 & 0 & +10\\
-3 & 0 & +3
\end{bmatrix},
G_y=\begin{bmatrix}
-3 & -10 & -3\\
0 & 0 & 0\\
+3 & +10 & +3
\end{bmatrix}
$$"><meta name=author content="fffzlfk"><link rel="preload stylesheet" as=style href=https://fffzlfk.github.io/main.min.css><link rel=preload as=image href=https://fffzlfk.github.io/theme.svg><link rel=preload as=image href="https://avatars.githubusercontent.com/u/44939690?v=4"><link rel=preload as=image href=https://fffzlfk.github.io/github.svg><link rel=preload as=image href=https://fffzlfk.github.io/instagram.svg><link rel=preload as=image href=https://fffzlfk.github.io/rss.svg><link rel=stylesheet href=/css/fonts.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",()=>renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1}))</script><link rel=icon href=https://fffzlfk.github.io/favicon.ico><link rel=apple-touch-icon href=https://fffzlfk.github.io/apple-touch-icon.png><meta name=generator content="Hugo 0.147.4"><meta itemprop=name content="OpenCV Sobel Derivatives"><meta itemprop=description content="理论 在之前的两个教程中，我们已经看到了卷积的应用实例。最重要的卷积之一是计算图像中的导数（或对它们的近似值）
为什么图像中的导数计算可能是重要的？让我们设想一下，我们要检测图像中存在的边缘。比如说： 你可以很容易地注意到，在一个边缘，像素强度的变化是很明显的。一个表达变化的好方法是使用导数。梯度的高变化表示图像中的一个重大变化。
为了更加形象，让我们假设我们有一个一维图像。在下面的图中，一个边缘由强度的 “跳跃 “来表示： 如果我们取第一个导数，可以更容易地看到边缘的 “跳跃”（实际上，这里出现的是一个最大值）： 因此，从上面的解释中，我们可以推断出，检测图像中的边缘的方法可以通过定位梯度高于其邻居的像素位置（或者概括地说，高于一个阈值）来进行。
更详细的解释，请参考Bradski和Kaehler的《Learning OpenCV》。
Sobel 算子 Sobel算子是一个离散的微分算子，它计算图像强度函数的梯度的近似值。 Sobel算子结合了Gaussian smoothing和微分。 Formulation 假设要操作的图像为 $I$:
我们计算两个导数： 水平变化：这是通过用奇数大小的内核 $G_x$ 对 $I$ 进行卷积计算的。例如，对于内核大小为 $3$ ， $G_x$ 将被计算为： $$ G_x=\begin{bmatrix} -1 & 0 & +1\\ -2 & 0 & +2\\ -1 & 0 & +1 \end{bmatrix} * I $$ 垂直变化：这是通过用奇数大小的内核 $G_y$ 对 $I$ 进行卷积计算的。例如，对于内核大小为 $3$ ， $G_y$ 将被计算为： $$ G_y = \begin{bmatrix} -1 & -2 & -1\\ 0 & 0 & 0\\ +1 & +2 & + 1 \end{bmatrix} * I $$ 在图像的每一点上，我们通过结合上述两个结果计算出该点的梯度近似值： $$ G = \sqrt{G_{x}^{2}+G_{y}^{2}} $$ 有时会使用以下更简单的方程式： $$ G = |G_x|+|G_y| $$ 当核的大小为 $3$ 时，上面显示的 Sobel核可能会产生明显的不准确（毕竟， Sobel 只是一个导数的近似值）。OpenCV通过使用 Scharr() 函数来解决这种大小为 $3$ 的核的不精确性。这和标准的 Sobel 函数一样快，但比它更准确。它可以实现以下内核 $$ G_x=\begin{bmatrix} -3 & 0 & +3\\ -10 & 0 & +10\\ -3 & 0 & +3 \end{bmatrix}, G_y=\begin{bmatrix} -3 & -10 & -3\\ 0 & 0 & 0\\ +3 & +10 & +3 \end{bmatrix} $$"><meta itemprop=datePublished content="2022-01-16T12:18:12+08:00"><meta itemprop=dateModified content="2022-01-16T12:18:12+08:00"><meta itemprop=wordCount content="338"><meta itemprop=keywords content="OpenCV"><meta property="og:url" content="https://fffzlfk.github.io/posts/opencv_sobel_derivatives/"><meta property="og:site_name" content="fffzlfk's Blog"><meta property="og:title" content="OpenCV Sobel Derivatives"><meta property="og:description" content="理论 在之前的两个教程中，我们已经看到了卷积的应用实例。最重要的卷积之一是计算图像中的导数（或对它们的近似值）
为什么图像中的导数计算可能是重要的？让我们设想一下，我们要检测图像中存在的边缘。比如说： 你可以很容易地注意到，在一个边缘，像素强度的变化是很明显的。一个表达变化的好方法是使用导数。梯度的高变化表示图像中的一个重大变化。
为了更加形象，让我们假设我们有一个一维图像。在下面的图中，一个边缘由强度的 “跳跃 “来表示： 如果我们取第一个导数，可以更容易地看到边缘的 “跳跃”（实际上，这里出现的是一个最大值）： 因此，从上面的解释中，我们可以推断出，检测图像中的边缘的方法可以通过定位梯度高于其邻居的像素位置（或者概括地说，高于一个阈值）来进行。
更详细的解释，请参考Bradski和Kaehler的《Learning OpenCV》。
Sobel 算子 Sobel算子是一个离散的微分算子，它计算图像强度函数的梯度的近似值。 Sobel算子结合了Gaussian smoothing和微分。 Formulation 假设要操作的图像为 $I$:
我们计算两个导数： 水平变化：这是通过用奇数大小的内核 $G_x$ 对 $I$ 进行卷积计算的。例如，对于内核大小为 $3$ ， $G_x$ 将被计算为： $$ G_x=\begin{bmatrix} -1 & 0 & +1\\ -2 & 0 & +2\\ -1 & 0 & +1 \end{bmatrix} * I $$ 垂直变化：这是通过用奇数大小的内核 $G_y$ 对 $I$ 进行卷积计算的。例如，对于内核大小为 $3$ ， $G_y$ 将被计算为： $$ G_y = \begin{bmatrix} -1 & -2 & -1\\ 0 & 0 & 0\\ +1 & +2 & + 1 \end{bmatrix} * I $$ 在图像的每一点上，我们通过结合上述两个结果计算出该点的梯度近似值： $$ G = \sqrt{G_{x}^{2}+G_{y}^{2}} $$ 有时会使用以下更简单的方程式： $$ G = |G_x|+|G_y| $$ 当核的大小为 $3$ 时，上面显示的 Sobel核可能会产生明显的不准确（毕竟， Sobel 只是一个导数的近似值）。OpenCV通过使用 Scharr() 函数来解决这种大小为 $3$ 的核的不精确性。这和标准的 Sobel 函数一样快，但比它更准确。它可以实现以下内核 $$ G_x=\begin{bmatrix} -3 & 0 & +3\\ -10 & 0 & +10\\ -3 & 0 & +3 \end{bmatrix}, G_y=\begin{bmatrix} -3 & -10 & -3\\ 0 & 0 & 0\\ +3 & +10 & +3 \end{bmatrix} $$"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-16T12:18:12+08:00"><meta property="article:modified_time" content="2022-01-16T12:18:12+08:00"><meta property="article:tag" content="OpenCV"><meta name=twitter:card content="summary"><meta name=twitter:title content="OpenCV Sobel Derivatives"><meta name=twitter:description content="理论 在之前的两个教程中，我们已经看到了卷积的应用实例。最重要的卷积之一是计算图像中的导数（或对它们的近似值）
为什么图像中的导数计算可能是重要的？让我们设想一下，我们要检测图像中存在的边缘。比如说： 你可以很容易地注意到，在一个边缘，像素强度的变化是很明显的。一个表达变化的好方法是使用导数。梯度的高变化表示图像中的一个重大变化。
为了更加形象，让我们假设我们有一个一维图像。在下面的图中，一个边缘由强度的 “跳跃 “来表示： 如果我们取第一个导数，可以更容易地看到边缘的 “跳跃”（实际上，这里出现的是一个最大值）： 因此，从上面的解释中，我们可以推断出，检测图像中的边缘的方法可以通过定位梯度高于其邻居的像素位置（或者概括地说，高于一个阈值）来进行。
更详细的解释，请参考Bradski和Kaehler的《Learning OpenCV》。
Sobel 算子 Sobel算子是一个离散的微分算子，它计算图像强度函数的梯度的近似值。 Sobel算子结合了Gaussian smoothing和微分。 Formulation 假设要操作的图像为 $I$:
我们计算两个导数： 水平变化：这是通过用奇数大小的内核 $G_x$ 对 $I$ 进行卷积计算的。例如，对于内核大小为 $3$ ， $G_x$ 将被计算为： $$ G_x=\begin{bmatrix} -1 & 0 & +1\\ -2 & 0 & +2\\ -1 & 0 & +1 \end{bmatrix} * I $$ 垂直变化：这是通过用奇数大小的内核 $G_y$ 对 $I$ 进行卷积计算的。例如，对于内核大小为 $3$ ， $G_y$ 将被计算为： $$ G_y = \begin{bmatrix} -1 & -2 & -1\\ 0 & 0 & 0\\ +1 & +2 & + 1 \end{bmatrix} * I $$ 在图像的每一点上，我们通过结合上述两个结果计算出该点的梯度近似值： $$ G = \sqrt{G_{x}^{2}+G_{y}^{2}} $$ 有时会使用以下更简单的方程式： $$ G = |G_x|+|G_y| $$ 当核的大小为 $3$ 时，上面显示的 Sobel核可能会产生明显的不准确（毕竟， Sobel 只是一个导数的近似值）。OpenCV通过使用 Scharr() 函数来解决这种大小为 $3$ 的核的不精确性。这和标准的 Sobel 函数一样快，但比它更准确。它可以实现以下内核 $$ G_x=\begin{bmatrix} -3 & 0 & +3\\ -10 & 0 & +10\\ -3 & 0 & +3 \end{bmatrix}, G_y=\begin{bmatrix} -3 & -10 & -3\\ 0 & 0 & 0\\ +3 & +10 & +3 \end{bmatrix} $$"><link rel=canonical href=https://fffzlfk.github.io/posts/opencv_sobel_derivatives/></head><body class="bg-(--bg) text-black antialiased duration-200 ease-out [-webkit-tap-highlight-color:transparent] dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-(--w) px-8 whitespace-nowrap lg:justify-center"><div class="relative z-50 flex items-center ltr:mr-auto rtl:ml-auto"><a class="-translate-y-[1px] text-2xl font-medium" href=https://fffzlfk.github.io/>fffzlfk's Blog</a><div class="btn-dark text-[0px] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden ltr:-mr-8 rtl:-ml-8" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full flex-col justify-center bg-(--bg) pb-16 duration-200 select-none lg:static lg:h-auto lg:flex-row lg:bg-transparent! lg:pb-0 lg:transition-none"><nav class="mt-12 flex justify-center space-x-10 lg:mt-0 lg:items-center ltr:lg:ml-14 rtl:space-x-reverse rtl:lg:mr-14 dark:invert"><a class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/fffzlfk target=_blank rel=me>github</a>
<a class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./instagram.svg) href=https://instagram.com/fffzlfk target=_blank rel=me>instagram</a>
<a class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./rss.svg) href=https://fffzlfk.github.io/index.xml target=_blank rel=alternate>rss</a></nav></div></header><main class="prose prose-neutral dark:prose-invert relative mx-auto min-h-[calc(100vh-9rem)] max-w-(--w) px-8 pt-14 pb-16"><article><header class=mb-14><h1 class="my-0! pb-2.5">OpenCV Sobel Derivatives</h1><div class="text-xs antialiased opacity-60"><time>Jan 16, 2022</time></div></header><section><h2 id=理论>理论</h2><ol><li><p>在之前的两个教程中，我们已经看到了卷积的应用实例。最重要的卷积之一是计算图像中的导数（或对它们的近似值）</p></li><li><p>为什么图像中的导数计算可能是重要的？让我们设想一下，我们要检测图像中存在的边缘。比如说：
<img src=https://docs.opencv.org/4.5.5/Sobel_Derivatives_Tutorial_Theory_0.jpg alt>
你可以很容易地注意到，在一个边缘，像素强度的变化是很明显的。一个表达变化的好方法是使用导数。梯度的高变化表示图像中的一个重大变化。</p></li><li><p>为了更加形象，让我们假设我们有一个一维图像。在下面的图中，一个边缘由强度的 &ldquo;跳跃 &ldquo;来表示：
<img src=https://docs.opencv.org/4.5.5/Sobel_Derivatives_Tutorial_Theory_Intensity_Function.jpg alt></p></li><li><p>如果我们取第一个导数，可以更容易地看到边缘的 &ldquo;跳跃&rdquo;（实际上，这里出现的是一个最大值）：
<img src=https://docs.opencv.org/4.5.5/Sobel_Derivatives_Tutorial_Theory_dIntensity_Function.jpg alt></p></li><li><p>因此，从上面的解释中，我们可以推断出，检测图像中的边缘的方法可以通过定位梯度高于其邻居的像素位置（或者概括地说，高于一个阈值）来进行。</p></li><li><p>更详细的解释，请参考Bradski和Kaehler的<a href=https://www.amazon.com/Learning-OpenCV-Computer-Vision-Library/dp/0596516134>《Learning OpenCV》</a>。</p></li></ol><h3 id=sobel-算子>Sobel 算子</h3><ol><li>Sobel算子是一个离散的微分算子，它计算图像强度函数的梯度的近似值。</li><li>Sobel算子结合了<code>Gaussian smoothing</code>和微分。</li></ol><h3 id=formulation>Formulation</h3><p>假设要操作的图像为 $I$:</p><ol><li>我们计算两个导数：<ol><li><strong>水平变化</strong>：这是通过用奇数大小的内核 $G_x$ 对 $I$ 进行卷积计算的。例如，对于内核大小为 $3$ ， $G_x$ 将被计算为：
$$
G_x=\begin{bmatrix}
-1 & 0 & +1\\
-2 & 0 & +2\\
-1 & 0 & +1
\end{bmatrix} * I
$$</li><li><strong>垂直变化</strong>：这是通过用奇数大小的内核 $G_y$ 对 $I$ 进行卷积计算的。例如，对于内核大小为 $3$ ， $G_y$ 将被计算为：
$$
G_y = \begin{bmatrix}
-1 & -2 & -1\\
0 & 0 & 0\\
+1 & +2 & + 1
\end{bmatrix} * I
$$</li></ol></li><li>在图像的每一点上，我们通过结合上述两个结果计算出该点的梯度近似值：
$$
G = \sqrt{G_{x}^{2}+G_{y}^{2}}
$$
有时会使用以下更简单的方程式：
$$
G = |G_x|+|G_y|
$$</li></ol><blockquote><p>当核的大小为 $3$ 时，上面显示的 <code>Sobel</code>核可能会产生明显的不准确（毕竟， <code>Sobel</code> 只是一个导数的近似值）。OpenCV通过使用 <code>Scharr()</code> 函数来解决这种大小为 $3$ 的核的不精确性。这和标准的 <code>Sobel</code> 函数一样快，但比它更准确。它可以实现以下内核
$$
G_x=\begin{bmatrix}
-3 & 0 & +3\\
-10 & 0 & +10\\
-3 & 0 & +3
\end{bmatrix},
G_y=\begin{bmatrix}
-3 & -10 & -3\\
0 & 0 & 0\\
+3 & +10 & +3
\end{bmatrix}
$$</p></blockquote><h2 id=code>Code</h2><p><a href=https://github.com/fffzlfk/opencv_learning/blob/main/src/transformations/copy_make_border.cpp>代码链接</a></p><h3 id=explanation>Explanation</h3><h4 id=变量声明>变量声明</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// First we declare the variables we are going to use
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Mat image,src, src_gray;
</span></span><span style=display:flex><span>Mat grad;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> String window_name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Sobel Demo - Simple Edge Detector&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> ksize <span style=color:#f92672>=</span> parser.get<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(<span style=color:#e6db74>&#34;ksize&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> scale <span style=color:#f92672>=</span> parser.get<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(<span style=color:#e6db74>&#34;scale&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> delta <span style=color:#f92672>=</span> parser.get<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(<span style=color:#e6db74>&#34;delta&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> ddepth <span style=color:#f92672>=</span> CV_16S;
</span></span></code></pre></div><h4 id=加载图像>加载图像</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>String imageName <span style=color:#f92672>=</span> parser.get<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>(<span style=color:#e6db74>&#34;@input&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>// As usual we load our source image (src)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>image <span style=color:#f92672>=</span> imread( samples<span style=color:#f92672>::</span>findFile( imageName ), IMREAD_COLOR ); <span style=color:#75715e>// Load an image
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Check if image is loaded fine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span>( image.empty() )
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;Error opening image: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, imageName.c_str());
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> EXIT_FAILURE;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=消除噪声>消除噪声</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Remove noise by blurring with a Gaussian filter ( kernel size = 3 )
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>GaussianBlur(image, src, Size(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>3</span>), <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, BORDER_DEFAULT);
</span></span></code></pre></div><h4 id=灰度化>灰度化</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Convert the image to grayscale
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>cvtColor(src, src_gray, COLOR_BGR2GRAY);
</span></span></code></pre></div><h4 id=sobel-算子-1>Sobel 算子</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Mat grad_x, grad_y;
</span></span><span style=display:flex><span>Mat abs_grad_x, abs_grad_y;
</span></span><span style=display:flex><span>Sobel(src_gray, grad_x, ddepth, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, ksize, scale, delta, BORDER_DEFAULT);
</span></span><span style=display:flex><span>Sobel(src_gray, grad_y, ddepth, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, ksize, scale, delta, BORDER_DEFAULT);
</span></span></code></pre></div><ul><li>我们计算 $x$ 和 $y$ 方向的 &ldquo;导数&rdquo;。为此，我们使用函数<code>Sobel()</code>，如下所示。该函数需要以下参数:<ul><li><code>src_gray</code>：在我们的例子中，输入的图像。这里是<code>CV_8U</code></li><li><code>grad_x / grad_y</code>：输出图像。</li><li><code>ddepth</code>：输出图像的深度。我们将其设置为<code>CV_16S</code>以避免溢出。</li><li><code>x_order</code>： $X$ 方向上的导数顺序。</li><li><code>y_order</code>: $Y$ 方向的导数顺序。</li><li><code>scale</code>：<code>delta</code>和<code>BORDER_DEFAULT</code>：我们使用默认值。</li></ul></li></ul><blockquote><p>注意，在计算 $x$ 方向的梯度时，我们使用：<code>xorder=1</code>，<code>yorder=0</code>，我们对 $y$ 方向进行类似的计算。</p></blockquote><h4 id=转换为cv_8u图像>转换为CV_8U图像</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// converting back to CV_8U
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>convertScaleAbs(grad_x, abs_grad_x);
</span></span><span style=display:flex><span>convertScaleAbs(grad_y, abs_grad_y);
</span></span></code></pre></div><h4 id=梯度>梯度</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>addWeighted(abs_grad_x, <span style=color:#ae81ff>0.5</span>, abs_grad_y, <span style=color:#ae81ff>0.5</span>, <span style=color:#ae81ff>0</span>, grad);
</span></span></code></pre></div><blockquote><p>我们试图通过增加两个方向的梯度来近似计算梯度（注意，这不是一个精确的计算！但对我们的目的来说是好的）。</p></blockquote><h2 id=结果>结果</h2><p><img src=https://docs.opencv.org/4.5.5/Sobel_Derivatives_Tutorial_Result.jpg alt></p><h2 id=references>References</h2><p><a href=https://docs.opencv.org/4.5.5/d2/d2c/tutorial_sobel_derivatives.html>https://docs.opencv.org/4.5.5/d2/d2c/tutorial_sobel_derivatives.html</a></p></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] ltr:mr-1.5 rtl:ml-1.5 dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://fffzlfk.github.io/tags/opencv>OpenCV</a></footer><div class="giscus mt-24"></div><script src=https://giscus.app/client.js data-repo=fffzlfk/fffzlfk.github.io data-repo-id=R_kgDOG4ERGw data-category=Q&amp;A data-category-id=DIC_kwDOG4ERG84CBP5t data-mapping=pathname data-strict=1 data-reactions-enabled=0 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class="mx-auto flex h-[4.5rem] max-w-(--w) items-center px-8 text-xs tracking-wider uppercase opacity-60"><div class=mr-auto>&copy;2025
<a class=link href=https://fffzlfk.github.io/>fffzlfk's Blog</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>powered by hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>hugo-paper</a></footer></body></html>