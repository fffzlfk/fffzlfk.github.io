<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>OpenCV Sobel Derivatives | fffzlfk's Blog</title><meta name=keywords content="OpenCV"><meta name=description content="理论   在之前的两个教程中，我们已经看到了卷积的应用实例。最重要的卷积之一是计算图像中的导数（或对它们的近似值）
  为什么图像中的导数计算可能是重要的？让我们设想一下，我们要检测图像中存在的边缘。比如说：  你可以很容易地注意到，在一个边缘，像素强度的变化是很明显的。一个表达变化的好方法是使用导数。梯度的高变化表示图像中的一个重大变化。
  为了更加形象，让我们假设我们有一个一维图像。在下面的图中，一个边缘由强度的 &ldquo;跳跃 &ldquo;来表示：    如果我们取第一个导数，可以更容易地看到边缘的 &ldquo;跳跃&rdquo;（实际上，这里出现的是一个最大值）：    因此，从上面的解释中，我们可以推断出，检测图像中的边缘的方法可以通过定位梯度高于其邻居的像素位置（或者概括地说，高于一个阈值）来进行。
  更详细的解释，请参考Bradski和Kaehler的《Learning OpenCV》。
  Sobel 算子  Sobel算子是一个离散的微分算子，它计算图像强度函数的梯度的近似值。 Sobel算子结合了Gaussian smoothing和微分。  Formulation 假设要操作的图像为 $I$:
 我们计算两个导数：  水平变化：这是通过用奇数大小的内核 $G_x$ 对 $I$ 进行卷积计算的。例如，对于内核大小为 $3$ ， $G_x$ 将被计算为： $$ G_x=\begin{bmatrix} -1 & 0 & +1\\ -2 & 0 & +2\\ -1 & 0 & +1 \end{bmatrix} * I $$ 垂直变化：这是通过用奇数大小的内核 $G_y$ 对 $I$ 进行卷积计算的。例如，对于内核大小为 $3$ ， $G_y$ 将被计算为： $$ G_y = \begin{bmatrix} -1 & -2 & -1\\ 0 & 0 & 0\\ +1 & +2 & + 1 \end{bmatrix} * I $$   在图像的每一点上，我们通过结合上述两个结果计算出该点的梯度近似值： $$ G = \sqrt{G_{x}^{2}+G_{y}^{2}} $$ 有时会使用以下更简单的方程式： $$ G = |G_x|+|G_y| $$   当核的大小为 $3$ 时，上面显示的 Sobel核可能会产生明显的不准确（毕竟， Sobel 只是一个导数的近似值）。OpenCV通过使用 Scharr() 函数来解决这种大小为 $3$ 的核的不精确性。这和标准的 Sobel 函数一样快，但比它更准确。它可以实现以下内核 $$ G_x=\begin{bmatrix} -3 & 0 & +3\\ -10 & 0 & +10\\ -3 & 0 & +3 \end{bmatrix}, G_y=\begin{bmatrix} -3 & -10 & -3\\ 0 & 0 & 0\\ +3 & +10 & +3 \end{bmatrix} $$"><meta name=author content="fffzlfk"><link rel=canonical href=https://fffzlfk.github.io/posts/opencv_sobel_derivatives/><link crossorigin=anonymous href=/assets/css/stylesheet.min.488c669e30254018edc40d34ee225981781048e4d51e9685a30eb8863170b436.css integrity="sha256-SIxmnjAlQBjtxA007iJZgXgQSOTVHpaFow64hjFwtDY=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://fffzlfk.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://fffzlfk.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://fffzlfk.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://fffzlfk.github.io/apple_touch_icon.png><link rel=mask-icon href=https://fffzlfk.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:title" content="OpenCV Sobel Derivatives"><meta property="og:description" content="理论   在之前的两个教程中，我们已经看到了卷积的应用实例。最重要的卷积之一是计算图像中的导数（或对它们的近似值）
  为什么图像中的导数计算可能是重要的？让我们设想一下，我们要检测图像中存在的边缘。比如说：  你可以很容易地注意到，在一个边缘，像素强度的变化是很明显的。一个表达变化的好方法是使用导数。梯度的高变化表示图像中的一个重大变化。
  为了更加形象，让我们假设我们有一个一维图像。在下面的图中，一个边缘由强度的 &ldquo;跳跃 &ldquo;来表示：    如果我们取第一个导数，可以更容易地看到边缘的 &ldquo;跳跃&rdquo;（实际上，这里出现的是一个最大值）：    因此，从上面的解释中，我们可以推断出，检测图像中的边缘的方法可以通过定位梯度高于其邻居的像素位置（或者概括地说，高于一个阈值）来进行。
  更详细的解释，请参考Bradski和Kaehler的《Learning OpenCV》。
  Sobel 算子  Sobel算子是一个离散的微分算子，它计算图像强度函数的梯度的近似值。 Sobel算子结合了Gaussian smoothing和微分。  Formulation 假设要操作的图像为 $I$:
 我们计算两个导数：  水平变化：这是通过用奇数大小的内核 $G_x$ 对 $I$ 进行卷积计算的。例如，对于内核大小为 $3$ ， $G_x$ 将被计算为： $$ G_x=\begin{bmatrix} -1 & 0 & +1\\ -2 & 0 & +2\\ -1 & 0 & +1 \end{bmatrix} * I $$ 垂直变化：这是通过用奇数大小的内核 $G_y$ 对 $I$ 进行卷积计算的。例如，对于内核大小为 $3$ ， $G_y$ 将被计算为： $$ G_y = \begin{bmatrix} -1 & -2 & -1\\ 0 & 0 & 0\\ +1 & +2 & + 1 \end{bmatrix} * I $$   在图像的每一点上，我们通过结合上述两个结果计算出该点的梯度近似值： $$ G = \sqrt{G_{x}^{2}+G_{y}^{2}} $$ 有时会使用以下更简单的方程式： $$ G = |G_x|+|G_y| $$   当核的大小为 $3$ 时，上面显示的 Sobel核可能会产生明显的不准确（毕竟， Sobel 只是一个导数的近似值）。OpenCV通过使用 Scharr() 函数来解决这种大小为 $3$ 的核的不精确性。这和标准的 Sobel 函数一样快，但比它更准确。它可以实现以下内核 $$ G_x=\begin{bmatrix} -3 & 0 & +3\\ -10 & 0 & +10\\ -3 & 0 & +3 \end{bmatrix}, G_y=\begin{bmatrix} -3 & -10 & -3\\ 0 & 0 & 0\\ +3 & +10 & +3 \end{bmatrix} $$"><meta property="og:type" content="article"><meta property="og:url" content="https://fffzlfk.github.io/posts/opencv_sobel_derivatives/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-16T12:18:12+08:00"><meta property="article:modified_time" content="2022-01-16T12:18:12+08:00"><meta property="og:site_name" content="fffzlfk's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="OpenCV Sobel Derivatives"><meta name=twitter:description content="理论   在之前的两个教程中，我们已经看到了卷积的应用实例。最重要的卷积之一是计算图像中的导数（或对它们的近似值）
  为什么图像中的导数计算可能是重要的？让我们设想一下，我们要检测图像中存在的边缘。比如说：  你可以很容易地注意到，在一个边缘，像素强度的变化是很明显的。一个表达变化的好方法是使用导数。梯度的高变化表示图像中的一个重大变化。
  为了更加形象，让我们假设我们有一个一维图像。在下面的图中，一个边缘由强度的 &ldquo;跳跃 &ldquo;来表示：    如果我们取第一个导数，可以更容易地看到边缘的 &ldquo;跳跃&rdquo;（实际上，这里出现的是一个最大值）：    因此，从上面的解释中，我们可以推断出，检测图像中的边缘的方法可以通过定位梯度高于其邻居的像素位置（或者概括地说，高于一个阈值）来进行。
  更详细的解释，请参考Bradski和Kaehler的《Learning OpenCV》。
  Sobel 算子  Sobel算子是一个离散的微分算子，它计算图像强度函数的梯度的近似值。 Sobel算子结合了Gaussian smoothing和微分。  Formulation 假设要操作的图像为 $I$:
 我们计算两个导数：  水平变化：这是通过用奇数大小的内核 $G_x$ 对 $I$ 进行卷积计算的。例如，对于内核大小为 $3$ ， $G_x$ 将被计算为： $$ G_x=\begin{bmatrix} -1 & 0 & +1\\ -2 & 0 & +2\\ -1 & 0 & +1 \end{bmatrix} * I $$ 垂直变化：这是通过用奇数大小的内核 $G_y$ 对 $I$ 进行卷积计算的。例如，对于内核大小为 $3$ ， $G_y$ 将被计算为： $$ G_y = \begin{bmatrix} -1 & -2 & -1\\ 0 & 0 & 0\\ +1 & +2 & + 1 \end{bmatrix} * I $$   在图像的每一点上，我们通过结合上述两个结果计算出该点的梯度近似值： $$ G = \sqrt{G_{x}^{2}+G_{y}^{2}} $$ 有时会使用以下更简单的方程式： $$ G = |G_x|+|G_y| $$   当核的大小为 $3$ 时，上面显示的 Sobel核可能会产生明显的不准确（毕竟， Sobel 只是一个导数的近似值）。OpenCV通过使用 Scharr() 函数来解决这种大小为 $3$ 的核的不精确性。这和标准的 Sobel 函数一样快，但比它更准确。它可以实现以下内核 $$ G_x=\begin{bmatrix} -3 & 0 & +3\\ -10 & 0 & +10\\ -3 & 0 & +3 \end{bmatrix}, G_y=\begin{bmatrix} -3 & -10 & -3\\ 0 & 0 & 0\\ +3 & +10 & +3 \end{bmatrix} $$"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://fffzlfk.github.io/posts/"},{"@type":"ListItem","position":3,"name":"OpenCV Sobel Derivatives","item":"https://fffzlfk.github.io/posts/opencv_sobel_derivatives/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"OpenCV Sobel Derivatives","name":"OpenCV Sobel Derivatives","description":"理论   在之前的两个教程中，我们已经看到了卷积的应用实例。最重要的卷积之一是计算图像中的导数（或对它们的近似值）\n  为什么图像中的导数计算可能是重要的？让我们设想一下，我们要检测图像中存在的边缘。比如说：  你可以很容易地注意到，在一个边缘，像素强度的变化是很明显的。一个表达变化的好方法是使用导数。梯度的高变化表示图像中的一个重大变化。\n  为了更加形象，让我们假设我们有一个一维图像。在下面的图中，一个边缘由强度的 \u0026ldquo;跳跃 \u0026ldquo;来表示：    如果我们取第一个导数，可以更容易地看到边缘的 \u0026ldquo;跳跃\u0026rdquo;（实际上，这里出现的是一个最大值）：    因此，从上面的解释中，我们可以推断出，检测图像中的边缘的方法可以通过定位梯度高于其邻居的像素位置（或者概括地说，高于一个阈值）来进行。\n  更详细的解释，请参考Bradski和Kaehler的《Learning OpenCV》。\n  Sobel 算子  Sobel算子是一个离散的微分算子，它计算图像强度函数的梯度的近似值。 Sobel算子结合了Gaussian smoothing和微分。  Formulation 假设要操作的图像为 $I$:\n 我们计算两个导数：  水平变化：这是通过用奇数大小的内核 $G_x$ 对 $I$ 进行卷积计算的。例如，对于内核大小为 $3$ ， $G_x$ 将被计算为： $$ G_x=\\begin{bmatrix} -1 \u0026amp; 0 \u0026amp; +1\\\\ -2 \u0026amp; 0 \u0026amp; +2\\\\ -1 \u0026amp; 0 \u0026amp; +1 \\end{bmatrix} * I $$ 垂直变化：这是通过用奇数大小的内核 $G_y$ 对 $I$ 进行卷积计算的。例如，对于内核大小为 $3$ ， $G_y$ 将被计算为： $$ G_y = \\begin{bmatrix} -1 \u0026amp; -2 \u0026amp; -1\\\\ 0 \u0026amp; 0 \u0026amp; 0\\\\ +1 \u0026amp; +2 \u0026amp; + 1 \\end{bmatrix} * I $$   在图像的每一点上，我们通过结合上述两个结果计算出该点的梯度近似值： $$ G = \\sqrt{G_{x}^{2}+G_{y}^{2}} $$ 有时会使用以下更简单的方程式： $$ G = |G_x|+|G_y| $$   当核的大小为 $3$ 时，上面显示的 Sobel核可能会产生明显的不准确（毕竟， Sobel 只是一个导数的近似值）。OpenCV通过使用 Scharr() 函数来解决这种大小为 $3$ 的核的不精确性。这和标准的 Sobel 函数一样快，但比它更准确。它可以实现以下内核 $$ G_x=\\begin{bmatrix} -3 \u0026amp; 0 \u0026amp; +3\\\\ -10 \u0026amp; 0 \u0026amp; +10\\\\ -3 \u0026amp; 0 \u0026amp; +3 \\end{bmatrix}, G_y=\\begin{bmatrix} -3 \u0026amp; -10 \u0026amp; -3\\\\ 0 \u0026amp; 0 \u0026amp; 0\\\\ +3 \u0026amp; +10 \u0026amp; +3 \\end{bmatrix} $$","keywords":["OpenCV"],"articleBody":"理论   在之前的两个教程中，我们已经看到了卷积的应用实例。最重要的卷积之一是计算图像中的导数（或对它们的近似值）\n  为什么图像中的导数计算可能是重要的？让我们设想一下，我们要检测图像中存在的边缘。比如说：  你可以很容易地注意到，在一个边缘，像素强度的变化是很明显的。一个表达变化的好方法是使用导数。梯度的高变化表示图像中的一个重大变化。\n  为了更加形象，让我们假设我们有一个一维图像。在下面的图中，一个边缘由强度的 “跳跃 “来表示：    如果我们取第一个导数，可以更容易地看到边缘的 “跳跃”（实际上，这里出现的是一个最大值）：    因此，从上面的解释中，我们可以推断出，检测图像中的边缘的方法可以通过定位梯度高于其邻居的像素位置（或者概括地说，高于一个阈值）来进行。\n  更详细的解释，请参考Bradski和Kaehler的《Learning OpenCV》。\n  Sobel 算子  Sobel算子是一个离散的微分算子，它计算图像强度函数的梯度的近似值。 Sobel算子结合了Gaussian smoothing和微分。  Formulation 假设要操作的图像为 $I$:\n 我们计算两个导数：  水平变化：这是通过用奇数大小的内核 $G_x$ 对 $I$ 进行卷积计算的。例如，对于内核大小为 $3$ ， $G_x$ 将被计算为： $$ G_x=\\begin{bmatrix} -1 \u0026 0 \u0026 +1\\\\ -2 \u0026 0 \u0026 +2\\\\ -1 \u0026 0 \u0026 +1 \\end{bmatrix} * I $$ 垂直变化：这是通过用奇数大小的内核 $G_y$ 对 $I$ 进行卷积计算的。例如，对于内核大小为 $3$ ， $G_y$ 将被计算为： $$ G_y = \\begin{bmatrix} -1 \u0026 -2 \u0026 -1\\\\ 0 \u0026 0 \u0026 0\\\\ +1 \u0026 +2 \u0026 + 1 \\end{bmatrix} * I $$   在图像的每一点上，我们通过结合上述两个结果计算出该点的梯度近似值： $$ G = \\sqrt{G_{x}^{2}+G_{y}^{2}} $$ 有时会使用以下更简单的方程式： $$ G = |G_x|+|G_y| $$   当核的大小为 $3$ 时，上面显示的 Sobel核可能会产生明显的不准确（毕竟， Sobel 只是一个导数的近似值）。OpenCV通过使用 Scharr() 函数来解决这种大小为 $3$ 的核的不精确性。这和标准的 Sobel 函数一样快，但比它更准确。它可以实现以下内核 $$ G_x=\\begin{bmatrix} -3 \u0026 0 \u0026 +3\\\\ -10 \u0026 0 \u0026 +10\\\\ -3 \u0026 0 \u0026 +3 \\end{bmatrix}, G_y=\\begin{bmatrix} -3 \u0026 -10 \u0026 -3\\\\ 0 \u0026 0 \u0026 0\\\\ +3 \u0026 +10 \u0026 +3 \\end{bmatrix} $$\n Code 代码链接\nExplanation 变量声明 // First we declare the variables we are going to use Mat image,src, src_gray; Mat grad; const String window_name = \"Sobel Demo - Simple Edge Detector\"; int ksize = parser.getint(\"ksize\"); int scale = parser.getint(\"scale\"); int delta = parser.getint(\"delta\"); int ddepth = CV_16S; 加载图像 String imageName = parser.getString(\"@input\"); // As usual we load our source image (src) image = imread( samples::findFile( imageName ), IMREAD_COLOR ); // Load an image // Check if image is loaded fine if( image.empty() ) {  printf(\"Error opening image: %s\\n\", imageName.c_str());  return EXIT_FAILURE; } 消除噪声 // Remove noise by blurring with a Gaussian filter ( kernel size = 3 ) GaussianBlur(image, src, Size(3, 3), 0, 0, BORDER_DEFAULT); 灰度化 // Convert the image to grayscale cvtColor(src, src_gray, COLOR_BGR2GRAY); Sobel 算子 Mat grad_x, grad_y; Mat abs_grad_x, abs_grad_y; Sobel(src_gray, grad_x, ddepth, 1, 0, ksize, scale, delta, BORDER_DEFAULT); Sobel(src_gray, grad_y, ddepth, 0, 1, ksize, scale, delta, BORDER_DEFAULT);  我们计算 $x$ 和 $y$ 方向的 “导数”。为此，我们使用函数Sobel()，如下所示。该函数需要以下参数:  src_gray：在我们的例子中，输入的图像。这里是CV_8U grad_x / grad_y：输出图像。 ddepth：输出图像的深度。我们将其设置为CV_16S以避免溢出。 x_order： $X$ 方向上的导数顺序。 y_order: $Y$ 方向的导数顺序。 scale：delta和BORDER_DEFAULT：我们使用默认值。     注意，在计算 $x$ 方向的梯度时，我们使用：xorder=1，yorder=0，我们对 $y$ 方向进行类似的计算。\n 转换为CV_8U图像 // converting back to CV_8U convertScaleAbs(grad_x, abs_grad_x); convertScaleAbs(grad_y, abs_grad_y); 梯度 addWeighted(abs_grad_x, 0.5, abs_grad_y, 0.5, 0, grad);  我们试图通过增加两个方向的梯度来近似计算梯度（注意，这不是一个精确的计算！但对我们的目的来说是好的）。\n 结果  References https://docs.opencv.org/4.5.5/d2/d2c/tutorial_sobel_derivatives.html\n","wordCount":"338","inLanguage":"en","datePublished":"2022-01-16T12:18:12+08:00","dateModified":"2022-01-16T12:18:12+08:00","author":{"@type":"Person","name":"fffzlfk"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://fffzlfk.github.io/posts/opencv_sobel_derivatives/"},"publisher":{"@type":"Organization","name":"fffzlfk's Blog","logo":{"@type":"ImageObject","url":"https://fffzlfk.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://fffzlfk.github.io accesskey=h title="fffzlfk's Blog (Alt + H)"><img src=https://fffzlfk.github.io/android-chrome-512x512.png alt=logo aria-label=logo height=35>fffzlfk's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://github.com/fffzlfk title=GitHub><span>GitHub</span></a></li><li><a href=https://fffzlfk.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://fffzlfk.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://fffzlfk.github.io/about/ title=About><span>About</span></a></li><li><a href=https://fffzlfk.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://fffzlfk.github.io>Home</a>&nbsp;»&nbsp;<a href=https://fffzlfk.github.io/posts/>Posts</a></div><h1 class=post-title>OpenCV Sobel Derivatives</h1><div class=post-meta><span title="2022-01-16 12:18:12 +0800 +0800">January 16, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;fffzlfk&nbsp;|&nbsp;<a href=https://github.com/fffzlfk/fffzlfk.github.io/blob/master/content/posts/OpenCV_Sobel_Derivatives.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e7%90%86%e8%ae%ba aria-label=理论>理论</a><ul><li><a href=#sobel-%e7%ae%97%e5%ad%90 aria-label="Sobel 算子">Sobel 算子</a></li><li><a href=#formulation aria-label=Formulation>Formulation</a></li></ul></li><li><a href=#code aria-label=Code>Code</a><ul><li><a href=#explanation aria-label=Explanation>Explanation</a><ul><li><a href=#%e5%8f%98%e9%87%8f%e5%a3%b0%e6%98%8e aria-label=变量声明>变量声明</a></li><li><a href=#%e5%8a%a0%e8%bd%bd%e5%9b%be%e5%83%8f aria-label=加载图像>加载图像</a></li><li><a href=#%e6%b6%88%e9%99%a4%e5%99%aa%e5%a3%b0 aria-label=消除噪声>消除噪声</a></li><li><a href=#%e7%81%b0%e5%ba%a6%e5%8c%96 aria-label=灰度化>灰度化</a></li><li><a href=#sobel-%e7%ae%97%e5%ad%90-1 aria-label="Sobel 算子">Sobel 算子</a></li><li><a href=#%e8%bd%ac%e6%8d%a2%e4%b8%bacv_8u%e5%9b%be%e5%83%8f aria-label=转换为CV_8U图像>转换为CV_8U图像</a></li><li><a href=#%e6%a2%af%e5%ba%a6 aria-label=梯度>梯度</a></li></ul></li></ul></li><li><a href=#%e7%bb%93%e6%9e%9c aria-label=结果>结果</a></li><li><a href=#references aria-label=References>References</a></li></ul></div></details></div><div class=post-content><h2 id=理论>理论<a hidden class=anchor aria-hidden=true href=#理论>#</a></h2><ol><li><p>在之前的两个教程中，我们已经看到了卷积的应用实例。最重要的卷积之一是计算图像中的导数（或对它们的近似值）</p></li><li><p>为什么图像中的导数计算可能是重要的？让我们设想一下，我们要检测图像中存在的边缘。比如说：<div class=render-image><img loading=lazy src=https://docs.opencv.org/4.5.5/Sobel_Derivatives_Tutorial_Theory_0.jpg alt></div>你可以很容易地注意到，在一个边缘，像素强度的变化是很明显的。一个表达变化的好方法是使用导数。梯度的高变化表示图像中的一个重大变化。</p></li><li><p>为了更加形象，让我们假设我们有一个一维图像。在下面的图中，一个边缘由强度的 &ldquo;跳跃 &ldquo;来表示：<div class=render-image><img loading=lazy src=https://docs.opencv.org/4.5.5/Sobel_Derivatives_Tutorial_Theory_Intensity_Function.jpg alt></div></p></li><li><p>如果我们取第一个导数，可以更容易地看到边缘的 &ldquo;跳跃&rdquo;（实际上，这里出现的是一个最大值）：<div class=render-image><img loading=lazy src=https://docs.opencv.org/4.5.5/Sobel_Derivatives_Tutorial_Theory_dIntensity_Function.jpg alt></div></p></li><li><p>因此，从上面的解释中，我们可以推断出，检测图像中的边缘的方法可以通过定位梯度高于其邻居的像素位置（或者概括地说，高于一个阈值）来进行。</p></li><li><p>更详细的解释，请参考Bradski和Kaehler的<a href=https://www.amazon.com/Learning-OpenCV-Computer-Vision-Library/dp/0596516134>《Learning OpenCV》</a>。</p></li></ol><h3 id=sobel-算子>Sobel 算子<a hidden class=anchor aria-hidden=true href=#sobel-算子>#</a></h3><ol><li>Sobel算子是一个离散的微分算子，它计算图像强度函数的梯度的近似值。</li><li>Sobel算子结合了<code>Gaussian smoothing</code>和微分。</li></ol><h3 id=formulation>Formulation<a hidden class=anchor aria-hidden=true href=#formulation>#</a></h3><p>假设要操作的图像为 $I$:</p><ol><li>我们计算两个导数：<ol><li><strong>水平变化</strong>：这是通过用奇数大小的内核 $G_x$ 对 $I$ 进行卷积计算的。例如，对于内核大小为 $3$ ， $G_x$ 将被计算为：
$$
G_x=\begin{bmatrix}
-1 & 0 & +1\\
-2 & 0 & +2\\
-1 & 0 & +1
\end{bmatrix} * I
$$</li><li><strong>垂直变化</strong>：这是通过用奇数大小的内核 $G_y$ 对 $I$ 进行卷积计算的。例如，对于内核大小为 $3$ ， $G_y$ 将被计算为：
$$
G_y = \begin{bmatrix}
-1 & -2 & -1\\
0 & 0 & 0\\
+1 & +2 & + 1
\end{bmatrix} * I
$$</li></ol></li><li>在图像的每一点上，我们通过结合上述两个结果计算出该点的梯度近似值：
$$
G = \sqrt{G_{x}^{2}+G_{y}^{2}}
$$
有时会使用以下更简单的方程式：
$$
G = |G_x|+|G_y|
$$</li></ol><blockquote><p>当核的大小为 $3$ 时，上面显示的 <code>Sobel</code>核可能会产生明显的不准确（毕竟， <code>Sobel</code> 只是一个导数的近似值）。OpenCV通过使用 <code>Scharr()</code> 函数来解决这种大小为 $3$ 的核的不精确性。这和标准的 <code>Sobel</code> 函数一样快，但比它更准确。它可以实现以下内核
$$
G_x=\begin{bmatrix}
-3 & 0 & +3\\
-10 & 0 & +10\\
-3 & 0 & +3
\end{bmatrix},
G_y=\begin{bmatrix}
-3 & -10 & -3\\
0 & 0 & 0\\
+3 & +10 & +3
\end{bmatrix}
$$</p></blockquote><h2 id=code>Code<a hidden class=anchor aria-hidden=true href=#code>#</a></h2><p><a href=https://github.com/fffzlfk/opencv_learning/blob/main/src/transformations/copy_make_border.cpp>代码链接</a></p><h3 id=explanation>Explanation<a hidden class=anchor aria-hidden=true href=#explanation>#</a></h3><h4 id=变量声明>变量声明<a hidden class=anchor aria-hidden=true href=#变量声明>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// First we declare the variables we are going to use
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Mat image,src, src_gray;
</span></span><span style=display:flex><span>Mat grad;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> String window_name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Sobel Demo - Simple Edge Detector&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> ksize <span style=color:#f92672>=</span> parser.get<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(<span style=color:#e6db74>&#34;ksize&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> scale <span style=color:#f92672>=</span> parser.get<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(<span style=color:#e6db74>&#34;scale&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> delta <span style=color:#f92672>=</span> parser.get<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(<span style=color:#e6db74>&#34;delta&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> ddepth <span style=color:#f92672>=</span> CV_16S;
</span></span></code></pre></div><h4 id=加载图像>加载图像<a hidden class=anchor aria-hidden=true href=#加载图像>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>String imageName <span style=color:#f92672>=</span> parser.get<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>(<span style=color:#e6db74>&#34;@input&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>// As usual we load our source image (src)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>image <span style=color:#f92672>=</span> imread( samples<span style=color:#f92672>::</span>findFile( imageName ), IMREAD_COLOR ); <span style=color:#75715e>// Load an image
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Check if image is loaded fine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span>( image.empty() )
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;Error opening image: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, imageName.c_str());
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> EXIT_FAILURE;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=消除噪声>消除噪声<a hidden class=anchor aria-hidden=true href=#消除噪声>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Remove noise by blurring with a Gaussian filter ( kernel size = 3 )
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>GaussianBlur(image, src, Size(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>3</span>), <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, BORDER_DEFAULT);
</span></span></code></pre></div><h4 id=灰度化>灰度化<a hidden class=anchor aria-hidden=true href=#灰度化>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Convert the image to grayscale
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>cvtColor(src, src_gray, COLOR_BGR2GRAY);
</span></span></code></pre></div><h4 id=sobel-算子-1>Sobel 算子<a hidden class=anchor aria-hidden=true href=#sobel-算子-1>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Mat grad_x, grad_y;
</span></span><span style=display:flex><span>Mat abs_grad_x, abs_grad_y;
</span></span><span style=display:flex><span>Sobel(src_gray, grad_x, ddepth, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, ksize, scale, delta, BORDER_DEFAULT);
</span></span><span style=display:flex><span>Sobel(src_gray, grad_y, ddepth, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, ksize, scale, delta, BORDER_DEFAULT);
</span></span></code></pre></div><ul><li>我们计算 $x$ 和 $y$ 方向的 &ldquo;导数&rdquo;。为此，我们使用函数<code>Sobel()</code>，如下所示。该函数需要以下参数:<ul><li><code>src_gray</code>：在我们的例子中，输入的图像。这里是<code>CV_8U</code></li><li><code>grad_x / grad_y</code>：输出图像。</li><li><code>ddepth</code>：输出图像的深度。我们将其设置为<code>CV_16S</code>以避免溢出。</li><li><code>x_order</code>： $X$ 方向上的导数顺序。</li><li><code>y_order</code>: $Y$ 方向的导数顺序。</li><li><code>scale</code>：<code>delta</code>和<code>BORDER_DEFAULT</code>：我们使用默认值。</li></ul></li></ul><blockquote><p>注意，在计算 $x$ 方向的梯度时，我们使用：<code>xorder=1</code>，<code>yorder=0</code>，我们对 $y$ 方向进行类似的计算。</p></blockquote><h4 id=转换为cv_8u图像>转换为CV_8U图像<a hidden class=anchor aria-hidden=true href=#转换为cv_8u图像>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// converting back to CV_8U
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>convertScaleAbs(grad_x, abs_grad_x);
</span></span><span style=display:flex><span>convertScaleAbs(grad_y, abs_grad_y);
</span></span></code></pre></div><h4 id=梯度>梯度<a hidden class=anchor aria-hidden=true href=#梯度>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>addWeighted(abs_grad_x, <span style=color:#ae81ff>0.5</span>, abs_grad_y, <span style=color:#ae81ff>0.5</span>, <span style=color:#ae81ff>0</span>, grad);
</span></span></code></pre></div><blockquote><p>我们试图通过增加两个方向的梯度来近似计算梯度（注意，这不是一个精确的计算！但对我们的目的来说是好的）。</p></blockquote><h2 id=结果>结果<a hidden class=anchor aria-hidden=true href=#结果>#</a></h2><p><div class=render-image><img loading=lazy src=https://docs.opencv.org/4.5.5/Sobel_Derivatives_Tutorial_Result.jpg alt></div></p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><p><a href=https://docs.opencv.org/4.5.5/d2/d2c/tutorial_sobel_derivatives.html>https://docs.opencv.org/4.5.5/d2/d2c/tutorial_sobel_derivatives.html</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://fffzlfk.github.io/tags/opencv/>OpenCV</a></li></ul><nav class=paginav><a class=prev href=https://fffzlfk.github.io/posts/opencv_laplace_operator/><span class=title>« Prev Page</span><br><span>OpenCV Laplace Operator</span></a>
<a class=next href=https://fffzlfk.github.io/posts/opencv_erosion_dilatation/><span class=title>Next Page »</span><br><span>OpenCV Erosion Dilatation</span></a></nav></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//https-fffzlfk-github-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2022 <a href=https://fffzlfk.github.io>fffzlfk's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>