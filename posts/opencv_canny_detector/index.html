<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>OpenCV Canny Detector | fffzlfk's Blog</title><meta name=keywords content="OpenCV">
<meta name=description content="理论 Canny边缘检测是由John F. Canny在1986年开发的。许多人也将其称为最佳检测器，Canny算法旨在满足三个主要标准。
 好的检测：算法能够尽可能多地标识出图像中的实际边缘。 好的定位：标识出的边缘要与实际图像中的实际边缘尽可能接近。 最小响应：图像中的边缘只能标识一次，并且可能存在的图像雜訊不应标识为边缘。  步骤   降噪：使用高斯滤波来达到，下面是一个大小为 $5$ 的高斯核的例子： $$ K = \frac{1}{159}\begin{bmatrix} 2 & 4 & 5 & 4 & 2\\ 4 & 9 & 12 & 9 & 4\\ 5 & 12 & 15 & 12 & 5\\ 4 & 9 & 12 & 9 & 4\\ 2 & 4 & 5 & 4 & 2 \end{bmatrix} $$
  找到图像的亮度梯度：为此，我们遵循一个类似于Sobel的程序：
 应用一对卷积masks（在 $x$ 和 $y$ 方向上）： $$ G_x = \begin{bmatrix} -1 & 0 & +1\\ -2 & 0 & +2\\ -1 & 0 & +1 \end{bmatrix}, G_y=\begin{bmatrix} -1 & -2 & -1\\ 0 & 0 & 0\\ +1 & +2 & +1 \end{bmatrix} $$ 寻找梯度强度和方向： $$ G=\sqrt{G_x^2+G_y^2}\\ \theta = \arctan(\frac{G_y}{G_x}) $$ 方向被四舍五入为四个可能的角度之一（即 $0\degree$ 、 $45\degree$ 、 $90\degree$ 或 $135\degree$ ）。    过滤非最大值：在高斯滤波过程中，边缘有可能被放大了。这个步骤使用一个规则来过滤不是边缘的点，使边缘的宽度尽可能为1个像素点：如果一个像素点属于边缘，那么这个像素点在梯度方向上的梯度值是最大的。否则不是边缘，将灰度值设为 $0$ 。 $$ M_T(m, n) = \begin{cases} M(m, n)& \text{if } M(m, n) \lt T\\ 0 & \text{otherwise} \end{cases} $$">
<meta name=author content="fffzlfk">
<link rel=canonical href=https://fffzlfk.github.io/posts/opencv_canny_detector/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.3cc2f3b678f10ed24598ec2e25cb5e89b6337af814542c19224ebfcba8304f9d.css integrity="sha256-PMLztnjxDtJFmOwuJcteibYzevgUVCwZIk6/y6gwT50=" rel="preload stylesheet" as=style>
<link rel=preload href=/android-chrome-512x512.png as=image>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://fffzlfk.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://fffzlfk.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://fffzlfk.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://fffzlfk.github.io/apple_touch_icon.png>
<link rel=mask-icon href=https://fffzlfk.github.io/favicon.ico>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="OpenCV Canny Detector">
<meta property="og:description" content="理论 Canny边缘检测是由John F. Canny在1986年开发的。许多人也将其称为最佳检测器，Canny算法旨在满足三个主要标准。
 好的检测：算法能够尽可能多地标识出图像中的实际边缘。 好的定位：标识出的边缘要与实际图像中的实际边缘尽可能接近。 最小响应：图像中的边缘只能标识一次，并且可能存在的图像雜訊不应标识为边缘。  步骤   降噪：使用高斯滤波来达到，下面是一个大小为 $5$ 的高斯核的例子： $$ K = \frac{1}{159}\begin{bmatrix} 2 & 4 & 5 & 4 & 2\\ 4 & 9 & 12 & 9 & 4\\ 5 & 12 & 15 & 12 & 5\\ 4 & 9 & 12 & 9 & 4\\ 2 & 4 & 5 & 4 & 2 \end{bmatrix} $$
  找到图像的亮度梯度：为此，我们遵循一个类似于Sobel的程序：
 应用一对卷积masks（在 $x$ 和 $y$ 方向上）： $$ G_x = \begin{bmatrix} -1 & 0 & +1\\ -2 & 0 & +2\\ -1 & 0 & +1 \end{bmatrix}, G_y=\begin{bmatrix} -1 & -2 & -1\\ 0 & 0 & 0\\ +1 & +2 & +1 \end{bmatrix} $$ 寻找梯度强度和方向： $$ G=\sqrt{G_x^2+G_y^2}\\ \theta = \arctan(\frac{G_y}{G_x}) $$ 方向被四舍五入为四个可能的角度之一（即 $0\degree$ 、 $45\degree$ 、 $90\degree$ 或 $135\degree$ ）。    过滤非最大值：在高斯滤波过程中，边缘有可能被放大了。这个步骤使用一个规则来过滤不是边缘的点，使边缘的宽度尽可能为1个像素点：如果一个像素点属于边缘，那么这个像素点在梯度方向上的梯度值是最大的。否则不是边缘，将灰度值设为 $0$ 。 $$ M_T(m, n) = \begin{cases} M(m, n)& \text{if } M(m, n) \lt T\\ 0 & \text{otherwise} \end{cases} $$">
<meta property="og:type" content="article">
<meta property="og:url" content="https://fffzlfk.github.io/posts/opencv_canny_detector/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-01-17T11:35:18+08:00">
<meta property="article:modified_time" content="2022-01-17T11:35:18+08:00"><meta property="og:site_name" content="fffzlfk's Blog">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="OpenCV Canny Detector">
<meta name=twitter:description content="理论 Canny边缘检测是由John F. Canny在1986年开发的。许多人也将其称为最佳检测器，Canny算法旨在满足三个主要标准。
 好的检测：算法能够尽可能多地标识出图像中的实际边缘。 好的定位：标识出的边缘要与实际图像中的实际边缘尽可能接近。 最小响应：图像中的边缘只能标识一次，并且可能存在的图像雜訊不应标识为边缘。  步骤   降噪：使用高斯滤波来达到，下面是一个大小为 $5$ 的高斯核的例子： $$ K = \frac{1}{159}\begin{bmatrix} 2 & 4 & 5 & 4 & 2\\ 4 & 9 & 12 & 9 & 4\\ 5 & 12 & 15 & 12 & 5\\ 4 & 9 & 12 & 9 & 4\\ 2 & 4 & 5 & 4 & 2 \end{bmatrix} $$
  找到图像的亮度梯度：为此，我们遵循一个类似于Sobel的程序：
 应用一对卷积masks（在 $x$ 和 $y$ 方向上）： $$ G_x = \begin{bmatrix} -1 & 0 & +1\\ -2 & 0 & +2\\ -1 & 0 & +1 \end{bmatrix}, G_y=\begin{bmatrix} -1 & -2 & -1\\ 0 & 0 & 0\\ +1 & +2 & +1 \end{bmatrix} $$ 寻找梯度强度和方向： $$ G=\sqrt{G_x^2+G_y^2}\\ \theta = \arctan(\frac{G_y}{G_x}) $$ 方向被四舍五入为四个可能的角度之一（即 $0\degree$ 、 $45\degree$ 、 $90\degree$ 或 $135\degree$ ）。    过滤非最大值：在高斯滤波过程中，边缘有可能被放大了。这个步骤使用一个规则来过滤不是边缘的点，使边缘的宽度尽可能为1个像素点：如果一个像素点属于边缘，那么这个像素点在梯度方向上的梯度值是最大的。否则不是边缘，将灰度值设为 $0$ 。 $$ M_T(m, n) = \begin{cases} M(m, n)& \text{if } M(m, n) \lt T\\ 0 & \text{otherwise} \end{cases} $$">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://fffzlfk.github.io/posts/"},{"@type":"ListItem","position":3,"name":"OpenCV Canny Detector","item":"https://fffzlfk.github.io/posts/opencv_canny_detector/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"OpenCV Canny Detector","name":"OpenCV Canny Detector","description":"理论 Canny边缘检测是由John F. Canny在1986年开发的。许多人也将其称为最佳检测器，Canny算法旨在满足三个主要标准。\n 好的检测：算法能够尽可能多地标识出图像中的实际边缘。 好的定位：标识出的边缘要与实际图像中的实际边缘尽可能接近。 最小响应：图像中的边缘只能标识一次，并且可能存在的图像雜訊不应标识为边缘。  步骤   降噪：使用高斯滤波来达到，下面是一个大小为 $5$ 的高斯核的例子： $$ K = \\frac{1}{159}\\begin{bmatrix} 2 \u0026amp; 4 \u0026amp; 5 \u0026amp; 4 \u0026amp; 2\\\\ 4 \u0026amp; 9 \u0026amp; 12 \u0026amp; 9 \u0026amp; 4\\\\ 5 \u0026amp; 12 \u0026amp; 15 \u0026amp; 12 \u0026amp; 5\\\\ 4 \u0026amp; 9 \u0026amp; 12 \u0026amp; 9 \u0026amp; 4\\\\ 2 \u0026amp; 4 \u0026amp; 5 \u0026amp; 4 \u0026amp; 2 \\end{bmatrix} $$\n  找到图像的亮度梯度：为此，我们遵循一个类似于Sobel的程序：\n 应用一对卷积masks（在 $x$ 和 $y$ 方向上）： $$ G_x = \\begin{bmatrix} -1 \u0026amp; 0 \u0026amp; +1\\\\ -2 \u0026amp; 0 \u0026amp; +2\\\\ -1 \u0026amp; 0 \u0026amp; +1 \\end{bmatrix}, G_y=\\begin{bmatrix} -1 \u0026amp; -2 \u0026amp; -1\\\\ 0 \u0026amp; 0 \u0026amp; 0\\\\ +1 \u0026amp; +2 \u0026amp; +1 \\end{bmatrix} $$ 寻找梯度强度和方向： $$ G=\\sqrt{G_x^2+G_y^2}\\\\ \\theta = \\arctan(\\frac{G_y}{G_x}) $$ 方向被四舍五入为四个可能的角度之一（即 $0\\degree$ 、 $45\\degree$ 、 $90\\degree$ 或 $135\\degree$ ）。    过滤非最大值：在高斯滤波过程中，边缘有可能被放大了。这个步骤使用一个规则来过滤不是边缘的点，使边缘的宽度尽可能为1个像素点：如果一个像素点属于边缘，那么这个像素点在梯度方向上的梯度值是最大的。否则不是边缘，将灰度值设为 $0$ 。 $$ M_T(m, n) = \\begin{cases} M(m, n)\u0026amp; \\text{if } M(m, n) \\lt T\\\\ 0 \u0026amp; \\text{otherwise} \\end{cases} $$","keywords":["OpenCV"],"articleBody":"理论 Canny边缘检测是由John F. Canny在1986年开发的。许多人也将其称为最佳检测器，Canny算法旨在满足三个主要标准。\n 好的检测：算法能够尽可能多地标识出图像中的实际边缘。 好的定位：标识出的边缘要与实际图像中的实际边缘尽可能接近。 最小响应：图像中的边缘只能标识一次，并且可能存在的图像雜訊不应标识为边缘。  步骤   降噪：使用高斯滤波来达到，下面是一个大小为 $5$ 的高斯核的例子： $$ K = \\frac{1}{159}\\begin{bmatrix} 2 \u0026 4 \u0026 5 \u0026 4 \u0026 2\\\\ 4 \u0026 9 \u0026 12 \u0026 9 \u0026 4\\\\ 5 \u0026 12 \u0026 15 \u0026 12 \u0026 5\\\\ 4 \u0026 9 \u0026 12 \u0026 9 \u0026 4\\\\ 2 \u0026 4 \u0026 5 \u0026 4 \u0026 2 \\end{bmatrix} $$\n  找到图像的亮度梯度：为此，我们遵循一个类似于Sobel的程序：\n 应用一对卷积masks（在 $x$ 和 $y$ 方向上）： $$ G_x = \\begin{bmatrix} -1 \u0026 0 \u0026 +1\\\\ -2 \u0026 0 \u0026 +2\\\\ -1 \u0026 0 \u0026 +1 \\end{bmatrix}, G_y=\\begin{bmatrix} -1 \u0026 -2 \u0026 -1\\\\ 0 \u0026 0 \u0026 0\\\\ +1 \u0026 +2 \u0026 +1 \\end{bmatrix} $$ 寻找梯度强度和方向： $$ G=\\sqrt{G_x^2+G_y^2}\\\\ \\theta = \\arctan(\\frac{G_y}{G_x}) $$ 方向被四舍五入为四个可能的角度之一（即 $0\\degree$ 、 $45\\degree$ 、 $90\\degree$ 或 $135\\degree$ ）。    过滤非最大值：在高斯滤波过程中，边缘有可能被放大了。这个步骤使用一个规则来过滤不是边缘的点，使边缘的宽度尽可能为1个像素点：如果一个像素点属于边缘，那么这个像素点在梯度方向上的梯度值是最大的。否则不是边缘，将灰度值设为 $0$ 。 $$ M_T(m, n) = \\begin{cases} M(m, n)\u0026 \\text{if } M(m, n) \\lt T\\\\ 0 \u0026 \\text{otherwise} \\end{cases} $$\n  滞后：这是最后一步，Canny确实使用了两个阈值（上限和下限）。\n 如果一个像素的梯度值高于上限阈值，则该像素被接受为边缘。 如果一个像素的梯度值低于下限阈值，那么它将被拒绝。 如果像素梯度在两个阈值之间，那么只有当它与高于上层阈值的像素相连时，才会被接受。 Canny建议上下限的比值在 $2:1$ 和 $3:1$ 之间。    Code 代码链接\nExplanation 变量定义 Mat src, src_gray; Mat dst, detected_edges; int lowThreshold = 0; const int max_lowThreshold = 100; const int ratio = 3; const int kernel_size = 3; const char* window_name = \"Edge Map\";  我们建立了一个 $3:1$ 的下限:上限阈值的比值（用可变比值）。 我们设定内核大小为 $3$ （用于Canny函数内部进行的Sobel运算） 我们将下限阈值的最大值设定为 $100$ 。  加载图像 CommandLineParser parser( argc, argv, \"{@input | fruits.jpg | input image}\" ); src = imread( samples::findFile( parser.getString( \"@input\" ) ), IMREAD_COLOR ); // Load an image if( src.empty() ) {  std::cout  \"Could not open or find the image!\\n\"  std::endl;  std::cout  \"Usage: \"  argv[0]  \" \"  std::endl;  return -1; } 创建一个与src相同类型和大小的矩阵（dst）。 dst.create( src.size(), src.type() ); 灰度化 cvtColor( src, src_gray, COLOR_BGR2GRAY ); 创建一个窗口来显示结果 namedWindow( window_name, WINDOW_AUTOSIZE ); 创建一个Trackbar，让用户为我们的Canny检测器输入低阈值 createTrackbar( \"Min Threshold:\", window_name, \u0026lowThreshold, max_lowThreshold, CannyThreshold ); 让我们一步一步地观察CannyThreshold函数   首先，我们用内核大小为 $3$ 的滤波器对图像进行模糊处理。\nblur( src_gray, detected_edges, Size(3,3) );   接着，我们应用OpenCV函数cv::Canny\nCanny( detected_edges, detected_edges, lowThreshold, lowThreshold*ratio, kernel_size );  detected_edges：源图像（灰度图） detected_edges：输出图像（可与输入相同） lowThreshold：用户移动Trackbar时输入的值 highThreshold：在程序中设置为lowThreshold的 $3$ 倍（按照Canny的建议） kernel_size：我们将其定义为 $3$ （内部使用的Sobel内核的大小）。    我们用零来填充dst图像（意味着图像是完全黑色的） dst = Scalar::all(0); 显示 最后，我们将使用函数cv::Mat::copyTo只映射图像中被识别为边缘的区域（在黑色背景上）。cv::Mat::copyTo将src图像复制到dst上。注意，它只会复制像素的非零值的位置。因为Canny检测器的输出是黑色背景上的边缘轮廓，所以除了检测到的边缘，生成的dst将是黑色的。\n 若没有这一步，那么我们得到的图像是边缘的灰度图\n 结果 References https://docs.opencv.org/4.5.5/da/d5c/tutorial_canny_detector.html\n","wordCount":"313","inLanguage":"en","datePublished":"2022-01-17T11:35:18+08:00","dateModified":"2022-01-17T11:35:18+08:00","author":{"@type":"Person","name":"fffzlfk"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://fffzlfk.github.io/posts/opencv_canny_detector/"},"publisher":{"@type":"Organization","name":"fffzlfk's Blog","logo":{"@type":"ImageObject","url":"https://fffzlfk.github.io/favicon.ico"}}}</script>
</head><body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://fffzlfk.github.io accesskey=h title="fffzlfk's Blog (Alt + H)">
<img src=https://fffzlfk.github.io/android-chrome-512x512.png alt=logo aria-label=logo height=35>fffzlfk's Blog</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div><ul id=menu>
<li>
<a href=https://github.com/fffzlfk title=GitHub>
<span>GitHub</span>
</a>
</li><li>
<a href=https://fffzlfk.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li><li>
<a href=https://fffzlfk.github.io/archives title=Archive>
<span>Archive</span>
</a>
</li><li>
<a href=https://fffzlfk.github.io/about/ title=About>
<span>About</span>
</a>
</li><li>
<a href=https://fffzlfk.github.io/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li></ul></nav></header><main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://fffzlfk.github.io>Home</a>&nbsp;»&nbsp;<a href=https://fffzlfk.github.io/posts/>Posts</a></div><h1 class=post-title>
OpenCV Canny Detector
</h1><div class=post-meta><span title="2022-01-17 11:35:18 +0800 +0800">January 17, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;fffzlfk&nbsp;|&nbsp;<a href=https://github.com/fffzlfk/fffzlfk.github.io/blob/master/content/posts/OpenCV_Canny_Detector.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div></header><div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#%e7%90%86%e8%ae%ba aria-label=理论>理论</a><ul>
<li>
<a href=#%e6%ad%a5%e9%aa%a4 aria-label=步骤>步骤</a></li></ul></li><li>
<a href=#code aria-label=Code>Code</a><ul>
<li>
<a href=#explanation aria-label=Explanation>Explanation</a><ul>
<li>
<a href=#%e5%8f%98%e9%87%8f%e5%ae%9a%e4%b9%89 aria-label=变量定义>变量定义</a></li><li>
<a href=#%e5%8a%a0%e8%bd%bd%e5%9b%be%e5%83%8f aria-label=加载图像>加载图像</a></li><li>
<a href=#%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e4%b8%8esrc%e7%9b%b8%e5%90%8c%e7%b1%bb%e5%9e%8b%e5%92%8c%e5%a4%a7%e5%b0%8f%e7%9a%84%e7%9f%a9%e9%98%b5dst aria-label=创建一个与src相同类型和大小的矩阵（dst）。>创建一个与src相同类型和大小的矩阵（dst）。</a></li><li>
<a href=#%e7%81%b0%e5%ba%a6%e5%8c%96 aria-label=灰度化>灰度化</a></li><li>
<a href=#%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e7%aa%97%e5%8f%a3%e6%9d%a5%e6%98%be%e7%a4%ba%e7%bb%93%e6%9e%9c aria-label=创建一个窗口来显示结果>创建一个窗口来显示结果</a></li><li>
<a href=#%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aatrackbar%e8%ae%a9%e7%94%a8%e6%88%b7%e4%b8%ba%e6%88%91%e4%bb%ac%e7%9a%84canny%e6%a3%80%e6%b5%8b%e5%99%a8%e8%be%93%e5%85%a5%e4%bd%8e%e9%98%88%e5%80%bc aria-label=创建一个Trackbar，让用户为我们的Canny检测器输入低阈值>创建一个Trackbar，让用户为我们的Canny检测器输入低阈值</a></li><li>
<a href=#%e8%ae%a9%e6%88%91%e4%bb%ac%e4%b8%80%e6%ad%a5%e4%b8%80%e6%ad%a5%e5%9c%b0%e8%a7%82%e5%af%9fcannythreshold%e5%87%bd%e6%95%b0 aria-label=让我们一步一步地观察CannyThreshold函数>让我们一步一步地观察CannyThreshold函数</a></li><li>
<a href=#%e6%88%91%e4%bb%ac%e7%94%a8%e9%9b%b6%e6%9d%a5%e5%a1%ab%e5%85%85dst%e5%9b%be%e5%83%8f%e6%84%8f%e5%91%b3%e7%9d%80%e5%9b%be%e5%83%8f%e6%98%af%e5%ae%8c%e5%85%a8%e9%bb%91%e8%89%b2%e7%9a%84 aria-label=我们用零来填充dst图像（意味着图像是完全黑色的）>我们用零来填充dst图像（意味着图像是完全黑色的）</a></li><li>
<a href=#%e6%98%be%e7%a4%ba aria-label=显示>显示</a></li></ul></li></ul></li><li>
<a href=#%e7%bb%93%e6%9e%9c aria-label=结果>结果</a></li><li>
<a href=#references aria-label=References>References</a>
</li></ul></div></details>
</div><div class=post-content><h2 id=理论>理论<a hidden class=anchor aria-hidden=true href=#理论>#</a></h2><p><strong>Canny边缘检测</strong>是由John F. Canny在1986年开发的。许多人也将其称为最佳检测器，Canny算法旨在满足三个主要标准。</p><ul>
<li><strong>好的检测</strong>：算法能够尽可能多地标识出图像中的实际边缘。</li><li><strong>好的定位</strong>：标识出的边缘要与实际图像中的实际边缘尽可能接近。</li><li><strong>最小响应</strong>：图像中的边缘只能标识一次，并且可能存在的图像雜訊不应标识为边缘。</li></ul><h3 id=步骤>步骤<a hidden class=anchor aria-hidden=true href=#步骤>#</a></h3><ol>
<li>
<p><strong>降噪</strong>：使用高斯滤波来达到，下面是一个大小为 $5$ 的高斯核的例子：
$$
K = \frac{1}{159}\begin{bmatrix}
2 & 4 & 5 & 4 & 2\\
4 & 9 & 12 & 9 & 4\\
5 & 12 & 15 & 12 & 5\\
4 & 9 & 12 & 9 & 4\\
2 & 4 & 5 & 4 & 2
\end{bmatrix}
$$</p></li><li>
<p><strong>找到图像的亮度梯度</strong>：为此，我们遵循一个类似于<code>Sobel</code>的程序：</p><ol>
<li>应用一对卷积<code>masks</code>（在 $x$ 和 $y$ 方向上）：
$$
G_x = \begin{bmatrix}
-1 & 0 & +1\\
-2 & 0 & +2\\
-1 & 0 & +1
\end{bmatrix}, G_y=\begin{bmatrix}
-1 & -2 & -1\\
0 & 0 & 0\\
+1 & +2 & +1
\end{bmatrix}
$$</li><li>寻找梯度强度和方向：
$$
G=\sqrt{G_x^2+G_y^2}\\
\theta = \arctan(\frac{G_y}{G_x})
$$
方向被四舍五入为四个可能的角度之一（即 $0\degree$ 、 $45\degree$ 、 $90\degree$ 或 $135\degree$ ）。</li></ol></li><li>
<p><strong>过滤非最大值</strong>：在高斯滤波过程中，边缘有可能被放大了。这个步骤使用一个规则来过滤不是边缘的点，使边缘的宽度尽可能为1个像素点：如果一个像素点属于边缘，那么这个像素点在梯度方向上的梯度值是最大的。否则不是边缘，将灰度值设为 $0$ 。
$$
M_T(m, n) = \begin{cases}
M(m, n)& \text{if } M(m, n) \lt T\\
0 & \text{otherwise}
\end{cases}
$$</p></li><li>
<p><strong>滞后</strong>：这是最后一步，Canny确实使用了两个阈值（上限和下限）。</p><ol>
<li>如果一个像素的梯度值高于上限阈值，则该像素被接受为边缘。</li><li>如果一个像素的梯度值低于下限阈值，那么它将被拒绝。</li><li>如果像素梯度在两个阈值之间，那么只有当它与高于上层阈值的像素相连时，才会被接受。
Canny建议上下限的比值在 $2:1$ 和 $3:1$ 之间。</li></ol></li></ol><h2 id=code>Code<a hidden class=anchor aria-hidden=true href=#code>#</a></h2><p><a href=https://github.com/fffzlfk/opencv_learning/blob/main/src/transformations/canny.cpp>代码链接</a></p><h3 id=explanation>Explanation<a hidden class=anchor aria-hidden=true href=#explanation>#</a></h3><h4 id=变量定义>变量定义<a hidden class=anchor aria-hidden=true href=#变量定义>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Mat src, src_gray;
</span></span><span style=display:flex><span>Mat dst, detected_edges;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> lowThreshold <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> max_lowThreshold <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> ratio <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> kernel_size <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> window_name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Edge Map&#34;</span>;
</span></span></code></pre></div><ul>
<li>我们建立了一个 $3:1$ 的下限:上限阈值的比值（用可变比值）。</li><li>我们设定内核大小为 $3$ （用于<code>Canny</code>函数内部进行的<code>Sobel</code>运算）</li><li>我们将下限阈值的最大值设定为 $100$ 。</li></ul><h4 id=加载图像>加载图像<a hidden class=anchor aria-hidden=true href=#加载图像>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>CommandLineParser <span style=color:#a6e22e>parser</span>( argc, argv, <span style=color:#e6db74>&#34;{@input | fruits.jpg | input image}&#34;</span> );
</span></span><span style=display:flex><span>src <span style=color:#f92672>=</span> imread( samples<span style=color:#f92672>::</span>findFile( parser.get<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>( <span style=color:#e6db74>&#34;@input&#34;</span> ) ), IMREAD_COLOR ); <span style=color:#75715e>// Load an image
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span>( src.empty() )
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Could not open or find the image!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>  std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Usage: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> argv[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &lt;Input image&gt;&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=创建一个与src相同类型和大小的矩阵dst>创建一个与src相同类型和大小的矩阵（dst）。<a hidden class=anchor aria-hidden=true href=#创建一个与src相同类型和大小的矩阵dst>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>dst.create( src.size(), src.type() );
</span></span></code></pre></div><h4 id=灰度化>灰度化<a hidden class=anchor aria-hidden=true href=#灰度化>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>cvtColor( src, src_gray, COLOR_BGR2GRAY );
</span></span></code></pre></div><h4 id=创建一个窗口来显示结果>创建一个窗口来显示结果<a hidden class=anchor aria-hidden=true href=#创建一个窗口来显示结果>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>namedWindow( window_name, WINDOW_AUTOSIZE );
</span></span></code></pre></div><h4 id=创建一个trackbar让用户为我们的canny检测器输入低阈值>创建一个Trackbar，让用户为我们的Canny检测器输入低阈值<a hidden class=anchor aria-hidden=true href=#创建一个trackbar让用户为我们的canny检测器输入低阈值>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>createTrackbar( <span style=color:#e6db74>&#34;Min Threshold:&#34;</span>, window_name, <span style=color:#f92672>&amp;</span>lowThreshold, max_lowThreshold, CannyThreshold );
</span></span></code></pre></div><h4 id=让我们一步一步地观察cannythreshold函数>让我们一步一步地观察CannyThreshold函数<a hidden class=anchor aria-hidden=true href=#让我们一步一步地观察cannythreshold函数>#</a></h4><ul>
<li>
<p>首先，我们用内核大小为 $3$ 的滤波器对图像进行模糊处理。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>blur( src_gray, detected_edges, Size(<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>3</span>) );
</span></span></code></pre></div></li><li>
<p>接着，我们应用OpenCV函数<code>cv::Canny</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Canny( detected_edges, detected_edges, lowThreshold, lowThreshold<span style=color:#f92672>*</span>ratio, kernel_size );
</span></span></code></pre></div><ul>
<li><code>detected_edges</code>：源图像（灰度图）</li><li><code>detected_edges</code>：输出图像（可与输入相同）</li><li><code>lowThreshold</code>：用户移动<code>Trackbar</code>时输入的值</li><li><code>highThreshold</code>：在程序中设置为<code>lowThreshold</code>的 $3$ 倍（按照Canny的建议）</li><li><code>kernel_size</code>：我们将其定义为 $3$ （内部使用的<code>Sobel</code>内核的大小）。</li></ul></li></ul><h4 id=我们用零来填充dst图像意味着图像是完全黑色的>我们用零来填充dst图像（意味着图像是完全黑色的）<a hidden class=anchor aria-hidden=true href=#我们用零来填充dst图像意味着图像是完全黑色的>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>dst <span style=color:#f92672>=</span> Scalar<span style=color:#f92672>::</span>all(<span style=color:#ae81ff>0</span>);
</span></span></code></pre></div><h4 id=显示>显示<a hidden class=anchor aria-hidden=true href=#显示>#</a></h4><p>最后，我们将使用函数<code>cv::Mat::copyTo</code>只映射图像中被识别为边缘的区域（在黑色背景上）。<code>cv::Mat::copyTo</code>将<code>src</code>图像复制到<code>dst</code>上。注意，它只会复制像素的非零值的位置。因为Canny检测器的输出是黑色背景上的边缘轮廓，所以除了检测到的边缘，生成的<code>dst</code>将是黑色的。</p><blockquote>
<p>若没有这一步，那么我们得到的图像是边缘的灰度图</p></blockquote><h2 id=结果>结果<a hidden class=anchor aria-hidden=true href=#结果>#</a></h2><p><img loading=lazy src=https://i.imgur.com/4M66qk0.png alt>
</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><p><a href=https://docs.opencv.org/4.5.5/da/d5c/tutorial_canny_detector.html>https://docs.opencv.org/4.5.5/da/d5c/tutorial_canny_detector.html</a></p></div><footer class=post-footer>
<ul class=post-tags>
<li><a href=https://fffzlfk.github.io/tags/opencv/>OpenCV</a></li></ul><nav class=paginav>
<a class=prev href=https://fffzlfk.github.io/posts/cuda_%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0/>
<span class=title>« Prev Page</span>
<br>
<span>Cuda 硬件实现</span>
</a>
<a class=next href=https://fffzlfk.github.io/posts/opencv_laplace_operator/>
<span class=title>Next Page »</span>
<br>
<span>OpenCV Laplace Operator</span>
</a>
</nav></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//https-fffzlfk-github-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
</article></main><footer class=footer>
<span>&copy; 2022 <a href=https://fffzlfk.github.io>fffzlfk's Blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script>
<script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script>
</body></html>