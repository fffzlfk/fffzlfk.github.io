<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=zh-cn dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>OpenCV Canny Detector - fffzlfk's Blog</title>
<meta name=theme-color><meta name=description content="理论
Canny边缘检测是由John F. Canny在1986年开发的。许多人也将其称为最佳检测器，Canny算法旨在满足三个主要标准。

好的检测：算法能够尽可能多地标识出图像中的实际边缘。
好的定位：标识出的边缘要与实际图像中的实际边缘尽可能接近。
最小响应：图像中的边缘只能标识一次，并且可能存在的图像雜訊不应标识为边缘。

步骤


降噪：使用高斯滤波来达到，下面是一个大小为 $5$ 的高斯核的例子：
$$
K = \frac{1}{159}\begin{bmatrix}
2 & 4 & 5 & 4 & 2\\
4 & 9 & 12 & 9 & 4\\
5 & 12 & 15 & 12 & 5\\
4 & 9 & 12 & 9 & 4\\
2 & 4 & 5 & 4 & 2
\end{bmatrix}
$$


找到图像的亮度梯度：为此，我们遵循一个类似于Sobel的程序：

应用一对卷积masks（在 $x$ 和 $y$ 方向上）：
$$
G_x = \begin{bmatrix}
-1 & 0 & +1\\
-2 & 0 & +2\\
-1 & 0 & +1
\end{bmatrix}, G_y=\begin{bmatrix}
-1 & -2 & -1\\
0 & 0 & 0\\
+1 & +2 & +1
\end{bmatrix}
$$
寻找梯度强度和方向：
$$
G=\sqrt{G_x^2+G_y^2}\\
\theta = \arctan(\frac{G_y}{G_x})
$$
方向被四舍五入为四个可能的角度之一（即 $0\degree$ 、 $45\degree$  、 $90\degree$ 或 $135\degree$ ）。



过滤非最大值：在高斯滤波过程中，边缘有可能被放大了。这个步骤使用一个规则来过滤不是边缘的点，使边缘的宽度尽可能为1个像素点：如果一个像素点属于边缘，那么这个像素点在梯度方向上的梯度值是最大的。否则不是边缘，将灰度值设为 $0$ 。
$$
M_T(m, n) = \begin{cases}
M(m, n)& \text{if } M(m, n) \lt T\\
0 & \text{otherwise}
\end{cases}
$$"><meta name=author content="fffzlfk"><link rel="preload stylesheet" as=style href=https://fffzlfk.github.io/main.min.css><link rel=preload as=image href=https://fffzlfk.github.io/theme.svg><link rel=preload as=image href="https://avatars.githubusercontent.com/u/44939690?v=4"><link rel=preload as=image href=https://fffzlfk.github.io/github.svg><link rel=preload as=image href=https://fffzlfk.github.io/instagram.svg><link rel=preload as=image href=https://fffzlfk.github.io/rss.svg><link rel=stylesheet href=/css/fonts.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",()=>renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1}))</script><link rel=icon href=https://fffzlfk.github.io/favicon.ico><link rel=apple-touch-icon href=https://fffzlfk.github.io/apple-touch-icon.png><meta name=generator content="Hugo 0.147.4"><meta itemprop=name content="OpenCV Canny Detector"><meta itemprop=description content="理论 Canny边缘检测是由John F. Canny在1986年开发的。许多人也将其称为最佳检测器，Canny算法旨在满足三个主要标准。
好的检测：算法能够尽可能多地标识出图像中的实际边缘。 好的定位：标识出的边缘要与实际图像中的实际边缘尽可能接近。 最小响应：图像中的边缘只能标识一次，并且可能存在的图像雜訊不应标识为边缘。 步骤 降噪：使用高斯滤波来达到，下面是一个大小为 $5$ 的高斯核的例子： $$ K = \frac{1}{159}\begin{bmatrix} 2 & 4 & 5 & 4 & 2\\ 4 & 9 & 12 & 9 & 4\\ 5 & 12 & 15 & 12 & 5\\ 4 & 9 & 12 & 9 & 4\\ 2 & 4 & 5 & 4 & 2 \end{bmatrix} $$
找到图像的亮度梯度：为此，我们遵循一个类似于Sobel的程序：
应用一对卷积masks（在 $x$ 和 $y$ 方向上）： $$ G_x = \begin{bmatrix} -1 & 0 & +1\\ -2 & 0 & +2\\ -1 & 0 & +1 \end{bmatrix}, G_y=\begin{bmatrix} -1 & -2 & -1\\ 0 & 0 & 0\\ +1 & +2 & +1 \end{bmatrix} $$ 寻找梯度强度和方向： $$ G=\sqrt{G_x^2+G_y^2}\\ \theta = \arctan(\frac{G_y}{G_x}) $$ 方向被四舍五入为四个可能的角度之一（即 $0\degree$ 、 $45\degree$ 、 $90\degree$ 或 $135\degree$ ）。 过滤非最大值：在高斯滤波过程中，边缘有可能被放大了。这个步骤使用一个规则来过滤不是边缘的点，使边缘的宽度尽可能为1个像素点：如果一个像素点属于边缘，那么这个像素点在梯度方向上的梯度值是最大的。否则不是边缘，将灰度值设为 $0$ 。 $$ M_T(m, n) = \begin{cases} M(m, n)& \text{if } M(m, n) \lt T\\ 0 & \text{otherwise} \end{cases} $$"><meta itemprop=datePublished content="2022-01-17T11:35:18+08:00"><meta itemprop=dateModified content="2022-01-17T11:35:18+08:00"><meta itemprop=wordCount content="313"><meta itemprop=keywords content="OpenCV"><meta property="og:url" content="https://fffzlfk.github.io/posts/opencv_canny_detector/"><meta property="og:site_name" content="fffzlfk's Blog"><meta property="og:title" content="OpenCV Canny Detector"><meta property="og:description" content="理论 Canny边缘检测是由John F. Canny在1986年开发的。许多人也将其称为最佳检测器，Canny算法旨在满足三个主要标准。
好的检测：算法能够尽可能多地标识出图像中的实际边缘。 好的定位：标识出的边缘要与实际图像中的实际边缘尽可能接近。 最小响应：图像中的边缘只能标识一次，并且可能存在的图像雜訊不应标识为边缘。 步骤 降噪：使用高斯滤波来达到，下面是一个大小为 $5$ 的高斯核的例子： $$ K = \frac{1}{159}\begin{bmatrix} 2 & 4 & 5 & 4 & 2\\ 4 & 9 & 12 & 9 & 4\\ 5 & 12 & 15 & 12 & 5\\ 4 & 9 & 12 & 9 & 4\\ 2 & 4 & 5 & 4 & 2 \end{bmatrix} $$
找到图像的亮度梯度：为此，我们遵循一个类似于Sobel的程序：
应用一对卷积masks（在 $x$ 和 $y$ 方向上）： $$ G_x = \begin{bmatrix} -1 & 0 & +1\\ -2 & 0 & +2\\ -1 & 0 & +1 \end{bmatrix}, G_y=\begin{bmatrix} -1 & -2 & -1\\ 0 & 0 & 0\\ +1 & +2 & +1 \end{bmatrix} $$ 寻找梯度强度和方向： $$ G=\sqrt{G_x^2+G_y^2}\\ \theta = \arctan(\frac{G_y}{G_x}) $$ 方向被四舍五入为四个可能的角度之一（即 $0\degree$ 、 $45\degree$ 、 $90\degree$ 或 $135\degree$ ）。 过滤非最大值：在高斯滤波过程中，边缘有可能被放大了。这个步骤使用一个规则来过滤不是边缘的点，使边缘的宽度尽可能为1个像素点：如果一个像素点属于边缘，那么这个像素点在梯度方向上的梯度值是最大的。否则不是边缘，将灰度值设为 $0$ 。 $$ M_T(m, n) = \begin{cases} M(m, n)& \text{if } M(m, n) \lt T\\ 0 & \text{otherwise} \end{cases} $$"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-17T11:35:18+08:00"><meta property="article:modified_time" content="2022-01-17T11:35:18+08:00"><meta property="article:tag" content="OpenCV"><meta name=twitter:card content="summary"><meta name=twitter:title content="OpenCV Canny Detector"><meta name=twitter:description content="理论 Canny边缘检测是由John F. Canny在1986年开发的。许多人也将其称为最佳检测器，Canny算法旨在满足三个主要标准。
好的检测：算法能够尽可能多地标识出图像中的实际边缘。 好的定位：标识出的边缘要与实际图像中的实际边缘尽可能接近。 最小响应：图像中的边缘只能标识一次，并且可能存在的图像雜訊不应标识为边缘。 步骤 降噪：使用高斯滤波来达到，下面是一个大小为 $5$ 的高斯核的例子： $$ K = \frac{1}{159}\begin{bmatrix} 2 & 4 & 5 & 4 & 2\\ 4 & 9 & 12 & 9 & 4\\ 5 & 12 & 15 & 12 & 5\\ 4 & 9 & 12 & 9 & 4\\ 2 & 4 & 5 & 4 & 2 \end{bmatrix} $$
找到图像的亮度梯度：为此，我们遵循一个类似于Sobel的程序：
应用一对卷积masks（在 $x$ 和 $y$ 方向上）： $$ G_x = \begin{bmatrix} -1 & 0 & +1\\ -2 & 0 & +2\\ -1 & 0 & +1 \end{bmatrix}, G_y=\begin{bmatrix} -1 & -2 & -1\\ 0 & 0 & 0\\ +1 & +2 & +1 \end{bmatrix} $$ 寻找梯度强度和方向： $$ G=\sqrt{G_x^2+G_y^2}\\ \theta = \arctan(\frac{G_y}{G_x}) $$ 方向被四舍五入为四个可能的角度之一（即 $0\degree$ 、 $45\degree$ 、 $90\degree$ 或 $135\degree$ ）。 过滤非最大值：在高斯滤波过程中，边缘有可能被放大了。这个步骤使用一个规则来过滤不是边缘的点，使边缘的宽度尽可能为1个像素点：如果一个像素点属于边缘，那么这个像素点在梯度方向上的梯度值是最大的。否则不是边缘，将灰度值设为 $0$ 。 $$ M_T(m, n) = \begin{cases} M(m, n)& \text{if } M(m, n) \lt T\\ 0 & \text{otherwise} \end{cases} $$"><link rel=canonical href=https://fffzlfk.github.io/posts/opencv_canny_detector/></head><body class="bg-(--bg) text-black antialiased duration-200 ease-out [-webkit-tap-highlight-color:transparent] dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-(--w) px-8 whitespace-nowrap lg:justify-center"><div class="relative z-50 flex items-center ltr:mr-auto rtl:ml-auto"><a class="-translate-y-[1px] text-2xl font-medium" href=https://fffzlfk.github.io/>fffzlfk's Blog</a><div class="btn-dark text-[0px] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden ltr:-mr-8 rtl:-ml-8" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full flex-col justify-center bg-(--bg) pb-16 duration-200 select-none lg:static lg:h-auto lg:flex-row lg:bg-transparent! lg:pb-0 lg:transition-none"><nav class="mt-12 flex justify-center space-x-10 lg:mt-0 lg:items-center ltr:lg:ml-14 rtl:space-x-reverse rtl:lg:mr-14 dark:invert"><a class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/fffzlfk target=_blank rel=me>github</a>
<a class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./instagram.svg) href=https://instagram.com/fffzlfk target=_blank rel=me>instagram</a>
<a class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./rss.svg) href=https://fffzlfk.github.io/index.xml target=_blank rel=alternate>rss</a></nav></div></header><main class="prose prose-neutral dark:prose-invert relative mx-auto min-h-[calc(100vh-9rem)] max-w-(--w) px-8 pt-14 pb-16"><article><header class=mb-14><h1 class="my-0! pb-2.5">OpenCV Canny Detector</h1><div class="text-xs antialiased opacity-60"><time>Jan 17, 2022</time></div></header><section><h2 id=理论>理论</h2><p><strong>Canny边缘检测</strong>是由John F. Canny在1986年开发的。许多人也将其称为最佳检测器，Canny算法旨在满足三个主要标准。</p><ul><li><strong>好的检测</strong>：算法能够尽可能多地标识出图像中的实际边缘。</li><li><strong>好的定位</strong>：标识出的边缘要与实际图像中的实际边缘尽可能接近。</li><li><strong>最小响应</strong>：图像中的边缘只能标识一次，并且可能存在的图像雜訊不应标识为边缘。</li></ul><h3 id=步骤>步骤</h3><ol><li><p><strong>降噪</strong>：使用高斯滤波来达到，下面是一个大小为 $5$ 的高斯核的例子：
$$
K = \frac{1}{159}\begin{bmatrix}
2 & 4 & 5 & 4 & 2\\
4 & 9 & 12 & 9 & 4\\
5 & 12 & 15 & 12 & 5\\
4 & 9 & 12 & 9 & 4\\
2 & 4 & 5 & 4 & 2
\end{bmatrix}
$$</p></li><li><p><strong>找到图像的亮度梯度</strong>：为此，我们遵循一个类似于<code>Sobel</code>的程序：</p><ol><li>应用一对卷积<code>masks</code>（在 $x$ 和 $y$ 方向上）：
$$
G_x = \begin{bmatrix}
-1 & 0 & +1\\
-2 & 0 & +2\\
-1 & 0 & +1
\end{bmatrix}, G_y=\begin{bmatrix}
-1 & -2 & -1\\
0 & 0 & 0\\
+1 & +2 & +1
\end{bmatrix}
$$</li><li>寻找梯度强度和方向：
$$
G=\sqrt{G_x^2+G_y^2}\\
\theta = \arctan(\frac{G_y}{G_x})
$$
方向被四舍五入为四个可能的角度之一（即 $0\degree$ 、 $45\degree$ 、 $90\degree$ 或 $135\degree$ ）。</li></ol></li><li><p><strong>过滤非最大值</strong>：在高斯滤波过程中，边缘有可能被放大了。这个步骤使用一个规则来过滤不是边缘的点，使边缘的宽度尽可能为1个像素点：如果一个像素点属于边缘，那么这个像素点在梯度方向上的梯度值是最大的。否则不是边缘，将灰度值设为 $0$ 。
$$
M_T(m, n) = \begin{cases}
M(m, n)& \text{if } M(m, n) \lt T\\
0 & \text{otherwise}
\end{cases}
$$</p></li><li><p><strong>滞后</strong>：这是最后一步，Canny确实使用了两个阈值（上限和下限）。</p><ol><li>如果一个像素的梯度值高于上限阈值，则该像素被接受为边缘。</li><li>如果一个像素的梯度值低于下限阈值，那么它将被拒绝。</li><li>如果像素梯度在两个阈值之间，那么只有当它与高于上层阈值的像素相连时，才会被接受。
Canny建议上下限的比值在 $2:1$ 和 $3:1$ 之间。</li></ol></li></ol><h2 id=code>Code</h2><p><a href=https://github.com/fffzlfk/opencv_learning/blob/main/src/transformations/canny.cpp>代码链接</a></p><h3 id=explanation>Explanation</h3><h4 id=变量定义>变量定义</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Mat src, src_gray;
</span></span><span style=display:flex><span>Mat dst, detected_edges;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> lowThreshold <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> max_lowThreshold <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> ratio <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> kernel_size <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> window_name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Edge Map&#34;</span>;
</span></span></code></pre></div><ul><li>我们建立了一个 $3:1$ 的下限:上限阈值的比值（用可变比值）。</li><li>我们设定内核大小为 $3$ （用于<code>Canny</code>函数内部进行的<code>Sobel</code>运算）</li><li>我们将下限阈值的最大值设定为 $100$ 。</li></ul><h4 id=加载图像>加载图像</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>CommandLineParser <span style=color:#a6e22e>parser</span>( argc, argv, <span style=color:#e6db74>&#34;{@input | fruits.jpg | input image}&#34;</span> );
</span></span><span style=display:flex><span>src <span style=color:#f92672>=</span> imread( samples<span style=color:#f92672>::</span>findFile( parser.get<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>( <span style=color:#e6db74>&#34;@input&#34;</span> ) ), IMREAD_COLOR ); <span style=color:#75715e>// Load an image
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span>( src.empty() )
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Could not open or find the image!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>  std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Usage: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> argv[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &lt;Input image&gt;&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=创建一个与src相同类型和大小的矩阵dst>创建一个与src相同类型和大小的矩阵（dst）。</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>dst.create( src.size(), src.type() );
</span></span></code></pre></div><h4 id=灰度化>灰度化</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>cvtColor( src, src_gray, COLOR_BGR2GRAY );
</span></span></code></pre></div><h4 id=创建一个窗口来显示结果>创建一个窗口来显示结果</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>namedWindow( window_name, WINDOW_AUTOSIZE );
</span></span></code></pre></div><h4 id=创建一个trackbar让用户为我们的canny检测器输入低阈值>创建一个Trackbar，让用户为我们的Canny检测器输入低阈值</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>createTrackbar( <span style=color:#e6db74>&#34;Min Threshold:&#34;</span>, window_name, <span style=color:#f92672>&amp;</span>lowThreshold, max_lowThreshold, CannyThreshold );
</span></span></code></pre></div><h4 id=让我们一步一步地观察cannythreshold函数>让我们一步一步地观察CannyThreshold函数</h4><ul><li><p>首先，我们用内核大小为 $3$ 的滤波器对图像进行模糊处理。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>blur( src_gray, detected_edges, Size(<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>3</span>) );
</span></span></code></pre></div></li><li><p>接着，我们应用OpenCV函数<code>cv::Canny</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Canny( detected_edges, detected_edges, lowThreshold, lowThreshold<span style=color:#f92672>*</span>ratio, kernel_size );
</span></span></code></pre></div><ul><li><code>detected_edges</code>：源图像（灰度图）</li><li><code>detected_edges</code>：输出图像（可与输入相同）</li><li><code>lowThreshold</code>：用户移动<code>Trackbar</code>时输入的值</li><li><code>highThreshold</code>：在程序中设置为<code>lowThreshold</code>的 $3$ 倍（按照Canny的建议）</li><li><code>kernel_size</code>：我们将其定义为 $3$ （内部使用的<code>Sobel</code>内核的大小）。</li></ul></li></ul><h4 id=我们用零来填充dst图像意味着图像是完全黑色的>我们用零来填充dst图像（意味着图像是完全黑色的）</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>dst <span style=color:#f92672>=</span> Scalar<span style=color:#f92672>::</span>all(<span style=color:#ae81ff>0</span>);
</span></span></code></pre></div><h4 id=显示>显示</h4><p>最后，我们将使用函数<code>cv::Mat::copyTo</code>只映射图像中被识别为边缘的区域（在黑色背景上）。<code>cv::Mat::copyTo</code>将<code>src</code>图像复制到<code>dst</code>上。注意，它只会复制像素的非零值的位置。因为Canny检测器的输出是黑色背景上的边缘轮廓，所以除了检测到的边缘，生成的<code>dst</code>将是黑色的。</p><blockquote><p>若没有这一步，那么我们得到的图像是边缘的灰度图</p></blockquote><h2 id=结果>结果</h2><p><img src=https://i.imgur.com/4M66qk0.png alt></p><h2 id=references>References</h2><p><a href=https://docs.opencv.org/4.5.5/da/d5c/tutorial_canny_detector.html>https://docs.opencv.org/4.5.5/da/d5c/tutorial_canny_detector.html</a></p></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] ltr:mr-1.5 rtl:ml-1.5 dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://fffzlfk.github.io/tags/opencv>OpenCV</a></footer><div class="giscus mt-24"></div><script src=https://giscus.app/client.js data-repo=fffzlfk/fffzlfk.github.io data-repo-id=R_kgDOG4ERGw data-category=Q&amp;A data-category-id=DIC_kwDOG4ERG84CBP5t data-mapping=pathname data-strict=1 data-reactions-enabled=0 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class="mx-auto flex h-[4.5rem] max-w-(--w) items-center px-8 text-xs tracking-wider uppercase opacity-60"><div class=mr-auto>&copy;2025
<a class=link href=https://fffzlfk.github.io/>fffzlfk's Blog</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>powered by hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>hugo-paper</a></footer></body></html>