<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>OOP(C++) | fffzlfk's Blog</title><meta name=keywords content="C++,Academic"><meta name=description content="Object-Oriented Programming"><meta name=author content="fffzlfk"><link rel=canonical href=https://fffzlfk.github.io/posts/oopc++/><link crossorigin=anonymous href=/assets/css/stylesheet.d3686bac777f9ee0e34bad704508027f37f21ffabbb626d7e104edd44f404883.css integrity="sha256-02hrrHd/nuDjS61wRQgCfzfyH/q7tibX4QTt1E9ASIM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.ab916b8151320cc693135f5df9fe4b75e6e4754d8f0dff5782df332cacd1ba8e.js integrity="sha256-q5FrgVEyDMaTE19d+f5LdebkdU2PDf9Xgt8zLKzRuo4=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://fffzlfk.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://fffzlfk.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://fffzlfk.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://fffzlfk.github.io/apple_touch_icon.png><link rel=mask-icon href=https://fffzlfk.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:title" content="OOP(C++)"><meta property="og:description" content="Object-Oriented Programming"><meta property="og:type" content="article"><meta property="og:url" content="https://fffzlfk.github.io/posts/oopc++/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-10-06T12:25:11+08:00"><meta property="article:modified_time" content="2020-10-06T12:25:11+08:00"><meta property="og:site_name" content="fffzlfk's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="OOP(C++)"><meta name=twitter:description content="Object-Oriented Programming"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://fffzlfk.github.io/posts/"},{"@type":"ListItem","position":3,"name":"OOP(C++)","item":"https://fffzlfk.github.io/posts/oopc++/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"OOP(C++)","name":"OOP(C\u002b\u002b)","description":"Object-Oriented Programming","keywords":["C++","Academic"],"articleBody":"C++基础 C++对C的扩充 名字空间 namespace ns1{ int inflag; } namespace ns2{ int inflag; } ns1::inflag=2; ns2::inflag=-3; // using ns1::inflag; inflag=2; // ns2::inflag=-3; 用const定义常量 用const定义标识符常量时，一定要对其初始化，这是唯一方法。 引用 对变量起另外一个名字，这个名字称为该变量的引用。\n其中原变量名必须是一个已定义过的变量。\n引用并没有重新在内存中开辟存储单元，只是引用原变量的单元。\n对引用的初始化，可以用一个变量名，也可以用另一个引用。\nint a=3; int \u0026b=a; int \u0026c=b; 引用同变量一样有地址，可以对其地址进行操作，即将其地址赋给一指针。\n对const常量的引用使用如下方式：\nint i = 5; const int \u0026ri = i; // ri = 10; 错误 i = 10; //正确 cout \u003c\u003c ri; 以下的声明是非法的\n企图建立void类型的引用 void \u0026a 企图建立引用的数组 int \u0026a[6] 企图建立指向引用的指针 int \u0026*p 指针和引用的区别：\n指针是通过地址间接访问某个变量，而引用是通过别名直接访问某个变量。 引用必须初始化，而一旦初始化后不再作为其他变量的别名。指针若不进行初始化，编译器不会报错。 引用与函数 函数的返回值为引用类型 内联函数 调用内联函数时，编译器首先检查调用是否正确（类型安全检查或者自动进行类型转换）。如果正确，则将内联函数的代码直接替换函数调用，并用实参换型参，于是省去了函数调用的开销。因此，内联机制增加了空间开销而节约了时间开销。 第一次上级题目 求2个或3个正整数中的最大数，用带有默认参数的函数实现。 输入三个整数，将它们按由小到大的顺序输出，要求使用变量的引用。 编写一个程序，用同一个函数名对几个数据进行从小到大排序，数据类型可以是整型、浮点型。用重载函数实现。 对第3题改用函数模板实现，并与第3题程序进行对比分析。 设计一个日期Date类，它能实现年月日的输入和输出，要求分别将成员函数定义在类体内和类体外。 声明一个Circle类，有数据成员Radius（半径）、成员函数GetArea（）计算圆的面积，构造一个Circle的对象进行测试。 编写一个基于对象的程序，求出3个长方柱的体积。数据成员包括length(长)、width(宽)、height(高)。要求用成员函数实现以下功能：\n(1) 由键盘分别输入3个长方柱的长、宽、高；\n(2) 计算长方柱的体积；\n(3) 输出3个长方柱的体积。 源码下载 1\n2\n3\n4\n5\n6\n7\n类和对象 复制构造函数调用时机 程序中需要新建立一个对象，并用另一个同类的对象对它初始化 Box box1(1,2,3); Box box2 = box1; // Box box2(box1); 当函数的参数为类对象时，在调用函数时需要将实参对象完整的传递给形参 void func(Box b) { // do something... } int main() { Box box1(1, 2, 3); fun(box1); } 当函数的返回值是类的对象，在函数调用完毕将返回值带回函数调用处时 Box f1() { Box box1(1, 2, 3); return box1; } int main() { Box box2; box2 = f(); return 0; } 指向非静态成员函数的指针 /* Author: fffzlfk */ #include using namespace std; class Node { public: Node(int xx, int yy) : x(xx), y(yy){} int get_x() { return x; } int get_y() { return y; } private: int x, y; }; int main() { Node node(1, 2); int (Node::*p_x)() = \u0026Node::get_x; // 需要加类名和作用域运算符 int (Node::*p_y)() = \u0026Node::get_y; cout \u003c\u003c (node.*p_x)() \u003c\u003c '\\n'; cout \u003c\u003c (node.*p_y)() \u003c\u003c '\\n'; return 0; } 指向静态成员函数的指针 /* Author: fffzlfk */ #include using namespace std; class A { public: static int get() { return 666; } }; int main() { int (*p)() = \u0026A::get; cout \u003c\u003c p() \u003c\u003c '\\n'; cout \u003c\u003c (*p)(); // 加不加*都可 return 0; } 对象引用的作用 Tip\n避免通过值来传递对象，而是通过引用来传递 参数传递的是引用，没有构造函数或析构函数被调用，节约了系统资源，提高了运行效率 /* Author: fffzlfk */ #include using namespace std; class Student { public: Student(); Student returnS(Student s) { return s; } Student(const Student \u0026e) { cout \u003c\u003c \"Copy Constructor\\n\"; } ~Student() { cout \u003c\u003c \"Destructor\\n\"; } }; Student::Student() {} int main() { Student stu1; stu1.returnS(stu1); return 0; } 输出为：\nCopy Constructor\nCopy Constructor\nDestructor\nDestructor\nDestructor\n修改为\nStudent\u0026 returnS(Student \u0026s) { return s; } 之后，输出：\nDestructor\n关于数据成员初始化 数据成员 成员初始化列表 构造函数体内 类外 普通数据成员 $\\checkmark $ $\\checkmark $ 常数据成员 $\\checkmark $ 静态数据成员 $\\checkmark $ 静态常数据成员 $\\checkmark $ 常对象 Tip\n常对象的所有数据成员都是常量，不能改变。因此，常对象必须初始化。\n不能通过常对象调用普通的成员函数，可以调用常成员函数。\n如果要修改常对象中某个数据成员的值，可以将数据成员声明为mutable，这样就可以用声明为const的成员函数来修改它的值。\n/* Author: fffzlfk */ #include using namespace std; class A { private: mutable int i; // 可以用常成员函数来修改 public: A() {} //常对象必须初始化 void f_const() const { i++; cout \u003c\u003c \"i = \" \u003c\u003c i \u003c\u003c '\\n'; cout \u003c\u003c \"f_const()\" \u003c\u003c '\\n'; } void f() { cout \u003c\u003c \"f()\" \u003c\u003c '\\n'; } }; int main() { const A a; //常对象必须初始化 a.f_const(); //常对象只能调用常成员函数 return 0; } 常成员 常数据成员\nTip\n在任何函数中都不能对常数据成员赋值\n只能通过构造函数的参数初始化表对常数据成员进行初始化\nconst int Hour; Time::Time(int h) : Hour(h) {} 类的所有对象中的常数据成员的值均不能改变，但不同对象中的该数据成员可以不同（在定义对象时给出） 示例程序： /* Author: fffzlfk */ #include using namespace std; class A { public: A(int i) : a(i) {} // 非静态常数据成员只能通过初始化表来获得初值 void print() { cout \u003c\u003c a \u003c\u003c \":\" \u003c\u003c b \u003c\u003c '\\n'; } private: const int a; static const int b; }; const int A::b = 10; // 静态常数据成员只能在类外初始化 int main() { A a1(100), a2(0); a1.print(); a2.print(); return 0; } 常成员函数\nTip\n通过常成员函数来引用本类中的数据成员，但不能修改他们 const 是函数类型的一部分，在声明函数时都要有const，在调用时不必加const 常成员函数不能更新对象的数据成员，也不能调用该类中的非const成员函数 通过常对象只能调用它的常成员函数，而不能调用其他成员函数 常对象中的成员函数不是常成员函数，除非成员函数有const修饰 const关键字可以用于对重载函数的区分 /* Author: fffzlfk */ #include using namespace std; class R { public: R(int r1, int r2) { R1 = r1; R2 = r2; } void print() { cout \u003c\u003c R1 \u003c\u003c '-' \u003c\u003c R2 \u003c\u003c '\\n'; } void print() const { cout \u003c\u003c R1 \u003c\u003c \"+\" \u003c\u003c R2 \u003c\u003c '\\n'; } private: int R1, R2; }; int main() { R a(5, 4); a.print(); // 普通对象a调用普通成员函数 const R b(20, 5); b.print(); // 常对象b调用常成员函数 return 0; } const成员和非const成员之间的调用关系\n数据成员 非const成员函数 const成员函数 非const数据成员 可以引用，也可以改变值 可以引用，但不可以改变值 const数据成员 可以引用，但不能改变值 可以引用，但不可以改变值 const对象的数据成员 不允许引用和改变值 可以引用，不可以改变值 const与指针 指向对象的常指针指针本身的值不能改变，即其指向不能改变。\n类名 *const 指针变量名 = 对象地址\nTime t1(10, 12, 15), t2; Time *const ptr1 = \u0026t1; ptr1 = \u0026t2; //错误，ptr1不能改变指向 Tip\n常指针始终指向同一个对象，但是可以改变其所指对象中数据成员的值。\n指向常对象的指针\nconst 类名 *指针变量名 = 对象地址\n如果存在一个常对象，只能用指向常对象的指针去指向它，而不能用非const型的指针去指向它。\n指向常对象的指针还可以指向非const型的对象，此时不能通过指针改变该对象的值，但是通过该对象本身来改变。指针本身的值也可以改变。\nTime t1(10, 12, 15), t2; const Time *p = \u0026t1; // p是指向常对象的指针，并指向t1对象 (*p).hour = 18; // 错误，不能通过指针改变t1的值 t1.hour = 18; // 正确，t1不是常对象 p = \u0026t2; // 正确，p改为指向t2 Note\n指向常对象的指针可以指向const和非const型的对象，而指向非const型对象的指针只能指向非const的对象。\n对象数组 /* Author: fffzlfk */ #include using namespace std; class Box { public: Box(int h = 10, int w = 12, int len = 15) : height(h), width(w), length(len) {} int volume(); private: int height, width, length; }; int Box::volume() { return height * width * length; } int main() { Box a[2]{Box(10, 12, 15), Box(15, 18, 20)}; // Box a[2] = {Box(10, 12, 15), Box(15, 18, // 20)}; 加不加等号都可 cout \u003c\u003c a[0].volume() \u003c\u003c '\\n'; cout \u003c\u003c a[1].volume() \u003c\u003c '\\n'; } 类模板 类模板是对一批仅有成员数据类型不同的类的抽象\n关于函数模板\n类模板中的成员函数的定义 可以放在类模板的定义定义体中（此时与类中的成员函数定义方法一致）\n也可以放在类模板的外部，此时成员函数的定义格式如下：\ntemplate\u003cclass 类型参数\u003e \u003c返回值类型\u003e \u003c类模板名\u003e\u003c类型参数\u003e::\u003c函数名\u003e (\u003c参数表\u003e) { \u003c函数体\u003e } 在类模板外定义成员函数时，每一个函数前均加上：\ntemplate 第二次上机题目 编写设计一个People（人）类。该类的数据成员有年龄（age）、身高（height）、体重（weight）和人数（num），其中人数为静态数据成员，成员函数有构造函数（People）、进食（Eating）、运动（Sporting）、睡眠（Sleeping）、显示（Show）和显示人数（ShowNum）。其中构造函数由已知参数年龄(a)、身高(h)和体重(w)构造对象，进食函数使体重加1，运动函数使身高加1，睡眠函数使年龄、身高、体重各加1，显示函数用于显示人的年龄、身高、体重，显示人数函数为静态成员函数，用于显示人的个数。假设年龄的单位为岁，身高的单位为厘米，体重的单位为市斤，要求所有数据成员为protected访问权限，所有成员函数为public访问权限，在主函数中通过对象直接访问类的所有成员函数。 定义一个描述学生（Student）基本情况的类，数据成员包括姓名(name)、学号(num)、数学成绩(mathScore)、英语成绩(englishScore)、人数(count)、数学总成绩(mathTotalScore)和英语总成绩(englishTotalScore)。其中姓名定义为长度为18的字符数组，其他数据成员类型为整型，数学总成绩、英语总成绩和人数为静态数据成员，函数成员包括构造函数、显示基本数据函数（ShowBase）和显示静态数据函数(showStatic)，其中构造函数由已知参数姓名(nm)、学号(nu)、数学成绩(math)和英语成绩(english)构造对象，显示基本数据函数用于显示学生的姓名、学号、数学成绩、英语成绩，显示静态数据函数为静态成员函数，用于显示人数、数学总成绩、英语总成绩；要求所有数据成员为private访问权限，所有成员函数为public访问权限，在主函数中定义若干个学生对象，分别显示学生基本信息，以及显示学生人数，数学总成绩与英语总成绩。 定义一个Dog，包含name、age、sex和weight等属性以及对这些属性操作的方法。要求用字符指针描述name，并且用对象指针来测试这个类。 管理个人活期账户：个人储蓄活期账户包括账号、户名、密码、余额、活期年利率等信息。要求能够对个人账户进行存钱、取钱、计算年利息、打印账户相关信息等操作。编写主函数测试账户相关功能。 5．建立一个对象数组，内放5个学生的数据（学号、成绩），（1）用指针指向数组首元素，输出第1，3，5个学生的数据；（2）设立一个函数max，用指向对象的指针作函数参数，在max函数中找出5个学生中成绩最高者，并输出其学号。 源码下载 1\n2\n3\n4\n5\n运算符重载 不能重载的运算符 不能重载的运算符 说明 :: 作用域运算符 . 成员访问运算符 .* 成员指针 ?: 条件运算符 sizeof 长度运算符 重载为类的成员函数 \u003c函数类型\u003e operator \u003c运算符\u003e(\u003c参数表\u003e) {函数体}\nC++中不允许重载有三个操作数的运算符 运算符作为成员函数时最多有一个形参：参数可以是对象，对象的引用，或其它类型的参数 运算符重载的实质就是函数重载 运算符重载的函数参数就是该运算符涉及的操作数 单目运算符的重载++、– ++为前置运算符时： operator++() {…} ++为后置运算符时： operator++(int) {…} 友元函数 有时候需要某些函数访问对象的私有成员，可以通过声明该函数为类的友元函数\nTip\n友元函数是可以直接访问类的私有成员的非成员函数。 它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明，声明时只需在友元的名称前加上关键字friend，其格式如下：\nfriend 类型 函数名(形式参数); #include using namespace std; class A { int i; public: friend void foo(A); }; void foo(A a) { cout \u003c\u003c a.i \u003c\u003c '\\n'; } int main() { A a; foo(a); } 大多数情况下友元函数是某个类的成员函数，即A类中的某个成员函数是B类中的友元函数，这个成员函数可以直接访问B类中的私有数据。这实现了类与类之间的沟通。\nclass A { class B { void fun(B \u0026); friend void A::fun(B \u0026b); }; }; 友元类\nclass A { class B { ... ... // B类是A类的友元 // B类可以自由使用A类中的成员 friend class B; }； }; 重载为类的友元函数 friend \u003c函数值类型\u003e operator\u003c运算符\u003e(\u003c参数表\u003e) {函数体}\n运算符重载为类的友元函数****最多只能有两个参数** 如果重载双目运算符，则第一个参数代表左操作数，第二个参数代表右操作数 单目运算符重载 ++为前置运算符时，它的运算符重载函数的一般格式为：A operator ++(A \u0026a) ++为后置运算符时，它的运算符重载函数的一般格式为：A operator ++(A \u0026a, int)(使用哑元区分) 重载输入输出运算符 输入运算符：friend istream \u0026 operater »(istream \u0026is, ClassName \u0026f){…}\n输出运算符：friend ostream \u0026 operater «(ostream \u0026, ClassName \u0026){…}\n函数对象 #include using namespace std; class Test { public: int operator()(int a, int b) { cout \u003c\u003c \"operator() called. \" \u003c\u003c a \u003c\u003c ' ' \u003c\u003c b \u003c\u003c endl; return a + b; } }; int main() { Test sum; int s = sum(3, 4); // sum看上去像是一个函数，故也称“函数对象” cout \u003c\u003c \"a + b = \" \u003c\u003c s \u003c\u003c endl; } 类型转换运算符重载 基本类型到类类型的转换 如果直接将数据赋值给对象，所赋入的数据要强制类型转换，这种转换需要调用构造函数。也就是利用构造函数能完成基本类型到类类型的转换 使用构造函数进行类型转换必须有一个前提，那就是在这个类中定义一个只有一个参数的构造函数（或者其他参数有默认值）——转换构造函数 类类型到基本类型的转换 C++引入一种特殊的成员函数——类型转换函数。类型转换函数实际上就是一个类型转换运算符重载函数\n类型转换函数专门用来将类类型转换为基本数据类型，它只能被重载为成员函数\n重载类型转换运算符函数格式：\noperator〈返回基本类型名〉（） { …… return 〈基本类型值〉 }\n#include using namespace std; class A { int i; public: A(int a = 0) : i(a) {} void show(void) { cout \u003c\u003c \"i = \" \u003c\u003c i \u003c\u003c '\\n'; } operator int() { return i; } }; int main() { A a1(10), a2(20); cout \u003c\u003c a1 \u003c\u003c '\\n'; cout \u003c\u003c a2 \u003c\u003c '\\n'; return 0; } 示例代码 #include using namespace std; class Complex { double real, imag; public: Complex(double r = 0.0, double i = 0.0) : real(r), imag(i) {} double getReal() const { return real; } double getImag() const { return imag; } Complex operator++(); Complex operator++(int); Complex operator+(Complex \u0026); Complex operator+(double d); friend istream \u0026operator\u003e\u003e(istream \u0026, Complex \u0026); friend ostream \u0026operator\u003c\u003c(ostream \u0026, const Complex \u0026); }; Complex Complex::operator++() { return Complex(++real, imag); } Complex Complex::operator++(int a) { return Complex(real++, imag); } Complex Complex::operator+(Complex \u0026c) { return Complex(real + c.real, imag + c.imag); } Complex Complex::operator+(double d) { return Complex(real + d, imag); } istream \u0026operator\u003e\u003e(istream \u0026in, Complex \u0026c) { in \u003e\u003e c.real \u003e\u003e c.imag; return in; } ostream \u0026operator\u003c\u003c(ostream \u0026out, const Complex \u0026c) { out \u003c\u003c to_string(c.real) + \"+\" + to_string(c.imag) + \"i\"; return out; } int main() { Complex a(1, 2); cout \u003c\u003c a + a \u003c\u003c '\\n'; cout \u003c\u003c a++ \u003c\u003c '\\n' \u003c\u003c ++a \u003c\u003c '\\n'; a = 10; // 相当于a = Complex(10); 产生临时对象，调用构造函数和析构函数 cout \u003c\u003c a \u003c\u003c '\\n'; return 0; } 继承与派生 派生类定义 三种继承方式派生类中基类成员的访问控制权限 公有继承 私有继承 保护继承 公有成员 公有 私有 保护 私有成员 派生类不可访问 派生类不可访问 派生类不可访问 保护成员 保护 私有 保护 派生类的构造函数和析构函数 派生类构造函数 不能在派生类构造函数体中显式调用基类构造函数\n在成员初始化表中可以显式调用基类构造函数\nRectangle(float x,float y,float w,float h) : Point(x,y) { W=w; H=h; } 或: Rectangle(float x,float y,float w,float h) : Point(x,y),W(w),H(h) {} 构造函数和析构函数的调用顺序 构造函数调用顺序：基类的构造函数-\u003e对象成员构造函数-\u003e派生类构造函数\n析构函数调用顺序刚好相反\n#include using namespace std; class O { public: O() { cout \u003c\u003c \"O()\" \u003c\u003c '\\n'; } ~O() { cout \u003c\u003c \"~O()\" \u003c\u003c '\\n'; } }; class A { public: A() { cout \u003c\u003c \"A()\" \u003c\u003c '\\n'; } ~A() { cout \u003c\u003c \"~A()\" \u003c\u003c '\\n'; } }; class B : public A { O o; public: B() { cout \u003c\u003c \"B()\" \u003c\u003c '\\n'; } ~B() { cout \u003c\u003c \"~B()\" \u003c\u003c '\\n'; } }; int main() { B b; return 0; } A()\rO()\rB()\r~B()\r~O()\r~A() ⚠️注意\n当基类中没有显式定义构造函数，或定义了无参数构造函数时，派生类构造函数的初始化表可以省略对基类构造函数的调用，而采用隐含调用 当基类的构造函数使用一个或多个参数时候，派生类必须定义构造函数，提供将参数传递给基类的构造函数的途径。这时，派生类构造函数体可能为空，仅起到参数传递作用 无论是哪种继承方式，基类的私有成员在派生类中都是不可被访问的。只能通过基类的成员函数访问基类的私有数据成员。 如果在一个派生类中要访问基类中的私有成员，可以将这个派生类声明为基类的友元。 class Base { class Derive : public Base { friend class Derive; // 直接使用Base中的私有成员 } } 友元关系是不能继承的：B类是A类的友元，C类是B类的派生类，则C类和A类之间没有任何友元关系，除非C类声明A类是友元。 多继承与虚基类 多继承派生类的定义 class \u003c派生类名\u003e：\u003c继承方式\u003e \u003c基类名1\u003e，…，\u003c继承方式\u003e \u003c基类名n\u003e { \u003c派生类新定义成员\u003e }； 多继承派生类的构造函数 \u003c派生类名\u003e(\u003c总参数表\u003e):\u003c基类名1\u003e(\u003c参数表1\u003e)，…，\u003c 基类名n\u003e (\u003c参数表n\u003e) { \u003c派生类数据成员的初始化\u003e }; 构造函数的调用顺序是：先调用所有基类的构造函数，再调用对象成员构造函数，最后调用派生类的构造函数\n处于同一层次的各基类构造函数的调用顺序取决于定义派生类时所指定的基类顺序，与派生类构造函数中所定义的成员初始化列表无关\n如果有多个成员类对象，则构造函数额调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化列表的顺序\n析构函数的调用顺序与构造函数的调用顺序相反\n#include using namespace std; class M1 { int i; public: M1(int _i) : i(_i) { cout \u003c\u003c \"M1(\" \u003c\u003c i \u003c\u003c \")\" \u003c\u003c '\\n'; } }; class M2 { int i; public: M2(int _i) : i(_i) { cout \u003c\u003c \"M2(\" \u003c\u003c i \u003c\u003c \")\" \u003c\u003c '\\n'; } }; class Base1 { public: Base1() { cout \u003c\u003c \"Base1()\" \u003c\u003c '\\n'; } }; class Base2 { public: Base2() { cout \u003c\u003c \"Base2()\" \u003c\u003c '\\n'; } }; class Derive : public Base1, public Base2 { M2 m2; M1 m1; public: Derive(int a, int b) : m1(a), m2(b), Base2() , Base1() {} }; int main() { Derive d(8, 9); return 0; } Base1()\rBase2()\rM2(9)\rM1(8) 多继承引起的二义性问题 两个基类有同名成员 implementation #include using namespace std; class A { public: void display() { cout \u003c\u003c \"display() in A\" \u003c\u003c '\\n'; } }; class B { public: void display() { cout \u003c\u003c \"display() in B\" \u003c\u003c '\\n'; } }; class C : public A, public B { }; int main() { C c; c.display(); return 0; } 编译错误 两个基类和派生类三者都有同名成员 基类的同名成员在派生类中被屏蔽，或者说，派生类新增加的同名成员隐藏了基类中的同名成员 implementation #include using namespace std; class A { public: void display() { cout \u003c\u003c \"display() in A\" \u003c\u003c '\\n'; } }; class B { public: void display() { cout \u003c\u003c \"display() in B\" \u003c\u003c '\\n'; } }; class C : public A, public B { public: void display() { cout \u003c\u003c \"display() in C\" \u003c\u003c '\\n'; } }; int main() { C c; c.display(); return 0; } 访问的是派生类C中的成员 display() in C 虚基类 虚基类概念 为了避免对基类成员访问的二义性问题，可以将直接基类（如A、B）的共同基类如N设置为虚基类，这样共同基类N在内存中只有一个副本存在 引进虚基类后，派生类对象中只存在一个虚基类成员的副本 为了保证虚基类在派生类中只继承一次，应当在该基类的所有直接派生类中声明为虚基类，否则仍然会出现对基类的多次继承。 构造函数的调用顺序 先调用虚基类的构造函数，再调用非虚基类的构造函数 若同一层次包含多个虚基类，其调用顺序为定义时的顺序 若虚基类构造函数由非虚基类派生而来，则仍先按先调用基类构造函数，再调用派生类构造函数的顺序 #include using namespace std; class Base1 { public: Base1() { cout \u003c\u003c \"class Base1\" \u003c\u003c endl; } }; class Base2 { public: Base2() { cout \u003c\u003c \"class Base2\" \u003c\u003c endl; } }; class Level1 : public Base2, virtual public Base1 { public: Level1() { cout \u003c\u003c \"class Level1\" \u003c\u003c endl; } }; class Level2 : public Base2, virtual public Base1 { public: Level2() { cout \u003c\u003c \"class Level2\" \u003c\u003c endl; } }; class TopLevel : public Level1, virtual public Level2 { public: TopLevel() { cout \u003c\u003c \"class TopLevel\" \u003c\u003c endl; } }; int main() { TopLevel obj; return 0; } 输出 class Base1\rclass Base2\rclass Level2\rclass Base2\rclass Level1\rclass TopLevel 虚基类的初始化 如果在虚基类中只定义了带参数的构造函数，则要在其所有派生类（包括直接派生类或间接派生类）中，通过构造函数的初始化表对虚基类进行初始化。\nclass A { A(int i){} … }; class B:virtual public A { B(int n):A(n){}… }; class C:virtual public A { C(int n):A(n){}… }; class D:public B, public C { D(int n):A(n),B(n),C(n){}… }; ⚠️注意 如果多继承不牵扯到对同一基类的派生，就没有必要定义虚基类 使用多继承要十分小心，经常会出现二义性问题 能用单一继承的问题就不要用多继承 多态性与虚函数 类型兼容规则 派生类的对象可以赋值给基类对象 派生类的对象可以初始化基类的引用 派生类的对象的地址可以赋给基类的指针变量 #include using namespace std; class Base { public: void who() { cout \u003c\u003c \"Base class\" \u003c\u003c endl; } }; class Derive1 : public Base { public: void who() { cout \u003c\u003c \"Derive1 class\" \u003c\u003c endl; } }; class Derive2 : public Base { public: void who() { cout \u003c\u003c \"Derive2 class\" \u003c\u003c endl; } }; int main() { Base obj1, *p; //定义基类对象obj1和基类对象指针p Derive1 obj2; Derive2 obj3; p = \u0026obj1; // p指向obj1 p-\u003ewho(); //通过指针p调用obj1的公有成员函数//who() p = \u0026obj2; // p指向obj2 p-\u003ewho(); // p只能访问从基类继承下来的who() p = \u0026obj3; // p指向obj2 p-\u003ewho(); // p只能访问从基类继承下来的who() obj2.who(); obj3.who(); return 0; } 输出\nBase class\rBase class\rBase class\rDerive1 class\rDerive2 class #include using namespace std; class Student { int num; public: Student(int n) : num(n) {} void display() { cout \u003c\u003c \"num = \" \u003c\u003c num \u003c\u003c endl; } }; class Graduate : public Student { string name; public: Graduate(int n, string _name) : Student(n), name(_name) {} void display() { Student::display(); cout \u003c\u003c \"name = \" \u003c\u003c name \u003c\u003c '\\n'; } }; int main() { Student stu(1001); Graduate grad(2001, \"Jack\"); Student *pt = \u0026stu; pt-\u003edisplay(); pt = \u0026grad; pt-\u003edisplay(); return 0; } 输出\nnum = 1001\rnum = 2001 多态（Polymorphism） 相似功能的不同函数使用一个名称来实现，从而可以使用相同的调用方式来调用这些具有不同功能的同名函数\n多态的分类 静态多态性（编译时的多态性）：通过函数重载实现 动态多态性（运行时的多态性）：通过虚函数实现 虚函数 虚函数就是在基类中被关键字virtual说明、并在一个或多个派生类中被重新定义的成员函数\nvirtual \u003c函数值类型\u003e \u003c函数名\u003e(\u003c参数表\u003e);\n程序运行时，不同类的对象调用各自的虚函数，这就是动态多态\n实现动态的多态性时，必须使用基类类型的指针变量或对象引用，并使其指向不同的派生对象，并通过调用指针或引用所指向的虚函数才能实现动态的多态性\n声明虚函数要注意\n静态成员函数和友元函数不能声明为虚函数 内联成员函数不能声明为虚函数 构造函数不能是虚函数 析构函数可以是虚函数 #include using namespace std; class Base { public: Base() = default; virtual ~Base() { cout \u003c\u003c \"Base destructor\" \u003c\u003c '\\n'; } }; class Derived : public Base { public: Derived() = default; ~Derived() { cout \u003c\u003c \"Derived destructor\" \u003c\u003c '\\n'; } }; int main() { Base *b = new Derived; delete b; return 0; } 联编 联编的分类 静态联编：在编译阶段完成的联编\n#include using namespace std; class Student { public: void print() { cout \u003c\u003c \"A student\" \u003c\u003c endl; } }; class GStudent : public Student { public: void print() { cout \u003c\u003c \"A graduate student\" \u003c\u003c endl; } }; int main() { Student s1, *ps; GStudent s2; s1.print(); s2.print(); s2.Student::print(); ps = \u0026s1; ps-\u003eprint(); //基类指针和基类成员函数发生关联 ps = \u0026s2; ps-\u003eprint(); //希望调用对象s2的输出函数，但调用的却是对象s1的输出函数 return 0; } 输出\nA student\rA graduate student\rA student\rA student\rA student 动态联编：根据具体的执行情况来动态的确定，在运行阶段完成\n#include using namespace std; class Student { public: // virtual可省略 virtual void print() { cout \u003c\u003c \"a Student\" \u003c\u003c '\\n'; } }; class GStudent : public Student { public: virtual void print() { cout \u003c\u003c \"A graduate student\" \u003c\u003c '\\n'; } }; int main() { Student s1, *ps; GStudent s2; s1.print(); s2.print(); s2.Student::print(); ps = \u0026s1; ps-\u003eprint(); ps = \u0026s2; // 对象指针调用虚函数，采用动态联编方式 ps-\u003eprint(); return 0; } 输出\na Student\rA graduate student\ra Student\ra Student\rA graduate student #include using namespace std; class Student { public: virtual void print() { cout \u003c\u003c \"A studnet\" \u003c\u003c '\\n'; } }; class GStudent : public Student { public: void print() { cout \u003c\u003c \"A graduate studnet\" \u003c\u003c '\\n'; } }; void fun(Student \u0026s) { s.print(); } int main() { Student s1; GStudent s2; fun(s1); fun(s2); return 0; } 输出\nA studnet\rA graduate studnet ⚠️注意 virtual关键字只能用在虚函数声明中，不能用在虚函数的实现中 只有通过对象指针或对象引用来调用虚函数，才能实现动态联编。如果采用对象来调用虚函数，则采用的是静态联编方式 在派生类中重新定义虚函数时，返回值类型、函数名、参数个数、类型和顺序，都必须与基类的原型相同 当在派生类中定义了虚函数的重载函数，但并没有重新定义虚函数时，与虚函数同名的重载函数覆盖了派生类中的虚函数。此时若试图通过派生类对象、指针调用派生类对象的虚函数就会产生错误 #include using namespace std; const int PI = 3.1415; class Point { int X, Y; public: Point(int X = 0, int Y = 0) { this-\u003eX = X; this-\u003eY = Y; } virtual double area() { return 0.0; } }; class Circle : public Point { double radius; public: Circle(int X, int Y, double R) : Point(X, Y) { radius = R; } double area(int i) { return PI * radius * radius; } }; int main() { Point P1(10, 10); cout \u003c\u003c \"P1.area = \" \u003c\u003c P1.area() \u003c\u003c endl; Circle C1(10, 10, 20); cout \u003c\u003c \"C1.area = \" \u003c\u003c C1.area() \u003c\u003c endl; Point *Pp; Pp = \u0026C1; cout \u003c\u003c \"Pp.area = \" \u003c\u003c Pp-\u003earea() \u003c\u003c endl; Point \u0026Rp = C1; cout \u003c\u003c \"Rp.area = \" \u003c\u003c Rp.area() \u003c\u003c endl; return 0; } 如果在派生类中没有重新定义虚函数，则不实现动态联编，派生类的对象将使用基类虚函数的代码 一个类中的虚函数说明只对派生类中重定义的函数有影响，对它的基类中的函数并没有影响 #include using namespace std; class Base { public: int func(int x) { cout \u003c\u003c \"This is Base class\" \u003c\u003c endl; return x; } }; class SubClass : public Base { public: virtual int func(int x) { cout \u003c\u003c \"This is SubClass\" \u003c\u003c endl; return x; } }; class SubSubClass : public SubClass { public: int func(int x) { cout \u003c\u003c \"This is SubSubClass\" \u003c\u003c endl; return x; } }; int main() { SubSubClass ss; Base \u0026b = ss; cout \u003c\u003c b.func(5) \u003c\u003c endl; SubClass \u0026s = ss; cout \u003c\u003c s.func(5) \u003c\u003c endl; return 0; } 输出 This is Base class 5\rThis is Sub2 class 5 纯虚函数 纯虚函数用virtual声明，没有任何实现，必须由派生类重新定义该函数提供实现\n纯虚函数与函数体为空的虚函数\n区别 前者没有函数体，后者有函数体 前者所在的类是抽象类，不能直接实例化；后者所在的类是可以实例化的（该类中不含有其他纯虚函数） 共同点 可以派生出新的类，然后在新类中给出虚函数的实现，而且这种实现可以具有动态特征 #include using namespace std; class A { protected: int x; public: A() { x = 1000; } virtual void print() = 0; // 定义纯虚函数 }; class B : public A { int y; public: B() { y = 2000; } void print() { cout \u003c\u003c \"y = \" \u003c\u003c y \u003c\u003c '\\n'; } // 重新定义纯虚函数 }; class C : public A { int z; public: C() { z = 3000; } void print() { cout \u003c\u003c \"z = \" \u003c\u003c z \u003c\u003c '\\n'; } // 重新定义纯虚函数 }; int main() { A *pa; B b; C c; pa = \u0026b; pa-\u003eprint(); pa = \u0026c; pa-\u003eprint(); // A a; 不能定义抽象类的对象 // pa = \u0026a; // pa-\u003epritn(); return 0; } 输出\ny = 2000\rz = 3000 抽象类 包含一个或多个纯虚函数的类称为抽象类\n如果派生类没有实现基类中的所有纯虚函数，派生类也是抽象类\n抽象类无法实例化\n抽象类不能用作参数类型、函数值类型或显式转换的类型，但可以声明指向抽象类的的指针或引用，通过指针或引用来指向并访问派生类对象，从而实现动态多态\n#include using namespace std; const double PI = 3.14159; class Shapes //抽象类 { public: void setvalue(int d, int w = 0) { x = d; y = w; } virtual void area() = 0; //纯虚函数 protected: int x, y; }; class Square : public Shapes { public: void area() //计算矩形面积 { cout \u003c\u003c \"area of rectangle:\" \u003c\u003c x * y \u003c\u003c endl; } }; class Circle : public Shapes { public: void area() //计算圆面积 { cout \u003c\u003c \"area of circle:\" \u003c\u003c PI * x * x \u003c\u003c endl; } }; int main() { Shapes *ptr[2]; //声明抽象类指针 Square s1; //声明派生类对象 Circle c1; //声明派生类对象 ptr[0] = \u0026s1; //抽象类指针指向派生类对象 ptr[0]-\u003esetvalue(10, 5); ptr[0]-\u003earea(); //抽象类指针调用派生类成员函数,实现多态 ptr[1] = \u0026c1; //抽象类指针指向派生类对象 ptr[1]-\u003esetvalue(10); ptr[1]-\u003earea(); //抽象类指针调用派生类成员函数,实现多态 return 0; } 输出\narea of rectangle:50\rarea of circle:314.159 第三次上机题目 定义一个复数类Complex，重载运算符“+”，“-”，“*”，“/”,使之能用于复数的加、减、乘、除。运算符重载函数作为Complex类的成员函数。编程序，分别求两个复数之和、差、积和商。 对于2行3列矩阵，重载流插入运算符“«”和流提取运算符“»”，使之能用于矩阵的输入和输出。 定义Time类和Date类，Time类为Date类的友元类，通过Time类中的display函数引用Date类对象的私有数据，输出年、月、日和时、分、秒。 分别定义Teacher（教师）类和Cadre（干部）类，采用多继承方式由这两个类派生出新类Teacher_Cadre（教师兼干部）。要求： 在两个基类中都包含姓名、年龄、性别、地址、电话等数据成员。 在Teacher类中还包含数据成员titile（职称），在Cadre类中还包含数据成员post（职务），在Teacher_Cadre类中还包含数据成员wages（工资）。 对两个基类中的姓名、年龄、性别、地址、电话等数据成员用相同的名字，在引用这些数据成员时，指定作用域。 在类体中声明成员函数，在类外定义成员函数。 在派生类Teacher_Cadre的成员函数show中调用Teacher类中的display函数，输出姓名、年龄、性别、职称、地址、电话，然后再用cout语句输出职务与工资。 写一个程序，定义抽象基类Shape，由它派生出5个派生类：Circle（圆形）、Square（正方形）、Rectangle（矩形）、Trapezoid（梯形）、Triangle（三角形）。用虚函数分别计算几种图形面积，并求它们的和。要求用基类指针数组，使它的每一个元素指向一个派生类对象。 源码下载 1\n2\n3\n4\n5\n输入输出流 流 数据从一个位置流向另一个位置。流是字节的序列。\nI/O流类库的层次结构 C++编译系统提供的I/O流类库含有两个平行基类： streambuf ios ios类有4个直接派生类： 输入流类istream 输出流类ostream 文件流类基类fstreambase 字符串流类基类strstreambase I/O流类库的头文件 iostream：I/O流类库的最主要的头文件，包含了对输入输出流进行操作的所需的基本信息，还包括cin、cout、cerr、clog共4个流对象 fstream：用于用户管理的文件的I/O操作 strstream：用于字符串流I/O stdiostream：用于混合使用C和C++的I/O操作 iomanip：用于格式化I/O时应包含此头文件 输入输出的格式控制 两种格式化方式 用流对象的有关成员函数进行格式化 用专门的控制符进行格式化输入输出 用流对象的成员函数格式化 设置状态标志 long ios::setf(long flags) 清楚状态标志 long ios::unsetf(long flags) 取状态标志 long ios::flags() 取状态标志并设置状态标志 long ios::flags(long flag) ⚠️以上三组函数必须用流式对象（cin或cout）来调用\n#include using namespace std; void showflags(long f) { long i; for (i = 0x8000; i; i \u003e\u003e= 1) { cout \u003c\u003c ((i \u0026 f) ? \"1\" : \"0\"); } cout \u003c\u003c '\\n'; } int main() { long f; f = cout.flags(); showflags(f); cout.setf(ios::showpos | ios::scientific | ios::fixed); // 追加状态标志 f = cout.flags(); showflags(f); cout.unsetf(ios::scientific); // 从状态标志中去掉scientific f = cout.flags(); showflags(f); f = cout.flags(ios::hex); // 重新设置状态标志 showflags(f); // 重新设置状态标志之前 f = cout.flags(); showflags(f); return 0; } 用流对象的成员函数设置输出宽度 int ios::width(int len) int ios::width() 第一种设置输出宽度并返回原来的输出宽度；第二种返回当前输出宽度，默认输出宽度为0 只对其后的第一个输出项有效 设置填充字符 char ios::fill(char ch) char ios::fill() 设置输出精度 int ios::precision(int p) int ios::precision() 默认输出精度为6 用流成员函数put输出字符 cout.out('a') #include using namespace std; int main() { int i = cout.width(); cout \u003c\u003c \"width: \" \u003c\u003c i \u003c\u003c endl; cout.width(8); cout \u003c\u003c cout.width() \u003c\u003c \"new width\" \u003c\u003c endl; char c = cout.fill(); cout \u003c\u003c \"filling word is: \" \u003c\u003c c \u003c\u003c \"(ASCII code\" \u003c\u003c (int)c \u003c\u003c \")\" \u003c\u003c endl; cout.fill('*'); cout \u003c\u003c cout.fill() \u003c\u003c \"(\" \u003c\u003c (int)cout.fill() \u003c\u003c \")(new filling word)\" \u003c\u003c endl; int j = cout.precision(); cout \u003c\u003c \"precision: \" \u003c\u003c j \u003c\u003c endl; cout.precision(8); cout \u003c\u003c 123.456789 \u003c\u003c \"(example)\" \u003c\u003c endl; cout \u003c\u003c cout.precision() \u003c\u003c \"(new precision)\" \u003c\u003c endl; return 0; } width:0\r8(new width)\rfilling word is: (ASCII code32)\r*(42)(new filling word)\rprecision:6\r123.45679(example)\r8(new precision) 用于字符输入的流成员函数 不带参数的get函数 #include using namespace std; int main() { int c; cout \u003c\u003c \"enter a sentence:\" \u003c\u003c endl; while ((c = cin.get()) != EOF) // 函数的返回值就是读入的字符 cout.put(c); return 0; } 有一个参数的get函数 #include using namespace std; int main() { char c; cout \u003c\u003c \"enter a sentence:\" \u003c\u003c endl; while (cin.get( c)) // 读取一个字符赋给c，如果读取成功，返回真，如失败（如遇文件结束符）则返回假 cout.put(c); cout \u003c\u003c \"end\" \u003c\u003c endl; return 0; } 有三个参数的get函数 cin.get(字符数组/字符指针, 字符个数n, 终止字符) 从输入流中读取n-1个字符，赋给指定的字符数组（或字符指针指向的数组） 如果在读取n-1个字符之前遇到指定的终止字符，则提前读取结束 如果读取成功返回真，失败（遇文件结束符）则返回假 #include using namespace std; int main() { char ch[20]; cout \u003c\u003c \"enter a sentence:\" \u003c\u003c endl; cin.get(ch, 10, '/'); cout \u003c\u003c ch \u003c\u003c endl; cin.get(ch, 20, '\\n'); // cin.get(ch, 20); cout \u003c\u003c ch \u003c\u003c endl; return 0; } enter a sentence:\ryou!/her.\ryou!\r/her. 用getline函数读入一行字符 cin.getline(字符数组（或字符指针）, 字符个数n, 终止字符) 从输入流中读取一行字符，其用法与带3个参数的get函数类似 #include using namespace std; int main() { char ch[20]; cout \u003c\u003c \"enter a sentence:\" \u003c\u003c endl; cin \u003e\u003e ch; cout \u003c\u003c ch \u003c\u003c endl; cin.getline(ch, 20, '/'); cout \u003c\u003c ch \u003c\u003c endl; cin.getline(ch, 20); cout \u003c\u003c ch \u003c\u003c endl; return 0; } enter a sentence:\rI like C++./I study C++./I am happy.\rI\rlike C++.\rI study C++./I am h eof函数 while(!cin.eof()) peek函数 无参函数，表示“观察”，观测下一字符 返回值是当前指针指向的当前字符，但只是观测，指针仍停留在当前位置，并不后移 如果要访问的字符是文件结束符时，则函数值是EOF c = cin.peek(); putback函数 将前面用get或getline函数从输入流中读取的字符ch返回到输入流，插入到当前指针位置，供后面读取 #include using namespace std; int main() { char c[20]; int ch; cout \u003c\u003c \"enter a sentence:\" \u003c\u003c endl; cin.getline(c, 15, '/'); cout \u003c\u003c c \u003c\u003c endl; ch = cin.peek(); // 观看当前字符 cout \u003c\u003c ch \u003c\u003c endl; cin.putback(c[0]); // 将'I'插入到指针所指处 cin.getline(c, 15, '/'); cout \u003c\u003c c \u003c\u003c endl; return 0; } enter a sentence:\rI am a boy./ am a student./\rI am a boy.\r32\rI am a student ignore函数 cin.ignore(n, 终止字符) 跳过输入流中n个字符，或在遇到指定的终止字符时提前结束（此时跳过包括终止字符在内的若干字符） ignore(5, 'A'); // 跳过5个字符，遇'A'后不再跳 ignore(); \u003c-\u003e ignore(1, EOF); 示例代码 不加ignore #include using namespace std; int main() { char ch[20]; cin.get(ch, 20, '/'); cout \u003c\u003c \"the first part is: \" \u003c\u003c ch \u003c\u003c endl; cin.get(ch, 20, '/'); // get不跳过终止字符 cout \u003c\u003c \"the second part is: \" \u003c\u003c ch \u003c\u003c endl; return 0; } I like C++./I study C++./I am happy.\rThe first part is:I like C++.\rThe second part is: 加ignore #include using namespace std; int main() { char ch[20]; cin.get(ch, 20, '/'); cout \u003c\u003c \"the first part is: \" \u003c\u003c ch \u003c\u003c endl; cin.ignore(); // 跳过输入流中一个字符 cin.get(ch, 20, '/'); // get不跳过终止字符 cout \u003c\u003c \"the second part is: \" \u003c\u003c ch \u003c\u003c endl; return 0; } I like C++./I study C++./I am happy.\rThe first part is:I like C++.\rThe second part is:I study C++. 用控制符格式化 这组控制符不属于任何类成员，定义在inomanip头文件中 将他们用在提取运算符\"»“或插入运算符”«“后面来设定输入/输出格式，即在读写对象之间插入一个修改状态的操作 设置输入/输出宽度setw(int) 用整型参数来指定输入/输出域的宽度。使用时只对其后一项输入/输出有效 当用于输出时，若实际宽度小于设置宽度时，数据向右对齐，反之则按照数据的实际宽度输出 当用于输入时，若输入的数据宽度超过设置宽度时，超出的数据部分被截断而被作为下一项输入内容 #include using namespace std; int main() { char *p = \"12345\", *q = \"678\"; char f[4], g[4]; int i = 10; cout \u003c\u003c p \u003c\u003c setw(6) \u003c\u003c q \u003c\u003c setw(4) \u003c\u003c p \u003c\u003c q \u003c\u003c endl; cin \u003e\u003e setw(4) \u003e\u003e f \u003e\u003e g; cout \u003c\u003c f \u003c\u003c endl \u003c\u003c g \u003c\u003c endl \u003c\u003c \"i : \" \u003c\u003c i \u003c\u003c endl; return 0; } 12345 67812345678\r12345\r123\r45\ri:10 设置输出填充字符setfill(char) setprecision(int) 在以fixed形式和scientific形式输出时参数为小数位数 setiosflags(ios::fixed)用定点方式表示实数 setiosflags(ios::scientific)用科学记数法方式表示实数 setiosflags(ios::left)左对齐 setiosflags(ios::right)右对齐 setiosflags(ios::uppercase)大写表示 setiosflags(ios::showpos)正号 setiosflags(ios::skipws)忽略前导空格 resetiosflags() 终止已设置的输出格式状态，在括号中应指定内容 #include #include using namespace std; int main() { double f=22.0/7; //在用浮点形式表示的输出中，setprecision(n)表示实数的有效位数 cout\u003c\u003cf\u003c\u003cendl; //默认有效位数为6 cout\u003c\u003csetprecision(3)\u003c\u003cf\u003c\u003cendl; //设置有效位数为3 //在用定点形式表示的输出中，setprecision(n)表示实数的小数位数 cout\u003c\u003csetiosflags(ios::fixed); cout\u003c\u003csetprecision(8)\u003c\u003cf\u003c\u003cendl; //小数位数为8 return 0; } 3.14286\r3.14\r3.14285714 设置输入/输出整型数数制dec、hex和oct 控制换行的控制符endl 代表输出单字符’\\0’的控制符ends ","wordCount":"3577","inLanguage":"en","datePublished":"2020-10-06T12:25:11+08:00","dateModified":"2020-10-06T12:25:11+08:00","author":{"@type":"Person","name":"fffzlfk"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://fffzlfk.github.io/posts/oopc++/"},"publisher":{"@type":"Organization","name":"fffzlfk's Blog","logo":{"@type":"ImageObject","url":"https://fffzlfk.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://fffzlfk.github.io accesskey=h title="fffzlfk's Blog (Alt + H)"><img src=https://fffzlfk.github.io/android-chrome-512x512.png alt aria-label=logo height=35>fffzlfk's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://github.com/fffzlfk title=GitHub><span>GitHub</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://fffzlfk.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://fffzlfk.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://fffzlfk.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://www.travellings.cn/go.html title=Travellings><span>Travellings</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://fffzlfk.github.io>Home</a>&nbsp;»&nbsp;<a href=https://fffzlfk.github.io/posts/>Posts</a></div><h1 class=post-title>OOP(C++)</h1><div class=post-meta><span title='2020-10-06 12:25:11 +0800 +0800'>October 6, 2020</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;fffzlfk&nbsp;|&nbsp;<a href=https://github.com/fffzlfk/fffzlfk.github.io/blob/master/content/posts/OOP%28C++%29.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#c%e5%9f%ba%e7%a1%80 aria-label=C++基础>C++基础</a><ul><li><a href=#c%e5%af%b9c%e7%9a%84%e6%89%a9%e5%85%85 aria-label=C++对C的扩充>C++对C的扩充</a><ul><li><a href=#%e5%90%8d%e5%ad%97%e7%a9%ba%e9%97%b4 aria-label=名字空间>名字空间</a></li><li><a href=#%e7%94%a8const%e5%ae%9a%e4%b9%89%e5%b8%b8%e9%87%8f aria-label=用const定义常量>用const定义常量</a></li><li><a href=#%e5%bc%95%e7%94%a8 aria-label=引用>引用</a></li><li><a href=#%e5%bc%95%e7%94%a8%e4%b8%8e%e5%87%bd%e6%95%b0 aria-label=引用与函数>引用与函数</a></li><li><a href=#%e5%86%85%e8%81%94%e5%87%bd%e6%95%b0 aria-label=内联函数>内联函数</a></li></ul></li><li><a href=#%e7%ac%ac%e4%b8%80%e6%ac%a1%e4%b8%8a%e7%ba%a7%e9%a2%98%e7%9b%ae aria-label=第一次上级题目>第一次上级题目</a><ul><li><a href=#%e6%ba%90%e7%a0%81%e4%b8%8b%e8%bd%bd aria-label=源码下载>源码下载</a></li></ul></li></ul></li><li><a href=#%e7%b1%bb%e5%92%8c%e5%af%b9%e8%b1%a1 aria-label=类和对象>类和对象</a><ul><li><a href=#%e5%a4%8d%e5%88%b6%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8%e6%97%b6%e6%9c%ba aria-label=复制构造函数调用时机>复制构造函数调用时机</a></li><li><a href=#%e6%8c%87%e5%90%91%e9%9d%9e%e9%9d%99%e6%80%81%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0%e7%9a%84%e6%8c%87%e9%92%88 aria-label=指向非静态成员函数的指针>指向非静态成员函数的指针</a></li><li><a href=#%e6%8c%87%e5%90%91%e9%9d%99%e6%80%81%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0%e7%9a%84%e6%8c%87%e9%92%88 aria-label=指向静态成员函数的指针>指向静态成员函数的指针</a></li><li><a href=#%e5%af%b9%e8%b1%a1%e5%bc%95%e7%94%a8%e7%9a%84%e4%bd%9c%e7%94%a8 aria-label=对象引用的作用>对象引用的作用</a></li><li><a href=#%e5%85%b3%e4%ba%8e%e6%95%b0%e6%8d%ae%e6%88%90%e5%91%98%e5%88%9d%e5%a7%8b%e5%8c%96 aria-label=关于数据成员初始化>关于数据成员初始化</a></li><li><a href=#%e5%b8%b8%e5%af%b9%e8%b1%a1 aria-label=常对象>常对象</a><ul><li><a href=#%e5%b8%b8%e6%88%90%e5%91%98 aria-label=常成员>常成员</a></li><li><a href=#const%e4%b8%8e%e6%8c%87%e9%92%88 aria-label=const与指针>const与指针</a></li></ul></li><li><a href=#%e5%af%b9%e8%b1%a1%e6%95%b0%e7%bb%84 aria-label=对象数组>对象数组</a></li><li><a href=#%e7%b1%bb%e6%a8%a1%e6%9d%bf aria-label=类模板>类模板</a><ul><li><a href=#%e7%b1%bb%e6%a8%a1%e6%9d%bf%e4%b8%ad%e7%9a%84%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0%e7%9a%84%e5%ae%9a%e4%b9%89 aria-label=类模板中的成员函数的定义>类模板中的成员函数的定义</a></li></ul></li><li><a href=#%e7%ac%ac%e4%ba%8c%e6%ac%a1%e4%b8%8a%e6%9c%ba%e9%a2%98%e7%9b%ae aria-label=第二次上机题目>第二次上机题目</a><ul><li><a href=#%e6%ba%90%e7%a0%81%e4%b8%8b%e8%bd%bd-1 aria-label=源码下载>源码下载</a></li></ul></li></ul></li><li><a href=#%e8%bf%90%e7%ae%97%e7%ac%a6%e9%87%8d%e8%bd%bd aria-label=运算符重载>运算符重载</a><ul><li><a href=#%e4%b8%8d%e8%83%bd%e9%87%8d%e8%bd%bd%e7%9a%84%e8%bf%90%e7%ae%97%e7%ac%a6 aria-label=不能重载的运算符>不能重载的运算符</a></li><li><a href=#%e9%87%8d%e8%bd%bd%e4%b8%ba%e7%b1%bb%e7%9a%84%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0 aria-label=重载为类的成员函数>重载为类的成员函数</a><ul><li><a href=#%e5%8d%95%e7%9b%ae%e8%bf%90%e7%ae%97%e7%ac%a6%e7%9a%84%e9%87%8d%e8%bd%bd-- aria-label=单目运算符的重载++、&amp;ndash;>单目运算符的重载++、&ndash;</a></li></ul></li><li><a href=#%e5%8f%8b%e5%85%83%e5%87%bd%e6%95%b0 aria-label=友元函数>友元函数</a></li><li><a href=#%e9%87%8d%e8%bd%bd%e4%b8%ba%e7%b1%bb%e7%9a%84%e5%8f%8b%e5%85%83%e5%87%bd%e6%95%b0 aria-label=重载为类的友元函数>重载为类的友元函数</a><ul><li><a href=#%e5%8d%95%e7%9b%ae%e8%bf%90%e7%ae%97%e7%ac%a6%e9%87%8d%e8%bd%bd aria-label=单目运算符重载>单目运算符重载</a></li></ul></li><li><a href=#%e9%87%8d%e8%bd%bd%e8%be%93%e5%85%a5%e8%be%93%e5%87%ba%e8%bf%90%e7%ae%97%e7%ac%a6 aria-label=重载输入输出运算符>重载输入输出运算符</a></li><li><a href=#%e5%87%bd%e6%95%b0%e5%af%b9%e8%b1%a1 aria-label=函数对象>函数对象</a></li><li><a href=#%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%e8%bf%90%e7%ae%97%e7%ac%a6%e9%87%8d%e8%bd%bd aria-label=类型转换运算符重载>类型转换运算符重载</a><ul><li><a href=#%e5%9f%ba%e6%9c%ac%e7%b1%bb%e5%9e%8b%e5%88%b0%e7%b1%bb%e7%b1%bb%e5%9e%8b%e7%9a%84%e8%bd%ac%e6%8d%a2 aria-label=基本类型到类类型的转换>基本类型到类类型的转换</a></li><li><a href=#%e7%b1%bb%e7%b1%bb%e5%9e%8b%e5%88%b0%e5%9f%ba%e6%9c%ac%e7%b1%bb%e5%9e%8b%e7%9a%84%e8%bd%ac%e6%8d%a2 aria-label=类类型到基本类型的转换>类类型到基本类型的转换</a></li></ul></li><li><a href=#%e7%a4%ba%e4%be%8b%e4%bb%a3%e7%a0%81 aria-label=示例代码>示例代码</a></li></ul></li><li><a href=#%e7%bb%a7%e6%89%bf%e4%b8%8e%e6%b4%be%e7%94%9f aria-label=继承与派生>继承与派生</a><ul><li><a href=#%e6%b4%be%e7%94%9f%e7%b1%bb%e5%ae%9a%e4%b9%89 aria-label=派生类定义>派生类定义</a><ul><li><a href=#%e4%b8%89%e7%a7%8d%e7%bb%a7%e6%89%bf%e6%96%b9%e5%bc%8f%e6%b4%be%e7%94%9f%e7%b1%bb%e4%b8%ad%e5%9f%ba%e7%b1%bb%e6%88%90%e5%91%98%e7%9a%84%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6%e6%9d%83%e9%99%90 aria-label=三种继承方式派生类中基类成员的访问控制权限>三种继承方式派生类中基类成员的访问控制权限</a></li></ul></li><li><a href=#%e6%b4%be%e7%94%9f%e7%b1%bb%e7%9a%84%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e5%92%8c%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0 aria-label=派生类的构造函数和析构函数>派生类的构造函数和析构函数</a><ul><li><a href=#%e6%b4%be%e7%94%9f%e7%b1%bb%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0 aria-label=派生类构造函数>派生类构造函数</a></li><li><a href=#%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e5%92%8c%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0%e7%9a%84%e8%b0%83%e7%94%a8%e9%a1%ba%e5%ba%8f aria-label=构造函数和析构函数的调用顺序>构造函数和析构函数的调用顺序</a></li></ul></li><li><a href=#%e5%a4%9a%e7%bb%a7%e6%89%bf%e4%b8%8e%e8%99%9a%e5%9f%ba%e7%b1%bb aria-label=多继承与虚基类>多继承与虚基类</a><ul><li><a href=#%e5%a4%9a%e7%bb%a7%e6%89%bf%e6%b4%be%e7%94%9f%e7%b1%bb%e7%9a%84%e5%ae%9a%e4%b9%89 aria-label=多继承派生类的定义>多继承派生类的定义</a></li><li><a href=#%e5%a4%9a%e7%bb%a7%e6%89%bf%e6%b4%be%e7%94%9f%e7%b1%bb%e7%9a%84%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0 aria-label=多继承派生类的构造函数>多继承派生类的构造函数</a></li></ul></li><li><a href=#%e5%a4%9a%e7%bb%a7%e6%89%bf%e5%bc%95%e8%b5%b7%e7%9a%84%e4%ba%8c%e4%b9%89%e6%80%a7%e9%97%ae%e9%a2%98 aria-label=多继承引起的二义性问题>多继承引起的二义性问题</a><ul><li><a href=#%e4%b8%a4%e4%b8%aa%e5%9f%ba%e7%b1%bb%e6%9c%89%e5%90%8c%e5%90%8d%e6%88%90%e5%91%98 aria-label=两个基类有同名成员>两个基类有同名成员</a></li><li><a href=#%e4%b8%a4%e4%b8%aa%e5%9f%ba%e7%b1%bb%e5%92%8c%e6%b4%be%e7%94%9f%e7%b1%bb%e4%b8%89%e8%80%85%e9%83%bd%e6%9c%89%e5%90%8c%e5%90%8d%e6%88%90%e5%91%98 aria-label=两个基类和派生类三者都有同名成员>两个基类和派生类三者都有同名成员</a></li></ul></li><li><a href=#%e8%99%9a%e5%9f%ba%e7%b1%bb aria-label=虚基类>虚基类</a><ul><li><a href=#%e8%99%9a%e5%9f%ba%e7%b1%bb%e6%a6%82%e5%bf%b5 aria-label=虚基类概念>虚基类概念</a></li><li><a href=#%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e7%9a%84%e8%b0%83%e7%94%a8%e9%a1%ba%e5%ba%8f aria-label=构造函数的调用顺序>构造函数的调用顺序</a></li><li><a href=#%e8%99%9a%e5%9f%ba%e7%b1%bb%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96 aria-label=虚基类的初始化>虚基类的初始化</a></li></ul></li></ul></li><li><a href=#%e5%a4%9a%e6%80%81%e6%80%a7%e4%b8%8e%e8%99%9a%e5%87%bd%e6%95%b0 aria-label=多态性与虚函数>多态性与虚函数</a><ul><li><a href=#%e7%b1%bb%e5%9e%8b%e5%85%bc%e5%ae%b9%e8%a7%84%e5%88%99 aria-label=类型兼容规则>类型兼容规则</a></li><li><a href=#%e5%a4%9a%e6%80%81polymorphism aria-label=多态（Polymorphism）>多态（Polymorphism）</a><ul><li><a href=#%e5%a4%9a%e6%80%81%e7%9a%84%e5%88%86%e7%b1%bb aria-label=多态的分类>多态的分类</a></li><li><a href=#%e8%99%9a%e5%87%bd%e6%95%b0 aria-label=虚函数>虚函数</a></li><li><a href=#%e8%81%94%e7%bc%96 aria-label=联编>联编</a></li><li><a href=#%e7%ba%af%e8%99%9a%e5%87%bd%e6%95%b0 aria-label=纯虚函数>纯虚函数</a></li><li><a href=#%e6%8a%bd%e8%b1%a1%e7%b1%bb aria-label=抽象类>抽象类</a></li></ul></li><li><a href=#%e7%ac%ac%e4%b8%89%e6%ac%a1%e4%b8%8a%e6%9c%ba%e9%a2%98%e7%9b%ae aria-label=第三次上机题目>第三次上机题目</a><ul><li><a href=#%e6%ba%90%e7%a0%81%e4%b8%8b%e8%bd%bd-2 aria-label=源码下载>源码下载</a></li></ul></li></ul></li><li><a href=#%e8%be%93%e5%85%a5%e8%be%93%e5%87%ba%e6%b5%81 aria-label=输入输出流>输入输出流</a><ul><li><a href=#%e6%b5%81 aria-label=流>流</a></li><li><a href=#io%e6%b5%81%e7%b1%bb%e5%ba%93%e7%9a%84%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84 aria-label=I/O流类库的层次结构>I/O流类库的层次结构</a></li><li><a href=#io%e6%b5%81%e7%b1%bb%e5%ba%93%e7%9a%84%e5%a4%b4%e6%96%87%e4%bb%b6 aria-label=I/O流类库的头文件>I/O流类库的头文件</a></li><li><a href=#%e8%be%93%e5%85%a5%e8%be%93%e5%87%ba%e7%9a%84%e6%a0%bc%e5%bc%8f%e6%8e%a7%e5%88%b6 aria-label=输入输出的格式控制>输入输出的格式控制</a><ul><li><a href=#%e7%94%a8%e6%b5%81%e5%af%b9%e8%b1%a1%e7%9a%84%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0%e6%a0%bc%e5%bc%8f%e5%8c%96 aria-label=用流对象的成员函数格式化>用流对象的成员函数格式化</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h2 id=c基础>C++基础<a hidden class=anchor aria-hidden=true href=#c基础>#</a></h2><h3 id=c对c的扩充>C++对C的扩充<a hidden class=anchor aria-hidden=true href=#c对c的扩充>#</a></h3><h4 id=名字空间>名字空间<a hidden class=anchor aria-hidden=true href=#名字空间>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>namespace</span> ns1{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> inflag;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> ns2{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> inflag;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ns1<span style=color:#f92672>::</span>inflag<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>ns2<span style=color:#f92672>::</span>inflag<span style=color:#f92672>=-</span><span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>// using ns1::inflag; inflag=2;
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ns2::inflag=-3;
</span></span></span></code></pre></div><h4 id=用const定义常量>用const定义常量<a hidden class=anchor aria-hidden=true href=#用const定义常量>#</a></h4><ul><li>用const定义标识符常量时，<strong>一定要对其初始化</strong>，这是唯一方法。</li></ul><h4 id=引用>引用<a hidden class=anchor aria-hidden=true href=#引用>#</a></h4><ul><li><p>对变量起另外一个名字，这个名字称为该变量的引用。</p></li><li><p>其中原变量名必须是一个已定义过的变量。</p></li><li><p>引用并没有重新在内存中开辟存储单元，只是引用原变量的单元。</p></li><li><p>对引用的初始化，可以用一个变量名，也可以用另一个引用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span>   a<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span>  <span style=color:#f92672>&amp;</span>b<span style=color:#f92672>=</span>a;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span>  <span style=color:#f92672>&amp;</span>c<span style=color:#f92672>=</span>b;
</span></span></code></pre></div></li><li><p>引用同变量一样有地址，可以对其地址进行操作，即将其地址赋给一指针。</p></li><li><p>对const常量的引用使用如下方式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>ri <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ri = 10;  错误
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  i <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;    <span style=color:#75715e>//正确
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  cout <span style=color:#f92672>&lt;&lt;</span> ri;
</span></span></code></pre></div></li><li><p>以下的声明是非法的</p><ul><li>企图建立void类型的引用 void &amp;a</li><li>企图建立引用的数组 int &amp;a[6]</li><li>企图建立指向引用的指针 int &*p</li></ul></li><li><p>指针和引用的区别：</p><ul><li>指针是通过地址<strong>间接</strong>访问某个变量，而引用是通过别名<strong>直接</strong>访问某个变量。</li><li>引用必须初始化，而<strong>一旦初始化后不再作为其他变量的别名</strong>。指针若不进行初始化，编译器不会报错。</li></ul></li></ul><h4 id=引用与函数>引用与函数<a hidden class=anchor aria-hidden=true href=#引用与函数>#</a></h4><ul><li>函数的返回值为引用类型<div class=render-image><img loading=lazy src=https://i.postimg.cc/P5PdH4VS/1.jpg alt></div></li></ul><h4 id=内联函数>内联函数<a hidden class=anchor aria-hidden=true href=#内联函数>#</a></h4><ul><li>调用内联函数时，编译器首先检查调用是否正确（类型安全检查或者自动进行类型转换）。如果正确，则<strong>将内联函数的代码直接替换函数调用，并用实参换型参</strong>，于是省去了函数调用的开销。因此，内联机制增加了空间开销而节约了时间开销。</li></ul><h3 id=第一次上级题目>第一次上级题目<a hidden class=anchor aria-hidden=true href=#第一次上级题目>#</a></h3><ol><li>求2个或3个正整数中的最大数，用带有默认参数的函数实现。</li><li>输入三个整数，将它们按由小到大的顺序输出，要求使用变量的引用。</li><li>编写一个程序，用同一个函数名对几个数据进行从小到大排序，数据类型可以是整型、浮点型。用重载函数实现。</li><li>对第3题改用函数模板实现，并与第3题程序进行对比分析。</li><li>设计一个日期Date类，它能实现年月日的输入和输出，要求分别将成员函数定义在类体内和类体外。</li><li>声明一个Circle类，有数据成员Radius（半径）、成员函数GetArea（）计算圆的面积，构造一个Circle的对象进行测试。</li><li>编写一个基于对象的程序，求出3个长方柱的体积。数据成员包括length(长)、width(宽)、height(高)。要求用成员函数实现以下功能：<br>(1) 由键盘分别输入3个长方柱的长、宽、高；<br>(2) 计算长方柱的体积；<br>(3) 输出3个长方柱的体积。</li></ol><h4 id=源码下载>源码下载<a hidden class=anchor aria-hidden=true href=#源码下载>#</a></h4><p><a href=/0x01/test1.cpp>1</a><br><a href=/0x01/test2.cpp>2</a><br><a href=/0x01/test3.cpp>3</a><br><a href=/0x01/test4.cpp>4</a><br><a href=/0x01/test5.cpp>5</a><br><a href=/0x01/test6.cpp>6</a><br><a href=/0x01/test7.cpp>7</a></p><h2 id=类和对象>类和对象<a hidden class=anchor aria-hidden=true href=#类和对象>#</a></h2><h3 id=复制构造函数调用时机>复制构造函数调用时机<a hidden class=anchor aria-hidden=true href=#复制构造函数调用时机>#</a></h3><ol><li>程序中需要新建立一个对象，并用另一个同类的对象对它初始化</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Box <span style=color:#a6e22e>box1</span>(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>Box box2 <span style=color:#f92672>=</span> box1; <span style=color:#75715e>// Box box2(box1);
</span></span></span></code></pre></div><ol start=2><li>当函数的参数为类对象时，在调用函数时需要将实参对象完整的传递给形参</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func</span>(Box b) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// do something...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  Box box1(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>  fun(box1);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>当函数的返回值是类的对象，在函数调用完毕将返回值带回函数调用处时</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Box <span style=color:#a6e22e>f1</span>() {
</span></span><span style=display:flex><span>  Box box1(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> box1;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  Box box2;
</span></span><span style=display:flex><span>  box2 <span style=color:#f92672>=</span> f();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=指向非静态成员函数的指针>指向非静态成员函数的指针<a hidden class=anchor aria-hidden=true href=#指向非静态成员函数的指针>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/* Author: fffzlfk */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Node(<span style=color:#66d9ef>int</span> xx, <span style=color:#66d9ef>int</span> yy) <span style=color:#f92672>:</span> x(xx), y(yy){}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>get_x</span>() { <span style=color:#66d9ef>return</span> x; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>get_y</span>() { <span style=color:#66d9ef>return</span> y; }
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x, y;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Node node(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> (Node<span style=color:#f92672>::*</span>p_x)() <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>Node<span style=color:#f92672>::</span>get_x; <span style=color:#75715e>// 需要加类名和作用域运算符
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> (Node<span style=color:#f92672>::*</span>p_y)() <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>Node<span style=color:#f92672>::</span>get_y;
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> (node.<span style=color:#f92672>*</span>p_x)() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> (node.<span style=color:#f92672>*</span>p_y)() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=指向静态成员函数的指针>指向静态成员函数的指针<a hidden class=anchor aria-hidden=true href=#指向静态成员函数的指针>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/* Author: fffzlfk */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> get() { <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>666</span>; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> (<span style=color:#f92672>*</span>p)() <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>A<span style=color:#f92672>::</span>get;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> p() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> (<span style=color:#f92672>*</span>p)(); <span style=color:#75715e>// 加不加*都可
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=对象引用的作用>对象引用的作用<a hidden class=anchor aria-hidden=true href=#对象引用的作用>#</a></h3><style type=text/css>.notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fa}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:.125em;position:relative}</style><div><svg width="0" height="0" display="none" xmlns="http://www.w3.org/2000/svg"><symbol id="tip-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379.0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628.0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628.0l-22.627 22.627c-6.248 6.248-6.248 16.379.0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"/></symbol><symbol id="note-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405.0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346 7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373.0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884.0-12.356 5.78-11.981 12.654z"/></symbol><symbol id="warning-notice" viewBox="0 0 576 512" preserveAspectRatio="xMidYMid meet"><path d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937.0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154.0l239.94 416.028zM288 354c-25.405.0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346 7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373.0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884.0-12.356 5.78-11.981 12.654z"/></symbol><symbol id="info-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196.0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627.0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627.0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627.0 12 5.373 12 12v1e2h12c6.627.0 12 5.373 12 12v24z"/></symbol></svg></div><div class="notice tip"><p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#tip-notice"/></svg></span>Tip</p><ol><li>避免通过值来传递对象，而是通过引用来传递</li><li>参数传递的是引用，没有构造函数或析构函数被调用，节约了系统资源，提高了运行效率</li></ol></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/* Author: fffzlfk */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	Student();
</span></span><span style=display:flex><span>	Student <span style=color:#a6e22e>returnS</span>(Student s) { <span style=color:#66d9ef>return</span> s; }
</span></span><span style=display:flex><span>    Student(<span style=color:#66d9ef>const</span> Student <span style=color:#f92672>&amp;</span>e) { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Copy Constructor</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>; }
</span></span><span style=display:flex><span>    <span style=color:#f92672>~</span>Student() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Destructor</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>Student<span style=color:#f92672>::</span>Student() {}
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Student stu1;
</span></span><span style=display:flex><span>    stu1.returnS(stu1);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出为：<br>Copy Constructor<br>Copy Constructor<br>Destructor<br>Destructor<br>Destructor<br>修改为</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Student<span style=color:#f92672>&amp;</span> returnS(Student <span style=color:#f92672>&amp;</span>s) { <span style=color:#66d9ef>return</span> s; }
</span></span></code></pre></div><p>之后，输出：<br>Destructor</p><h3 id=关于数据成员初始化>关于数据成员初始化<a hidden class=anchor aria-hidden=true href=#关于数据成员初始化>#</a></h3><table><thead><tr><th>数据成员</th><th>成员初始化列表</th><th>构造函数体内</th><th>类外</th></tr></thead><tbody><tr><td>普通数据成员</td><td>$\checkmark $</td><td>$\checkmark $</td><td></td></tr><tr><td>常数据成员</td><td>$\checkmark $</td><td></td><td></td></tr><tr><td>静态数据成员</td><td></td><td></td><td>$\checkmark $</td></tr><tr><td>静态常数据成员</td><td></td><td></td><td>$\checkmark $</td></tr></tbody></table><h3 id=常对象>常对象<a hidden class=anchor aria-hidden=true href=#常对象>#</a></h3><div class="notice tip"><p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#tip-notice"/></svg></span>Tip</p><ol><li><p>常对象的所有数据成员都是常量，不能改变。因此，常对象必须初始化。</p></li><li><p>不能通过常对象调用普通的成员函数，可以调用常成员函数。</p></li><li><p>如果要修改常对象中某个数据成员的值，可以将数据成员声明为mutable，这样就可以用声明为const的成员函数来修改它的值。</p></li></ol></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/* Author: fffzlfk */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>mutable</span> <span style=color:#66d9ef>int</span> i; <span style=color:#75715e>// 可以用常成员函数来修改
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	A() {} <span style=color:#75715e>//常对象必须初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>f_const</span>() <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>		i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;i = &#34;</span> <span style=color:#f92672>&lt;&lt;</span> i <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;f_const()&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>f</span>() {
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;f()&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>const</span> A a; <span style=color:#75715e>//常对象必须初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	a.f_const(); <span style=color:#75715e>//常对象只能调用常成员函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=常成员>常成员<a hidden class=anchor aria-hidden=true href=#常成员>#</a></h4><ul><li><p>常数据成员</p><div class="notice tip"><p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#tip-notice"/></svg></span>Tip</p><ol><li><p>在任何函数中都不能对常数据成员赋值</p></li><li><p>只能通过构造函数的参数初始化表对常数据成员进行初始化</p></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> Hour;
</span></span><span style=display:flex><span>Time<span style=color:#f92672>::</span>Time(<span style=color:#66d9ef>int</span> h) <span style=color:#f92672>:</span> Hour(h) {}
</span></span></code></pre></div><ol start=3><li>类的所有对象中的常数据成员的值均不能改变，但不同对象中的该数据成员可以不同（在定义对象时给出）</li></ol></div><ul><li>示例程序：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/* Author: fffzlfk */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  A(<span style=color:#66d9ef>int</span> i) <span style=color:#f92672>:</span> a(i) {} <span style=color:#75715e>// 非静态常数据成员只能通过初始化表来获得初值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print</span>() {
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> a <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> b <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> a;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> b;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> A<span style=color:#f92672>::</span>b <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>; <span style=color:#75715e>// 静态常数据成员只能在类外初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  A a1(<span style=color:#ae81ff>100</span>), a2(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  a1.print();
</span></span><span style=display:flex><span>  a2.print();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>常成员函数</p><div class="notice tip"><p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#tip-notice"/></svg></span>Tip</p><ol><li>通过常成员函数来引用本类中的数据成员，但不能修改他们</li><li>const 是函数类型的一部分，在声明函数时都要有const，在调用时不必加const</li><li>常成员函数不能更新对象的数据成员，也不能调用该类中的非const成员函数</li><li>通过常对象只能调用它的常成员函数，而不能调用其他成员函数</li><li>常对象中的成员函数不是常成员函数，除非成员函数有const修饰</li><li>const关键字可以用于对重载函数的区分</li></ol></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/* Author: fffzlfk */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>R</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  R(<span style=color:#66d9ef>int</span> r1, <span style=color:#66d9ef>int</span> r2) {
</span></span><span style=display:flex><span>    R1 <span style=color:#f92672>=</span> r1;
</span></span><span style=display:flex><span>    R2 <span style=color:#f92672>=</span> r2;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print</span>() {
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> R1 <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;-&#39;</span> <span style=color:#f92672>&lt;&lt;</span> R2 <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print</span>() <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> R1 <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;+&#34;</span> <span style=color:#f92672>&lt;&lt;</span> R2 <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> R1, R2;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  R a(<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>  a.print(); <span style=color:#75715e>// 普通对象a调用普通成员函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> R b(<span style=color:#ae81ff>20</span>, <span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>  b.print(); <span style=color:#75715e>// 常对象b调用常成员函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>const成员和非const成员之间的调用关系</p><table><thead><tr><th>数据成员</th><th>非const成员函数</th><th>const成员函数</th></tr></thead><tbody><tr><td>非const数据成员</td><td>可以引用，也可以改变值</td><td>可以引用，但不可以改变值</td></tr><tr><td>const数据成员</td><td>可以引用，但不能改变值</td><td>可以引用，但不可以改变值</td></tr><tr><td>const对象的数据成员</td><td>不允许引用和改变值</td><td>可以引用，不可以改变值</td></tr></tbody></table></li></ul><h4 id=const与指针>const与指针<a hidden class=anchor aria-hidden=true href=#const与指针>#</a></h4><ul><li><p>指向对象的常指针指针本身的值不能改变，即其指向不能改变。</p><p><strong>类名 *const 指针变量名 = 对象地址</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Time <span style=color:#a6e22e>t1</span>(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>15</span>), t2;
</span></span><span style=display:flex><span>Time <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> ptr1 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>t1;
</span></span><span style=display:flex><span>ptr1 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>t2; <span style=color:#75715e>//错误，ptr1不能改变指向
</span></span></span></code></pre></div><div class="notice tip"><p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#tip-notice"/></svg></span>Tip</p><p>常指针始终指向同一个对象，但是可以改变其所指对象中数据成员的值。</p></div></li><li><p>指向常对象的指针</p><p><strong>const 类名 *指针变量名 = 对象地址</strong></p><ul><li><p>如果存在一个常对象，只能用指向常对象的指针去指向它，而不能用非const型的指针去指向它。</p></li><li><p>指向常对象的指针还可以指向非const型的对象，此时不能通过指针改变该对象的值，但是通过该对象本身来改变。指针本身的值也可以改变。</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Time <span style=color:#a6e22e>t1</span>(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>15</span>), t2;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> Time <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>t1; <span style=color:#75715e>// p是指向常对象的指针，并指向t1对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>(<span style=color:#f92672>*</span>p).hour <span style=color:#f92672>=</span> <span style=color:#ae81ff>18</span>;      <span style=color:#75715e>// 错误，不能通过指针改变t1的值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>t1.hour <span style=color:#f92672>=</span> <span style=color:#ae81ff>18</span>;        <span style=color:#75715e>// 正确，t1不是常对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>p <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>t2;             <span style=color:#75715e>// 正确，p改为指向t2
</span></span></span></code></pre></div><div class="notice note"><p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#note-notice"/></svg></span>Note</p><p>指向常对象的指针可以指向const和非const型的对象，而指向非const型对象的指针只能指向非const的对象。</p></div></li></ul><h3 id=对象数组>对象数组<a hidden class=anchor aria-hidden=true href=#对象数组>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/* Author: fffzlfk */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Box</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Box(<span style=color:#66d9ef>int</span> h <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>, <span style=color:#66d9ef>int</span> w <span style=color:#f92672>=</span> <span style=color:#ae81ff>12</span>, <span style=color:#66d9ef>int</span> len <span style=color:#f92672>=</span> <span style=color:#ae81ff>15</span>)
</span></span><span style=display:flex><span>        <span style=color:#f92672>:</span> height(h), width(w), length(len) {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>volume</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> height, width, length;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> Box<span style=color:#f92672>::</span>volume() { <span style=color:#66d9ef>return</span> height <span style=color:#f92672>*</span> width <span style=color:#f92672>*</span> length; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Box a[<span style=color:#ae81ff>2</span>]{Box(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>15</span>),
</span></span><span style=display:flex><span>            Box(<span style=color:#ae81ff>15</span>, <span style=color:#ae81ff>18</span>, <span style=color:#ae81ff>20</span>)};  <span style=color:#75715e>// Box a[2] = {Box(10, 12, 15), Box(15, 18,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                <span style=color:#75715e>// 20)}; 加不加等号都可
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cout <span style=color:#f92672>&lt;&lt;</span> a[<span style=color:#ae81ff>0</span>].volume() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> a[<span style=color:#ae81ff>1</span>].volume() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=类模板>类模板<a hidden class=anchor aria-hidden=true href=#类模板>#</a></h3><p>类模板是对一批仅有成员数据类型不同的类的抽象</p><blockquote><p><a href=https://blog.csdn.net/WChQGouge/article/details/100085331><em>关于函数模板</em></a></p></blockquote><h4 id=类模板中的成员函数的定义>类模板中的成员函数的定义<a hidden class=anchor aria-hidden=true href=#类模板中的成员函数的定义>#</a></h4><ol><li><p>可以放在类模板的定义定义体中（此时与类中的成员函数定义方法一致）</p></li><li><p>也可以放在类模板的外部，此时成员函数的定义格式如下：</p></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#960050;background-color:#1e0010>类型参数</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>返回值类型</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>类模板名</span><span style=color:#f92672>&gt;&lt;</span><span style=color:#960050;background-color:#1e0010>类型参数</span><span style=color:#f92672>&gt;::&lt;</span><span style=color:#960050;background-color:#1e0010>函数名</span><span style=color:#f92672>&gt;</span> (<span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>参数表</span><span style=color:#f92672>&gt;</span>) {
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>函数体</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="notice warn"><p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#warn-notice"/></svg></span></p><p>在类模板外定义成员函数时，每一个函数前均加上：<br><strong>template &lt;class 类型参数></strong></p></div><h3 id=第二次上机题目>第二次上机题目<a hidden class=anchor aria-hidden=true href=#第二次上机题目>#</a></h3><ol><li>编写设计一个People（人）类。该类的数据成员有年龄（age）、身高（height）、体重（weight）和人数（num），其中人数为静态数据成员，成员函数有构造函数（People）、进食（Eating）、运动（Sporting）、睡眠（Sleeping）、显示（Show）和显示人数（ShowNum）。其中构造函数由已知参数年龄(a)、身高(h)和体重(w)构造对象，进食函数使体重加1，运动函数使身高加1，睡眠函数使年龄、身高、体重各加1，显示函数用于显示人的年龄、身高、体重，显示人数函数为静态成员函数，用于显示人的个数。假设年龄的单位为岁，身高的单位为厘米，体重的单位为市斤，要求所有数据成员为protected访问权限，所有成员函数为public访问权限，在主函数中通过对象直接访问类的所有成员函数。</li><li>定义一个描述学生（Student）基本情况的类，数据成员包括姓名(name)、学号(num)、数学成绩(mathScore)、英语成绩(englishScore)、人数(count)、数学总成绩(mathTotalScore)和英语总成绩(englishTotalScore)。其中姓名定义为长度为18的字符数组，其他数据成员类型为整型，数学总成绩、英语总成绩和人数为静态数据成员，函数成员包括构造函数、显示基本数据函数（ShowBase）和显示静态数据函数(showStatic)，其中构造函数由已知参数姓名(nm)、学号(nu)、数学成绩(math)和英语成绩(english)构造对象，显示基本数据函数用于显示学生的姓名、学号、数学成绩、英语成绩，显示静态数据函数为静态成员函数，用于显示人数、数学总成绩、英语总成绩；要求所有数据成员为private访问权限，所有成员函数为public访问权限，在主函数中定义若干个学生对象，分别显示学生基本信息，以及显示学生人数，数学总成绩与英语总成绩。</li><li>定义一个Dog，包含name、age、sex和weight等属性以及对这些属性操作的方法。要求用字符指针描述name，并且用对象指针来测试这个类。</li><li>管理个人活期账户：个人储蓄活期账户包括账号、户名、密码、余额、活期年利率等信息。要求能够对个人账户进行存钱、取钱、计算年利息、打印账户相关信息等操作。编写主函数测试账户相关功能。
5．建立一个对象数组，内放5个学生的数据（学号、成绩），（1）用指针指向数组首元素，输出第1，3，5个学生的数据；（2）设立一个函数max，用指向对象的指针作函数参数，在max函数中找出5个学生中成绩最高者，并输出其学号。</li></ol><h4 id=源码下载-1>源码下载<a hidden class=anchor aria-hidden=true href=#源码下载-1>#</a></h4><p><a href=/0x02/test1.cc>1</a><br><a href=/0x02/test2.cc>2</a><br><a href=/0x02/test3.cc>3</a><br><a href=/0x02/test4.cc>4</a><br><a href=/0x02/test5.cc>5</a></p><h2 id=运算符重载>运算符重载<a hidden class=anchor aria-hidden=true href=#运算符重载>#</a></h2><h3 id=不能重载的运算符>不能重载的运算符<a hidden class=anchor aria-hidden=true href=#不能重载的运算符>#</a></h3><table><thead><tr><th>不能重载的运算符</th><th>说明</th></tr></thead><tbody><tr><td>::</td><td>作用域运算符</td></tr><tr><td>.</td><td>成员访问运算符</td></tr><tr><td>.*</td><td>成员指针</td></tr><tr><td>?:</td><td>条件运算符</td></tr><tr><td>sizeof</td><td>长度运算符</td></tr></tbody></table><h3 id=重载为类的成员函数>重载为类的成员函数<a hidden class=anchor aria-hidden=true href=#重载为类的成员函数>#</a></h3><blockquote><p><strong>&lt;函数类型> operator &lt;运算符>(&lt;参数表>) {函数体}</strong></p></blockquote><ul><li>C++中不允许重载有三个操作数的运算符</li><li>运算符作为成员函数时<strong>最多有一个形参</strong>：参数可以是对象，对象的引用，或其它类型的参数</li><li>运算符重载的<strong>实质就是函数重载</strong></li><li>运算符重载的函数参数<strong>就是该运算符涉及的操作数</strong></li></ul><h4 id=单目运算符的重载-->单目运算符的重载++、&ndash;<a hidden class=anchor aria-hidden=true href=#单目运算符的重载-->#</a></h4><ul><li>++为<strong>前置运算符</strong>时：<strong> operator++() {&mldr;}</strong></li><li>++为<strong>后置运算符</strong>时：<strong> operator++(int) {&mldr;}</strong></li></ul><h3 id=友元函数>友元函数<a hidden class=anchor aria-hidden=true href=#友元函数>#</a></h3><p>有时候需要某些函数访问对象的私有成员，可以通过声明该函数为类的友元函数</p><div class="notice tip"><p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#tip-notice"/></svg></span>Tip</p><ul><li>友元函数是可以直接访问类的私有成员的非成员函数。</li><li>它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明，声明时只需在友元的名称前加上关键字friend，其格式如下：<br><strong>friend 类型 函数名(形式参数);</strong></li></ul></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>friend</span> <span style=color:#66d9ef>void</span> foo(A);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>foo</span>(A a) { cout <span style=color:#f92672>&lt;&lt;</span> a.i <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    A a;
</span></span><span style=display:flex><span>    foo(a);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><p>大多数情况下友元函数是某个类的成员函数，即A类中的某个成员函数是B类中的友元函数，这个成员函数可以直接访问B类中的私有数据。这实现了类与类之间的沟通。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {               <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>fun</span>(B <span style=color:#f92672>&amp;</span>);          <span style=color:#66d9ef>friend</span> <span style=color:#66d9ef>void</span> A<span style=color:#f92672>::</span>fun(B <span style=color:#f92672>&amp;</span>b);
</span></span><span style=display:flex><span>};                      };
</span></span></code></pre></div></li><li><p>友元类</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {             <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> {
</span></span><span style=display:flex><span>  ...                   ...
</span></span><span style=display:flex><span>  <span style=color:#75715e>// B类是A类的友元       // B类可以自由使用A类中的成员
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>friend</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span>;     }<span style=color:#960050;background-color:#1e0010>；</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div></li></ul><h3 id=重载为类的友元函数>重载为类的友元函数<a hidden class=anchor aria-hidden=true href=#重载为类的友元函数>#</a></h3><p><strong>friend &lt;函数值类型> operator&lt;运算符>(&lt;参数表>) {函数体}</strong></p><ul><li>运算符重载为类的友元函数****最多只能有两个参数**</li><li>如果重载双目运算符，则第一个参数代表左操作数，第二个参数代表右操作数</li></ul><h4 id=单目运算符重载>单目运算符重载<a hidden class=anchor aria-hidden=true href=#单目运算符重载>#</a></h4><ul><li>++为<strong>前置</strong>运算符时，它的运算符重载函数的一般格式为：<strong>A operator ++(A &amp;a)</strong></li><li>++为<strong>后置</strong>运算符时，它的运算符重载函数的一般格式为：<strong>A operator ++(A &amp;a, int)</strong>(使用哑元区分)</li></ul><h3 id=重载输入输出运算符>重载输入输出运算符<a hidden class=anchor aria-hidden=true href=#重载输入输出运算符>#</a></h3><ul><li><p><strong>输入</strong>运算符：<strong>friend istream & operater &#187;(istream &amp;is, ClassName &amp;f){…}</strong></p></li><li><p><strong>输出</strong>运算符：<strong>friend ostream & operater &#171;(ostream &, ClassName &){&mldr;}</strong></p></li></ul><h3 id=函数对象>函数对象<a hidden class=anchor aria-hidden=true href=#函数对象>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Test</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#66d9ef>operator</span>()(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;operator() called. &#34;</span> <span style=color:#f92672>&lt;&lt;</span> a <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>&lt;&lt;</span> b <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> a <span style=color:#f92672>+</span> b;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Test sum;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> s <span style=color:#f92672>=</span> sum(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>);  <span style=color:#75715e>// sum看上去像是一个函数，故也称“函数对象”
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;a + b = &#34;</span> <span style=color:#f92672>&lt;&lt;</span> s <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=类型转换运算符重载>类型转换运算符重载<a hidden class=anchor aria-hidden=true href=#类型转换运算符重载>#</a></h3><h4 id=基本类型到类类型的转换>基本类型到类类型的转换<a hidden class=anchor aria-hidden=true href=#基本类型到类类型的转换>#</a></h4><ul><li>如果<strong>直接将数据赋值给对象</strong>，所赋入的数据要强制类型转换，这种转换<strong>需要调用构造函数</strong>。也就是利用<strong>构造函数</strong>能完成基本类型到类类型的转换</li><li>使用构造函数进行类型转换必须有一个前提，那就是在这个类中定义一个只有一个参数的构造函数（或者其他参数有默认值）——<strong>转换构造函数</strong></li></ul><h4 id=类类型到基本类型的转换>类类型到基本类型的转换<a hidden class=anchor aria-hidden=true href=#类类型到基本类型的转换>#</a></h4><ul><li><p>C++引入一种特殊的成员函数——<strong>类型转换函数</strong>。类型转换函数实际上就是一个类型转换运算符重载函数</p></li><li><p>类型转换函数专门用来将类类型转换为基本数据类型，它只能被重载为成员函数</p></li><li><p>重载类型转换运算符函数格式：<br><strong>operator〈返回基本类型名〉（）
{
……
return 〈基本类型值〉
}</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    A(<span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>:</span> i(a) {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>show</span>(<span style=color:#66d9ef>void</span>) { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;i = &#34;</span> <span style=color:#f92672>&lt;&lt;</span> i <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>operator</span> <span style=color:#a6e22e>int</span>() { <span style=color:#66d9ef>return</span> i; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    A a1(<span style=color:#ae81ff>10</span>), a2(<span style=color:#ae81ff>20</span>);
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> a1 <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> a2 <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><h3 id=示例代码>示例代码<a hidden class=anchor aria-hidden=true href=#示例代码>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Complex</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> real, imag;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Complex(<span style=color:#66d9ef>double</span> r <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>, <span style=color:#66d9ef>double</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>) <span style=color:#f92672>:</span> real(r), imag(i) {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>getReal</span>() <span style=color:#66d9ef>const</span> { <span style=color:#66d9ef>return</span> real; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>getImag</span>() <span style=color:#66d9ef>const</span> { <span style=color:#66d9ef>return</span> imag; }
</span></span><span style=display:flex><span>    Complex <span style=color:#66d9ef>operator</span><span style=color:#f92672>++</span>();
</span></span><span style=display:flex><span>    Complex <span style=color:#66d9ef>operator</span><span style=color:#f92672>++</span>(<span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span>    Complex <span style=color:#66d9ef>operator</span><span style=color:#f92672>+</span>(Complex <span style=color:#f92672>&amp;</span>);
</span></span><span style=display:flex><span>    Complex <span style=color:#66d9ef>operator</span><span style=color:#f92672>+</span>(<span style=color:#66d9ef>double</span> d);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>friend</span> istream <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>&gt;&gt;</span>(istream <span style=color:#f92672>&amp;</span>, Complex <span style=color:#f92672>&amp;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>friend</span> ostream <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>&lt;&lt;</span>(ostream <span style=color:#f92672>&amp;</span>, <span style=color:#66d9ef>const</span> Complex <span style=color:#f92672>&amp;</span>);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Complex Complex<span style=color:#f92672>::</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>++</span>() { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Complex</span>(<span style=color:#f92672>++</span>real, imag); }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Complex Complex<span style=color:#f92672>::</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>++</span>(<span style=color:#66d9ef>int</span> a) { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Complex</span>(real<span style=color:#f92672>++</span>, imag); }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Complex Complex<span style=color:#f92672>::</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>+</span>(Complex <span style=color:#f92672>&amp;</span>c) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Complex</span>(real <span style=color:#f92672>+</span> c.real, imag <span style=color:#f92672>+</span> c.imag);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Complex Complex<span style=color:#f92672>::</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>+</span>(<span style=color:#66d9ef>double</span> d) { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Complex</span>(real <span style=color:#f92672>+</span> d, imag); }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>istream <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>&gt;&gt;</span>(istream <span style=color:#f92672>&amp;</span>in, Complex <span style=color:#f92672>&amp;</span>c) {
</span></span><span style=display:flex><span>    in <span style=color:#f92672>&gt;&gt;</span> c.real <span style=color:#f92672>&gt;&gt;</span> c.imag;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> in;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ostream <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>&lt;&lt;</span>(ostream <span style=color:#f92672>&amp;</span>out, <span style=color:#66d9ef>const</span> Complex <span style=color:#f92672>&amp;</span>c) {
</span></span><span style=display:flex><span>    out <span style=color:#f92672>&lt;&lt;</span> to_string(c.real) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;+&#34;</span> <span style=color:#f92672>+</span> to_string(c.imag) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;i&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> out;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Complex a(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> a <span style=color:#f92672>+</span> a <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> a<span style=color:#f92672>++</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>++</span>a <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>    a <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;  <span style=color:#75715e>// 相当于a = Complex(10); 产生临时对象，调用构造函数和析构函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cout <span style=color:#f92672>&lt;&lt;</span> a <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=继承与派生>继承与派生<a hidden class=anchor aria-hidden=true href=#继承与派生>#</a></h2><h3 id=派生类定义>派生类定义<a hidden class=anchor aria-hidden=true href=#派生类定义>#</a></h3><h4 id=三种继承方式派生类中基类成员的访问控制权限>三种继承方式派生类中基类成员的访问控制权限<a hidden class=anchor aria-hidden=true href=#三种继承方式派生类中基类成员的访问控制权限>#</a></h4><table><thead><tr><th></th><th>公有继承</th><th>私有继承</th><th>保护继承</th></tr></thead><tbody><tr><td>公有成员</td><td>公有</td><td>私有</td><td>保护</td></tr><tr><td>私有成员</td><td>派生类不可访问</td><td>派生类不可访问</td><td>派生类不可访问</td></tr><tr><td>保护成员</td><td>保护</td><td>私有</td><td>保护</td></tr></tbody></table><h3 id=派生类的构造函数和析构函数>派生类的构造函数和析构函数<a hidden class=anchor aria-hidden=true href=#派生类的构造函数和析构函数>#</a></h3><h4 id=派生类构造函数>派生类构造函数<a hidden class=anchor aria-hidden=true href=#派生类构造函数>#</a></h4><ul><li><p>不能在派生类构造函数体中显式调用基类构造函数</p></li><li><p>在成员初始化表中可以显式调用基类构造函数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Rectangle(<span style=color:#66d9ef>float</span> x,<span style=color:#66d9ef>float</span> y,<span style=color:#66d9ef>float</span> w,<span style=color:#66d9ef>float</span> h) <span style=color:#f92672>:</span> Point(x,y)
</span></span><span style=display:flex><span>{ W<span style=color:#f92672>=</span>w; H<span style=color:#f92672>=</span>h; }
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>或</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>Rectangle(<span style=color:#66d9ef>float</span> x,<span style=color:#66d9ef>float</span> y,<span style=color:#66d9ef>float</span> w,<span style=color:#66d9ef>float</span> h) <span style=color:#f92672>:</span> Point(x,y),W(w),H(h) {}
</span></span></code></pre></div></li></ul><h4 id=构造函数和析构函数的调用顺序>构造函数和析构函数的调用顺序<a hidden class=anchor aria-hidden=true href=#构造函数和析构函数的调用顺序>#</a></h4><ul><li><p>构造函数调用顺序：基类的构造函数->对象成员构造函数->派生类构造函数</p></li><li><p>析构函数调用顺序刚好相反</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>O</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    O() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;O()&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>; }
</span></span><span style=display:flex><span>    <span style=color:#f92672>~</span>O() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;~O()&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    A() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;A()&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>; }
</span></span><span style=display:flex><span>    <span style=color:#f92672>~</span>A() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;~A()&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> A {
</span></span><span style=display:flex><span>    O o;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    B() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;B()&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>; }
</span></span><span style=display:flex><span>    <span style=color:#f92672>~</span>B() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;~B()&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    B b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>A()
O()
B()
~B()
~O()
~A()
</code></pre></li><li><p>⚠️注意</p><ul><li>当基类中没有显式定义构造函数，或定义了无参数构造函数时，派生类构造函数的初始化表可以省略对基类构造函数的调用，而采用<strong>隐含调用</strong></li><li>当基类的构造函数使用<strong>一个或多个参数时候</strong>，<strong>派生类必须定义构造函数</strong>，提供将<strong>参数传递</strong>给基类的构造函数的途径。这时，派生类构造函数体可能为空，仅起到参数传递作用</li><li>无论是哪种继承方式，基类的私有成员在派生类中都是不可被访问的。只能通过基类的成员函数访问基类的私有数据成员。</li><li>如果在一个派生类中要访问基类中的私有成员，可以将这个派生类声明为基类的友元。<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Base</span> {              <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Derive</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Base {              
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>friend</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Derive</span>;        <span style=color:#75715e>// 直接使用Base中的私有成员
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}                         }
</span></span></code></pre></div></li><li>友元关系是不能继承的：B类是A类的友元，C类是B类的派生类，则C类和A类之间没有任何友元关系，除非C类声明A类是友元。</li></ul></li></ul><h3 id=多继承与虚基类>多继承与虚基类<a hidden class=anchor aria-hidden=true href=#多继承与虚基类>#</a></h3><h4 id=多继承派生类的定义>多继承派生类的定义<a hidden class=anchor aria-hidden=true href=#多继承派生类的定义>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#960050;background-color:#1e0010>&lt;派生类名</span><span style=color:#f92672>&gt;</span><span style=color:#960050;background-color:#1e0010>：</span><span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>继承方式</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>基类名</span><span style=color:#ae81ff>1</span><span style=color:#f92672>&gt;</span><span style=color:#960050;background-color:#1e0010>，…，</span><span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>继承方式</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>基类名</span>n<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>派生类新定义成员</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>}<span style=color:#960050;background-color:#1e0010>；</span>
</span></span></code></pre></div><h4 id=多继承派生类的构造函数>多继承派生类的构造函数<a hidden class=anchor aria-hidden=true href=#多继承派生类的构造函数>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>派生类名</span><span style=color:#f92672>&gt;</span>(<span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>总参数表</span><span style=color:#f92672>&gt;</span>)<span style=color:#f92672>:&lt;</span><span style=color:#960050;background-color:#1e0010>基类名</span><span style=color:#ae81ff>1</span><span style=color:#f92672>&gt;</span>(<span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>参数表</span><span style=color:#ae81ff>1</span><span style=color:#f92672>&gt;</span>)<span style=color:#960050;background-color:#1e0010>，…，</span><span style=color:#f92672>&lt;</span> <span style=color:#960050;background-color:#1e0010>基类名</span>n<span style=color:#f92672>&gt;</span> (<span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>参数表</span>n<span style=color:#f92672>&gt;</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>派生类数据成员的初始化</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><ul><li><p>构造函数的调用顺序是：先调用所有基类的构造函数，再调用对象成员构造函数，最后调用派生类的构造函数</p></li><li><p>处于同一层次的各基类构造函数的调用顺序取决于<strong>定义派生类时所指定的基类顺序</strong>，与派生类构造函数中所定义的成员初始化列表无关</p></li><li><p>如果有多个成员类对象，则构造函数额调用顺序是<strong>对象在类中被声明的顺序</strong>，而不是它们出现在成员初始化列表的顺序</p></li><li><p>析构函数的调用顺序与构造函数的调用顺序相反</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>M1</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    M1(<span style=color:#66d9ef>int</span> _i) <span style=color:#f92672>:</span> i(_i) { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;M1(&#34;</span> <span style=color:#f92672>&lt;&lt;</span> i <span style=color:#f92672>&lt;&lt;</span>  <span style=color:#e6db74>&#34;)&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>M2</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    M2(<span style=color:#66d9ef>int</span> _i) <span style=color:#f92672>:</span> i(_i) { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;M2(&#34;</span> <span style=color:#f92672>&lt;&lt;</span> i <span style=color:#f92672>&lt;&lt;</span>  <span style=color:#e6db74>&#34;)&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Base1</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Base1() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Base1()&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Base2</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Base2() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Base2()&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Derive</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Base1, <span style=color:#66d9ef>public</span> Base2 {
</span></span><span style=display:flex><span>    M2 m2;
</span></span><span style=display:flex><span>    M1 m1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Derive(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) <span style=color:#f92672>:</span> m1(a), m2(b), Base2()  , Base1() {}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Derive d(<span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>Base1()
Base2()
M2(9)
M1(8)
</code></pre></li></ul><h3 id=多继承引起的二义性问题>多继承引起的二义性问题<a hidden class=anchor aria-hidden=true href=#多继承引起的二义性问题>#</a></h3><h4 id=两个基类有同名成员>两个基类有同名成员<a hidden class=anchor aria-hidden=true href=#两个基类有同名成员>#</a></h4><ul><li>implementation<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>void</span> display() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;display() in A&#34;</span>   <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>; }
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>void</span> display() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;display() in B&#34;</span>   <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>; }
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>C</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> A, <span style=color:#66d9ef>public</span> B {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>      C c;
</span></span><span style=display:flex><span>      c.display();
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div></li><li>编译错误<div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/11/10/BL72ZT.jpg alt></div></li></ul><h4 id=两个基类和派生类三者都有同名成员>两个基类和派生类三者都有同名成员<a hidden class=anchor aria-hidden=true href=#两个基类和派生类三者都有同名成员>#</a></h4><ul><li>基类的同名成员在派生类中被屏蔽，或者说，派生类新增加的同名成员隐藏了基类中的同名成员</li><li>implementation<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> display() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;display() in A&#34;</span>   <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> display() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;display() in B&#34;</span>   <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>C</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> A, <span style=color:#66d9ef>public</span> B {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> display() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;display() in C&#34;</span>   <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    C c;
</span></span><span style=display:flex><span>    c.display();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li>访问的是派生类C中的成员<pre tabindex=0><code>display() in C
</code></pre></li></ul><h3 id=虚基类>虚基类<a hidden class=anchor aria-hidden=true href=#虚基类>#</a></h3><h4 id=虚基类概念>虚基类概念<a hidden class=anchor aria-hidden=true href=#虚基类概念>#</a></h4><ul><li>为了避免对基类成员访问的二义性问题，可以将<strong>直接基类（如A、B）的共同基类如N设置为虚基类</strong>，这样共同基类N在内存中只有一个副本存在</li><li>引进虚基类后，派生类对象中只存在一个虚基类成员的副本</li><li>为了保证虚基类在派生类中只继承一次，应当在该基类的所有直接派生类中声明为虚基类，否则仍然会出现对基类的多次继承。</li></ul><p><div class=render-image><img loading=lazy src=https://s1.ax1x.com/2020/11/10/BLOP3Q.jpg alt></div></p><h4 id=构造函数的调用顺序>构造函数的调用顺序<a hidden class=anchor aria-hidden=true href=#构造函数的调用顺序>#</a></h4><ul><li>先调用<strong>虚基类</strong>的构造函数，<strong>再调用非虚基类</strong>的构造函数</li><li>若同一层次包含多个虚基类，其调用顺序为<strong>定义时的顺序</strong></li><li>若虚基类构造函数由非虚基类派生而来，则仍先按先调用基类构造函数，再调用派生类构造函数的顺序<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Base1</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Base1() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;class Base1&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Base2</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Base2() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;class Base2&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Level1</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Base2, <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>public</span>   Base1 {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Level1() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;class Level1&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Level2</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Base2, <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>public</span>   Base1 {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Level2() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;class Level2&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TopLevel</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Level1, <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>public</span>  Level2 {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    TopLevel() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;class TopLevel&#34;</span> <span style=color:#f92672>&lt;&lt;</span>  endl; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    TopLevel obj;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div>输出<pre tabindex=0><code>class Base1
class Base2
class Level2
class Base2
class Level1
class TopLevel
</code></pre></li></ul><h4 id=虚基类的初始化>虚基类的初始化<a hidden class=anchor aria-hidden=true href=#虚基类的初始化>#</a></h4><p>如果在虚基类中只定义了带参数的构造函数，则要在其所有派生类（包括直接派生类或间接派生类）中，通过构造函数的初始化表对虚基类进行初始化。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span>
</span></span><span style=display:flex><span>{ A(<span style=color:#66d9ef>int</span> i){} <span style=color:#960050;background-color:#1e0010>…</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span><span style=color:#f92672>:</span><span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>public</span> A
</span></span><span style=display:flex><span>{ B(<span style=color:#66d9ef>int</span> n)<span style=color:#f92672>:</span>A(n){}<span style=color:#960050;background-color:#1e0010>…</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>C</span><span style=color:#f92672>:</span><span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>public</span> A
</span></span><span style=display:flex><span>{ C(<span style=color:#66d9ef>int</span> n)<span style=color:#f92672>:</span>A(n){}<span style=color:#960050;background-color:#1e0010>…</span> }; 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>D</span><span style=color:#f92672>:</span><span style=color:#66d9ef>public</span> B, <span style=color:#66d9ef>public</span> C
</span></span><span style=display:flex><span>{ D(<span style=color:#66d9ef>int</span> n)<span style=color:#f92672>:</span>A(n),B(n),C(n){}<span style=color:#960050;background-color:#1e0010>…</span> };
</span></span></code></pre></div><ul><li>⚠️注意<ul><li>如果多继承不牵扯到对同一基类的派生，就没有必要定义虚基类</li><li>使用多继承要十分小心，经常会出现二义性问题</li><li>能用单一继承的问题就不要用多继承</li></ul></li></ul><h2 id=多态性与虚函数>多态性与虚函数<a hidden class=anchor aria-hidden=true href=#多态性与虚函数>#</a></h2><h3 id=类型兼容规则>类型兼容规则<a hidden class=anchor aria-hidden=true href=#类型兼容规则>#</a></h3><ul><li>派生类的对象可以赋值给基类对象</li><li>派生类的对象可以初始化基类的引用</li><li>派生类的对象的地址可以赋给基类的指针变量</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Base</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> who() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Base class&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Derive1</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Base {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> who() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Derive1 class&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Derive2</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Base {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> who() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Derive2 class&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Base obj1, <span style=color:#f92672>*</span>p;
</span></span><span style=display:flex><span>    <span style=color:#75715e>//定义基类对象obj1和基类对象指针p
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Derive1 obj2;
</span></span><span style=display:flex><span>    Derive2 obj3;
</span></span><span style=display:flex><span>    p <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>obj1;  <span style=color:#75715e>// p指向obj1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    p<span style=color:#f92672>-&gt;</span>who();
</span></span><span style=display:flex><span>    <span style=color:#75715e>//通过指针p调用obj1的公有成员函数//who()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    p <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>obj2;  <span style=color:#75715e>// p指向obj2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    p<span style=color:#f92672>-&gt;</span>who();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// p只能访问从基类继承下来的who()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    p <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>obj3;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// p指向obj2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    p<span style=color:#f92672>-&gt;</span>who();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// p只能访问从基类继承下来的who()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    obj2.who();
</span></span><span style=display:flex><span>    obj3.who();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出</p><pre tabindex=0><code>Base class
Base class
Base class
Derive1 class
Derive2 class
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> num;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Student(<span style=color:#66d9ef>int</span> n) <span style=color:#f92672>:</span> num(n) {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>display</span>() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;num = &#34;</span> <span style=color:#f92672>&lt;&lt;</span> num <span style=color:#f92672>&lt;&lt;</span> endl; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Graduate</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Student {
</span></span><span style=display:flex><span>    string name;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Graduate(<span style=color:#66d9ef>int</span> n, string _name) <span style=color:#f92672>:</span> Student(n), name(_name) {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>display</span>() {
</span></span><span style=display:flex><span>        Student<span style=color:#f92672>::</span>display();
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;name = &#34;</span> <span style=color:#f92672>&lt;&lt;</span> name <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Student stu(<span style=color:#ae81ff>1001</span>);
</span></span><span style=display:flex><span>    Graduate grad(<span style=color:#ae81ff>2001</span>, <span style=color:#e6db74>&#34;Jack&#34;</span>);
</span></span><span style=display:flex><span>    Student <span style=color:#f92672>*</span>pt <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>stu;
</span></span><span style=display:flex><span>    pt<span style=color:#f92672>-&gt;</span>display();
</span></span><span style=display:flex><span>    pt <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>grad;
</span></span><span style=display:flex><span>    pt<span style=color:#f92672>-&gt;</span>display();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出</p><pre tabindex=0><code>num = 1001
num = 2001
</code></pre><h3 id=多态polymorphism>多态（Polymorphism）<a hidden class=anchor aria-hidden=true href=#多态polymorphism>#</a></h3><p>相似功能的不同函数使用一个名称来实现，从而可以使用相同的调用方式来调用这些具有不同功能的同名函数</p><h4 id=多态的分类>多态的分类<a hidden class=anchor aria-hidden=true href=#多态的分类>#</a></h4><ul><li>静态多态性（编译时的多态性）：通过函数重载实现</li><li>动态多态性（运行时的多态性）：通过虚函数实现</li></ul><h4 id=虚函数>虚函数<a hidden class=anchor aria-hidden=true href=#虚函数>#</a></h4><p>虚函数就是在基类中被关键字virtual说明、并在一个或多个派生类中被重新定义的成员函数</p><p><strong>virtual &lt;函数值类型> &lt;函数名>(&lt;参数表>);</strong></p><ul><li><p>程序运行时，不同类的对象调用各自的虚函数，这就是动态多态</p></li><li><p>实现动态的多态性时，必须使用<strong>基类类型的指针变量或对象引用</strong>，并使其<strong>指向不同的派生对象</strong>，并通过调用指针或引用所指向的虚函数才能实现动态的多态性</p></li><li><p>声明虚函数要注意</p><ul><li>静态成员函数和友元函数不能声明为虚函数</li><li>内联成员函数不能声明为虚函数</li><li>构造函数不能是虚函数</li><li>析构函数可以是虚函数<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Base</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Base() <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#f92672>~</span>Base() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Base destructor&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Derived</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Base {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Derived() <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>~</span>Derived() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Derived destructor&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Base <span style=color:#f92672>*</span>b <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Derived;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>delete</span> b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li></ul><h4 id=联编>联编<a hidden class=anchor aria-hidden=true href=#联编>#</a></h4><ul><li>联编的分类<ul><li><p>静态联编：在<strong>编译阶段</strong>完成的联编</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> print() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;A student&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GStudent</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Student {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> print() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;A graduate student&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Student s1, <span style=color:#f92672>*</span>ps;
</span></span><span style=display:flex><span>    GStudent s2;
</span></span><span style=display:flex><span>    s1.print();
</span></span><span style=display:flex><span>    s2.print();
</span></span><span style=display:flex><span>    s2.Student<span style=color:#f92672>::</span>print();
</span></span><span style=display:flex><span>    ps <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>s1;
</span></span><span style=display:flex><span>    ps<span style=color:#f92672>-&gt;</span>print();  <span style=color:#75715e>//基类指针和基类成员函数发生关联
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ps <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>s2;
</span></span><span style=display:flex><span>    ps<span style=color:#f92672>-&gt;</span>print();
</span></span><span style=display:flex><span>    <span style=color:#75715e>//希望调用对象s2的输出函数，但调用的却是对象s1的输出函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出</p><pre tabindex=0><code>A student
A graduate student
A student
A student
A student
</code></pre></li><li><p>动态联编：<strong>根据具体的执行情况来动态的确定</strong>，在<strong>运行阶段</strong>完成</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>   <span style=color:#75715e>// virtual可省略
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> print() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;a Student&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GStudent</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Student {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> print() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;A graduate student&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Student s1, <span style=color:#f92672>*</span>ps;
</span></span><span style=display:flex><span>    GStudent s2;
</span></span><span style=display:flex><span>    s1.print();
</span></span><span style=display:flex><span>    s2.print();
</span></span><span style=display:flex><span>    s2.Student<span style=color:#f92672>::</span>print();
</span></span><span style=display:flex><span>    ps <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>s1;
</span></span><span style=display:flex><span>    ps<span style=color:#f92672>-&gt;</span>print();
</span></span><span style=display:flex><span>    ps <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>s2;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 对象指针调用虚函数，采用动态联编方式
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ps<span style=color:#f92672>-&gt;</span>print();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出</p><pre tabindex=0><code>a Student
A graduate student
a Student
a Student
A graduate student
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> print() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;A studnet&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GStudent</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Student {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> print() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;A graduate studnet&#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>fun</span>(Student <span style=color:#f92672>&amp;</span>s) { s.print(); }
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Student s1;
</span></span><span style=display:flex><span>    GStudent s2;
</span></span><span style=display:flex><span>    fun(s1);
</span></span><span style=display:flex><span>    fun(s2);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出</p><pre tabindex=0><code>A studnet
A graduate studnet
</code></pre><ul><li>⚠️注意<ul><li><strong>virtual</strong>关键字只能用在虚函数声明中，不能用在虚函数的实现中</li><li>只有通过<strong>对象指针或对象引用</strong>来调用虚函数，才能实现动态联编。如果采用对象来调用虚函数，则采用的是静态联编方式</li><li>在派生类中重新定义虚函数时，返回值类型、函数名、参数个数、类型和顺序，都必须与<strong>基类的原型相同</strong></li><li>当在派生类中定义了虚函数的重载函数，但并没有重新定义虚函数时，与虚函数同名的重载函数<strong>覆盖</strong>了派生类中的虚函数。此时若试图通过派生类对象、指针调用派生类对象的虚函数就会产生错误<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> PI <span style=color:#f92672>=</span> <span style=color:#ae81ff>3.1415</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Point</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> X, Y;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Point(<span style=color:#66d9ef>int</span> X <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>int</span> Y <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>X <span style=color:#f92672>=</span> X;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>Y <span style=color:#f92672>=</span> Y;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>area</span>() { <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0.0</span>; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Circle</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Point {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> radius;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Circle(<span style=color:#66d9ef>int</span> X, <span style=color:#66d9ef>int</span> Y, <span style=color:#66d9ef>double</span> R) <span style=color:#f92672>:</span> Point(X, Y) { radius <span style=color:#f92672>=</span> R; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>area</span>(<span style=color:#66d9ef>int</span> i) { <span style=color:#66d9ef>return</span> PI <span style=color:#f92672>*</span> radius <span style=color:#f92672>*</span> radius; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Point P1(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;P1.area = &#34;</span> <span style=color:#f92672>&lt;&lt;</span> P1.area() <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    Circle C1(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>20</span>);
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;C1.area = &#34;</span> <span style=color:#f92672>&lt;&lt;</span> C1.area() <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    Point <span style=color:#f92672>*</span>Pp;
</span></span><span style=display:flex><span>    Pp <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>C1;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Pp.area = &#34;</span> <span style=color:#f92672>&lt;&lt;</span> Pp<span style=color:#f92672>-&gt;</span>area() <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    Point <span style=color:#f92672>&amp;</span>Rp <span style=color:#f92672>=</span> C1;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Rp.area = &#34;</span> <span style=color:#f92672>&lt;&lt;</span> Rp.area() <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=render-image><img loading=lazy src=https://s3.ax1x.com/2020/11/18/DeW6O0.png alt></div></li><li>如果在派生类中没有重新定义虚函数，则不实现动态联编，派生类的对象将使用基类虚函数的代码</li><li>一个类中的虚函数说明只对派生类中重定义的函数有影响，对它的基类中的函数并没有影响<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Base</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> func(<span style=color:#66d9ef>int</span> x) {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;This is Base class&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> x;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SubClass</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Base {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>int</span> func(<span style=color:#66d9ef>int</span> x) {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;This is SubClass&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> x;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SubSubClass</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> SubClass {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> func(<span style=color:#66d9ef>int</span> x) {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;This is SubSubClass&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> x;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    SubSubClass ss;
</span></span><span style=display:flex><span>    Base <span style=color:#f92672>&amp;</span>b <span style=color:#f92672>=</span> ss;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> b.func(<span style=color:#ae81ff>5</span>) <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	SubClass <span style=color:#f92672>&amp;</span>s <span style=color:#f92672>=</span> ss;
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> s.func(<span style=color:#ae81ff>5</span>) <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div>输出<pre tabindex=0><code>This is Base class  5
This is Sub2 class  5
</code></pre></li></ul></li></ul></li></ul></li></ul><h4 id=纯虚函数>纯虚函数<a hidden class=anchor aria-hidden=true href=#纯虚函数>#</a></h4><p>纯虚函数用virtual声明，<strong>没有任何实现</strong>，必须由派生类重新定义该函数提供实现</p><ul><li><p>纯虚函数与函数体为空的虚函数</p><ul><li>区别<ul><li>前者没有函数体，后者有函数体</li><li>前者所在的类是抽象类，不能直接实例化；后者所在的类是可以实例化的（该类中不含有其他纯虚函数）</li></ul></li><li>共同点<ul><li>可以派生出新的类，然后在新类中给出虚函数的实现，而且这种实现可以具有动态特征</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>protected</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    A() { x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1000</span>; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print</span>() <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;  <span style=color:#75715e>// 定义纯虚函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> A {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> y;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    B() { y <span style=color:#f92672>=</span> <span style=color:#ae81ff>2000</span>; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print</span>() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;y = &#34;</span> <span style=color:#f92672>&lt;&lt;</span> y <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>; }  <span style=color:#75715e>// 重新定义纯虚函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>C</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> A {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> z;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    C() { z <span style=color:#f92672>=</span> <span style=color:#ae81ff>3000</span>; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print</span>() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;z = &#34;</span> <span style=color:#f92672>&lt;&lt;</span> z <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>; }  <span style=color:#75715e>// 重新定义纯虚函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    A <span style=color:#f92672>*</span>pa;
</span></span><span style=display:flex><span>    B b;
</span></span><span style=display:flex><span>    C c;
</span></span><span style=display:flex><span>    pa <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>b;
</span></span><span style=display:flex><span>    pa<span style=color:#f92672>-&gt;</span>print();
</span></span><span style=display:flex><span>    pa <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>c;
</span></span><span style=display:flex><span>    pa<span style=color:#f92672>-&gt;</span>print();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// A a;          不能定义抽象类的对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// pa = &amp;a;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// pa-&gt;pritn();
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出</p><pre tabindex=0><code>y = 2000
z = 3000
</code></pre></li></ul><h4 id=抽象类>抽象类<a hidden class=anchor aria-hidden=true href=#抽象类>#</a></h4><ul><li><p>包含一个或多个纯虚函数的类称为抽象类</p></li><li><p>如果派生类没有实现基类中的<strong>所有</strong>纯虚函数，派生类也是抽象类</p></li><li><p>抽象类无法实例化</p></li><li><p>抽象类不能用作<strong>参数类型、函数值类型或显式转换的类型</strong>，但可以声明指向抽象类的的指针或引用，通过指针或引用来指向并访问派生类对象，从而实现动态多态</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>double</span> PI <span style=color:#f92672>=</span> <span style=color:#ae81ff>3.14159</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Shapes</span>  <span style=color:#75715e>//抽象类
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>{
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> setvalue(<span style=color:#66d9ef>int</span> d, <span style=color:#66d9ef>int</span> w <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        x <span style=color:#f92672>=</span> d;
</span></span><span style=display:flex><span>        y <span style=color:#f92672>=</span> w;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>area</span>() <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;  <span style=color:#75715e>//纯虚函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#66d9ef>protected</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x, y;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Square</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Shapes {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> area()  <span style=color:#75715e>//计算矩形面积
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;area of rectangle:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> x <span style=color:#f92672>*</span> y <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Circle</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Shapes {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> area()  <span style=color:#75715e>//计算圆面积
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;area of circle:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> PI <span style=color:#f92672>*</span> x <span style=color:#f92672>*</span> x <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Shapes <span style=color:#f92672>*</span>ptr[<span style=color:#ae81ff>2</span>];  <span style=color:#75715e>//声明抽象类指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Square s1;       <span style=color:#75715e>//声明派生类对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Circle c1;       <span style=color:#75715e>//声明派生类对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ptr[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>s1;
</span></span><span style=display:flex><span>    <span style=color:#75715e>//抽象类指针指向派生类对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ptr[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>-&gt;</span>setvalue(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>    ptr[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>-&gt;</span>area();
</span></span><span style=display:flex><span>    <span style=color:#75715e>//抽象类指针调用派生类成员函数,实现多态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ptr[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>c1;
</span></span><span style=display:flex><span>    <span style=color:#75715e>//抽象类指针指向派生类对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ptr[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>-&gt;</span>setvalue(<span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>    ptr[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>-&gt;</span>area();
</span></span><span style=display:flex><span>    <span style=color:#75715e>//抽象类指针调用派生类成员函数,实现多态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出</p><pre tabindex=0><code>area of rectangle:50
area of circle:314.159
</code></pre></li></ul><h3 id=第三次上机题目>第三次上机题目<a hidden class=anchor aria-hidden=true href=#第三次上机题目>#</a></h3><ol><li>定义一个复数类Complex，重载运算符“+”，“-”，“*”，“/”,使之能用于复数的加、减、乘、除。运算符重载函数作为Complex类的成员函数。编程序，分别求两个复数之和、差、积和商。</li><li>对于2行3列矩阵，重载流插入运算符“&#171;”和流提取运算符“&#187;”，使之能用于矩阵的输入和输出。</li><li>定义Time类和Date类，Time类为Date类的友元类，通过Time类中的display函数引用Date类对象的私有数据，输出年、月、日和时、分、秒。</li><li>分别定义Teacher（教师）类和Cadre（干部）类，采用多继承方式由这两个类派生出新类Teacher_Cadre（教师兼干部）。要求：<ul><li>在两个基类中都包含姓名、年龄、性别、地址、电话等数据成员。</li><li>在Teacher类中还包含数据成员titile（职称），在Cadre类中还包含数据成员post（职务），在Teacher_Cadre类中还包含数据成员wages（工资）。</li><li>对两个基类中的姓名、年龄、性别、地址、电话等数据成员用相同的名字，在引用这些数据成员时，指定作用域。</li><li>在类体中声明成员函数，在类外定义成员函数。</li><li>在派生类Teacher_Cadre的成员函数show中调用Teacher类中的display函数，输出姓名、年龄、性别、职称、地址、电话，然后再用cout语句输出职务与工资。</li></ul></li><li>写一个程序，定义抽象基类Shape，由它派生出5个派生类：Circle（圆形）、Square（正方形）、Rectangle（矩形）、Trapezoid（梯形）、Triangle（三角形）。用虚函数分别计算几种图形面积，并求它们的和。要求用基类指针数组，使它的每一个元素指向一个派生类对象。</li></ol><h4 id=源码下载-2>源码下载<a hidden class=anchor aria-hidden=true href=#源码下载-2>#</a></h4><p><a href=/0x03/test1.cc>1</a><br><a href=/0x03/test2.cc>2</a><br><a href=/0x03/test3.cc>3</a><br><a href=/0x03/test4.cc>4</a><br><a href=/0x03/test5.cc>5</a></p><h2 id=输入输出流>输入输出流<a hidden class=anchor aria-hidden=true href=#输入输出流>#</a></h2><h3 id=流>流<a hidden class=anchor aria-hidden=true href=#流>#</a></h3><p>数据从一个位置流向另一个位置。流是字节的序列。</p><h3 id=io流类库的层次结构>I/O流类库的层次结构<a hidden class=anchor aria-hidden=true href=#io流类库的层次结构>#</a></h3><ul><li>C++编译系统提供的I/O流类库含有两个平行基类：<ul><li>streambuf</li><li>ios</li></ul></li><li>ios类有4个直接派生类：<ul><li>输入流类istream</li><li>输出流类ostream</li><li>文件流类基类fstreambase</li><li>字符串流类基类strstreambase<div class=render-image><img loading=lazy src=https://i.postimg.cc/YSF0JJhX/1.jpg alt></div></li></ul></li></ul><h3 id=io流类库的头文件>I/O流类库的头文件<a hidden class=anchor aria-hidden=true href=#io流类库的头文件>#</a></h3><ul><li><strong>iostream</strong>：I/O流类库的最主要的头文件，包含了对输入输出流进行操作的所需的基本信息，还包括cin、cout、cerr、clog共4个流对象</li><li><strong>fstream</strong>：用于用户管理的文件的I/O操作</li><li><strong>strstream</strong>：用于字符串流I/O</li><li><strong>stdiostream</strong>：用于混合使用C和C++的I/O操作</li><li><strong>iomanip</strong>：用于格式化I/O时应包含此头文件</li></ul><h3 id=输入输出的格式控制>输入输出的格式控制<a hidden class=anchor aria-hidden=true href=#输入输出的格式控制>#</a></h3><ul><li>两种格式化方式<ul><li>用流对象的有关成员函数进行格式化</li><li>用专门的控制符进行格式化输入输出</li></ul></li></ul><h4 id=用流对象的成员函数格式化>用流对象的成员函数格式化<a hidden class=anchor aria-hidden=true href=#用流对象的成员函数格式化>#</a></h4><ul><li>设置状态标志<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>long</span> ios<span style=color:#f92672>::</span>setf(<span style=color:#66d9ef>long</span> flags)
</span></span></code></pre></div></li><li>清楚状态标志<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>long</span> ios<span style=color:#f92672>::</span>unsetf(<span style=color:#66d9ef>long</span> flags)
</span></span></code></pre></div></li><li>取状态标志<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>long</span> ios<span style=color:#f92672>::</span>flags()
</span></span></code></pre></div></li><li>取状态标志并设置状态标志<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>long</span> ios<span style=color:#f92672>::</span>flags(<span style=color:#66d9ef>long</span> flag)
</span></span></code></pre></div></li></ul><p>⚠️以上三组函数必须用流式对象（cin或cout）来调用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>showflags</span>(<span style=color:#66d9ef>long</span> f) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>long</span> i;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x8000</span>; i; i <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> ((i <span style=color:#f92672>&amp;</span> f) <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;1&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;0&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>long</span> f;
</span></span><span style=display:flex><span>    f <span style=color:#f92672>=</span> cout.flags();
</span></span><span style=display:flex><span>    showflags(f);
</span></span><span style=display:flex><span>    cout.setf(ios<span style=color:#f92672>::</span>showpos <span style=color:#f92672>|</span> ios<span style=color:#f92672>::</span>scientific <span style=color:#f92672>|</span> ios<span style=color:#f92672>::</span>fixed);  <span style=color:#75715e>// 追加状态标志
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    f <span style=color:#f92672>=</span> cout.flags();
</span></span><span style=display:flex><span>    showflags(f);
</span></span><span style=display:flex><span>    cout.unsetf(ios<span style=color:#f92672>::</span>scientific);  <span style=color:#75715e>// 从状态标志中去掉scientific
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    f <span style=color:#f92672>=</span> cout.flags();
</span></span><span style=display:flex><span>    showflags(f);
</span></span><span style=display:flex><span>    f <span style=color:#f92672>=</span> cout.flags(ios<span style=color:#f92672>::</span>hex);  <span style=color:#75715e>// 重新设置状态标志
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    showflags(f);              <span style=color:#75715e>// 重新设置状态标志之前
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    f <span style=color:#f92672>=</span> cout.flags();
</span></span><span style=display:flex><span>    showflags(f);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>用流对象的成员函数设置输出宽度</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> ios<span style=color:#f92672>::</span>width(<span style=color:#66d9ef>int</span> len)
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> ios<span style=color:#f92672>::</span>width()
</span></span></code></pre></div><ul><li>第一种设置输出宽度并返回原来的输出宽度；第二种返回当前输出宽度，默认输出宽度为0</li><li>只对其后的第一个输出项有效</li><li>设置填充字符</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>char</span> ios<span style=color:#f92672>::</span>fill(<span style=color:#66d9ef>char</span> ch)
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> ios<span style=color:#f92672>::</span>fill()
</span></span></code></pre></div><ul><li>设置输出精度</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> ios<span style=color:#f92672>::</span>precision(<span style=color:#66d9ef>int</span> p)
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> ios<span style=color:#f92672>::</span>precision()
</span></span></code></pre></div><ul><li>默认输出精度为6</li><li>用流成员函数put输出字符</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>cout.out(<span style=color:#e6db74>&#39;a&#39;</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> cout.width();
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;width: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> i <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    cout.width(<span style=color:#ae81ff>8</span>);
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> cout.width() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;new width&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> c <span style=color:#f92672>=</span> cout.fill();
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;filling word is: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> c <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;(ASCII code&#34;</span> <span style=color:#f92672>&lt;&lt;</span> (<span style=color:#66d9ef>int</span>)c <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;)&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    cout.fill(<span style=color:#e6db74>&#39;*&#39;</span>);
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> cout.fill() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;(&#34;</span> <span style=color:#f92672>&lt;&lt;</span> (<span style=color:#66d9ef>int</span>)cout.fill() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;)(new filling word)&#34;</span>
</span></span><span style=display:flex><span>         <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> cout.precision();
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;precision: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> j <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    cout.precision(<span style=color:#ae81ff>8</span>);
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>123.456789</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;(example)&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> cout.precision() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;(new precision)&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>width:0
       8(new width)
filling word is: (ASCII code32)
*(42)(new filling word)
precision:6
123.45679(example)
8(new precision)
</code></pre><ul><li>用于字符输入的流成员函数<ul><li>不带参数的get函数<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> c;
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;enter a sentence:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> ((c <span style=color:#f92672>=</span> cin.get()) <span style=color:#f92672>!=</span> EOF) <span style=color:#75715e>// 函数的返回值就是读入的字符
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		cout.put(c);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li>有一个参数的get函数<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> c;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;enter a sentence:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (cin.get(
</span></span><span style=display:flex><span>        c))  <span style=color:#75715e>// 读取一个字符赋给c，如果读取成功，返回真，如失败（如遇文件结束符）则返回假
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        cout.put(c);
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;end&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li>有三个参数的get函数<ul><li>cin.get(字符数组/字符指针, 字符个数n, 终止字符)</li><li>从输入流中读取n-1个字符，赋给指定的字符数组（或字符指针指向的数组）</li><li>如果在读取n-1个字符之前遇到指定的终止字符，则提前读取结束</li><li>如果读取成功返回真，失败（遇文件结束符）则返回假</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> ch[<span style=color:#ae81ff>20</span>];
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;enter a sentence:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    cin.get(ch, <span style=color:#ae81ff>10</span>, <span style=color:#e6db74>&#39;/&#39;</span>);
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> ch <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    cin.get(ch, <span style=color:#ae81ff>20</span>, <span style=color:#e6db74>&#39;\n&#39;</span>);  <span style=color:#75715e>// cin.get(ch, 20);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cout <span style=color:#f92672>&lt;&lt;</span> ch <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>enter a sentence:
you!/her.
you!
/her.
</code></pre></li><li>用getline函数读入一行字符<ul><li>cin.getline(字符数组（或字符指针）, 字符个数n, 终止字符)</li><li>从输入流中读取一行字符，其用法与带3个参数的get函数类似<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> ch[<span style=color:#ae81ff>20</span>];
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;enter a sentence:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    cin <span style=color:#f92672>&gt;&gt;</span> ch;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> ch <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    cin.getline(ch, <span style=color:#ae81ff>20</span>, <span style=color:#e6db74>&#39;/&#39;</span>);
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> ch <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    cin.getline(ch, <span style=color:#ae81ff>20</span>);
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> ch <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>enter a sentence:
I like C++./I study C++./I am happy.
I
 like C++.
I study C++./I am h
</code></pre></li></ul></li><li>eof函数<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>cin.eof())
</span></span></code></pre></div></li><li>peek函数<ul><li>无参函数，表示“观察”，观测下一字符</li><li>返回值是当前指针指向的当前字符，但只是观测，指针仍停留在当前位置，并不后移</li><li>如果要访问的字符是文件结束符时，则函数值是EOF</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>c <span style=color:#f92672>=</span> cin.peek();
</span></span></code></pre></div></li><li>putback函数<ul><li>将前面用get或getline函数从输入流中读取的字符ch返回到输入流，插入到当前指针位置，供后面读取</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> c[<span style=color:#ae81ff>20</span>];
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> ch;
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;enter a sentence:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	cin.getline(c, <span style=color:#ae81ff>15</span>, <span style=color:#e6db74>&#39;/&#39;</span>);
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> c <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	ch <span style=color:#f92672>=</span> cin.peek(); <span style=color:#75715e>// 观看当前字符
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> ch <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	cin.putback(c[<span style=color:#ae81ff>0</span>]); <span style=color:#75715e>// 将&#39;I&#39;插入到指针所指处
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cin.getline(c, <span style=color:#ae81ff>15</span>, <span style=color:#e6db74>&#39;/&#39;</span>);
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> c <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>enter a sentence:
I am a boy./ am a student./
I am a boy.
32
I am a student
</code></pre></li><li>ignore函数<ul><li>cin.ignore(n, 终止字符)</li><li>跳过输入流中n个字符，或在遇到指定的终止字符时提前结束（此时跳过包括终止字符在内的若干字符）</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>ignore(<span style=color:#ae81ff>5</span>, <span style=color:#e6db74>&#39;A&#39;</span>); <span style=color:#75715e>// 跳过5个字符，遇&#39;A&#39;后不再跳
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>ignore(); <span style=color:#f92672>&lt;-&gt;</span> ignore(<span style=color:#ae81ff>1</span>, EOF);
</span></span></code></pre></div><ul><li>示例代码<ul><li>不加ignore<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> ch[<span style=color:#ae81ff>20</span>];
</span></span><span style=display:flex><span>    cin.get(ch, <span style=color:#ae81ff>20</span>, <span style=color:#e6db74>&#39;/&#39;</span>);
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;the first part is: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> ch <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    cin.get(ch, <span style=color:#ae81ff>20</span>, <span style=color:#e6db74>&#39;/&#39;</span>);  <span style=color:#75715e>// get不跳过终止字符
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;the second part is: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> ch <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>I like C++./I study C++./I am happy.
The first part is:I like C++.
The second part is:
</code></pre></li><li>加ignore<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> ch[<span style=color:#ae81ff>20</span>];
</span></span><span style=display:flex><span>    cin.get(ch, <span style=color:#ae81ff>20</span>, <span style=color:#e6db74>&#39;/&#39;</span>);
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;the first part is: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> ch <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    cin.ignore();          <span style=color:#75715e>// 跳过输入流中一个字符
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cin.get(ch, <span style=color:#ae81ff>20</span>, <span style=color:#e6db74>&#39;/&#39;</span>);  <span style=color:#75715e>// get不跳过终止字符
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;the second part is: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> ch <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>I like C++./I study C++./I am happy.
The first part is:I like C++.
The second part is:I study C++.
</code></pre></li></ul></li></ul></li></ul></li><li>用控制符格式化<ul><li>这组控制符<strong>不属于任何类成员</strong>，定义在inomanip头文件中</li><li>将他们用在提取运算符"&#187;&ldquo;或插入运算符&rdquo;&#171;&ldquo;后面来<strong>设定输入/输出格式</strong>，即在读写对象之间插入一个修改状态的操作</li><li>设置输入/输出宽度setw(int)<ul><li>用整型参数来指定输入/输出域的宽度。使用时只对其后一项输入/输出有效</li><li>当用于输出时，若实际宽度小于设置宽度时，数据向右对齐，反之则按照数据的实际宽度输出</li><li>当用于输入时，若输入的数据宽度超过设置宽度时，超出的数据部分被截断而被作为下一项输入内容</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;12345&#34;</span>, <span style=color:#f92672>*</span>q <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;678&#34;</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>char</span> f[<span style=color:#ae81ff>4</span>], g[<span style=color:#ae81ff>4</span>];
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> p <span style=color:#f92672>&lt;&lt;</span> setw(<span style=color:#ae81ff>6</span>) <span style=color:#f92672>&lt;&lt;</span> q <span style=color:#f92672>&lt;&lt;</span> setw(<span style=color:#ae81ff>4</span>) <span style=color:#f92672>&lt;&lt;</span> p <span style=color:#f92672>&lt;&lt;</span> q <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	cin <span style=color:#f92672>&gt;&gt;</span> setw(<span style=color:#ae81ff>4</span>) <span style=color:#f92672>&gt;&gt;</span> f <span style=color:#f92672>&gt;&gt;</span> g;
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> f <span style=color:#f92672>&lt;&lt;</span> endl <span style=color:#f92672>&lt;&lt;</span> g <span style=color:#f92672>&lt;&lt;</span> endl <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;i : &#34;</span> <span style=color:#f92672>&lt;&lt;</span> i <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>12345   67812345678
12345
123
45
i:10
</code></pre></li><li>设置输出填充字符setfill(char)</li><li>setprecision(int)<ul><li>在以fixed形式和scientific形式输出时参数为小数位数</li></ul></li><li>setiosflags(ios::fixed)用定点方式表示实数</li><li>setiosflags(ios::scientific)用科学记数法方式表示实数</li><li>setiosflags(ios::left)左对齐</li><li>setiosflags(ios::right)右对齐</li><li>setiosflags(ios::uppercase)大写表示</li><li>setiosflags(ios::showpos)正号</li><li>setiosflags(ios::skipws)忽略前导空格</li><li>resetiosflags() 终止已设置的输出格式状态，在括号中应指定内容</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iomanip&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> f<span style=color:#f92672>=</span><span style=color:#ae81ff>22.0</span><span style=color:#f92672>/</span><span style=color:#ae81ff>7</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>//在用浮点形式表示的输出中，setprecision(n)表示实数的有效位数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cout<span style=color:#f92672>&lt;&lt;</span>f<span style=color:#f92672>&lt;&lt;</span>endl;                    <span style=color:#75715e>//默认有效位数为6
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cout<span style=color:#f92672>&lt;&lt;</span>setprecision(<span style=color:#ae81ff>3</span>)<span style=color:#f92672>&lt;&lt;</span>f<span style=color:#f92672>&lt;&lt;</span>endl;   <span style=color:#75715e>//设置有效位数为3
</span></span></span><span style=display:flex><span><span style=color:#75715e>//在用定点形式表示的输出中，setprecision(n)表示实数的小数位数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cout<span style=color:#f92672>&lt;&lt;</span>setiosflags(ios<span style=color:#f92672>::</span>fixed); 
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span>setprecision(<span style=color:#ae81ff>8</span>)<span style=color:#f92672>&lt;&lt;</span>f<span style=color:#f92672>&lt;&lt;</span>endl;   <span style=color:#75715e>//小数位数为8
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>3.14286
3.14
3.14285714
</code></pre><ul><li>设置输入/输出整型数数制dec、hex和oct</li><li>控制换行的控制符endl</li><li>代表输出单字符&rsquo;\0&rsquo;的控制符ends</li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://fffzlfk.github.io/tags/c++/>C++</a></li><li><a href=https://fffzlfk.github.io/tags/academic/>Academic</a></li></ul><nav class=paginav><a class=prev href=https://fffzlfk.github.io/posts/algorithm4th/><span class=title>« Prev</span><br><span>算法（第四版）</span></a>
<a class=next href=https://fffzlfk.github.io/posts/%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F%E6%80%BB%E7%BB%93/><span class=title>Next »</span><br><span>泰勒公式总结</span></a></nav></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//https-fffzlfk-github-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2023 <a href=https://fffzlfk.github.io>fffzlfk's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>