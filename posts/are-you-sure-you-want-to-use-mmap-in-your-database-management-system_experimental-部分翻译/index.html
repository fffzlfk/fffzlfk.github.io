<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=zh-cn dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Are You Sure You Want to Use MMAP in Your Database Management System?[部分翻译] - fffzlfk's Blog</title>
<meta name=theme-color><meta name=description content="原文
Are You Sure You Want to Use MMAP in Your Database Management System?
4 实验分析
正如上一节解释的那样，一些mmap的问题可以通过仔细地实现来克服，但是我们认为，如果不进行重大的操作系统级别的重写，其固有的性能限制就无法解决。在这一节，我们通过实验结果分析展示了这些问题。
我们所有的实验在一个单处理器插槽的机器上运行，其配置信息为：AMD EPYC 7713 CPU(64 cores, 128 hardware threads)，512GB RAM，其中100GB可用于Linux（v5.11）的页面缓存，对于持久性存储，该机器有10×3.8TB的 三星PM1733固态硬盘（额定读取速度为7000MB/s，写入速度为3800MB/s），我们将固态硬盘作为块设备来避免潜在的文件系统开销。
作为基准线，我们使用了存储基准工具fio1，使用直接I/O(O_DIRECT)来绕过操作系统页面缓存。我们的分析专门聚焦在只读工作负载上，这代表了基于mmap的DBMS的最佳情况；否则，他们需要实现复杂的更新保护（3.1节），从而产生大量的额外开销。特别的是，我们评估了两种常见的访问模式：(1) 随机访问 和 (2) 顺序访问。
4.1 随机读取
在第一个实验中，我们在一块2TB SSD 范围内使用随机访问模式来模拟大于内存的OLTP工作负载。由于页面缓存只有100GB的内存，95%的访问都导致了缺页中断（即工作负载是I/O绑定的）。
图2a展示了100个线程每秒随机读取的数量。我们的fio基准线表现出了稳定的性能，达到了接近每秒90万次的读取速度，这符合100次出色的I/O操作和大约100𝜇s的NVMe延迟的预期性能。换句话说，这个结果表明，fio可以使NVMe SSD的性能完全饱和。

另一方面，mmap表现较差，即使是使用提示来匹配工作负载访问模式。我们在实验中观察到MADV_RANDOM的三个不同阶段。mmap在开始的27秒内与fio表现接近，然后在接下来的5秒钟突然下降到接近0，最后恢复到fio性能的一半。这个突然的性能下降发生在页面缓存被填满的时候，迫使操作系统开始从内存把页面置换出去。不出意料地是，其他访问模式提示下有更糟的性能表现。
在3.4节，我们列举了页面置换开销的三个关键来源。第一个问题是 TLB shootdowns2，我们使用/usr/interrupts记录的情况如图2b所示。如前所述，TLB shootdowns是十分昂贵的（需要成千上万个时钟周期），因为它涉及到发送处理器间的中断来刷新每个核心的TLB。第二，操作系统使用单个进程（kswapd）来置换页面，这在我们实验中是受CPU限制的。最后，操作系统必须同步页表，这在许多并发的线程中变得高度有竞争性。
4.2 顺序扫描
顺序扫描是DBMS的另一种常见的访问模式，特别是在OLAP工作负载中。因此，我们也在2TB SSD范围内对比了fio和mmap的扫描性能。我们首先使用仅仅一块SSD运行了我们的实验，然后我们在10块SSD组成的RAID 0上重新跑了相同的工作负载。
图3展示了fio可以利用一块SSD的全部带宽，同时保持稳定的性能。像之前的实验一样，mmap的性能开始和fio相似，但我们再次观察到，一旦页面缓存在大约17秒后被填满，性能就会急剧下降。另外，和这个工作负载预期的一样，MADV_NORMAL和MADV_SEQUENTIAL标志位比MADV_RANDOM性能要好。

图4展示了在10块SSD上重复顺序扫描的结果，进一步凸显了现代闪存理论上能够提供的与mmap能够实现的之间的差距。我们观察到在fio和mmap之间大概有20倍的性能差距，与使用一块SSD的结果相比，mmap几乎没有任何提升。

总的来说，我们发现mmap仅仅在单块SSD上的初始加载阶段表现得好。一旦页面置换开始或者使用多块SSD，mmap要比fio差2~20倍。随着PCIe 5.0 NVMe得即将发布，预计每块SSD的带宽将增加一倍，我们的结果展示了mmap不能够与传统的文件I/O的顺序扫描的性能相媲美。
6 结论
本论文提出了反对在DBMS中使用mmap来进行文件I/O。尽管有有限的好处，我们还是介绍了mmap的主要缺点，我们的实验分析证实了我们在其性能限制的发现。最后，我们向DBMS的开发者提供以下建议。
什么时候你不应该在你的DBMS中使用mmap：

你需要以一种事务安全的方式进行更新。
你想在不阻塞慢速I/O的情况下处理缺页中断，或者需要对内存中的数据进行明确控制。
你关心错误处理，需要返回正确的结果。
你需要在高速持久性存储设备上获得高吞吐量。

什么时候你也许应该使用mmap：

你的工作集（或者整个数据库）适合在内存中，并且工作负载是只读的。
你需要急于将产品推向市场，而不关心数据的一致性或者长期工程的头痛问题。
否则，永远不要使用。





fio: Flexible I/O Tester.&#160;&#8617;&#xfe0e;"><meta name=author content="fffzlfk"><link rel="preload stylesheet" as=style href=https://fffzlfk.github.io/main.min.css><link rel=preload as=image href=https://fffzlfk.github.io/theme.svg><link rel=preload as=image href="https://avatars.githubusercontent.com/u/44939690?v=4"><link rel=preload as=image href=https://fffzlfk.github.io/github.svg><link rel=preload as=image href=https://fffzlfk.github.io/instagram.svg><link rel=preload as=image href=https://fffzlfk.github.io/rss.svg><link rel=stylesheet href=/css/fonts.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",()=>renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1}))</script><link rel=icon href=https://fffzlfk.github.io/favicon.ico><link rel=apple-touch-icon href=https://fffzlfk.github.io/apple-touch-icon.png><meta name=generator content="Hugo 0.147.4"><meta itemprop=name content="Are You Sure You Want to Use MMAP in Your Database Management System?[部分翻译]"><meta itemprop=description content="原文 Are You Sure You Want to Use MMAP in Your Database Management System?
4 实验分析 正如上一节解释的那样，一些mmap的问题可以通过仔细地实现来克服，但是我们认为，如果不进行重大的操作系统级别的重写，其固有的性能限制就无法解决。在这一节，我们通过实验结果分析展示了这些问题。
我们所有的实验在一个单处理器插槽的机器上运行，其配置信息为：AMD EPYC 7713 CPU(64 cores, 128 hardware threads)，512GB RAM，其中100GB可用于Linux（v5.11）的页面缓存，对于持久性存储，该机器有10×3.8TB的 三星PM1733固态硬盘（额定读取速度为7000MB/s，写入速度为3800MB/s），我们将固态硬盘作为块设备来避免潜在的文件系统开销。
作为基准线，我们使用了存储基准工具fio1，使用直接I/O(O_DIRECT)来绕过操作系统页面缓存。我们的分析专门聚焦在只读工作负载上，这代表了基于mmap的DBMS的最佳情况；否则，他们需要实现复杂的更新保护（3.1节），从而产生大量的额外开销。特别的是，我们评估了两种常见的访问模式：(1) 随机访问 和 (2) 顺序访问。
4.1 随机读取 在第一个实验中，我们在一块2TB SSD 范围内使用随机访问模式来模拟大于内存的OLTP工作负载。由于页面缓存只有100GB的内存，95%的访问都导致了缺页中断（即工作负载是I/O绑定的）。
图2a展示了100个线程每秒随机读取的数量。我们的fio基准线表现出了稳定的性能，达到了接近每秒90万次的读取速度，这符合100次出色的I/O操作和大约100𝜇s的NVMe延迟的预期性能。换句话说，这个结果表明，fio可以使NVMe SSD的性能完全饱和。
另一方面，mmap表现较差，即使是使用提示来匹配工作负载访问模式。我们在实验中观察到MADV_RANDOM的三个不同阶段。mmap在开始的27秒内与fio表现接近，然后在接下来的5秒钟突然下降到接近0，最后恢复到fio性能的一半。这个突然的性能下降发生在页面缓存被填满的时候，迫使操作系统开始从内存把页面置换出去。不出意料地是，其他访问模式提示下有更糟的性能表现。
在3.4节，我们列举了页面置换开销的三个关键来源。第一个问题是 TLB shootdowns2，我们使用/usr/interrupts记录的情况如图2b所示。如前所述，TLB shootdowns是十分昂贵的（需要成千上万个时钟周期），因为它涉及到发送处理器间的中断来刷新每个核心的TLB。第二，操作系统使用单个进程（kswapd）来置换页面，这在我们实验中是受CPU限制的。最后，操作系统必须同步页表，这在许多并发的线程中变得高度有竞争性。
4.2 顺序扫描 顺序扫描是DBMS的另一种常见的访问模式，特别是在OLAP工作负载中。因此，我们也在2TB SSD范围内对比了fio和mmap的扫描性能。我们首先使用仅仅一块SSD运行了我们的实验，然后我们在10块SSD组成的RAID 0上重新跑了相同的工作负载。
图3展示了fio可以利用一块SSD的全部带宽，同时保持稳定的性能。像之前的实验一样，mmap的性能开始和fio相似，但我们再次观察到，一旦页面缓存在大约17秒后被填满，性能就会急剧下降。另外，和这个工作负载预期的一样，MADV_NORMAL和MADV_SEQUENTIAL标志位比MADV_RANDOM性能要好。
图4展示了在10块SSD上重复顺序扫描的结果，进一步凸显了现代闪存理论上能够提供的与mmap能够实现的之间的差距。我们观察到在fio和mmap之间大概有20倍的性能差距，与使用一块SSD的结果相比，mmap几乎没有任何提升。
总的来说，我们发现mmap仅仅在单块SSD上的初始加载阶段表现得好。一旦页面置换开始或者使用多块SSD，mmap要比fio差2~20倍。随着PCIe 5.0 NVMe得即将发布，预计每块SSD的带宽将增加一倍，我们的结果展示了mmap不能够与传统的文件I/O的顺序扫描的性能相媲美。
6 结论 本论文提出了反对在DBMS中使用mmap来进行文件I/O。尽管有有限的好处，我们还是介绍了mmap的主要缺点，我们的实验分析证实了我们在其性能限制的发现。最后，我们向DBMS的开发者提供以下建议。
什么时候你不应该在你的DBMS中使用mmap：
你需要以一种事务安全的方式进行更新。 你想在不阻塞慢速I/O的情况下处理缺页中断，或者需要对内存中的数据进行明确控制。 你关心错误处理，需要返回正确的结果。 你需要在高速持久性存储设备上获得高吞吐量。 什么时候你也许应该使用mmap：
你的工作集（或者整个数据库）适合在内存中，并且工作负载是只读的。 你需要急于将产品推向市场，而不关心数据的一致性或者长期工程的头痛问题。 否则，永远不要使用。 fio: Flexible I/O Tester. ↩︎"><meta itemprop=datePublished content="2022-12-15T13:18:08+08:00"><meta itemprop=dateModified content="2022-12-15T13:18:08+08:00"><meta itemprop=wordCount content="73"><meta property="og:url" content="https://fffzlfk.github.io/posts/are-you-sure-you-want-to-use-mmap-in-your-database-management-system_experimental-%E9%83%A8%E5%88%86%E7%BF%BB%E8%AF%91/"><meta property="og:site_name" content="fffzlfk's Blog"><meta property="og:title" content="Are You Sure You Want to Use MMAP in Your Database Management System?[部分翻译]"><meta property="og:description" content="原文 Are You Sure You Want to Use MMAP in Your Database Management System?
4 实验分析 正如上一节解释的那样，一些mmap的问题可以通过仔细地实现来克服，但是我们认为，如果不进行重大的操作系统级别的重写，其固有的性能限制就无法解决。在这一节，我们通过实验结果分析展示了这些问题。
我们所有的实验在一个单处理器插槽的机器上运行，其配置信息为：AMD EPYC 7713 CPU(64 cores, 128 hardware threads)，512GB RAM，其中100GB可用于Linux（v5.11）的页面缓存，对于持久性存储，该机器有10×3.8TB的 三星PM1733固态硬盘（额定读取速度为7000MB/s，写入速度为3800MB/s），我们将固态硬盘作为块设备来避免潜在的文件系统开销。
作为基准线，我们使用了存储基准工具fio1，使用直接I/O(O_DIRECT)来绕过操作系统页面缓存。我们的分析专门聚焦在只读工作负载上，这代表了基于mmap的DBMS的最佳情况；否则，他们需要实现复杂的更新保护（3.1节），从而产生大量的额外开销。特别的是，我们评估了两种常见的访问模式：(1) 随机访问 和 (2) 顺序访问。
4.1 随机读取 在第一个实验中，我们在一块2TB SSD 范围内使用随机访问模式来模拟大于内存的OLTP工作负载。由于页面缓存只有100GB的内存，95%的访问都导致了缺页中断（即工作负载是I/O绑定的）。
图2a展示了100个线程每秒随机读取的数量。我们的fio基准线表现出了稳定的性能，达到了接近每秒90万次的读取速度，这符合100次出色的I/O操作和大约100𝜇s的NVMe延迟的预期性能。换句话说，这个结果表明，fio可以使NVMe SSD的性能完全饱和。
另一方面，mmap表现较差，即使是使用提示来匹配工作负载访问模式。我们在实验中观察到MADV_RANDOM的三个不同阶段。mmap在开始的27秒内与fio表现接近，然后在接下来的5秒钟突然下降到接近0，最后恢复到fio性能的一半。这个突然的性能下降发生在页面缓存被填满的时候，迫使操作系统开始从内存把页面置换出去。不出意料地是，其他访问模式提示下有更糟的性能表现。
在3.4节，我们列举了页面置换开销的三个关键来源。第一个问题是 TLB shootdowns2，我们使用/usr/interrupts记录的情况如图2b所示。如前所述，TLB shootdowns是十分昂贵的（需要成千上万个时钟周期），因为它涉及到发送处理器间的中断来刷新每个核心的TLB。第二，操作系统使用单个进程（kswapd）来置换页面，这在我们实验中是受CPU限制的。最后，操作系统必须同步页表，这在许多并发的线程中变得高度有竞争性。
4.2 顺序扫描 顺序扫描是DBMS的另一种常见的访问模式，特别是在OLAP工作负载中。因此，我们也在2TB SSD范围内对比了fio和mmap的扫描性能。我们首先使用仅仅一块SSD运行了我们的实验，然后我们在10块SSD组成的RAID 0上重新跑了相同的工作负载。
图3展示了fio可以利用一块SSD的全部带宽，同时保持稳定的性能。像之前的实验一样，mmap的性能开始和fio相似，但我们再次观察到，一旦页面缓存在大约17秒后被填满，性能就会急剧下降。另外，和这个工作负载预期的一样，MADV_NORMAL和MADV_SEQUENTIAL标志位比MADV_RANDOM性能要好。
图4展示了在10块SSD上重复顺序扫描的结果，进一步凸显了现代闪存理论上能够提供的与mmap能够实现的之间的差距。我们观察到在fio和mmap之间大概有20倍的性能差距，与使用一块SSD的结果相比，mmap几乎没有任何提升。
总的来说，我们发现mmap仅仅在单块SSD上的初始加载阶段表现得好。一旦页面置换开始或者使用多块SSD，mmap要比fio差2~20倍。随着PCIe 5.0 NVMe得即将发布，预计每块SSD的带宽将增加一倍，我们的结果展示了mmap不能够与传统的文件I/O的顺序扫描的性能相媲美。
6 结论 本论文提出了反对在DBMS中使用mmap来进行文件I/O。尽管有有限的好处，我们还是介绍了mmap的主要缺点，我们的实验分析证实了我们在其性能限制的发现。最后，我们向DBMS的开发者提供以下建议。
什么时候你不应该在你的DBMS中使用mmap：
你需要以一种事务安全的方式进行更新。 你想在不阻塞慢速I/O的情况下处理缺页中断，或者需要对内存中的数据进行明确控制。 你关心错误处理，需要返回正确的结果。 你需要在高速持久性存储设备上获得高吞吐量。 什么时候你也许应该使用mmap：
你的工作集（或者整个数据库）适合在内存中，并且工作负载是只读的。 你需要急于将产品推向市场，而不关心数据的一致性或者长期工程的头痛问题。 否则，永远不要使用。 fio: Flexible I/O Tester. ↩︎"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-15T13:18:08+08:00"><meta property="article:modified_time" content="2022-12-15T13:18:08+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Are You Sure You Want to Use MMAP in Your Database Management System?[部分翻译]"><meta name=twitter:description content="原文 Are You Sure You Want to Use MMAP in Your Database Management System?
4 实验分析 正如上一节解释的那样，一些mmap的问题可以通过仔细地实现来克服，但是我们认为，如果不进行重大的操作系统级别的重写，其固有的性能限制就无法解决。在这一节，我们通过实验结果分析展示了这些问题。
我们所有的实验在一个单处理器插槽的机器上运行，其配置信息为：AMD EPYC 7713 CPU(64 cores, 128 hardware threads)，512GB RAM，其中100GB可用于Linux（v5.11）的页面缓存，对于持久性存储，该机器有10×3.8TB的 三星PM1733固态硬盘（额定读取速度为7000MB/s，写入速度为3800MB/s），我们将固态硬盘作为块设备来避免潜在的文件系统开销。
作为基准线，我们使用了存储基准工具fio1，使用直接I/O(O_DIRECT)来绕过操作系统页面缓存。我们的分析专门聚焦在只读工作负载上，这代表了基于mmap的DBMS的最佳情况；否则，他们需要实现复杂的更新保护（3.1节），从而产生大量的额外开销。特别的是，我们评估了两种常见的访问模式：(1) 随机访问 和 (2) 顺序访问。
4.1 随机读取 在第一个实验中，我们在一块2TB SSD 范围内使用随机访问模式来模拟大于内存的OLTP工作负载。由于页面缓存只有100GB的内存，95%的访问都导致了缺页中断（即工作负载是I/O绑定的）。
图2a展示了100个线程每秒随机读取的数量。我们的fio基准线表现出了稳定的性能，达到了接近每秒90万次的读取速度，这符合100次出色的I/O操作和大约100𝜇s的NVMe延迟的预期性能。换句话说，这个结果表明，fio可以使NVMe SSD的性能完全饱和。
另一方面，mmap表现较差，即使是使用提示来匹配工作负载访问模式。我们在实验中观察到MADV_RANDOM的三个不同阶段。mmap在开始的27秒内与fio表现接近，然后在接下来的5秒钟突然下降到接近0，最后恢复到fio性能的一半。这个突然的性能下降发生在页面缓存被填满的时候，迫使操作系统开始从内存把页面置换出去。不出意料地是，其他访问模式提示下有更糟的性能表现。
在3.4节，我们列举了页面置换开销的三个关键来源。第一个问题是 TLB shootdowns2，我们使用/usr/interrupts记录的情况如图2b所示。如前所述，TLB shootdowns是十分昂贵的（需要成千上万个时钟周期），因为它涉及到发送处理器间的中断来刷新每个核心的TLB。第二，操作系统使用单个进程（kswapd）来置换页面，这在我们实验中是受CPU限制的。最后，操作系统必须同步页表，这在许多并发的线程中变得高度有竞争性。
4.2 顺序扫描 顺序扫描是DBMS的另一种常见的访问模式，特别是在OLAP工作负载中。因此，我们也在2TB SSD范围内对比了fio和mmap的扫描性能。我们首先使用仅仅一块SSD运行了我们的实验，然后我们在10块SSD组成的RAID 0上重新跑了相同的工作负载。
图3展示了fio可以利用一块SSD的全部带宽，同时保持稳定的性能。像之前的实验一样，mmap的性能开始和fio相似，但我们再次观察到，一旦页面缓存在大约17秒后被填满，性能就会急剧下降。另外，和这个工作负载预期的一样，MADV_NORMAL和MADV_SEQUENTIAL标志位比MADV_RANDOM性能要好。
图4展示了在10块SSD上重复顺序扫描的结果，进一步凸显了现代闪存理论上能够提供的与mmap能够实现的之间的差距。我们观察到在fio和mmap之间大概有20倍的性能差距，与使用一块SSD的结果相比，mmap几乎没有任何提升。
总的来说，我们发现mmap仅仅在单块SSD上的初始加载阶段表现得好。一旦页面置换开始或者使用多块SSD，mmap要比fio差2~20倍。随着PCIe 5.0 NVMe得即将发布，预计每块SSD的带宽将增加一倍，我们的结果展示了mmap不能够与传统的文件I/O的顺序扫描的性能相媲美。
6 结论 本论文提出了反对在DBMS中使用mmap来进行文件I/O。尽管有有限的好处，我们还是介绍了mmap的主要缺点，我们的实验分析证实了我们在其性能限制的发现。最后，我们向DBMS的开发者提供以下建议。
什么时候你不应该在你的DBMS中使用mmap：
你需要以一种事务安全的方式进行更新。 你想在不阻塞慢速I/O的情况下处理缺页中断，或者需要对内存中的数据进行明确控制。 你关心错误处理，需要返回正确的结果。 你需要在高速持久性存储设备上获得高吞吐量。 什么时候你也许应该使用mmap：
你的工作集（或者整个数据库）适合在内存中，并且工作负载是只读的。 你需要急于将产品推向市场，而不关心数据的一致性或者长期工程的头痛问题。 否则，永远不要使用。 fio: Flexible I/O Tester. ↩︎"><link rel=canonical href=https://fffzlfk.github.io/posts/are-you-sure-you-want-to-use-mmap-in-your-database-management-system_experimental-%E9%83%A8%E5%88%86%E7%BF%BB%E8%AF%91/></head><body class="bg-(--bg) text-black antialiased duration-200 ease-out [-webkit-tap-highlight-color:transparent] dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-(--w) px-8 whitespace-nowrap lg:justify-center"><div class="relative z-50 flex items-center ltr:mr-auto rtl:ml-auto"><a class="-translate-y-[1px] text-2xl font-medium" href=https://fffzlfk.github.io/>fffzlfk's Blog</a><div class="btn-dark text-[0px] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden ltr:-mr-8 rtl:-ml-8" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full flex-col justify-center bg-(--bg) pb-16 duration-200 select-none lg:static lg:h-auto lg:flex-row lg:bg-transparent! lg:pb-0 lg:transition-none"><nav class="mt-12 flex justify-center space-x-10 lg:mt-0 lg:items-center ltr:lg:ml-14 rtl:space-x-reverse rtl:lg:mr-14 dark:invert"><a class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/fffzlfk target=_blank rel=me>github</a>
<a class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./instagram.svg) href=https://instagram.com/fffzlfk target=_blank rel=me>instagram</a>
<a class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./rss.svg) href=https://fffzlfk.github.io/index.xml target=_blank rel=alternate>rss</a></nav></div></header><main class="prose prose-neutral dark:prose-invert relative mx-auto min-h-[calc(100vh-9rem)] max-w-(--w) px-8 pt-14 pb-16"><article><header class=mb-14><h1 class="my-0! pb-2.5">Are You Sure You Want to Use MMAP in Your Database Management System?[部分翻译]</h1><div class="text-xs antialiased opacity-60"><time>Dec 15, 2022</time></div></header><section><h2 id=原文>原文</h2><p><a href=https://db.cs.cmu.edu/mmap-cidr2022/>Are You Sure You Want to Use MMAP in Your Database Management System?</a></p><h2 id=4-实验分析>4 实验分析</h2><p>正如上一节解释的那样，一些<code>mmap</code>的问题可以通过仔细地实现来克服，但是我们认为，如果不进行重大的操作系统级别的重写，其固有的性能限制就无法解决。在这一节，我们通过实验结果分析展示了这些问题。</p><p>我们所有的实验在一个单处理器插槽的机器上运行，其配置信息为：AMD EPYC 7713 CPU(64 cores, 128 hardware threads)，512GB RAM，其中100GB可用于Linux（v5.11）的页面缓存，对于持久性存储，该机器有10×3.8TB的 三星PM1733固态硬盘（额定读取速度为7000MB/s，写入速度为3800MB/s），我们将固态硬盘作为块设备来避免潜在的文件系统开销。</p><p>作为基准线，我们使用了存储基准工具<code>fio</code><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>，使用直接I/O(<code>O_DIRECT</code>)来绕过操作系统页面缓存。我们的分析专门聚焦在只读工作负载上，这代表了基于<code>mmap</code>的DBMS的最佳情况；否则，他们需要实现复杂的更新保护（3.1节），从而产生大量的额外开销。特别的是，我们评估了两种常见的访问模式：(1) 随机访问 和 (2) 顺序访问。</p><h3 id=41-随机读取>4.1 随机读取</h3><p>在第一个实验中，我们在一块2TB SSD 范围内使用随机访问模式来模拟大于内存的OLTP工作负载。由于页面缓存只有100GB的内存，95%的访问都导致了缺页中断（即工作负载是I/O绑定的）。</p><p>图2a展示了100个线程每秒随机读取的数量。我们的<code>fio</code>基准线表现出了稳定的性能，达到了接近每秒90万次的读取速度，这符合100次出色的I/O操作和大约100𝜇s的NVMe延迟的预期性能。换句话说，这个结果表明，<code>fio</code>可以使NVMe SSD的性能完全饱和。</p><p><img src=./images/Figure2.png alt></p><p>另一方面，<code>mmap</code>表现较差，即使是使用提示来匹配工作负载访问模式。我们在实验中观察到<code>MADV_RANDOM</code>的三个不同阶段。<code>mmap</code>在开始的27秒内与<code>fio</code>表现接近，然后在接下来的5秒钟突然下降到接近0，最后恢复到<code>fio</code>性能的一半。这个突然的性能下降发生在页面缓存被填满的时候，迫使操作系统开始从内存把页面置换出去。不出意料地是，其他访问模式提示下有更糟的性能表现。</p><p>在3.4节，我们列举了页面置换开销的三个关键来源。第一个问题是 TLB shootdowns<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>，我们使用<code>/usr/interrupts</code>记录的情况如图2b所示。如前所述，TLB shootdowns是十分昂贵的（需要成千上万个时钟周期），因为它涉及到发送处理器间的中断来刷新每个核心的TLB。第二，操作系统使用单个进程（<code>kswapd</code>）来置换页面，这在我们实验中是受CPU限制的。最后，操作系统必须同步页表，这在许多并发的线程中变得高度有竞争性。</p><h3 id=42-顺序扫描>4.2 顺序扫描</h3><p>顺序扫描是DBMS的另一种常见的访问模式，特别是在OLAP工作负载中。因此，我们也在2TB SSD范围内对比了<code>fio</code>和<code>mmap</code>的扫描性能。我们首先使用仅仅一块SSD运行了我们的实验，然后我们在10块SSD组成的RAID 0上重新跑了相同的工作负载。</p><p>图3展示了<code>fio</code>可以利用一块SSD的全部带宽，同时保持稳定的性能。像之前的实验一样，<code>mmap</code>的性能开始和<code>fio</code>相似，但我们再次观察到，一旦页面缓存在大约17秒后被填满，性能就会急剧下降。另外，和这个工作负载预期的一样，<code>MADV_NORMAL</code>和<code>MADV_SEQUENTIAL</code>标志位比<code>MADV_RANDOM</code>性能要好。</p><p><img src=./images/Figure3.png alt></p><p>图4展示了在10块SSD上重复顺序扫描的结果，进一步凸显了现代闪存理论上能够提供的与<code>mmap</code>能够实现的之间的差距。我们观察到在<code>fio</code>和<code>mmap</code>之间大概有20倍的性能差距，与使用一块SSD的结果相比，<code>mmap</code>几乎没有任何提升。</p><p><img src=./images/Figure4.png alt></p><p>总的来说，我们发现<code>mmap</code>仅仅在单块SSD上的初始加载阶段表现得好。一旦页面置换开始或者使用多块SSD，<code>mmap</code>要比<code>fio</code>差2~20倍。随着PCIe 5.0 NVMe得即将发布，预计每块SSD的带宽将增加一倍，我们的结果展示了<code>mmap</code>不能够与传统的文件I/O的顺序扫描的性能相媲美。</p><h2 id=6-结论>6 结论</h2><p>本论文提出了反对在DBMS中使用<code>mmap</code>来进行文件I/O。尽管有有限的好处，我们还是介绍了<code>mmap</code>的主要缺点，我们的实验分析证实了我们在其性能限制的发现。最后，我们向DBMS的开发者提供以下建议。</p><p>什么时候你<strong>不</strong>应该在你的DBMS中使用<code>mmap</code>：</p><ul><li>你需要以一种事务安全的方式进行更新。</li><li>你想在不阻塞慢速I/O的情况下处理缺页中断，或者需要对内存中的数据进行明确控制。</li><li>你关心错误处理，需要返回正确的结果。</li><li>你需要在高速持久性存储设备上获得高吞吐量。</li></ul><p>什么时候你<strong>也许</strong>应该使用<code>mmap</code>：</p><ul><li>你的工作集（或者整个数据库）适合在内存中，并且工作负载是只读的。</li><li>你需要急于将产品推向市场，而不关心数据的一致性或者长期工程的头痛问题。</li><li>否则，永远不要使用。</li></ul><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://github.com/axboe/fio>fio: Flexible I/O Tester.</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>TLB shootdowns: 一些内存被系统中的所有处理器共享，其中一个处理器修改了共享内存的映射关系时，需要同步这些修改到其他处理器。&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></section><div class="giscus mt-24"></div><script src=https://giscus.app/client.js data-repo=fffzlfk/fffzlfk.github.io data-repo-id=R_kgDOG4ERGw data-category=Q&amp;A data-category-id=DIC_kwDOG4ERG84CBP5t data-mapping=pathname data-strict=1 data-reactions-enabled=0 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class="mx-auto flex h-[4.5rem] max-w-(--w) items-center px-8 text-xs tracking-wider uppercase opacity-60"><div class=mr-auto>&copy;2025
<a class=link href=https://fffzlfk.github.io/>fffzlfk's Blog</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>powered by hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>hugo-paper</a></footer></body></html>