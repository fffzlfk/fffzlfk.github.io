---
title: "微机原理"
date: "2020-10-17T21:07:26+08:00"
toc: true
draft: false
summary: "西电微机原理"
tags:
  - Academic
---

## 单核处理器8086/8088

### 寄存器结构

![](/images/寄存器结构.svg)

#### 通用寄存器

| Reg   | 特殊用途                                                     |
| ----- | ------------------------------------------------------------ |
| AX,AL | **I/O 指令的数据寄存器**；乘法指令存放**被乘数或积**(隐含)，除法指令存放被除数或商(隐含) |
| AH    | LAHF指令的目标寄存器(隐含)                                   |
| AL    | 数制转换或十进制运算指令和XLAT指令的累加器(隐含)             |
| BX    | **间接寻址的基址寄存器** XLAT指令的基址寄存器(隐含)          |
| CX    | 串操作和**LOOP指令的计数器**(隐含)                           |
| DX    | 字乘法/除法指令存放**乘积高16位**或**被除数高位**或**余数**(隐含) 间接寻址的 **I/O 端口地址** |
| SI    | 串操作的源变址寄存器(隐含)、**间接寻址的变址寄存器**         |
| DI    | 串操作的目标变址寄存器(隐含)、**间接寻址的变址寄存器**       |
| BP    | 对**堆栈区间接寻址的基址指针**                               |
| SP    | **堆栈操作的堆栈顶部指针**                                   |

#### 标志寄存器

- 6个状态标志位

  - **CF，进位标志**。本次运算最高位**有进位或借位发生，则CF=1**。**STC（CLC）指令使CF=1（=0），CMC指令使之取反。**（用于无符号数）

  - PF，奇偶校验标志：低 8 位有偶数个 1 则 PF = 1

  - **AF：辅助进位标志**

    低 4 位向高四位有进位或借位， AF = 1 （用于 BCD 计算）

  - **ZF：全零标志**

    运算结果为 0 时，ZF = 1；

  - **SF：符号标志**

    运算结果最高位为1，SF = 1 （表示负数）

  - **OF：溢出标志**

    运算产生溢出 （两负数相加为正）（有符号数）时， OF =1

- 3 个控制标志位

  - TF：单步标志
  - IF：**中断标志**：IF = 1 允许，**IF=0 禁止 CPU 响应可屏蔽中断** （INTR）
  - DF：方向标志，串操作指令的地址变化方向


### 主存结构

#### 双体结构

既能实现16位存储，也可以实现8位存储。
![](https://s1.ax1x.com/2020/10/18/0XiVTf.png)

#### 分段结构

```asm
 68320H
+ 1280H
--------
 695A0H
```

### 芯片引脚

#### 8086芯片引脚

![](https://s1.ax1x.com/2020/10/18/0XZYA1.jpg)

![](https://s1.ax1x.com/2020/10/18/0XZ0je.jpg)

#### 8088芯片引脚

![](https://s1.ax1x.com/2020/10/18/0XexRf.png)

![](https://s1.ax1x.com/2020/10/18/0Xejit.png)

![](https://s1.ax1x.com/2020/10/18/0XevJP.png)

#### 8086vs.8088

1. 指令预取序列：4Bytes<=>6Bytes
2. AD7~AD0  
   AD15~AD0 => 总线传递数据更快
3. 8088：$ \overline{SSO} $, 8086: $ \overline{BHE} / S7 $
4. 8088: $ IO/\overline M $, 8086: $ M/\overline{IO} $

### 工作时序

1. 时钟周期：CPU处理动作最小单位
2. 总线周期：存储器读写、I/O读写、中断响应
3. 指令周期：取指+执行

主存读时序分析
![](https://s1.ax1x.com/2020/10/18/0XnNhq.png)

### 习题

#### 2.2

若8086CPU工作在最小模式下：
1. 当CPU访问储存器时，要利用哪些信号？

>$AD0 \sim AD15、A16\sim A19、ALE、\overline{BHE}、DT/\overline{R}、\overline{DEN}、M/\overline{IO}、\overline{RD}、\overline{WR}$

2. 当CPU访问外设端口时，要利用哪些信号？

>$AD0 \sim AD15、ALE、\overline{BHE}、DT/\overline{R}、\overline{DEN}、M/\overline{IO}、\overline{RD}、\overline{WR}$

3. 当HOLD有效并得到回应时，CPU的哪些信号置高阻？

>CPU所有三态输出的地址、数据和相关控制信号。

#### 2.2

若8086CPU工作在最大模式下：

1. S0、S1、S2可以表示哪些CPU的状态？

>INTA周期、I/O读周期、I/O写周期、暂停、取值周期、存储器读周期、存储器写周期

2. CPU的$ \overline{RQ}/\overline{GT} $信号的作用是什么？

>$ \overline{RQ}/\overline{GT} $是裁决总线使用权的请求/允许信号


## Intel指令系统与程序设计

### 程序框架


```asm
STACK  SEGMENT STACK
       DB 100 DUP(0)
STACK  ENDS

DATA   SEGMENT
NUM8   DB 16,25
NUM16  DW 36,64
ARRAY8 DB 20 DUP(0)
………  …………

DATA   ENDS
CODE   SEGMENT
       ASSUME CS:CODE,DS:DATA,SS:STACK
START: MOV AX,DATA
       MOV DS,AX
        …………
       MOV AX,4C00H
       INT 21H
CODE   ENDS
       END START
```

子程序结构

```asm
     ……
    CALL SUB1
    ……    

SUB1 PROC
      PUSH …
     ……
     POP …
     RET

SUB1 ENDP
```

### 数据传送、寻址、算术运算指令

#### 数据传送

- **MOV指令**

  - MOV指令必须遵从的的规则：  
    1. 两个操作数的尺寸必须一致
    2. 两个操作数不能同为操作数
    3. 目的操作数不能位CS, EIP和IP
    4. 立即数不能直接送至段寄存器
      ```asm
      mov r/m16,sreg
      mov sreg,r/m16
      ```
  - MOV指令格式  
    ```asm
    mov reg, reg
    mov mem, reg
    mov reg, mem
    mov mem, imm
    mov reg, emm
    ```

- **整数的零/符号扩展**

  1. MOVZX
  2. MOVSZ

- **XCHG指令**

  交换两个操作数的内容

#### 加法和减法

- **INC和DEC指令**

  ```asm
  inc reg/mem
  dec reg/mem
  ```

  < notice tip >
  INC和DEC指令不影响进位标志
  < /notice >
- **ADD、SUB、NEG指令**

  影响的标志位：CF, ZF, SF, OF, AF, PF

#### 和数据相关的操作符和伪指令

- **OFFSET操作符**

- **PTR操作符**
  - 用来重载操作数的默认尺寸
  - 必须和标准数据类型联合使用
  ```asm
  .data
  myDouble DWORD 12345678h
  .code
  mov ax, myDouble              ; 错误
  mov ax, WORD PTR myDouble     ; ax = 5678h
  mov ax, WORD PTR [myDouble+2] ; ax = 1234h
  mov bl, BYTE PTR myDouble     ; bl = 78h
  ```
- **TYPE操作符**
  返回按字节计算的变量的单个元素的大小
- **LENGTHOF操作符**
  计算数组元素的个数
- **SIZEOF操作符**
  SIZEOF返回值=LENGTHOF返回值*TYPE返回值

#### 间接寻址

- **间接操作数(寄存器间接寻址)**

  PTR与间接操作数的联合使用：  
  ```asm
  inc [esi]     ; error: operand must have size
  inc BYTE PTR [esi]
  ```

- **数组**  
  例：三个双字相加
  ```asm
  .data
  arrayD DWORD 10000h,20000h,30000h
  .code
  mov esi, OFFSET arrayD
  mov eax, [esi]
  add esi, 4
  add eax, [esi]
  add esi, 4
  add eax, [esi]
  ```

- **变址操作数(寄存器相对寻址)**  
  例：
  ```asm
  .data
  arrayB BYTE 10h, 20h, 30h
  .code
  mov esi, 0
  mov al, [arrayB+esi]  ; AL = 10h
  mov al, arrayB[esi]   ; 同上，另一种格式
  mov esi, OFFSET arrayB
  mov al, [esi]         ; AL = 10h
  mov al, [esi+1]       ; AL = 20h
  mov al, [esi+2]       ; AL = 30h
  ```
  <notice warning>
  实模式下只能使用SI，DI，BX，BP寄存器（尽量避免使用BP寄存器）
  </notice>

#### JMP和LOOP指令
- **JMP**：无条件转移
- **LOOP**:条件转移
  - 在实地址模式下，用做默认循环计数器的是CX而不是ECX
  - 在任何模式下，LOOPD指令都使用ECX作为循环计数器，LOOPW都使用CX作为循环计数器
  - 循环的目的地址与当前地址只能在相距-128到+127字节的范围之内。机器指令平均在3字节左右，因此一个循环平均最多只能包含大约42条指令
  - 循环的嵌套
    ```asm
    .data
    count DWORD ?
    .code
        mov ecx, 100
    L1: mov count, ecx
        mov ecx, 20
    L2: ...
        ...
        loop L2
        mov ecx, count
        loop L1
    ```

#### 小结：操作数类型（寻址方式）
- **直接操作数（直接寻址）**
  变量的名字，代表变量的地址
- **直接偏移操作数**
  在变量的名字上加一个偏移量
- **间接操作数（寄存器间接寻址）**
  用方括号括起的包含数据地址的寄存器
- **变址操作数（寄存器相对寻址）**
  把常量和间接操作数结合在一起

### 过程

#### 与外部库链接

1. 程序中要用PROTO伪指令声明要调用的程序:
        WriteString PROTO
2. 用一条CALL指令执行WriteString过程:
        call WriteString
3. 当程序被编译时，编译器为CALL指令的目标地址留出空白，该空白将有链接器填充
4. 连接器在链接库中查找WriteString这个名字，从库中把合适的机器指令拷贝到程序的可执行文件中，并把WriteString的地址插入到CALL指令中

#### 堆栈操作
- **堆栈**
  - 压栈操作：
    32位的压栈（PUSH）操作将堆栈指针减4，并将进栈数据拷贝到堆栈指针所指向的位置
  - 出栈操作：
    出栈（POP）操作从堆栈顶端移走一个值并将其置于寄存器或变量中。在值从栈顶弹出后，堆栈指针相应增加。

    ![](https://s1.ax1x.com/2020/10/21/B92cgU.jpg)

  - 堆栈的用途：
    - 临时保存区域
    - CALL指令用堆栈保存当前过程的:warning:返回地址
    - 调用过程时,通过堆栈::warning:传递参数
    - 过程内的:warning:局部变量在堆栈上创建，过程结束时，这些变量被丢弃
- **PUSH和POP指令**
  - PUSH指令
    - 执行过程
      - 减小ESP的值
        - 16位操作数：ESP减2
        - 32位操作数：ESP减4
      - 将一个16位或32位的源操作数拷贝至堆栈上
    - 指令格式
      ```
      push r/m16
      push r/m32
      push imm32
      ```
    - 保护模式下的立即数总是32位的；
      在实地址模式下，如果未使用.386（或更高）处理器伪指令，默认的立即数是16位的

  - POP指令
    - 执行过程
      - 将ESP所指向的堆栈元素拷贝到16位或32位的目的操作数中
      - 增加ESP的值
        - 16位操作数：ESP加2
        - 32位操作数：ESP加4
      - 指令格式
        ```
        pop r/m16
        pop r/m32
        ```
  - PUSHFD和POPFD指令
    - 32位：
      - PUSHFD：在堆栈压入32位EFLAGS寄存器的值
      - POPFD：将堆栈顶部的值弹出并送至EFLAGS寄存器
    - 实地址模式：
      - PUSHF：在堆栈上压入16位FLAGS寄存器的值
      - POPF：将堆栈顶部的值弹出并送至FLAGS寄存器
  - PUSHAD,PUSHA,POPAD和POPA指令
    - 32位：
      - PUSHAD：将EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI按顺序压入堆栈
      - POPAD：按相反顺序弹出这些通用寄存器
    - 80286：
      - PUSHA：以用样的顺序压入AX、CX、DX、BX、SP、BP、SI、DI
      - POPA：以相反的顺序弹出

#### 过程的定义和使用

- **PROC伪指令**

  ```asm
  Sumof PROC
    add eax, ebx
    add eax, ecx
    ret
  Sumof ENDP
  ```

- **CALL和RET指令**
  - 调用和返回的例子
    ![](https://s1.ax1x.com/2020/10/21/B97DL6.png)
  - 可嵌套使用
  - 局部标号和全局标号
    
    ```asm
    L1::      ; global label
        ...
    L2:       ; local babel
        ...
    ```

### 条件处理

#### 布尔和比较指令

- **AND指令**：按位与
  - 影响的标志位：
    - 总是清除OF和CF；
    - 根据结果修改SF，ZF，PF
  - 主要用途：对特定的位清0
  - 大写字母和小写字母的ASCII码之间的关系：
    - 'a': 61h, 01100001b
    - 'A': 41h, 01000001b
- **OR指令**：按位或   
  - 主要用途：对特定的位置1
- **XOR指令**：按位异或
  - 用途：
    - 对某些位取反
    - 判断16位或32位值的奇偶性
      ```asm
      mov ax, 64C1h     ; 0110 0100 1100 0001
      xor ah, al        ; PE, 奇偶位被设置
      ```
    - 简单数据加密
      将某个操作数与同样的操作数执行两次异或操作之后，其值保持不变
      $$ (X\oplus Y) \oplus Y = X $$
- **NOT指令**：取反
  < notice warning >
  **NOT指令不影响任何状态标志**
  < /notice >
- **TEST指令**：两操作数按位**与**，根据结果设置标志位，但**不回送结果**（不修改目的操作数）
  - 用途：测试某一位是“0”还是“1”
    ```asm
    test al, 00001001b   ; test bits 0 and 3
    ```
    判断ZF是否等于1
  - 影响的标志位：清除OF、CF；修改SF、ZF、PF
- **CMP指令**
  - 功能：与减法指令一样执行减法操作，但**不回送**结果，只**影响标志位**
  - 影响的标志位：根据相减结果修改OF、SF、ZF、CF、AF、PF
  - 无符号操作数的比较
    | CMP的结果 | ZF | CF |
    | -- | -- | -- |
    | 目的 < 源 | 0 | 1 |
    | 目的 > 源 | 0 | 0 |
    | 目的 = 源 | 1 | 0 |
  - 有符号操作数的比较
    
    ```asm
    mov ax, 5
    cmp ax, 10  ; CF = 1

    mov si, 105
    cmp si, 0   ; ZF = 0, CF = 0

    mov ax, 1000
    mov cx, 1000
    cmp ax, cx  ; ZF = 1
    ```
  
  - 设置和清除单个CPU标志
    
    ```asm
    test al, 0   ; 设置零标志
    and al, 0    ; 设置零标志
    or al, 0     ; 设置零标志
    
    or al, 80h   ; 设置符号标志
    and al, 7Fh  ; 清楚符号标志

    stc          ; 设置进位标志
    clc          ; 清除进位标志

    mov al, 7Fh  ; AL = +127
    inc al       ; AL = 80h
    or eax, 0    ; 清除溢出标志
    ```

#### 条件跳转

- **条件结构**
  - 使用CMP、TEST、AND之类的指令修改CPU标志
  - 使用条件跳转指令测试标志值，已决定是否向新的分支转移
  
    ```asm
        cmp al, 0
        jz  L1      ; jump if ZF = 1
        ...

    L1:
    ```

    ```asm
        and dl, 10110000b
        jnz L2            ; jump if ZF = 0
        ...
    L2:    
    ```

- **Jcond指令**
  - 功能：
    - 条件标志为真：分支转移到新的目标标号处
    - 条件标志为假：执行紧跟在条件跳转指令之后的指令
  - 格式：
    例：
    ```asm
    mov ax, 5     mov ax, 5     mov ax, 5
    cmp ax, 5     cmp ax, 6     mov ax, 6
    je L1         j1 L1         jg L1
    ```
- 条件跳转指令的类型
  - 基于特定CPU**标志值**
    | 助记符 | 描述 | 标志值 |
    | -- | -- | -- |
    | JZ | 为零则跳转 | ZF = 1 |
    | JNZ | 不为零则跳转 | ZF = 0 |
    | JC | 如果设置进位标志则跳转 | CF = 1 |
    | JNC | 如果未设置进位标志则跳转 | CF = 0 |
    | JO | 如果设置溢出标志则跳转 | OF = 1 |
    | JNO | 如果未设置溢出标志则跳转 | OF = 0 |
    | JS | 如果设置符号标志则跳转 | SF = 1 |
    | JNS | 如果未设置符号标志则跳转 | SF = 0 |
    | JP | 如果设置了奇偶标志则跳转（偶） | PF = 1 |
    | JNP | 如果未设置奇偶标志则跳转（奇）| PF = 0 |
  - 依据**相等**比较的跳转指令
    | 助记符 | 描述 |
    | --- | --- |
    | JE | 相等则跳转 |
    | JNE | 不相等则不跳转 |
    | JCXZ | CX = 0 则跳转 |
    | JECXZ | ECX = 0 则跳转 |
  - 基于**无符号整数**比较结果的跳转指令
    > A:Above, B: Below, E:Equal
    
    | 助记府 | 描述 |
    | - | - |
    | JA | 大于则跳转(leftOp > rightOp) |
    | JNBE | 不（小于或等于）（同JA） |
    | JAE | 大于或等于则跳转 (leftOp >= rightOp) | 
    | JNB | 不小于则跳转 （同JAE） |
    | JB | 小于则跳转(leftOp < rightOp) |
    | JNAE | 不（大于或等于）（同JB） |
    | JBE | 小于或等于则跳转(leftOp <= rightOp) |
    | JNA | 不大于则跳转（同JBE） |

  - 基于**有符号整数**比较结果的跳转指令
    > G: Grater, L: Less, E: Equal

    | 助记府 | 描述 |
    | - | - |
    | JG | 大于则跳转(leftOp > rightOp) |
    | JNLE | 不（小于或等于）（同JA） |
    | JGE | 大于或等于则跳转 (leftOp >= rightOp) | 
    | JNL | 不小于则跳转 （同JAE） |
    | JL | 小于则跳转(leftOp < rightOp) |
    | JNGE | 不（大于或等于）（同JB） |
    | JLE | 小于或等于则跳转(leftOp <= rightOp) |
    | JNG | 不大于则跳转（同JBE） |

    ```asm
    mov al, 7Fh     ; (7Fh or +127)
    cmp al, 80h     ; (80h or -128)
    ja IsAbove      ; no : 7F not > 180h

    mov al, 7Fh     ; (7Fh or +127)
    cmp al, 80h     ; (80h or -128)
    jg IsAbove      ; yes: +127 > -128
    ```

#### 条件循环指令

- **LOOPZ和LOOPE指令**
  - 含义：Loop if zero，Loop if equal
  - 二者等价
  - 执行逻辑：
    ECX = ECX - 1  
    if ECX > 0 and ZF = 1, jump to destination
- **LOOPNZ和LOOPNE指令**
  - 含义：Loop if not zero， Loop if not equal
  - 二者等价
  - 执行逻辑：
    ECX = ECX - 1  
    if ECX > 0 and ZF = 0, jump to destination
  
  ```asm
  ; 扫描数组中的每个数值，直到发现正数为止
  .data
  array SWORD -3,-6,-1,-10,10,30,40,4
  sentinel SWORD 0
  .code
        mov esi, OFFSET array
        mov ecx, LENGTHOF array
  next: test WORD PTR [esi], 8000h ; test highest bit
        pushfd                     ; push flags on stack
        add esi, TYPE array        
        popfd                      ; pop flags from stack
        loopnz next                ; continue
        jnz quit                   ; none found
        sub esi, TYPE array        ; SI points to value
  ```

### 整数运算指令

#### 移位和循环移位指令
< notice note >
**S**hift
**L**eft
**R**ight
**A**rithmetic
**R**otate
**C**arry
< /notice >
- 移位指令
  | 助记符 | 描述 |
  | --- | --- |
  | SHL | 逻辑左移 |
  | SHR | 逻辑右移 |
  | SAL | 算数左移 |
  | SAR | 算数右移 |
  | ROL | 循环左移 |
  | ROR | 循环右移 |
  | RCL | 带进位的循环左移 |
  | RCR | 带进位的循环右移 |
  | SHLD | 双精度左移 |
  | SHRD | 双精度右移 |
- 上述指令影响**OF、CF**
- **逻辑移位和算术移位**
  ![](https://s1.ax1x.com/2020/10/21/BPG8pt.png)
- **循环左移ROL和循环右移ROR**
  ![](src="https://s1.ax1x.com/2020/10/21/BPG1fI.png)
  ![](https://s1.ax1x.com/2020/10/21/BPGQkd.png)
- **带进位的循环左移RCL和右移RCR**
  ![](https://s1.ax1x.com/2020/10/21/BPGltA.png)

- **SHLD/SHRD指令**
  - 格式：**SHLD 目的操作数，源操作数，移位位数**
  - 要求至少是Intel386处理器
  - SHLD：双精度左移，**Sh**ift **L**eft **D**ouble  
    将目的操作数左移指定的位数，低位空出来的位用源操作数的高位填充
  - SHRD：双精度右移，**Sh**ift **R**ight **D**ouble  
    将目的操作数右移指定的位数，空出来的位由源操作数的低位来填充。
- 格式：  
  **助记符 目的操作数，移位位数**
  ```asm
  SHL reg, imm8
  SAL mem, imm8
  ROR reg, CL
  RCL mem, CL
  ```
  - 8088/8086要求imm8必须等于1；80286以上，imm8可以为“任意”整数
  - CL方式可用于任何Intel x86处理器

#### 乘法和除法指令

- **MUL指令**
  - 格式（操作数为乘数）：  
    MUL r/m8  
    MUL r/m16  
    MUL r/m32  
  - 功能：无符号乘法。将8位、16位或32位的操作数与AL、AX或EAX相乘  
    | 被乘数 | 乘数 | 积 | CF = 1的条件 |
    | -- | -- | -- | -- |
    | AL | r/m8 | AX | AH $\neq$ 0 |
    | AX | r/m16 | DX:AX | DX $\neq$ 0 |
    | EAX | r/m32 | EDX:EAX | EDX $\neq$ 0 |
- **IMUL指令**：有符号乘法  
  如果累积的高半部分**不是低半部分的符号扩展（换而言之就是低半部分不足够表示累积）**，则设置CF和OF  
  例：
    ```asm
    mov al, 48      ; 48D = 30H
    mov bl, 4
    imul bl         ; AX = 00C0h, OF = 1

    mov al, -4
    mov bl, 4
    imul bl         ; AX = FFF0h, OF = 0

    mov ax, 48
    mov bx, 4
    imul ax         ; DX:AX = 000000C0h, OF = 1
    ```

- **DIV指令**：无符号除法
  | 被除数 | 除数 | 商 | 余数 |
  | -- | -- | -- | -- |
  | AX | r/m8 | AL | AH |
  | DX:AX | r/m16 | AX | DX |
  | EDX:EAX | r/m32 | EAX | EDX |

- **有符号整数除法**
  - CBW, CWD, CDQ指令
    - CBW(Convert Byte to Word): 将AL中的符号位扩展到AH
    - CWD(Convert Word to Doubleword): 将AX中的符号位扩展到DX
    - CDQ(Convert DoubleWord QuadWord): 将EAX中的符号位扩展到EDX
  - IDIV指令：有符号数整数的除法运算  
    例：
      ```asm
      .data
      byteVal SBYTE -48
      .code
        mov al, byteVal
        cbw               ; extend AL into AH
        mov bl, 5
        idiv bl           ; AL = -9, AH = -3
      
      .data
      wordVal SWORD -5000
      .code
        mov ax, wordVal
        cwd               ; extend AX into DX
        mov bx, 256
        idiv bx           ; AX = -19, DX = -136
      ```
  - 除法溢出
    - 当除法产生的商太大而无法容纳在目的操作数中的时候，将导致除法溢出，使CPU触发一个中断，当前程序被终止
    - 试图除以0也会发生相同的情况
    - 解决办法
      - 使用32位的除数来减小除法溢出的可能性
      - 测试除数，如果除数等于0则跳过除法指令

#### 扩展加法和减法

- **ADC指令**：扩展加法  
  目的操作数 + 源操作数 + 进位标志->目的操作数
- **SBB指令**：扩展减法  
  目的操作数 + 源操作数 - 进位标志->目的操作数

#### ASCII和压缩十进制算数

- **AAA**：**加**法之后进行ASCII码调整
  ```asm
  mov ag, 0
  mov al, '8'       ; AX = 0038h
  add al, '2'       ; AX = 006Ah
  aaa               ; AX = 0100h
  or ax, 3030h      ; AX = 3130h = '10'
  ```
- **AAS**：**减**法之后进行ASCII码调整
- **AAM**：**乘**法之后进行ASCII码调整
- **AAD**：**除**法之后进行ASCII码调整
- 压缩的十进制整数
  - **DAA指令**：将ADD或ADC指令执行后AL中的结果转换成压缩的十进制格式
  - **DAS指令**：将SUB或SBB指令执行后AL中的结果转换成压缩的十进制格式
  - 例：
    ```asm
    mov al, 35h     
    add al, 48h     ; AL = 7Dh
    daa             ; AL = 83h
    
    mov bl, 48h
    mov al, 85h
    sub al, bl      ; AL = 3Dh
    das             ; AL = 37h
    ```

### 字符串与数组

#### 基本字符串操作指令

| 指令 | 描述 |
| - | - |
| MOVSB, MOVSW, MOVSD | **移动字符串数据**：拷贝DS:(E)SI寻址的内存操作数至ES:(E)DI |
| CMPSB, SMPSW, CMPSD | **比较字符串**：比较内存中由DS:(E)SI寻址和ES:(E)DI寻址的字符串。源-目的 |
| SCASB, SCASW, SCASD | **扫描字符串**：扫描ES:(E)DI指向的内存字符串查找与累加器匹配的值 |
| STOSB, STOSW, STOSD | **存储字符串**：将累加器内容存储到由ES:(E)DI寻址的内存中 |
| LODSB, LODSW, LODSD | **将字符串数据装入累加器**：将由DS:(E)SI寻址的内存单元装入累加器中 |

- **使用重复前缀**
  - 字符串操作指令每次只能处理一个内存值。
  - 通过增加一个重复前缀，字符串指令就会使用ECX作为计数器进行重复 —— 实现用一条指令处理整个数组。
  - 可以使用的重复前缀
    | REP | ECX > 0时重复 |
    | - | - |
    | REPZ, REPE | 当ZF＝1且ECX＞0时重复 |
    | REPNE, REPNZ | 当ZF＝0且ECX＞0时重复 |
  - 方向标志：简单字符串指令使用方向标志来决定ESI和EDI是自动增加还是自动减少。
    - 方向标志位 DF＝0：ESI、EDI 自动增加；
    - 方向标志位 DF＝1：ESI、EDI 自动减少。
  - 方向标志可以通过CLD和STD指令改变：
    ```asm
    CLD	; 清除方向标志
    STD	; 设置方向标志
    ```

- **MOVSB、MOVSW 和 MOVSD 指令**

  ```asm
  .data
  source DWORD 20 DUP(0FFFFFFFFh)
  target DWORD 20 DUP(?)
  .code
  cld					       ; direction = forward
  mov ecx,LENGTHOF source	; set REP counter
  mov esi,OFFSET source		; ESI points to source
  mov edi,OFFSET target		; EDI points to target
  rep movsd			      	; copy doublewords
  ```

- **CMPSB、CMPSW 和 CMPSD 指令**  
  隐含执行：源-目的，这与 CMP 指令相反

  ```asm
  mov  esi,OFFSET source
  mov  edi,OFFSET target
  cld				    ; direction = up
  mov  ecx,count	; repetition counter
  repe cmpsd		  	; repeat while equal
  ```

- **SCASB、SCASW 和 SCASD 指令**  
  - 将AL/AX/EAX中的值同目标内存(由DI寻址)中的字节、字或双字相比较。
  - 例:扫描一个匹配字符：在字符串变量alpha中查找字母“F”
    ```asm
    .data
    alpha BYTE "ABCDEFGH",0
    .code
      mov edi,OFFSET alpha	 ; EDI points to the string
      mov al,'F'		 ; search for the letter F
      mov ecx,LENGTHOF alpha ; set the search count
      cld				 ; direction = up
      repne scasb		 ; repeat while not equal
      jnz quit			 ; quit if letter not found
      dec edi			 ; found: back up EDI
    quit:
    ```

- **STOSB、STOSW 和 STOSD 指令**
  - 将AL/AX/EAX的内容存储在EDI指向的内存单元中，同时EDI的值根据方向标志增加或减少。可与REP前缀联合使用。
  - 例：将string1的每个字节初始化为0FFh。
    ```asm
    .data
    count = 100
    string1 BYTE count DUP(?)
    .code
      mov al,0FFh		  ; value to be stored
      mov edi,OFFSET string1  ; ES:DI points to target
      mov ecx,count		  ; character count
      cld				  ; direction = forward
      rep stosb			  ; fill with contents of AL
    ```
- **LODSB、LODSW 和 LODSD 指令**
  - 从ESI指向的内存位置向AL/AX/EAX中装入一个值，同时ESI的值根据方向标志增加或减少。
  - 一般不与REP前缀联合使用。

#### 二维数组

- **基址变址操作数**：将两个寄存器的值相加(称为基址寄存器、变址寄存器)来产生偏移地址
  - 保护模式程序中，可使用任意两个32位通用寄存器
  - 实地址模式下，16位寄存器允许的组合是：**[bx+si], [bx+di], [bp+si], [bp+di]**  
  :warning:应尽量避免使用BP寄存器，除非要访问堆栈操作数
  ```asm
  .data
  array WORD 1000h,2000h,3000h
  .code
    mov ebx,OFFSET array
    mov esi,2
    mov ax,[ebx+esi]	; AX = 2000h
  ```
  - 表格的例子
    ![](https://s1.ax1x.com/2020/10/26/BKU6nf.png)
- **相对基址变址操作数**:有效地址偏移＝偏移＋基址寄存器＋变址寄存器
  - 几种常见的格式：
    - **[base + index + displacement]**
    - **displacement[base + index]**
    - **displacement[base][index]**
  - 偏移(Displacement)：变量的名字；常量表达式
  - 基址、变址：
    - 保护模式：任意32位寄存器
    - 实地址模式：BX、BP；SI、DI
  - 表格的例子：tableB[ebx + esi]

### 习题

#### 3.8

在DATA为首地址的内存区域中存放100个无符号数，试编写程序找出其中最大的数，并将其放在KVFF中。

```asm
stack segment stack
    db 512 dup(?)
stack ends 

data segment
    nums db 170, 248, 69, 67, 81, 104, 76, 178, 226, 201
    db 234, 230, 194, 85, 206, 92, 63, 28, 211, 237, 195, 240, 225
    db 126, 117, 173, 162, 78, 179, 252, 9, 202, 23, 152, 125, 32, 16
    db 86, 165, 27, 190, 137, 37, 172, 13, 228, 112, 146, 75, 225, 65 
    db 92, 150, 38, 77, 43, 233, 94, 88, 118, 60, 127, 214, 69, 44, 25 
    db 134, 137, 154, 209, 167, 32, 174, 13, 178, 65, 74, 35, 234, 95 
    db 70, 179, 98, 140, 185, 159, 14, 114, 105, 239, 137, 147, 227, 238
    db 228, 198, 135, 220, 203, 255
    KVFF db ?
data ends

code segment
assume CS:code, DS:data, SS:stack
start:
    mov ax, data
    mov ds, ax
    mov dl, 0
    mov si, OFFSET nums
    mov cx, 100
comp:
    cmp dl, BYTE PTR [si]
    jb  exch
L:
    inc si
    loop comp
    mov KVFF, dl
    mov ah, 4ch
    int 21h
exch:
    mov dl, BYTE PTR [si]
    jmp L
code ends
end start
```

#### 3.13

试编写程序，给从内存40000H到4BFFFH的每个单元均写入55H，并逐个单元读出比较。若写入的与读出的完全一致，则将AL置7EH，否则将AL置81H。

```asm
stack segment stack
    db 512 dup(?)
stack ends

code segment
assume cs:code, ss:stack
start:
    mov ax, 4000h
    mov ds, ax
    mov si, 0000h
    mov cx, 0BFFFh

write:
    mov BYTE PTR [si], 55h
    inc si
    loop write
    mov si, 0000h
    mov cx, 0BFFFh
read:
    cmp BYTE PTR [si], 55h
    jnz  not_equal

equal:
    inc si
    loop read
    mov al, 7eh
    mov ax, 4c00h
    int 21h

not_equal:
    mov al, 81h
    mov ax, 4c00h
    int 21h

code ends
end start
```

## 总线技术

### 总线概述

#### 总线的分类

- 按连接的层次
  - 片内总线
  - 元件级总线
  - 系统总线（内总线）
  - 通信总线（外总线、I/O总线）
  ![](https://s1.ax1x.com/2020/11/01/B00gX9.png)
- 按数据传输位数
  - 并行总线
  - 串行总线 

### 标准化总线

#### 内总线

- **ISA总线**(Industry Stanrard Architechure)
  - ISA特点
    - 支持8位、16位操作
    - 将将XT与AT总线的运行速度提升至8MHz
    - 更强调I/O处理能力：64KB的I/O空间、11级硬件中断、7级DMA通道
    - 地址、数据多路复用
    - 是多主控设备总线、带处理器的智能卡都可以成为ISA的主控设备
    - 曾广泛流行，支持的厂商众多
  - 信号定义
    - 数据总线为16位（支持8位、16位操作）
      - 提速：$ \overline{0WS} $，零等待状态，也叫$ \overline{NOWS} $（No Wait State）
      - 升位：$ \overline{MEMCS16},\overline{IOCS16} $ 
      - 位数可选：$ \overline{SBHE} $
    - 寻址能力达到16MB，地址、数据线不复用
    - 中断扩充为11个（PC/XT位6个）
    - DMA扩充为7个（PC/XT位4个）
    - ISA是一种多主控总线：$\overline{MASTER} $
    - 速度：CLK(B20, Output)  
      4.77MHz->8.33MHz->12MHz
- **PCI总线**(Peripheral Component Interconnect Local Bus)
  - PCI总线的特点
    - 不依赖于处理器
    - 扩充性好、多总线共存
    - 具有自动配置能力，支持即插即用（PnP）
    - 数据、地址奇偶校验功能
    - 数据宽度32位，可扩展为64位；2.0版本支持33MHz时钟，2.1版本增加了对66MHz总线操作的支持
    - 信号复用，支持无限读写突发操作
    - 支持多主控设备
    - 适应性广
    - 并行总线操作
  - 信号定义
    - PCI总线定义的信号可分为九类
      - 系统信号
      - 数据和地址信号
      - 接口控制信号
      - 仲裁信号
      - 错误报告信号
      - 中断信号
      - 高速缓存支持信号
      - 64位扩展信号
      - JTAG信号
    - PCI总线定义的信号也可分为必备和可选两大类
      - 主控设备需要49个必备信号  
        目标设备需要47必备信号
      - 可选信号线共51个，主要用于
        - 64位扩展
        - 中断请求
        - 高速缓存支持 等
- **PCIE总线**（PCI Express）

#### 外总线（通信总线）

- **RS-232C串行通信接口**
  - 特点
    - **串行异步**总线
    - 传输信号线少
      - 定义了20多个信号线
      - 实际应用中一般只用到3至7条
    - 传输距离较远。一般为**15米**
    - 采用不归零编码（NRZ）和负逻辑：逻辑1为-15V至-3V，逻辑0为+3V至+15V
    - 采用非平衡传输方式，即**单端通信**
    - 传输速率较低
  - 电气特性、引脚功能：25针/9针 D型连接器
    - 信号
      - 传送信息信号  
        TxD：发送数据线 (DTE->DCE)  
        RxD：接收数据线 (DTE<-DCE) 
      - 联络信号  
        RTS：请求发送 (DTE->DCE)  
        CTS：清楚发送 (DTE<-DCE)  
        DTR：DTE准备就绪 (DTE->DCE)  
        DSR：SCE准备就绪 (DTE<-DCE)  
        DCD：数据载波检测 (DTE<-DCE)  
        RI：振铃指示 (DTE<-DCE)
    - 电平
      |  | 数据信号 | 控制信号 |
      | - | - | - |
      | 逻辑1 | -3~-15V（传号） | +3~+15V（接通，ON状态） |
      | 逻辑0 | +3~+15V（空号） | -3~-15V（断开，OFF状态） |
      | | （一般为12V） |
    - 例：信息格式  
      传送ASCII码“C”（43H）
      ![](https://s1.ax1x.com/2020/11/02/Br1M4J.png)
  - RS-232的应用
    - 使用Modem连接
    - 软硬件系统调试：控制台、超级终端
    - 直接连接：计算机（DTE）<-> 计算机（DTE）
      - 交叉连接方式
      - 三线经济方式
  - RS423、RS422、RS485：
    - RS423：单端输出、差分接收（非平衡传输）
      - 1200米 1Kbps
      - 90米 100Kbps
    - RS422、RS485：差分输出、差分接收（平衡差分传输）
      - 1200米 100Kbps
      - 100米 1Mbps
      - 12米 10Mbps
- **USB总线**（Universal Serial Bus）
  - USB总线各版本参数比较
    ![](https://s1.ax1x.com/2020/11/02/BrdoY6.png)
    - 翻转不归零（NRZ-I）编码
      - 当数据为0时，电平翻转；数据为1时，电平不翻转
      - 比特填充技术：当数据中出现连续6个'1'时就必须插入1个'0'
      - 发送数据：并行数据->串行数据，比特填充，NRZI编码
      - 接收数据：NRZI解码，去除填充比特，转换成并行数据
    - 8b/10b编码
      - 传送的信息以每8比特为一组被编码为一个10比特的数据；接收端将10比特数据解码还原为8比特数据
      - 目的：使得整个比特流中尽量保持了0和1的平衡
      - SATA、PCI-Express也使用了8b/10b编码
      - USB3.2使用128b/132b编码
  - 对USB的需求
    - 当时PC机I/O模式的缺点
      - PC外设日益丰富，接口、扩展槽有限；种类日益繁多的接口电缆线
      - I/O资源分配(I/O空间、IRQ、DMA)->接口卡一多，上述资源可能耗尽
      - 热插拔、PnP的需求
    - USB2.0的特点/优点
      - 单一接口类型
      - 每个USB总线支持127个外设
      - 整个USB系统只用一个端口、一个中断->节省系统资源
      - 支持热插拔、动态加载驱动程序；带电拔出后自动回收资源；PnP，自动配置
      - 三种速率，适应不同类型外设
      - 设备供电
      - 四种传输类型
        - 控制传输
        - 同步传输
        - 中断传输
        - 批量传输
  - USB3.0
- **ATA总线**
  - PATA
  - SATA

### 总线的驱动和控制

#### 总线竞争与负载

- **总线竞争**：同一总线上，同一时刻，有两个或两个以上的器件输出其状态
  - TTL：此时总线上会是一种不高不低的非TTL电平，严重时会烧坏器件
    ![](https://s1.ax1x.com/2020/11/10/BbHwOf.png)
  - 对集电极开路输出：线与逻辑（Open Collector）
    ![](https://s1.ax1x.com/2020/11/10/BbHBm8.png)
  - 用三态电路严格，控制逻辑
    ![](https://s1.ax1x.com/2020/11/10/BbHd6P.png)
- **总线的负载**
  - 直流负载
    - 输出高电平时，驱动门的$ I_{OH} \ge \sum_{i=1}^{N}{IH_i} $
    - 输出高电平时，驱动门的$ I_{OL} \ge \sum_{i=1}^{N}{IL_i} $
  - 交流负载：$ C_P \ge (\sum_{i=1}^{N}{C_{Ii}+$电路板布线引入的电容$+$传输线引入的电容}) $
  ![](https://s1.ax1x.com/2020/11/10/BbOi9J.png)

#### 总线驱动设计

- 几种常用的芯片
  - 单向驱动器（三态输出）
    ![](https://s1.ax1x.com/2020/11/10/BbXoWQ.png)
  - 双向驱动器（三态输出）
    ![](https://s1.ax1x.com/2020/11/10/BbXTzj.png)
  - 锁存器（三态输出）
    ![](https://s1.ax1x.com/2020/11/10/BbXIJg.png)
- 系统总线的驱动与控制
- 扩展插件板（卡）的板内驱动

- **例题**
  - 某内存板，板内地址为A0000H～FFFFFH，试画出板内双向数据总线驱动与控制电路。
    - 防止总线竞争原则：只有当CPU读本电路板内的内存地址时，才允许双向驱动器指向系统总线的三态门是导通的。
    - 对板内内存地址进行分析，找出地址特征。A0000H～FFFFFH
      ![](https://s1.ax1x.com/2020/11/10/BbzM6J.jpg)
    - 设计译码电路，用来控制双向数据总线驱动器，使之满足防止总线竞争原则。
      ![](https://s1.ax1x.com/2020/11/10/Bqp3i6.jpg)
  - 某微型机电路板上有内存C0000H～EFFFFH和接口A000H～BFFFH，试画出该电路板板内双向数据总线驱动与控制电路。（P128，例4.3）
    - 防止总线竞争原则：只有当CPU读板内内存或读板内接口时，才允许双向数据驱动器指向系统总线的三态门是导通的。
    - 地址分析（内存地址、接口地址）
      ![](https://s1.ax1x.com/2020/11/10/Bq9DB9.jpg)
    - 画驱动与控制电路
      ![](https://s1.ax1x.com/2020/11/10/BqCF3T.jpg)
      - 几种可供选择的译码方式
         - 基本门电路
         - 译码器，如74LS138
         - 译码PROM
         - CPLD、FPGA
  - 采用8086 CPU的微机系统，其主存地址范围为C0000H～C7FFFH，由4块大小为8k8b的芯片构成主存板，试画出板内双向数据总线驱动控制电路及单向信号驱动电路。
    - 主存地址分析
      ![](https://s1.ax1x.com/2020/11/10/BqEuUH.jpg)
    - 双向数据总线驱动控制电路及单向信号驱动电路
    ![](https://s1.ax1x.com/2020/11/10/BqkuLD.jpg) 

### 总线设计中的工程问题

#### 总线交叉串扰

- 减少总线长度
- 增加总线间的距离
- 降低总线上的负载
- 降低总线信号的工作频率
- 两条信号线之间加一条地线
- 减少总线的平行走向
- 圆滑脉冲信号的边缘
- 采用双绞线

#### 总线的延时

- 尽量减少总线长度
- 采用延时小、输出输出电容小、驱动能力强的元器件
- 需要同步的信号线，布线时候应匹配长度

#### 总线信号的反射

- 在满足系统功能的前提下，降低传输信号的频率
- 尽量使信号源内阻、总线特性阻抗、负载阻抗三者相匹配
- 限制总线长度

### PC中的总线

#### 8086微处理器16位微机：ISA总线

- 总线信号依据8086处理器信号定义
- 8086处理器与ISA总线可以实现直接对接
- 利用ISA总线可以直接读写主存或I/O接口

#### 80386微处理器32位微机：与CPU无关的PCI总线

- PCI总线具有较快的数据传输速率
- PCI总线支持即插即用和热插拔
- 基于PCI总线的微机系统还支持多总线结构，进而使系统具有一定的并行操作能力


## 存储技术

### 概述

#### 存储器的分类

![](https://s1.ax1x.com/2020/11/11/BvPyrV.jpg)

#### 主要性能指标

- 容量
- 速度：存取时间
- 成本：价格

### 常用存储器芯片及连接使用

#### 静态随机读/写存储器（SRAM）及接口设计

- 静态随机读写存储器（Static Random Access Memory
- 分类
  - 同步型
  - 异步型

- **异步SRAM**

  - **典型芯片**：6264（8K $\times $ 8bit）
    - 引线
      ![](https://s1.ax1x.com/2020/11/11/BvAofe.jpg)
    - 工作过程、时序
      - 写入时序
        ![](https://s1.ax1x.com/2020/11/11/BvEWcj.jpg)
      - 读出时序
        ![](https://s1.ax1x.com/2020/11/11/BvEfjs.jpg)
  - **连接使用**
    - 全地址译码与部分地址译码
      - SRAM 6264全地址译码连接
        ![](https://s3.ax1x.com/2020/11/11/BvV6q1.jpg)
      - SRAM 6264部分地址译码连接
        ![](https://s3.ax1x.com/2020/11/11/BvVyrR.jpg)
    - 译码电路的选择
      - 利用译码芯片
        ![](https://s3.ax1x.com/2020/11/11/BveU9U.jpg)
        ![](https://s3.ax1x.com/2020/11/11/Bvea3F.jpg)
      - 使用ROM作译码器  
        现在要用4片6264构成一个存储容量为32KB的存储器，其地址空间为E0000H～E7FFFH。用一块512×4的PROM芯片63S241作为ROM译码器
        ![](https://s3.ax1x.com/2020/11/11/BvljJI.gif)
      - 利用数字比较器作译码器
        ![](https://s3.ax1x.com/2020/11/11/Bv10TH.jpg)
      - 利用PLD做译码器
  - 存取时间
    - 控制信号的连接：8088/8086 最小模式、最大模式$ M/\overline{IO},\overline{RD},\overline{WR} => \overline{MEMR},\overline{MEMW} $
    - 例：已知8088微处理器时钟为4.77MHz，地址延时时间$t_{da}＝110ns$，存储系统各种附加的延时时$t_D$＝200ns。问：用存取周期为250ns的存储芯片能否满足系统要求？  
    $$
    \begin{align}
    t(R,W)+t_{da}+t_D &{\le} 3T \cr
	  t(R,W) &{\le} 3T－ t_{da}－ t_{D} \cr
		3×210－200－110 &＝ 320ns \cr
    \end{align}
    $$
		为存储器提供的存取时间  
    存储器要求的存取时间为250ns → 能满足系统要求

#### 只读存储器（ROM）及接口设计

- **EPROM**（紫外线可擦除只读存储器）：2764芯片（8K$\times 8bit）
  - 引线
    - A12~A0
    - D7~D0
    - $\overline{CE}$：片选
    - $\overline{OE}$：数据输出允许
    - $\overline{PGM}$：编程时：编程脉冲输入；读时：“1”
  - 连接：若利用全地址译码将EPROM 2764接在首地址为A0000H的内存区，试画连接图
    ![](https://i.postimg.cc/434VS3rF/1.jpg)
  - 编程
    - 擦除：紫外线 15～20min → 每单元内容均为FFH
    - EPROM编程
    ![](https://s3.ax1x.com/2020/11/11/BvwFJS.jpg)
    ![](https://s3.ax1x.com/2020/11/11/Bvwii8.jpg)
    ![](https://s3.ax1x.com/2020/11/11/BvwCIf.jpg)

- **EEPROM**
  - 典型EERROM芯片介绍：98C64A
    - 优点：可单字节随机读写（不需擦除，直接读写）
    - 缺点：存储密度高，单位成本高
  - 连接使用：将55H写满98C64A
    ![](https://s3.ax1x.com/2020/11/16/Dkq6XR.jpg)
    ![](https://s3.ax1x.com/2020/11/16/DkO9PO.jpg)
- **闪存EEPROM：FLASH**
  - NOR型
    - 独立数据、地址总线，可以随机**快速读取**
    - **读操作速度快，擦除、编程速度慢**
  - NAND型
    - 以**页**(256或512B)为单位读/编程
    - 以**块**(4K、8K、16K)为单位擦除（最多4ms）
    - 串行读取快、**随机读取慢**

#### 其他存储器

- 双端口存储器
- 先进先出（FIFO）存储器
- 铁电存储器（FRAM）


### Intel 16/32位微机系统的主存设计（SRAM部分）

#### 8086、8088处理器的内存接口

- 存储器SRAM 6116（$ 2K\times 8bit）$ 与8088的8位总线连接
- SRAM 6116与8086的16位总线连接
  - $ \overline{A0}$选偶地址
  - $ \overline{BHE} $选奇地址

- 存储器的字扩充
  ![](https://s3.ax1x.com/2020/11/11/BvYiPH.jpg)
- 存储器的位扩充
  ![](https://s3.ax1x.com/2020/11/11/BvYnZ8.jpg)
  - 6264与8086系统总线的连接
    ![](https://s3.ax1x.com/2020/11/11/BvYfFe.jpg)

#### 80386、80486的内存接口

- 与内存接口相关的信号
  - 地址信号**A2～A31**共30个地址信号，其编码可寻址1G个32位的存储单元。这里没有A0和A1，这两个信号已在80386、80486内部译码，用于产生4个体选择信号。
  - 体选择信号$ \overline{BE0}～\overline{BE3} $
  - 32位的数据信号**D0～D31**分为4个字节，分别是D0～D7、D8～D15、D16～D23 和 D24～D31。
  - 控制信号$ M/\overline{IO} $
  - $D/\overline{C}$（数据/控制）信号，低电平为**处理器中止或正在响应中断**，高电平表示正在**传送数据**；
  - $W/\overline{R}$（读/写）信号，低电平表示读内存或接口，高电平表示写内存或接口
    ![](https://s3.ax1x.com/2020/11/11/BvNJET.jpg)

#### Pentium处理器的内存组织

### 动态随机读/写存储器（DRAM）及接口设计

#### 简单异步DRAM

- 引线
  - 地址线复用：先输入行地址，再输入列地址
  - $\overline{WE}$写允许
  - $D_{IN}、D_{OUT} $
- 工作方式及时序
  - 读操作
    ![](https://s3.ax1x.com/2020/11/16/DATxuq.jpg)
  - 写操作
    - 提前写
      ![](https://s3.ax1x.com/2020/11/16/DA718H.jpg)
    - 读变写
      ![](https://s3.ax1x.com/2020/11/16/DAX0iV.jpg)
- 刷新：2-4ms刷新一次
- 连接使用/接口设计
  - 行列信号的形成
    ![](https://s3.ax1x.com/2020/11/16/DAjcp8.jpg)
  - 读写
  - 刷新
    ![](https://s3.ax1x.com/2020/11/16/DAvEBd.jpg)

#### 同步动态存储器SDRAM

- 概述
  - SDR SDRAM（Single Data Rate Synchronous Dynamic RAM）：单倍速率同步动态随机存储器
    - 只在时钟的上升沿传输命令、地址和数据
  - DDR(Double Date Rate)
    - 时钟上升沿、下降沿各传送一次数据
    - 从DDR2开始，接口的频率开始高于存储单元的核心频率
  ![](https://s3.ax1x.com/2020/11/20/DM4yZ9.jpg)
  - SDRAM和标准DRAM的主要不同
    - 同步和异步
    - 内部组织结构
      - SDRAM内部分体
      - 标准的DRAM可以看成内部只有一个体的SDRAM
    - 读写方式不同
      - SDRAM具有突发读写能力
        - 突发(Burst)是指在同一行中相邻的存储单元连续进行数据传输的方式。
        - 连续传输所涉及到的存储单元(列)的数量就是突发长度(Burst Lengths，BL)
    - 智能化
      - 在SDRAM芯片内部设置有**模式寄存器**
      - 一般的标准DRAM只有一种工作模式
- 典型的SDRAM芯片(三星K4S511632D(32M×16 bit SDRAM))
  - 引线
    - 地址输入
      - 行地址：RA0~RA12
      - 列地址：CA0~CA9
    - bank地址输入
    - 数据输入/输出
    - 输出允许
  - 常用指标
    - 容量：存储单元×体×每单元存储位数
    - 时钟周期
    - 存取时间
    - CAS的延迟时间（Cas latency）
    - 综合性能的评价：总延迟时间=系统时钟周期×CL模式数+存取时间
  - 时序
    ![](https://s3.ax1x.com/2020/11/22/D87VQs.jpg)

- SDRAM控制器
  - 实现方式
    - 以**南北桥芯片组**为主要核心的PC机系统
    - 某些为微处理器中**集成**了SDRAM控制器
    - **设计**与CPU或系统总线连接的独立SDRAM控制器，SDRAM芯片连接在SDRAM控制器上
  - SDRAM的基本操作
    - 对SDRAM的访问的三种情况
      - 当前访问的行所在的存储体中，**行缓冲器**是关闭的
        - 发送**激活**命令
        - 发送**读写**命令和**列地址**
        - 读写延迟中等
      - 当前访问的行的数据，刚好保存在相应存储体的**行缓冲器**中
        - 直接发送**读/写命令**和**列地址**
        - 读写延迟最小
      - 当前访问的行所在的存储体中，**行缓冲器打开**，**存的是另一个行的数据**
        - 先发送**Percharge**或**Precharge All**命令关闭行缓冲器
        - 再发送**激活**命令激活该行
        - 最后发送**读/写**和**列地址**
        - **读/写**延迟最大
  - SDRAM控制器的基本组成
    - 连续内存地址映射
      ![](https://s3.ax1x.com/2020/11/22/DGNatg.jpg)
    - 交错内存地址映射：将连续的逻辑地址映射到不同的存储体中
      ![](https://s3.ax1x.com/2020/11/22/DGNWh4.jpg)
  - SDRAM的控制优化
    - 行关闭优先策略（Close-Page Policy）：行激活、列读/写、预充电
    - 行打开优先策略（Open-Page Policy）
      - 访问请求**空间局部性很好**，大大**减少读写延迟**
      - 访问请求**空间分布很分散**，造成**较大读写延迟**

#### DDR SDRAM

- DDR SDRAM与SDRAM的不同
  - 初始化
  - 时钟
  - 数据选取脉冲
  - 写入延时
  - **突发长度和写入掩码**
    - DDR SDRAM，突发长度只有2、4、8，没有SDRAM的**随机存取的操作**和**全页触发方式**；同时，突发长度的定义不再指所连续寻址的存储单元数量，而是指**连续的传输周期数**
    - 对于突发写入，如果其中有不想存取的数据，仍可以使用**DM信号进行屏蔽**
  - 延迟锁定回路

### 习题

#### 5.5

已有两片6116，现在欲将它们连接到8088系统中去，其地址范围为40000H~40FFFH，试画连接电路图，写入某数据并读出与之比较；如有错，则在DL中写入01H；若每个单元均对，则在DL中写入EEH，试编写此检测程序。

![](https://s3.ax1x.com/2020/11/18/DnMO7F.png)
![](https://s3.ax1x.com/2020/11/18/DnQy4J.png)
![](https://s3.ax1x.com/2020/11/18/DnMvtJ.png)
![](https://s3.ax1x.com/2020/11/18/DnMxh9.png)

#### 5.10

将4片6264连接到8086系统总线上，要求内存地址范围为7000H~77FFFH，画出连接图。

![](https://s3.ax1x.com/2020/11/18/DnMjk4.png)
![](https://s3.ax1x.com/2020/11/18/DnQSpR.png)

#### 5.16

现有容量为32K×4bit的SRAM芯片。  
在8086系统中，利用这样的芯片构成从88000H～97FFFH的内存，画出最大模式下包括总线驱动在内的此芯片与系统总线的连接图（译码器件自行选择）

![](https://s3.ax1x.com/2020/11/18/DnIgJK.png)
![](https://s3.ax1x.com/2020/11/18/DnIyIx.png)
![](https://s3.ax1x.com/2020/11/18/DnIci6.png)


## 输入输出技术

### I/O概述

#### 基本输入/输出方法

- **程序控制**I/O方式
  - **无条件**传送方式：输入接口、输出接口
  - **查询**方式：单外设、多外设
  - **中断**防守
- **DMA**（直接存储器）方式

#### I/O接口概述

- I/O接口能做什么
  - 提供信息通道
  - 进行数据格式转换
  - CPU和外设速度匹配
  - 负载匹配
  - 时序匹配
  - 总线隔离
  - 提供中断、DMA能力
- 外设接口与端口
  - 统一编址的优点
    - CPUduiI/O端口的读写操作可是使用全部**存储器**的读/写数据操作指令
    - 内存与外设地址的分配可以用统一的分配图
    - 不需要专门的**输入、输出**操作**指令**
  - 统一编址的缺点
    - 使得系统中**实际**可以**直接寻址的内存单元数减少**
    - 给**检修、维护**增加了难度
    - 一般系统中I/O端口数远小于内存单元数，所以统一编址使得**指令代码较长**，**读/写执行时间也较长**
    - Motorola的M68系列采用**统一编址**，Intel的86x86系列CPU采用**独立编址**方式

#### I/O端口地址译码

![](https://s3.ax1x.com/2020/11/23/DYDNqJ.jpg)

#### 基本的并行输入（三态门）/输出（锁存器）接口

- 并行输入接口
  ![](https://s3.ax1x.com/2020/11/23/DYrKyD.jpg)
- 并行输出接口
  ![](https://s3.ax1x.com/2020/11/23/DYsd9x.jpg)

### 程序查询I/O方式

#### 无条件传送方式

#### 查询方式
  ![](https://s3.ax1x.com/2020/11/23/DYyBin.jpg)

  ![](https://s3.ax1x.com/2020/11/23/DYfU1A.jpg)
  ![](https://s3.ax1x.com/2020/11/23/DYfa6I.jpg)
  ![](https://s3.ax1x.com/2020/11/23/DYfdXt.jpg)

- 多外设的查询控制
  ![](https://s3.ax1x.com/2020/11/23/DYhZHf.jpg)
  ![](https://s3.ax1x.com/2020/11/23/DYhVDP.jpg)

### 中断方式

#### 8086/8088中断系统

- 中断源类型
  - 与中断有关的控制线：$ NMI、INTR、\overline{INTA} $
  - 8088系统中的中断源
    - 内部中断
      - **除法溢出**：类型号为**0**
      - **单步中断**：类型号为**1**
      - **断点中断**：类型号为**3**
      - **溢出中断**：类型号为**4**
      - **软件中断**：即INT n指令
    - 外部中断
      - 非屏蔽中断**NMI**：类型号为**2**，不可用软件屏蔽，CPU必须响应它
      - 可屏蔽中断**INTR**：类型号由*PIC*提供。IF=1时CPU才能响应它
- 中断向量表（IVT）
  - 用于存放各类中断服务程序的入口地址（段和偏移）
  - 表的地址位于内存的00000H~003FFH，大小为1KB，共256个入口
  - 每个入口占4 Bytes
  - 中断向量在IVT中的存放地址 = 4 * 中断类型号

#### 可编程中断控制器8259

- 8259内部结构
  ![](https://s3.ax1x.com/2020/11/25/DdpJoV.jpg)
  - 中断请求寄存器IRR
  - 中断服务寄存器ISR
  - 中断屏蔽寄存器IMR
  - 中断优先权判别电路
- 引脚功能
  ![](https://s3.ax1x.com/2020/11/25/DdCoPf.jpg)
- 8259工作方式
  - 中断结束方式
    - 非自动：在中断程序中提供EOI命令
    - 自动：无需EOI命令、第2个$\overline{INTA}$后沿
  - 缓冲方式：缓冲、非缓冲
  - 嵌套方式
    - 一般嵌套：单片使用；级联方式从属
    - 特殊嵌套：级联方式主控制器
  - 屏蔽方式：一般屏蔽、特殊屏蔽
  - 优先级规定：固定优先级、循环优先级
  ![](https://s3.ax1x.com/2020/11/25/DdFhZ9.jpg)
- 8259级联
  ![](https://s3.ax1x.com/2020/11/25/DdEdqe.jpg)

- 8259编程使用
  - 内部寄存器的寻址方法
    ![](https://s3.ax1x.com/2020/11/25/DdVbtA.jpg)
  - 初始化命令字ICW
    - 注意
      - 写ICW1意味着重新初始化8259
      - 写ICW1后，8259的状态如下
        - 清除ISR和IMR（全0）
        - 将中断**优先级**设置为初始状态
        - 设置为**一般屏蔽**方式
        - 采用**非自动中断结束**方式
        - 状态读出逻辑预置为读IRR
    - ICW1：初始化字
      ![](https://s3.ax1x.com/2020/11/25/DdeDIJ.jpg)
    - ICW2：中断向量码
      ![](https://s3.ax1x.com/2020/11/25/DdmVwF.jpg)
    - ICW3：级联控制字
      ![](https://s3.ax1x.com/2020/11/25/Ddmflq.jpg)
    - ICW4：中断结束方式字
      ![](https://s3.ax1x.com/2020/11/25/DduMqK.jpg)
  - 操作命令字OCW
    - OCW1：中断屏蔽字
      ![](https://s3.ax1x.com/2020/11/25/DdQ0Z6.jpg)
    - OCW2：中断结束和优先级循环
      ![](https://s3.ax1x.com/2020/11/25/DdlQld.jpg)
    - OCW3：屏蔽方式和读出控制字
      ![](https://s3.ax1x.com/2020/11/25/Dd1w4O.jpg)

#### 中断方式及实现方法

- 连接8259
  ![](https://s3.ax1x.com/2020/11/25/Dd1bbq.jpg)
- 编写中断初始化程序
  - 初始化8259
    ![](https://s3.ax1x.com/2020/11/25/Dd8Vwq.jpg)
    ![](https://s3.ax1x.com/2020/11/25/Dd8Emn.jpg)
    ![](https://s3.ax1x.com/2020/11/25/Dd8kOs.jpg)
  - 设置中断向量表
    ![](https://i.postimg.cc/MKC6z9jn/1.jpg)
  - 中断服务程序框架
    ![](https://i.postimg.cc/MZhHG6CZ/1.jpg)

### 直接存取器（DMA）方式

#### DMA工作过程

- 通过特殊硬件**DMA控制器**实现，传输速率高
- 外设**直接**与存储器进行数据交换，CPU不再作为中介者
- 总线由DMA控制器（DMAC）进行控制，CPU放弃总线控制权，内存/外设的**地址**和**读写控制信号**均由DMAC提供

![](https://i.postimg.cc/dttHLFrX/1.jpg)

### 习题

#### 6.6

叙述8086/88软件中断指令INT n的执行过程

- CPU**取INT n指令**，经指令译码获知这是一条中断指令，且该软件中断的中断向量码为n
- 将**PSW、CS、IP**压入**堆栈**保护起来，并**关中断**
- $ n \times 4 $ 得到中断向量表地址，从该地址开始的顺序两个字节的内容送IP，下两个字节的内容送CS，即$n \times 4\to IP,(n\times4+2)\to CS $
- 开始执行**中断服务**程序。（中断服务程序的入口地址早已填入中断向量表中）
- 中断服务程序的最后一条指令IRET，从堆栈恢复IP、CS、PSW，**中断返回**

#### 6.8

输入接口地址为04E5H，输出接口地址为E504H。
编程序：
若输入接口的bit3、bit4和bit7同时为1，将以DATA为首地址的10个内存数据连续由输出接口输出，若不满足条件则等待

![](https://i.postimg.cc/xCzqpjjx/Fia-VVso5-Pa9-EP-Ano3fe0-AOcni-Xj.png)

#### 6.9

若：系统只有一片8259，8259地址为E010H和E011H，允许8个中断源边沿触发，不需要缓冲，以一般嵌套方式工作，中断向量为40H，非自动EOI方式

1. 编写初始化程序
![](https://i.postimg.cc/pLqTWWWT/6-9-1.png)
![](https://i.postimg.cc/zfvf3svk/6-9-2.png)
2. 若允许中断嵌套，编写中断服务程序框架，包括返回前发送EOI命令。中断服务程序名称为IPROC40
![](https://i.postimg.cc/76TYnSgG/6-9-3.png)
3. 编程序，将上述中断处理程序的入口地址填入中断向量表
![](https://i.postimg.cc/HLNkM671/6-9-4.png)


## 常用接口器件

计算机和外设之间如何通过接口传送数据（非DMA）
![](https://i.postimg.cc/ZqQ3YDm0/1.jpg)
![](https://i.postimg.cc/QCGT19H3/2.jpg)
![](https://i.postimg.cc/C5GfNhqf/3.jpg)

### 可编程并行接口8255

#### 内部结构及外部总线

![](https://i.postimg.cc/rFbLJ1qx/1.jpg)

#### 8255的工作方式

- 工作方式0：基本输入输出方式
  - A口（PA0~PA7）：输入（无锁存能力）或输出（有锁存能力）
  - B口（PB0~PB7）：输入（无锁存能力）或输出（有锁存能力）
  - C口（PC4~PC7）：输入（无锁存能力）或输出（有锁存能力）
  - C口（PC0~PC3）：输入（无锁存能力）或输出（有锁存能力）
- 工作方式1：选通输入输出方式
  ![](https://i.postimg.cc/yNRQH94q/1.jpg)
- 工作方式2：双向输入输出方式（仅A口）
  - PC3-PC7：A口方式2下的控制线
  - PC0-PC2：输入或输出或B口方式1下的控制线
  - B口：方式0或方式1

#### 8255的方式控制字及状态字

- 控制字
  ![](https://i.postimg.cc/SK7yKnC5/1.jpg)
- 状态字
  ![](https://i.postimg.cc/nz2BqcbS/1.jpg)

#### 8255的寻址及连接使用

![](https://i.postimg.cc/QxJkp31T/1.jpg)

#### 8255的初始化及应用举例

- 方式0——打印机接口
  ![](https://i.postimg.cc/bwY0gB9F/2.jpg)
  ![](https://i.postimg.cc/Qd6QyJ6N/3.jpg)
  ![](https://i.postimg.cc/hGfLWQwL/4.jpg)
- 方式1——打印机接口
  ![](https://i.postimg.cc/ZqGVwLRB/1.jpg)
  ![](https://i.postimg.cc/tTFDwVZr/2.jpg)
  - 程序查询方式
    ![](https://i.postimg.cc/T1GQ6YnT/3.jpg)
  - 中断方式
    ![](https://i.postimg.cc/hGfLWQwL/4.jpg)

### 可编程定时器8253

#### 工作方式

- 方式0：计数结束产生中断
![](https://s3.ax1x.com/2020/12/07/DzF7lt.jpg)
- 方式1：可编程单稳
![](https://s3.ax1x.com/2020/12/07/DzFIfA.jpg)
- 方式2：频率发生器
![](https://s3.ax1x.com/2020/12/07/DzFTSI.jpg)
- 方式3：方波发生器
![](https://s3.ax1x.com/2020/12/07/DzF4FH.jpg)
- 方式4：软件触发选通
![](https://s3.ax1x.com/2020/12/07/DzF5Yd.jpg)
- 方式5：硬件触发选通
![](https://s3.ax1x.com/2020/12/07/DzFbOf.jpg)

#### 8253的控制字

![](https://s3.ax1x.com/2020/12/07/Dzkju6.jpg)

### 习题

#### 7.1

若8253芯片可利用8088的外设接口地址为D0D0H～D0D3H，试画出电路连接图。设加到8253上的时钟信号为2MHz。
若利用计数器0、1和2产生周期为100μs的对称方波以及每1s、10s产生一个负脉冲，试说明8253如何连接，并编写初始化程序。
![](https://s3.ax1x.com/2020/12/07/DzAZb8.jpg)
![](https://s3.ax1x.com/2020/12/07/DzAmVS.jpg)

#### 7.2

- 若8255芯片可占用的地址为FE00～FEFFH，试画出它与8086总线的连接图。
- A/D变换器的引线及工作时序图如下，试将此A/D变换器与8255相连接，并编写包括初始化程序在内的、变换一次数据并将数据放在DATA中的程序

![](https://s3.ax1x.com/2020/12/07/DzANaF.jpg)
![](https://s3.ax1x.com/2020/12/07/DzAtVU.jpg)

#### 7.3

说明8253的6种工作方式。若如加到8235上的时钟频率为0.5MHz，则一个计数器的最长定时时间是多少？若要求美10min产生一次定时中断，试提出解决方案


- 方式0：计数结束中断，输出一个正跳变
- 方式1：硬件可重复触发的单稳态触发器，输出一个宽度可调的负脉冲
- 方式2：比率发生器，输出序列负脉冲
- 方式3：方波发生器
- 方式4：软件触发延时选通脉冲发生器
- 方式5：硬件触发延时选通脉冲发生器

加到8253上的时钟频率是0.5MHz，则一个计数器的最长定时时间是$\frac {65536} {0.5\times 10^6}=0.131072 s$（初值为0）

计数器0和计数器1都工作于方式3（循环计数，产生周期性方波），两个计数器串联，计数器0的输出作为计数器1的时钟，计数器1的输出作为cpu中断信号用于产生定时中断。设计数器0的计数值=30000，计数器1的计数值=10000，则每计数30000×10000=3×1e8次，也即每2μs×3×108=600s=10min 产生一次定时中断


## 基于总线的I/O接口设计

### 基于ISA总线的I/O接口设计

#### LED接口

- 接口电路
  - 用通用并行接口芯片作接口
  ![](https://i.postimg.cc/zfmQgSpJ/1.jpg)
  ![](https://i.postimg.cc/T2FNFv5k/1.jpg)
  - 用LED译码器作接口：DM9368
  ![](https://i.postimg.cc/TYvqndDX/1.jpg)
  ![](https://i.postimg.cc/PqJmdNB1/1.jpg)
  利用上图电路中的4个数码管，实现将存储单元 BUF中的4位十六进制数加以显示，并每经过1秒，重新读取BUF单元数据，更新显示，则控制程序如下：
  ![](https://i.postimg.cc/NFky6w3g/8.jpg)
- 动态显示的接口电路
  - 用通用接口芯片
  ![](https://i.postimg.cc/52Y41Vs6/1.jpg)
  - 用专用接口芯片：MM74C912/917
  ![](https://i.postimg.cc/pTV3WQPq/1.jpg)
  ![](https://i.postimg.cc/pLZgg1Hp/1.jpg)

#### 键盘接口

- 非编码式键盘
  ![](https://i.postimg.cc/rw0rH7W9/1.jpg)
