<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>C&#43;&#43; on fffzlfk&#39;s Blog</title>
    <link>https://fffzlfk.github.io/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on fffzlfk&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 05 Feb 2022 14:10:47 +0800</lastBuildDate><atom:link href="https://fffzlfk.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C&#43;&#43; 完美转发</title>
      <link>https://fffzlfk.github.io/posts/c&#43;&#43;_%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</link>
      <pubDate>Sat, 05 Feb 2022 14:10:47 +0800</pubDate>
      
      <guid>https://fffzlfk.github.io/posts/c&#43;&#43;_%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</guid>
      <description>为什么要有完美转发 下面是一个类工厂函数：
template &amp;lt;typename T, typename Arg&amp;gt; std::shared_ptr&amp;lt;T&amp;gt; factory(Arg arg) { return std::shared_ptr&amp;lt;T&amp;gt;( new T(arg)); } 参数对象arg在上面的例子中是传值方式传递，这带来了生成额外临时对象1的代价，所以我们改成引用传递：
template &amp;lt;typename T, typename Arg&amp;gt; std::shared_ptr&amp;lt;T&amp;gt; factory(Arg &amp;amp;arg) { return std::shared_ptr&amp;lt;T&amp;gt;( new T(arg)); } 但这种实现的问题是不能绑定右值实参。如factory&amp;lt;X&amp;gt;(42)将编译报错，进一步的，我们按常量引用来传递：
template &amp;lt;typename T, typename Arg&amp;gt; std::shared_ptr&amp;lt;T&amp;gt; factory(const Arg &amp;amp;arg) { return std::shared_ptr&amp;lt;T&amp;gt;( new T(arg)); } 这种实现的问题是不能支持移动语义，形参使用右值引用可以解决完美转发问题。
引用折叠 在C++11之前，我们不能对一个引用类型继续引用，但C++由于右值引用的出现而放宽2了这一做法，从而产生了引用折叠规则，允许我们对引用进行引用，既能左引用，又能右引用。但是却遵循如下规则：
   函数形参类型 实参类型 推导后函数形参类型     T&amp;amp; 左引用 T&amp;amp;   T&amp;amp; 右引用 T&amp;amp;   T&amp;amp;&amp;amp; 左引用 T&amp;amp;   T&amp;amp;&amp;amp; 右引用 T&amp;amp;&amp;amp;    模板参数类型推导 对函数模板template&amp;lt;typename T&amp;gt;void foo(T&amp;amp;&amp;amp;);，应用上述引用折叠规则，可总结出以下结论：</description>
    </item>
    
    <item>
      <title>从模板元编程到constexpr(C&#43;&#43;)</title>
      <link>https://fffzlfk.github.io/posts/%E4%BB%8E%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%E5%88%B0constexprc&#43;&#43;/</link>
      <pubDate>Sun, 28 Nov 2021 19:43:10 +0800</pubDate>
      
      <guid>https://fffzlfk.github.io/posts/%E4%BB%8E%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%E5%88%B0constexprc&#43;&#43;/</guid>
      <description>C++元编程</description>
    </item>
    
    <item>
      <title>子数组和问题</title>
      <link>https://fffzlfk.github.io/posts/%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 21 Feb 2021 22:46:48 +0800</pubDate>
      
      <guid>https://fffzlfk.github.io/posts/%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E9%97%AE%E9%A2%98/</guid>
      <description>the Sum of Subsequence</description>
    </item>
    
    <item>
      <title>每日一题</title>
      <link>https://fffzlfk.github.io/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</link>
      <pubDate>Sun, 10 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.github.io/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</guid>
      <description>Algorithms Problems</description>
    </item>
    
    <item>
      <title>C&#43;&#43;(临时对象的分析)</title>
      <link>https://fffzlfk.github.io/posts/c&#43;&#43;%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E6%9E%90/</link>
      <pubDate>Sat, 10 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.github.io/posts/c&#43;&#43;%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E6%9E%90/</guid>
      <description>关闭编译器优化</description>
    </item>
    
    <item>
      <title>OOP(C&#43;&#43;)</title>
      <link>https://fffzlfk.github.io/posts/oopc&#43;&#43;/</link>
      <pubDate>Tue, 06 Oct 2020 12:25:11 +0800</pubDate>
      
      <guid>https://fffzlfk.github.io/posts/oopc&#43;&#43;/</guid>
      <description>Object-Oriented Programming</description>
    </item>
    
  </channel>
</rss>
