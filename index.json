[{"content":"不正确地使用new和delete 无论我们如何努力，要释放所有动态分配的内存是非常困难的。即使我们能做到这一点，也往往不能安全地避免出现异常。让我们看一个简单的例子。\nvoid SomeMethod() { ClassA *a = new ClassA; SomeOtherMethod(); // it can throws an execption  delete a; } 如果SomeOtherMethod抛出了异常，那么a对象永远不会被删除。下面的例子展示了一个更加安全同时又更简洁的实现，使用了在C++11提出的std::unique_ptr。\nvoid SomeMethod() { std::unique_ptr\u0026lt;ClassA\u0026gt; a(new ClassA); SomeOtherMethod(); } 无论发生什么，当a退出作用域的时候，它会被释放。\n然而，这仅仅是C++中这种错误最简单的例子，还有很多例子表明delete应该在其他地方调用，也许是在外层函数或者另一个线程中。这就是为什么应该避免使用new和delete，而应该使用适当的智能指针。\n被忘记的虚析构函数 这是最常见的错误之一，如果派生类中有动态内存分配，将会导致派生类的内存泄漏。这里有一些例子，当一个类不打算用于继承，并且它的大小和性能是至关重要的。虚析构函数或任何其他虚函数在类在类中引入了额外的数据，即指向虚函数表的指针，这使得类的任何实例的大小变大。\n然而，在大多数情况下，类可以被继承，即使它的初衷并非如此。因此，在声明一个类的时候，添加一个虚析构函数是一个非常好的做法。否则，如果一个类由于性能的原因必须不包含虚函数，那么在类的声明文件里面加上一个注释，说明这个类不应该被继承，是一个很好的做法。避免这个问题的最佳选择之一是使用一个支持在创建类时创建虚析构函数的IDE。\n关于这个问题，还有一点是来自标准库的类或模板。它们不是用来继承的，也没有一个虚析构函数。例如，如果我们创建了一个公开继承自std::string的新的增强字符串类，就可能有人错误地使用它与std::string的指针或引用，从而导致内存泄漏。\nclass MyString : public std::string { ~MyString() {} }; int main() { std::string *s = new MyString(); delete s; // May not invoke the destructor defined in MyString } 为了避免这样的问题，重用标准库中的类或模板的一个更安全的方法是使用私有继承1或组合。\n用delete或智能指针删除一个数组 创建动态大小的临时数组往往是必要的。当它们不再需要时，释放分配的内存是很重要的。这里的问题是，C++需要带有[]括号的特殊删除操作符，这一点很容易被遗忘。delete[]操作符不仅会删除分配给数组的内存，而且会首先调用数组中所有对象的析构函数。对原始类型使用不带[]括号的删除操作符也是不正确的，尽管这些类型没有析构函数，每个编译器都不能保证一个数组的指针会指向数组的第一个元素，所以使用不带[]括号的delete也会导致未定义的行为。\n在数组中使用智能指针，如unique_ptr\u0026lt;T\u0026gt;, shared_ptr，也是不正确的。当这样的智能指针从作用域中退出时，它将调用不带[]括号的删除操作符，这将导致上面描述的同样问题。如果需要对数组使用智能指针，可以使用unique_ptr\u0026lt;T[]\u0026gt;的特殊化。\n如果不需要引用计数的功能，主要是数组的情况，最优雅的方法是使用STL向量来代替。它们不只是负责释放内存，而且还提供额外的功能。\n返回一个局部对象的引用 这主要是一个初学者的错误，但它值得一提，因为有很多遗留的代码都存在这个问题。让我们看看下面的代码，一个程序员想通过避免不必要的复制来进行某种优化。\nComplex\u0026amp; SumComplex(const Complex\u0026amp; a, const Complex\u0026amp; b) { Complex result; ….. return result; } Complex\u0026amp; sum = SumComplex(a, b); 对象 sum现在将指向局部对象result。但是，在执行SumComplex函数后，对象result位于哪里呢？不知道。它位于堆栈中，但在函数返回后，堆栈被收缩，函数中的所有本地对象都被析构了。这最终会导致一个未定义的行为，即使是原始类型。为了避免性能问题，有时可以使用返回值优化。\nComplex SumComplex(const Complex\u0026amp; a, const Complex\u0026amp; b) { return Complex(a.real + b.real, a.imaginar + b.imaginar); } Complex sum = SumComplex(a, b); 对于今天的大多数编译器来说，如果一个返回行包含一个对象的构造函数，代码将被优化以避免所有不必要的复制\u0026ndash;构造函数将直接在sum对象上执行。\n使用对已删除资源的引用 这些C++问题比你想象的要经常发生，而且通常出现在多线程的应用程序中。让我们考虑一下下面的代码。\n Thread 1:  Connection\u0026amp; connection = connections.GetConnection(connectionId); // ...  Thread 2:  connections.DeleteConnection(connectionId); // …  Thread 1:  connection.send(data); 在这个例子中，如果两个线程使用相同的连接ID，这将导致未定义的行为。违反访问权限的错误往往是很难发现的。\n在这种情况下，当一个以上的线程访问同一资源时，保留资源的指针或引用是非常危险的，因为其他线程可以删除它。使用带有引用计数的智能指针要安全得多，例如std::shared_ptr。它使用原子操作来增加/减少一个引用计数器，所以它是线程安全的。\n允许异常离开析构函数 并不经常需要从一个析构函数中抛出一个异常。即使如此，也有更好的方法来做到这一点。然而，异常大多不是明确地从析构器中抛出的。可能发生的情况是，一个简单的记录对象销毁的命令就会导致异常的抛出。让我们考虑以下代码。\nclass A { public: A() {} ~A() { writeToLog(); // could cause an exception to be thrown  } }; // …  try { A a1;\tA a2;\t} catch (std::exception\u0026amp; e) { std::cout \u0026lt;\u0026lt; \u0026#34;exception caught\u0026#34;; } 在上面的代码中，如果异常发生了两次，比如在销毁两个对象的过程中，catch语句就不会被执行。因为有两个并行的异常，无论它们是同一类型还是不同类型，C++运行环境都不知道如何处理，并调用一个终止函数，导致程序执行的终止。为了避免这一点C++11开始，destructor默认是noexcept。\n使用无效的迭代器和引用 关于这个问题，可以写一整本书。每个STL容器都有一些特定的条件，在这些条件下它会使迭代器和引用失效。在使用任何操作时，都要注意这些细节。就像之前的C++问题一样，这个问题在多线程环境中也会经常发生，所以需要使用同步机制来避免它。让我们看看下面的顺序代码作为一个例子。\nvector\u0026lt;string\u0026gt; v; v.push_back(“string1”); string\u0026amp; s1 = v[0]; // assign a reference to the 1st element vector\u0026lt;string\u0026gt;::iterator iter = v.begin(); // assign an iterator to the 1st element v.push_back(“string2”); cout \u0026lt;\u0026lt; s1; // access to a reference of the 1st element cout \u0026lt;\u0026lt; *iter; // access to an iterator of the 1st element 从逻辑的角度来看，这段代码似乎完全没有问题。然而，在向量中添加第二个元素可能会导致向量内存的重新分配，这将使迭代器和引用都无效，并导致在最后两行试图访问它们时出现访问违规错误。\n通过值传递对象 你可能知道，由于对性能的影响，按值传递对象是个坏主意。许多人为了避免输入额外的字符而让它保持这样的状态，或者可能想到以后再返回去做优化。这通常是不可能的，结果是导致了性能较差的代码和容易出现意外行为的代码。\nclass A { public: virtual std::string GetName() const { return \u0026#34;A\u0026#34;; } ... }; class B : public A { public: virtual std::string GetName() const { return \u0026#34;B\u0026#34;; } ... }; void func1(A a) { std::string name = a.GetName(); ... } B b; func1(b); 这段代码调用func1函数将创建一个对象b的部分副本，即它将只复制类A的部分对象b到对象a（\u0026ldquo;切片问题\u0026rdquo;）。所以在函数中，它也会调用类A的方法，而不是类B的方法，这很可能不是调用该函数的人所期望的。\n类似的问题也发生在试图捕获异常的时候，比如说：\nclass ExceptionA : public std::exception; class ExceptionB : public ExceptionA; try { func2(); // can throw an ExceptionB exception } catch (ExceptionA ex) { writeToLog(ex.GetDescription()); throw; } 当一个ExceptionB类型的异常从函数func2抛出时，它将被catch块捕获，但由于切片问题，只有ExceptionA类的一部分会被复制，不正确的方法会被调用，而且重新抛出也会向外部的try-catch块抛出一个不正确的异常。\n总而言之，总是通过引用来传递对象，而不是通过值。\n类构造函数隐式调用 虽然有时候定义的转换也非常有用，但它们会导致难以预测的转换，而且很难定位。比方说，有人创建了一个有字符串类的库：\nclass String { public: String(int n); String(const char *s); ... } 第一个方法的目的是创建一个长度为 $n$ 的字符串，第二个方法的目的是创建一个包含给定字符的字符串。但是当你有这样的东西时，问题就出现了。\nString s1 = 123; String s2 = \u0026#39;abc\u0026#39;; 在上面的例子中，s1将成为一个大小为123的字符串，而不是一个包含\u0026quot;123\u0026quot;字符的字符串。第二个例子包含单引号而不是双引号（这可能是意外发生的），这也会导致调用第一个构造函数并创建一个尺寸非常大的字符串。这些都是非常简单的例子，还有很多更复杂的情况会导致混乱和难以预料的转换，很难发现。对于如何避免这类问题，C++11开始有了explicit关键字，可以指定构造函数或转换函数为显式, 即它不能用于隐式转换和复制初始化。\n  用《Effective C++》中的话说就是private继承是实现继承。就是class Derivative 想要用class Base的函数接口，但是又不想让别人通过使用Derivative的对象来使用Base的函数接口。这时可以用private继承。或者Base和Derivative根本没有任何逻辑上的联系，单纯的D想要复用一下B的代码，这时就用private 继承。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://fffzlfk.github.io/posts/c++%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BC%96%E7%A0%81%E9%94%99%E8%AF%AF/","summary":"不正确地使用new和delete 无论我们如何努力，要释放所有动态分配的内存是非常困难的。即使我们能做到这一点，也往往不能安全地避免出现异常。让我们看一个简单的例子。\nvoid SomeMethod() { ClassA *a = new ClassA; SomeOtherMethod(); // it can throws an execption  delete a; } 如果SomeOtherMethod抛出了异常，那么a对象永远不会被删除。下面的例子展示了一个更加安全同时又更简洁的实现，使用了在C++11提出的std::unique_ptr。\nvoid SomeMethod() { std::unique_ptr\u0026lt;ClassA\u0026gt; a(new ClassA); SomeOtherMethod(); } 无论发生什么，当a退出作用域的时候，它会被释放。\n然而，这仅仅是C++中这种错误最简单的例子，还有很多例子表明delete应该在其他地方调用，也许是在外层函数或者另一个线程中。这就是为什么应该避免使用new和delete，而应该使用适当的智能指针。\n被忘记的虚析构函数 这是最常见的错误之一，如果派生类中有动态内存分配，将会导致派生类的内存泄漏。这里有一些例子，当一个类不打算用于继承，并且它的大小和性能是至关重要的。虚析构函数或任何其他虚函数在类在类中引入了额外的数据，即指向虚函数表的指针，这使得类的任何实例的大小变大。\n然而，在大多数情况下，类可以被继承，即使它的初衷并非如此。因此，在声明一个类的时候，添加一个虚析构函数是一个非常好的做法。否则，如果一个类由于性能的原因必须不包含虚函数，那么在类的声明文件里面加上一个注释，说明这个类不应该被继承，是一个很好的做法。避免这个问题的最佳选择之一是使用一个支持在创建类时创建虚析构函数的IDE。\n关于这个问题，还有一点是来自标准库的类或模板。它们不是用来继承的，也没有一个虚析构函数。例如，如果我们创建了一个公开继承自std::string的新的增强字符串类，就可能有人错误地使用它与std::string的指针或引用，从而导致内存泄漏。\nclass MyString : public std::string { ~MyString() {} }; int main() { std::string *s = new MyString(); delete s; // May not invoke the destructor defined in MyString } 为了避免这样的问题，重用标准库中的类或模板的一个更安全的方法是使用私有继承1或组合。\n用delete或智能指针删除一个数组 创建动态大小的临时数组往往是必要的。当它们不再需要时，释放分配的内存是很重要的。这里的问题是，C++需要带有[]括号的特殊删除操作符，这一点很容易被遗忘。delete[]操作符不仅会删除分配给数组的内存，而且会首先调用数组中所有对象的析构函数。对原始类型使用不带[]括号的删除操作符也是不正确的，尽管这些类型没有析构函数，每个编译器都不能保证一个数组的指针会指向数组的第一个元素，所以使用不带[]括号的delete也会导致未定义的行为。\n在数组中使用智能指针，如unique_ptr\u0026lt;T\u0026gt;, shared_ptr，也是不正确的。当这样的智能指针从作用域中退出时，它将调用不带[]括号的删除操作符，这将导致上面描述的同样问题。如果需要对数组使用智能指针，可以使用unique_ptr\u0026lt;T[]\u0026gt;的特殊化。","title":"C++中常见的常见的编码错误"},{"content":"为什么要有完美转发 下面是一个类工厂函数：\ntemplate \u0026lt;typename T, typename Arg\u0026gt; std::shared_ptr\u0026lt;T\u0026gt; factory(Arg arg) { return std::shared_ptr\u0026lt;T\u0026gt;( new T(arg)); } 参数对象arg在上面的例子中是传值方式传递，这带来了生成额外临时对象1的代价，所以我们改成引用传递：\ntemplate \u0026lt;typename T, typename Arg\u0026gt; std::shared_ptr\u0026lt;T\u0026gt; factory(Arg \u0026amp;arg) { return std::shared_ptr\u0026lt;T\u0026gt;( new T(arg)); } 但这种实现的问题是不能绑定右值实参。如factory\u0026lt;X\u0026gt;(42)将编译报错，进一步的，我们按常量引用来传递：\ntemplate \u0026lt;typename T, typename Arg\u0026gt; std::shared_ptr\u0026lt;T\u0026gt; factory(const Arg \u0026amp;arg) { return std::shared_ptr\u0026lt;T\u0026gt;( new T(arg)); } 这种实现的问题是不能支持移动语义，形参使用右值引用可以解决完美转发问题。\n引用折叠 在C++11之前，我们不能对一个引用类型继续引用，但C++由于右值引用的出现而放宽2了这一做法，从而产生了引用折叠规则，允许我们对引用进行引用，既能左引用，又能右引用。但是却遵循如下规则：\n   函数形参类型 实参类型 推导后函数形参类型     T\u0026amp; 左引用 T\u0026amp;   T\u0026amp; 右引用 T\u0026amp;   T\u0026amp;\u0026amp; 左引用 T\u0026amp;   T\u0026amp;\u0026amp; 右引用 T\u0026amp;\u0026amp;    模板参数类型推导 对函数模板template\u0026lt;typename T\u0026gt;void foo(T\u0026amp;\u0026amp;);，应用上述引用折叠规则，可总结出以下结论：\n 如果实参是类型A的左值，则模板参数T的类型为A\u0026amp;，形参类型为A\u0026amp;； 如果实参是类型A的右值，则模板参数T的类型为A\u0026amp;\u0026amp;，形参类型为A\u0026amp;\u0026amp;。  这同样适用于类模板的成员函数模板的类型推导：\ntemplate \u0026lt;class T\u0026gt; class vector { public: // T是类模板参数 ⇒ 该成员函数不需要类型推导;这里的函数参数类型就是T的右值引用  void push_back(T \u0026amp;\u0026amp;x); // 该成员函数是个函数模板，有自己的模板参数，需要类型推导  template \u0026lt;typename Args\u0026gt; void emplace_back(Args \u0026amp;\u0026amp;args); } 函数模板的形参必须是T\u0026amp;\u0026amp;形式，才需要模板参数类型推导。即使形参声明为const T\u0026amp;\u0026amp;形式，就只能按字面意义使用，不需要模板参数类型推导。\n完美转发 下面是上述代码完美转发版本的实现：\ntemplate \u0026lt;typename T, typename Arg\u0026gt; shared_ptr\u0026lt;T\u0026gt; factory(Args\u0026amp;\u0026amp; arg) { return std::shared_ptr\u0026lt;T\u0026gt;( new T(std::forward\u0026lt;Arg\u0026gt;(arg)) ); } 其中std::forward是定义在标准库\u0026lt;utility\u0026gt;中的模板函数：\ntemplate\u0026lt; class T \u0026gt; T\u0026amp;\u0026amp; forward( typename std::remove_reference\u0026lt;T\u0026gt;::type\u0026amp; t ) { return static_cast\u0026lt;T\u0026amp;\u0026amp;\u0026gt;(t); } template\u0026lt; class T \u0026gt; T\u0026amp;\u0026amp; forward( typename std::remove_reference\u0026lt;T\u0026gt;::type\u0026amp;\u0026amp; t ) { return static_cast\u0026lt;T\u0026amp;\u0026amp;\u0026gt;(t); } std::remove_reference是个类模板，定义在标准库\u0026lt;type_traits\u0026gt;中，用于移除类型的引用其中定义的类型type是引用的基类型。\ntemplate\u0026lt; class T \u0026gt; struct remove_reference {typedef T type;}; template\u0026lt; class T \u0026gt; struct remove_reference\u0026lt;T\u0026amp;\u0026gt; {typedef T type;}; template\u0026lt; class T \u0026gt; struct remove_reference\u0026lt;T\u0026amp;\u0026amp;\u0026gt; {typedef T type;};  实参的数据类型是左值引用类型S\u0026amp;时(T = S\u0026amp;)，t的类型为S\u0026amp;，static_cast\u0026lt;S\u0026amp; \u0026amp;\u0026amp;\u0026gt;(t)折叠为static_cast\u0026lt;S\u0026amp;\u0026gt;(t) 实参的数据类型是右值引用类型S\u0026amp;\u0026amp;时(T = S\u0026amp;\u0026amp;)，t的类型为S\u0026amp;\u0026amp;，static_cast\u0026lt;S\u0026amp;\u0026amp; \u0026amp;\u0026amp;\u0026gt;(t)折叠为static_cast\u0026lt;S\u0026amp;\u0026amp;\u0026gt;(t)  References https://zh.wikipedia.org/zh-cn/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8\n  临时对象的生命周期只有一条语句的时间。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 这里使用放宽一词是因为：只有在类型别名和模板参数时可以间接定义引用的引用。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://fffzlfk.github.io/posts/c++_%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/","summary":"为什么要有完美转发 下面是一个类工厂函数：\ntemplate \u0026lt;typename T, typename Arg\u0026gt; std::shared_ptr\u0026lt;T\u0026gt; factory(Arg arg) { return std::shared_ptr\u0026lt;T\u0026gt;( new T(arg)); } 参数对象arg在上面的例子中是传值方式传递，这带来了生成额外临时对象1的代价，所以我们改成引用传递：\ntemplate \u0026lt;typename T, typename Arg\u0026gt; std::shared_ptr\u0026lt;T\u0026gt; factory(Arg \u0026amp;arg) { return std::shared_ptr\u0026lt;T\u0026gt;( new T(arg)); } 但这种实现的问题是不能绑定右值实参。如factory\u0026lt;X\u0026gt;(42)将编译报错，进一步的，我们按常量引用来传递：\ntemplate \u0026lt;typename T, typename Arg\u0026gt; std::shared_ptr\u0026lt;T\u0026gt; factory(const Arg \u0026amp;arg) { return std::shared_ptr\u0026lt;T\u0026gt;( new T(arg)); } 这种实现的问题是不能支持移动语义，形参使用右值引用可以解决完美转发问题。\n引用折叠 在C++11之前，我们不能对一个引用类型继续引用，但C++由于右值引用的出现而放宽2了这一做法，从而产生了引用折叠规则，允许我们对引用进行引用，既能左引用，又能右引用。但是却遵循如下规则：\n   函数形参类型 实参类型 推导后函数形参类型     T\u0026amp; 左引用 T\u0026amp;   T\u0026amp; 右引用 T\u0026amp;   T\u0026amp;\u0026amp; 左引用 T\u0026amp;   T\u0026amp;\u0026amp; 右引用 T\u0026amp;\u0026amp;    模板参数类型推导 对函数模板template\u0026lt;typename T\u0026gt;void foo(T\u0026amp;\u0026amp;);，应用上述引用折叠规则，可总结出以下结论：","title":"C++ 完美转发"},{"content":"Kernels CUDA C++对C++进行了扩展，允许程序员定义C++函数，称为内核，当被调用时，由 $N$ 个不同的CUDA线程并行执行 $N$ 次，而不是像普通C++函数那样只执行一次。\nkernel是使用__global__声明定义的，对于特定的内核调用，执行该内核的CUDA线程数量是使用\u0026lt;\u0026lt;\u0026lt;...\u0026gt;\u0026gt;\u0026gt;执行配置语法指定的（C++语言扩展）。每个执行内核的线程都有一个唯一的线程ID，可以在内核内通过内置变量访问。\n作为说明，下面的示例代码，使用内置变量threadIdx，将两个大小为 $N$ 的向量 $A$ 和 $B$ 相加，并将结果存入向量 $C$ 。\n// Kernel definition __global__ void VecAdd(float* A, float* B, float* C) { int i = threadIdx.x; C[i] = A[i] + B[i]; } int main() { ... // Kernel invocation with N threads  VecAdd\u0026lt;\u0026lt;\u0026lt;1, N\u0026gt;\u0026gt;\u0026gt;(A, B, C); ... } 在这里，执行VecAdd()的 $N$ 个线程中的每一个都执行了一次加法。\n线程体系 为方便起见，threadIdx是一个 $3$ 分量的向量，因此可以用一维、二维或三维的线程索引来识别线程，形成一个一维、二维或三维的线程块，称为线程块。这提供了一种自然的方式来调用域中的元素进行计算，如矢量、矩阵或体积。\n一个例子，下面的代码将两个大小为 $N\\times N$ 的矩阵 $A$ 和 $B$ 相加，并将结果存入矩阵 $C$ 。\n// Kernel definition __global__ void MatAdd(float A[N][N], float B[N][N], float C[N][N]) { int i = threadIdx.x; int j = threadIdx.y; C[i][j] = A[i][j] + B[i][j]; } int main() { ... // Kernel invocation with one block of N * N * 1 threads  int numBlocks = 1; dim3 threadsPerBlock(N, N); MatAdd\u0026lt;\u0026lt;\u0026lt;numBlocks, threadsPerBlock\u0026gt;\u0026gt;\u0026gt;(A, B, C); ... } 每个块的线程数量是有限制的，因为一个块的所有线程都要驻留在同一个处理器核心上，并且必须分享该核心的有限内存资源。在目前的GPU上，一个线程块最多可以包含 $1024$ 个线程。\n然而，一个内核可以由多个形状相同的线程块执行，因此线程的总数等于每个块的线程数乘以块的数量。\n块被组织成一个一维、二维或三维的线程块网格，如图所示。网格中的线程块的数量通常由正在处理的数据的大小决定，这通常超过了系统中的处理器数量。\n在\u0026lt;\u0026lt;\u0026lt;...\u0026gt;\u0026gt;\u0026gt;中指定的每个块的线程数和每个网格的块数可以是int或dim3类型。可以像上面的例子那样指定二维块或网格。\n网格中的每个块可以通过一个一维、二维或三维的唯一索引来识别，在内核中可以通过内置的blockIdx变量访问。线程块的尺寸可以在内核中通过内置的blockDim变量访问。\n扩展之前的MatAdd()例子以处理多个块，代码如下：\n// Kernel definition __global__ void MatAdd(float A[N][N], float B[N][N], float C[N][N]) { int i = blockIdx.x * blockDim.x + threadIdx.x; int j = blockIdx.y * blockDim.y + threadIdx.y; if (i \u0026lt; N \u0026amp;\u0026amp; j \u0026lt; N) C[i][j] = A[i][j] + B[i][j]; } int main() { ... // Kernel invocation  dim3 threadsPerBlock(16, 16); dim3 numBlocks(N / threadsPerBlock.x, N / threadsPerBlock.y); MatAdd\u0026lt;\u0026lt;\u0026lt;numBlocks, threadsPerBlock\u0026gt;\u0026gt;\u0026gt;(A, B, C); ... } 线程块大小为 $16 \\times 16$ （ $256$ 个线程），尽管在这种情况下是任意的，但却是一种常见的选择。网格是用足够的块创建的，以便像以前一样每个矩阵元素有一个线程。为简单起见，本例假设每个维度的每个网格的线程数被该维度的每个块的线程数平均分割，尽管不一定是这样的。\n线程块被要求独立执行。必须能够以任何顺序、平行或串联的方式执行它们。如图所示，这种独立性要求允许线程块在任何数量的内核上以任何顺序进行调度，使程序员能够编写随内核数量扩展的代码。\n一个块内的线程可以通过一些共享内存来共享数据，并通过同步它们的执行来协调内存访问来进行合作。更确切地说，我们可以通过调用__syncthreads()函数来指定内核中的同步点；__syncthreads()作为一个障碍，块中的所有线程必须在这个障碍处等待，然后才允许继续进行。共享内存给出了一个使用共享内存的例子。除了__syncthreads()之外，合作组API还提供了一套丰富的线程同步原语。\n共享内存应该是靠近每个处理器核心的低延迟内存（很像L1高速缓存），并且__syncthreads()应该是轻量级的。\n内存体系 如图所示，CUDA线程在执行过程中可以从多个内存空间访问数据。每个线程都有私有的本地内存。每个线程块都有共享内存，对该块的所有线程都是可见的，并且与该块具有相同的生命周期。所有线程都可以访问相同的全局内存。\n还有两个额外的只读内存空间可供所有线程访问：常量和纹理内存空间。全局、常量和纹理内存空间针对不同的内存使用情况进行了优化（见设备内存访问）。纹理内存还为一些特定的数据格式提供了不同的寻址模式，以及数据过滤（见纹理和表面内存）。\n全局、常量和纹理内存空间在同一个应用程序启动内核时是持久的。\n异构编程 如图所示，CUDA编程模型假设CUDA线程在一个物理上独立的设备上执行，该设备作为运行C++程序的主机的协处理器运行。例如，当内核在GPU上执行，而C++程序的其余部分在CPU上执行时，就属于这种情况。\nCUDA编程模型还假定主机和设备都在DRAM中保持自己独立的内存空间，分别称为主机内存和设备内存。因此，程序通过调用CUDA运行时（在编程接口中描述）来管理内核可见的全局、常量和纹理内存空间。这包括设备内存的分配和撤销，以及主机和设备内存之间的数据传输。\n统一内存提供了管理的内存来连接主机和设备内存空间。管理的内存可以从系统中的所有CPU和GPU访问，作为一个具有共同地址空间的单一、连贯的内存图像。这种能力使设备内存的超额认购成为可能，并且通过消除在主机和设备上显式镜像数据的需要，大大简化了移植应用程序的任务。关于统一内存的介绍，请参见统一内存编程。\n异步的SIMT编程模型 在CUDA编程模型中，线程是进行计算或内存操作的最低级别的抽象概念。从基于NVIDIA Ampere GPU架构的设备开始，CUDA编程模型通过异步编程模型为内存操作提供加速。异步编程模型定义了与CUDA线程有关的异步操作的行为。\n异步编程模型定义了用于CUDA线程之间同步的异步障碍的行为。该模型还解释并定义了cuda::memcpy_async如何在GPU中计算时用于从全局内存异步移动数据。\n异步操作 异步操作被定义为由一个CUDA线程发起并由另一个线程异步执行的操作。在一个完善的程序中，一个或多个CUDA线程会与异步操作同步。启动异步操作的CUDA线程并不需要在同步线程中。\n这样的异步线程（as-if线程）总是与启动异步操作的CUDA线程有关。一个异步操作使用一个同步对象来同步完成操作。这样的同步对象可以由用户显式管理（如cuda::memcpy_async）或在库内隐式管理（如cooperative_groups::memcpy_async）。\n一个同步对象可以是cuda::barrier或cuda::pipeline。这些对象在Asynchronous Barrier和Asynchronous Data Copies using cuda::pipeline中有详细解释。这些同步对象可以在不同的线程范围内使用。一个范围定义了可以使用同步对象与异步操作同步的线程集合。下表定义了CUDA C++中可用的线程作用域以及可以与每个线程同步的线程。\n   Thread 作用域 描述     cuda::thread_scope::thread_scope_thread 只有发起异步操作的CUDA线程才会同步   cuda::thread_scope::thread_scope_block 与启动线程在同一线程块内的所有或任何CUDA线程都会同步   cuda::thread_scope::thread_scope_device 与启动线程相同的GPU设备中的所有或任何CUDA线程进行同步   cuda::thread_scope::thread_scope_system 与启动线程在同一系统中的所有或任何CUDA或CPU线程进行同步    这些线程作用域在CUDA Standard C++库中作为标准C++的扩展来实现。\nReferences https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#programming-model\n","permalink":"https://fffzlfk.github.io/posts/cuda_%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/","summary":"Kernels CUDA C++对C++进行了扩展，允许程序员定义C++函数，称为内核，当被调用时，由 $N$ 个不同的CUDA线程并行执行 $N$ 次，而不是像普通C++函数那样只执行一次。\nkernel是使用__global__声明定义的，对于特定的内核调用，执行该内核的CUDA线程数量是使用\u0026lt;\u0026lt;\u0026lt;...\u0026gt;\u0026gt;\u0026gt;执行配置语法指定的（C++语言扩展）。每个执行内核的线程都有一个唯一的线程ID，可以在内核内通过内置变量访问。\n作为说明，下面的示例代码，使用内置变量threadIdx，将两个大小为 $N$ 的向量 $A$ 和 $B$ 相加，并将结果存入向量 $C$ 。\n// Kernel definition __global__ void VecAdd(float* A, float* B, float* C) { int i = threadIdx.x; C[i] = A[i] + B[i]; } int main() { ... // Kernel invocation with N threads  VecAdd\u0026lt;\u0026lt;\u0026lt;1, N\u0026gt;\u0026gt;\u0026gt;(A, B, C); ... } 在这里，执行VecAdd()的 $N$ 个线程中的每一个都执行了一次加法。\n线程体系 为方便起见，threadIdx是一个 $3$ 分量的向量，因此可以用一维、二维或三维的线程索引来识别线程，形成一个一维、二维或三维的线程块，称为线程块。这提供了一种自然的方式来调用域中的元素进行计算，如矢量、矩阵或体积。\n一个例子，下面的代码将两个大小为 $N\\times N$ 的矩阵 $A$ 和 $B$ 相加，并将结果存入矩阵 $C$ 。","title":"Cuda 编程模型"},{"content":"一组带有 on-chip 共享内存的 SIMD 多处理器 设备可以被看作一组多处理器，如图所示。每个多处理器使用单指令多数据(SIMD)架构：在任何给定的时钟周期内，多处理器的每个处理器执行同一指令，但操作不同的数据。\n每个多处理器使用四个以下类型的on-chip内存：\n 每个处理器一组 $32$ 位寄存器 并行数据缓存或共享内存，被所有处理器共享实现内存空间共享 通过设备内存的一个只读区域，一个只读常量缓存器被所有处理器共享 通过设备内存的一个只读区域，一个只读纹理缓存器被所有处理器共享  本地和全局内存空间作为设备内存的读写区域，而不被缓冲。 每个多处理器通过纹理单元访问纹理缓冲器，它执行各种各样的寻址模式和数据过滤。\n执行模式 一个线程块网格是通过多处理器规划执行的。每个多处理器一个接一个的处理块批处理。一个块只被一个多处理器处理，因此可以对驻留在on-chip共享内存的共享内存空间形成非常快速的访问。\n一个批处理中每个多处理器可以处理多少个块，取决于每个线程中分配了多少个寄存器和已知内核中每个时钟需要多少的共享内存，因为多处理器的寄存器和内存在所有的线程中是分开的。如果在至少一个块中，每个多处理器没有足够高的寄存器或共享内存用，那么内核将无法启动。\n线程块在一个批处理中被一个多处理器执行，被称为active，每个active块被划分成SIMD线程组，被称为warps；每一条这样的warp包含数量相同的线程，叫做warp大小，并且在SIMD的方式下通过多处理器执行，执行调度程序周期性地从一条warp切换到另一条warp，以达到多处理器计算资源使用的最大化。\n块被划分成warp的方式总是相同的；每条warp包含连续的线程，线程索引从第一个warp包含着的线程 0 开始递增。\n一个多处理器可以并发地处理几个块，通过划分在它们之中的寄存器和共享内存。更准确地说，每条线程可使用的寄存器数量，等于每个多处理器寄存器总数除以并发的线程数量，并发线程的数量等于并发块的数量乘以每块线程的数量。\n在一个线程块网格内的块次序是未定义的，并且在块之间不存在同步机制，因此来自同一个网格的两个不同块的线程不能通过全局内存彼此安全地通讯。\n计算兼容性 设备的兼容性由两个参数定义，主要版本号和次要版本号。设备拥有的主要版本号代表相同的核心架构。\n次要版本号代表一些改进的核心架构。比如新的特性。\n多设备 为一个应用程序使用多GPU作为CUDA设备，必须保证这些CPU是一样的类型。如果系统工作在SLI 模式下，那么只有一个GPU可以作为CUDA设备，由于所有的GPU在驱动堆栈中被底层的融合了。SLI 模式需要在控制面板中关闭,这样才能使多个GPU作为CUDA设备\n","permalink":"https://fffzlfk.github.io/posts/cuda_%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0/","summary":"一组带有 on-chip 共享内存的 SIMD 多处理器 设备可以被看作一组多处理器，如图所示。每个多处理器使用单指令多数据(SIMD)架构：在任何给定的时钟周期内，多处理器的每个处理器执行同一指令，但操作不同的数据。\n每个多处理器使用四个以下类型的on-chip内存：\n 每个处理器一组 $32$ 位寄存器 并行数据缓存或共享内存，被所有处理器共享实现内存空间共享 通过设备内存的一个只读区域，一个只读常量缓存器被所有处理器共享 通过设备内存的一个只读区域，一个只读纹理缓存器被所有处理器共享  本地和全局内存空间作为设备内存的读写区域，而不被缓冲。 每个多处理器通过纹理单元访问纹理缓冲器，它执行各种各样的寻址模式和数据过滤。\n执行模式 一个线程块网格是通过多处理器规划执行的。每个多处理器一个接一个的处理块批处理。一个块只被一个多处理器处理，因此可以对驻留在on-chip共享内存的共享内存空间形成非常快速的访问。\n一个批处理中每个多处理器可以处理多少个块，取决于每个线程中分配了多少个寄存器和已知内核中每个时钟需要多少的共享内存，因为多处理器的寄存器和内存在所有的线程中是分开的。如果在至少一个块中，每个多处理器没有足够高的寄存器或共享内存用，那么内核将无法启动。\n线程块在一个批处理中被一个多处理器执行，被称为active，每个active块被划分成SIMD线程组，被称为warps；每一条这样的warp包含数量相同的线程，叫做warp大小，并且在SIMD的方式下通过多处理器执行，执行调度程序周期性地从一条warp切换到另一条warp，以达到多处理器计算资源使用的最大化。\n块被划分成warp的方式总是相同的；每条warp包含连续的线程，线程索引从第一个warp包含着的线程 0 开始递增。\n一个多处理器可以并发地处理几个块，通过划分在它们之中的寄存器和共享内存。更准确地说，每条线程可使用的寄存器数量，等于每个多处理器寄存器总数除以并发的线程数量，并发线程的数量等于并发块的数量乘以每块线程的数量。\n在一个线程块网格内的块次序是未定义的，并且在块之间不存在同步机制，因此来自同一个网格的两个不同块的线程不能通过全局内存彼此安全地通讯。\n计算兼容性 设备的兼容性由两个参数定义，主要版本号和次要版本号。设备拥有的主要版本号代表相同的核心架构。\n次要版本号代表一些改进的核心架构。比如新的特性。\n多设备 为一个应用程序使用多GPU作为CUDA设备，必须保证这些CPU是一样的类型。如果系统工作在SLI 模式下，那么只有一个GPU可以作为CUDA设备，由于所有的GPU在驱动堆栈中被底层的融合了。SLI 模式需要在控制面板中关闭,这样才能使多个GPU作为CUDA设备","title":"Cuda 硬件实现"},{"content":"理论 Canny边缘检测是由John F. Canny在1986年开发的。许多人也将其称为最佳检测器，Canny算法旨在满足三个主要标准。\n 好的检测：算法能够尽可能多地标识出图像中的实际边缘。 好的定位：标识出的边缘要与实际图像中的实际边缘尽可能接近。 最小响应：图像中的边缘只能标识一次，并且可能存在的图像雜訊不应标识为边缘。  步骤   降噪：使用高斯滤波来达到，下面是一个大小为 $5$ 的高斯核的例子： $$ K = \\frac{1}{159}\\begin{bmatrix} 2 \u0026amp; 4 \u0026amp; 5 \u0026amp; 4 \u0026amp; 2\\\\ 4 \u0026amp; 9 \u0026amp; 12 \u0026amp; 9 \u0026amp; 4\\\\ 5 \u0026amp; 12 \u0026amp; 15 \u0026amp; 12 \u0026amp; 5\\\\ 4 \u0026amp; 9 \u0026amp; 12 \u0026amp; 9 \u0026amp; 4\\\\ 2 \u0026amp; 4 \u0026amp; 5 \u0026amp; 4 \u0026amp; 2 \\end{bmatrix} $$\n  找到图像的亮度梯度：为此，我们遵循一个类似于Sobel的程序：\n 应用一对卷积masks（在 $x$ 和 $y$ 方向上）： $$ G_x = \\begin{bmatrix} -1 \u0026amp; 0 \u0026amp; +1\\\\ -2 \u0026amp; 0 \u0026amp; +2\\\\ -1 \u0026amp; 0 \u0026amp; +1 \\end{bmatrix}, G_y=\\begin{bmatrix} -1 \u0026amp; -2 \u0026amp; -1\\\\ 0 \u0026amp; 0 \u0026amp; 0\\\\ +1 \u0026amp; +2 \u0026amp; +1 \\end{bmatrix} $$ 寻找梯度强度和方向： $$ G=\\sqrt{G_x^2+G_y^2}\\\\ \\theta = \\arctan(\\frac{G_y}{G_x}) $$ 方向被四舍五入为四个可能的角度之一（即 $0\\degree$ 、 $45\\degree$ 、 $90\\degree$ 或 $135\\degree$ ）。    过滤非最大值：在高斯滤波过程中，边缘有可能被放大了。这个步骤使用一个规则来过滤不是边缘的点，使边缘的宽度尽可能为1个像素点：如果一个像素点属于边缘，那么这个像素点在梯度方向上的梯度值是最大的。否则不是边缘，将灰度值设为 $0$ 。 $$ M_T(m, n) = \\begin{cases} M(m, n)\u0026amp; \\text{if } M(m, n) \\lt T\\\\ 0 \u0026amp; \\text{otherwise} \\end{cases} $$\n  滞后：这是最后一步，Canny确实使用了两个阈值（上限和下限）。\n 如果一个像素的梯度值高于上限阈值，则该像素被接受为边缘。 如果一个像素的梯度值低于下限阈值，那么它将被拒绝。 如果像素梯度在两个阈值之间，那么只有当它与高于上层阈值的像素相连时，才会被接受。 Canny建议上下限的比值在 $2:1$ 和 $3:1$ 之间。    Code 代码链接\nExplanation 变量定义 Mat src, src_gray; Mat dst, detected_edges; int lowThreshold = 0; const int max_lowThreshold = 100; const int ratio = 3; const int kernel_size = 3; const char* window_name = \u0026#34;Edge Map\u0026#34;;  我们建立了一个 $3:1$ 的下限:上限阈值的比值（用可变比值）。 我们设定内核大小为 $3$ （用于Canny函数内部进行的Sobel运算） 我们将下限阈值的最大值设定为 $100$ 。  加载图像 CommandLineParser parser( argc, argv, \u0026#34;{@input | fruits.jpg | input image}\u0026#34; ); src = imread( samples::findFile( parser.get\u0026lt;String\u0026gt;( \u0026#34;@input\u0026#34; ) ), IMREAD_COLOR ); // Load an image if( src.empty() ) { std::cout \u0026lt;\u0026lt; \u0026#34;Could not open or find the image!\\n\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Usage: \u0026#34; \u0026lt;\u0026lt; argv[0] \u0026lt;\u0026lt; \u0026#34; \u0026lt;Input image\u0026gt;\u0026#34; \u0026lt;\u0026lt; std::endl; return -1; } 创建一个与src相同类型和大小的矩阵（dst）。 dst.create( src.size(), src.type() ); 灰度化 cvtColor( src, src_gray, COLOR_BGR2GRAY ); 创建一个窗口来显示结果 namedWindow( window_name, WINDOW_AUTOSIZE ); 创建一个Trackbar，让用户为我们的Canny检测器输入低阈值 createTrackbar( \u0026#34;Min Threshold:\u0026#34;, window_name, \u0026amp;lowThreshold, max_lowThreshold, CannyThreshold ); 让我们一步一步地观察CannyThreshold函数   首先，我们用内核大小为 $3$ 的滤波器对图像进行模糊处理。\nblur( src_gray, detected_edges, Size(3,3) );   接着，我们应用OpenCV函数cv::Canny\nCanny( detected_edges, detected_edges, lowThreshold, lowThreshold*ratio, kernel_size );  detected_edges：源图像（灰度图） detected_edges：输出图像（可与输入相同） lowThreshold：用户移动Trackbar时输入的值 highThreshold：在程序中设置为lowThreshold的 $3$ 倍（按照Canny的建议） kernel_size：我们将其定义为 $3$ （内部使用的Sobel内核的大小）。    我们用零来填充dst图像（意味着图像是完全黑色的） dst = Scalar::all(0); 显示 最后，我们将使用函数cv::Mat::copyTo只映射图像中被识别为边缘的区域（在黑色背景上）。cv::Mat::copyTo将src图像复制到dst上。注意，它只会复制像素的非零值的位置。因为Canny检测器的输出是黑色背景上的边缘轮廓，所以除了检测到的边缘，生成的dst将是黑色的。\n 若没有这一步，那么我们得到的图像是边缘的灰度图\n 结果 References https://docs.opencv.org/4.5.5/da/d5c/tutorial_canny_detector.html\n","permalink":"https://fffzlfk.github.io/posts/opencv_canny_detector/","summary":"理论 Canny边缘检测是由John F. Canny在1986年开发的。许多人也将其称为最佳检测器，Canny算法旨在满足三个主要标准。\n 好的检测：算法能够尽可能多地标识出图像中的实际边缘。 好的定位：标识出的边缘要与实际图像中的实际边缘尽可能接近。 最小响应：图像中的边缘只能标识一次，并且可能存在的图像雜訊不应标识为边缘。  步骤   降噪：使用高斯滤波来达到，下面是一个大小为 $5$ 的高斯核的例子： $$ K = \\frac{1}{159}\\begin{bmatrix} 2 \u0026amp; 4 \u0026amp; 5 \u0026amp; 4 \u0026amp; 2\\\\ 4 \u0026amp; 9 \u0026amp; 12 \u0026amp; 9 \u0026amp; 4\\\\ 5 \u0026amp; 12 \u0026amp; 15 \u0026amp; 12 \u0026amp; 5\\\\ 4 \u0026amp; 9 \u0026amp; 12 \u0026amp; 9 \u0026amp; 4\\\\ 2 \u0026amp; 4 \u0026amp; 5 \u0026amp; 4 \u0026amp; 2 \\end{bmatrix} $$\n  找到图像的亮度梯度：为此，我们遵循一个类似于Sobel的程序：\n 应用一对卷积masks（在 $x$ 和 $y$ 方向上）： $$ G_x = \\begin{bmatrix} -1 \u0026amp; 0 \u0026amp; +1\\\\ -2 \u0026amp; 0 \u0026amp; +2\\\\ -1 \u0026amp; 0 \u0026amp; +1 \\end{bmatrix}, G_y=\\begin{bmatrix} -1 \u0026amp; -2 \u0026amp; -1\\\\ 0 \u0026amp; 0 \u0026amp; 0\\\\ +1 \u0026amp; +2 \u0026amp; +1 \\end{bmatrix} $$ 寻找梯度强度和方向： $$ G=\\sqrt{G_x^2+G_y^2}\\\\ \\theta = \\arctan(\\frac{G_y}{G_x}) $$ 方向被四舍五入为四个可能的角度之一（即 $0\\degree$ 、 $45\\degree$ 、 $90\\degree$ 或 $135\\degree$ ）。    过滤非最大值：在高斯滤波过程中，边缘有可能被放大了。这个步骤使用一个规则来过滤不是边缘的点，使边缘的宽度尽可能为1个像素点：如果一个像素点属于边缘，那么这个像素点在梯度方向上的梯度值是最大的。否则不是边缘，将灰度值设为 $0$ 。 $$ M_T(m, n) = \\begin{cases} M(m, n)\u0026amp; \\text{if } M(m, n) \\lt T\\\\ 0 \u0026amp; \\text{otherwise} \\end{cases} $$","title":"OpenCV Canny Detector"},{"content":"理论   在之前的教程中，我们学习了如何使用Sobel算子。它是基于这样一个事实，即在边缘区域，像素强度显示了一个 \u0026ldquo;跳跃\u0026quot;或强度的高变化。得到强度的一阶导数，我们观察到边缘的特征是一个最大值，如图所示：   那么，如果我们取二阶导数会怎样？ 你可以观察到，边缘二阶导数是零! 因此，我们也可以用这个标准来尝试检测图像的边缘。然而，请注意，零值不仅会出现在边缘（它们实际上可以出现在其他无意义的位置）；这可以通过在需要时使用过滤来解决。\n  拉普拉斯算子  从上面的解释中，我们可以推断出，二阶导数可以用来检测边缘。由于图像是二维的，我们需要在两个维度上取导数。这里，拉普拉斯算子就派上用场了。 拉普拉斯算子的定义是： $$ Laplace(f) = \\frac{\\partial^2f}{\\partial x^2}+\\frac{\\partial^2f}{\\partial y^2} $$ 拉普拉斯算子在OpenCV中是由函数Laplacian()实现的。事实上，由于拉普拉斯算子使用图像的梯度，它在内部调用索贝尔算子来进行计算的。  Code 代码链接\nExplanation 变量声明 // Declare the variables we are going to use Mat src, src_gray, dst; int kernel_size = 3; int scale = 1; int delta = 0; int ddepth = CV_16S; const char* window_name = \u0026#34;Laplace Demo\u0026#34;; 加载图像 const char* imageName = argc \u0026gt;=2 ? argv[1] : \u0026#34;./images/lena.jpg\u0026#34;; src = imread( samples::findFile( imageName ), IMREAD_COLOR ); // Load an image // Check if image is loaded fine if(src.empty()){ printf(\u0026#34; Error opening image\\n\u0026#34;); printf(\u0026#34; Program Arguments: [image_name -- default lena.jpg] \\n\u0026#34;); return -1; } 消除噪声 // Reduce noise by blurring with a Gaussian filter ( kernel size = 3 ) GaussianBlur( src, src, Size(3, 3), 0, 0, BORDER_DEFAULT ); 灰度化 cvtColor( src, src_gray, COLOR_BGR2GRAY ); // Convert the image to grayscale 拉普拉斯算子 Laplacian( src_gray, dst, ddepth, kernel_size, scale, delta, BORDER_DEFAULT );  参数如下。  src_gray：输入的图像。 dst：目标图像 ddepth。目的图像的深度。由于我们的输入是CV_8U，我们定义ddepth = CV_16S以避免溢出。 kernel_size。内部应用的Sobel算子的核大小。在这个例子中我们使用3。 scale, delta 和 BORDER_DEFAULT：我们把它们作为默认值。    将输出转换为CV_8U图像 // converting back to CV_8U convertScaleAbs( dst, abs_dst ); 结果   编译完上面的代码后，我们可以运行它，并将图像的路径作为参数。例如，以下图输入为例：   我们得到以下结果。注意到树木和牛的轮廓是如何被近似地定义的（除了在强度非常相似的区域，即牛头周围）。另外，请注意，树木后面的房子的屋顶（右侧）是不明显的标记。这是由于该区域的对比度较高。   References https://docs.opencv.org/4.5.5/d5/db5/tutorial_laplace_operator.html\n","permalink":"https://fffzlfk.github.io/posts/opencv_laplace_operator/","summary":"理论   在之前的教程中，我们学习了如何使用Sobel算子。它是基于这样一个事实，即在边缘区域，像素强度显示了一个 \u0026ldquo;跳跃\u0026quot;或强度的高变化。得到强度的一阶导数，我们观察到边缘的特征是一个最大值，如图所示：   那么，如果我们取二阶导数会怎样？ 你可以观察到，边缘二阶导数是零! 因此，我们也可以用这个标准来尝试检测图像的边缘。然而，请注意，零值不仅会出现在边缘（它们实际上可以出现在其他无意义的位置）；这可以通过在需要时使用过滤来解决。\n  拉普拉斯算子  从上面的解释中，我们可以推断出，二阶导数可以用来检测边缘。由于图像是二维的，我们需要在两个维度上取导数。这里，拉普拉斯算子就派上用场了。 拉普拉斯算子的定义是： $$ Laplace(f) = \\frac{\\partial^2f}{\\partial x^2}+\\frac{\\partial^2f}{\\partial y^2} $$ 拉普拉斯算子在OpenCV中是由函数Laplacian()实现的。事实上，由于拉普拉斯算子使用图像的梯度，它在内部调用索贝尔算子来进行计算的。  Code 代码链接\nExplanation 变量声明 // Declare the variables we are going to use Mat src, src_gray, dst; int kernel_size = 3; int scale = 1; int delta = 0; int ddepth = CV_16S; const char* window_name = \u0026#34;Laplace Demo\u0026#34;; 加载图像 const char* imageName = argc \u0026gt;=2 ?","title":"OpenCV Laplace Operator"},{"content":"理论   在之前的两个教程中，我们已经看到了卷积的应用实例。最重要的卷积之一是计算图像中的导数（或对它们的近似值）\n  为什么图像中的导数计算可能是重要的？让我们设想一下，我们要检测图像中存在的边缘。比如说： 你可以很容易地注意到，在一个边缘，像素强度的变化是很明显的。一个表达变化的好方法是使用导数。梯度的高变化表示图像中的一个重大变化。\n  为了更加形象，让我们假设我们有一个一维图像。在下面的图中，一个边缘由强度的 \u0026ldquo;跳跃 \u0026ldquo;来表示：   如果我们取第一个导数，可以更容易地看到边缘的 \u0026ldquo;跳跃\u0026rdquo;（实际上，这里出现的是一个最大值）：   因此，从上面的解释中，我们可以推断出，检测图像中的边缘的方法可以通过定位梯度高于其邻居的像素位置（或者概括地说，高于一个阈值）来进行。\n  更详细的解释，请参考Bradski和Kaehler的《Learning OpenCV》。\n  Sobel 算子  Sobel算子是一个离散的微分算子，它计算图像强度函数的梯度的近似值。 Sobel算子结合了Gaussian smoothing和微分。  Formulation 假设要操作的图像为 $I$:\n 我们计算两个导数：  水平变化：这是通过用奇数大小的内核 $G_x$ 对 $I$ 进行卷积计算的。例如，对于内核大小为 $3$ ， $G_x$ 将被计算为： $$ G_x=\\begin{bmatrix} -1 \u0026amp; 0 \u0026amp; +1\\\\ -2 \u0026amp; 0 \u0026amp; +2\\\\ -1 \u0026amp; 0 \u0026amp; +1 \\end{bmatrix} * I $$ 垂直变化：这是通过用奇数大小的内核 $G_y$ 对 $I$ 进行卷积计算的。例如，对于内核大小为 $3$ ， $G_y$ 将被计算为： $$ G_y = \\begin{bmatrix} -1 \u0026amp; -2 \u0026amp; -1\\\\ 0 \u0026amp; 0 \u0026amp; 0\\\\ +1 \u0026amp; +2 \u0026amp; + 1 \\end{bmatrix} * I $$   在图像的每一点上，我们通过结合上述两个结果计算出该点的梯度近似值： $$ G = \\sqrt{G_{x}^{2}+G_{y}^{2}} $$ 有时会使用以下更简单的方程式： $$ G = |G_x|+|G_y| $$   当核的大小为 $3$ 时，上面显示的 Sobel核可能会产生明显的不准确（毕竟， Sobel 只是一个导数的近似值）。OpenCV通过使用 Scharr() 函数来解决这种大小为 $3$ 的核的不精确性。这和标准的 Sobel 函数一样快，但比它更准确。它可以实现以下内核 $$ G_x=\\begin{bmatrix} -3 \u0026amp; 0 \u0026amp; +3\\\\ -10 \u0026amp; 0 \u0026amp; +10\\\\ -3 \u0026amp; 0 \u0026amp; +3 \\end{bmatrix}, G_y=\\begin{bmatrix} -3 \u0026amp; -10 \u0026amp; -3\\\\ 0 \u0026amp; 0 \u0026amp; 0\\\\ +3 \u0026amp; +10 \u0026amp; +3 \\end{bmatrix} $$\n Code 代码链接\nExplanation 变量声明 // First we declare the variables we are going to use Mat image,src, src_gray; Mat grad; const String window_name = \u0026#34;Sobel Demo - Simple Edge Detector\u0026#34;; int ksize = parser.get\u0026lt;int\u0026gt;(\u0026#34;ksize\u0026#34;); int scale = parser.get\u0026lt;int\u0026gt;(\u0026#34;scale\u0026#34;); int delta = parser.get\u0026lt;int\u0026gt;(\u0026#34;delta\u0026#34;); int ddepth = CV_16S; 加载图像 String imageName = parser.get\u0026lt;String\u0026gt;(\u0026#34;@input\u0026#34;); // As usual we load our source image (src) image = imread( samples::findFile( imageName ), IMREAD_COLOR ); // Load an image // Check if image is loaded fine if( image.empty() ) { printf(\u0026#34;Error opening image: %s\\n\u0026#34;, imageName.c_str()); return EXIT_FAILURE; } 消除噪声 // Remove noise by blurring with a Gaussian filter ( kernel size = 3 ) GaussianBlur(image, src, Size(3, 3), 0, 0, BORDER_DEFAULT); 灰度化 // Convert the image to grayscale cvtColor(src, src_gray, COLOR_BGR2GRAY); Sobel 算子 Mat grad_x, grad_y; Mat abs_grad_x, abs_grad_y; Sobel(src_gray, grad_x, ddepth, 1, 0, ksize, scale, delta, BORDER_DEFAULT); Sobel(src_gray, grad_y, ddepth, 0, 1, ksize, scale, delta, BORDER_DEFAULT);  我们计算 $x$ 和 $y$ 方向的 \u0026ldquo;导数\u0026rdquo;。为此，我们使用函数Sobel()，如下所示。该函数需要以下参数:  src_gray：在我们的例子中，输入的图像。这里是CV_8U grad_x / grad_y：输出图像。 ddepth：输出图像的深度。我们将其设置为CV_16S以避免溢出。 x_order： $X$ 方向上的导数顺序。 y_order: $Y$ 方向的导数顺序。 scale：delta和BORDER_DEFAULT：我们使用默认值。     注意，在计算 $x$ 方向的梯度时，我们使用：xorder=1，yorder=0，我们对 $y$ 方向进行类似的计算。\n 转换为CV_8U图像 // converting back to CV_8U convertScaleAbs(grad_x, abs_grad_x); convertScaleAbs(grad_y, abs_grad_y); 梯度 addWeighted(abs_grad_x, 0.5, abs_grad_y, 0.5, 0, grad);  我们试图通过增加两个方向的梯度来近似计算梯度（注意，这不是一个精确的计算！但对我们的目的来说是好的）。\n 结果 References https://docs.opencv.org/4.5.5/d2/d2c/tutorial_sobel_derivatives.html\n","permalink":"https://fffzlfk.github.io/posts/opencv_sobel_derivatives/","summary":"理论   在之前的两个教程中，我们已经看到了卷积的应用实例。最重要的卷积之一是计算图像中的导数（或对它们的近似值）\n  为什么图像中的导数计算可能是重要的？让我们设想一下，我们要检测图像中存在的边缘。比如说： 你可以很容易地注意到，在一个边缘，像素强度的变化是很明显的。一个表达变化的好方法是使用导数。梯度的高变化表示图像中的一个重大变化。\n  为了更加形象，让我们假设我们有一个一维图像。在下面的图中，一个边缘由强度的 \u0026ldquo;跳跃 \u0026ldquo;来表示：   如果我们取第一个导数，可以更容易地看到边缘的 \u0026ldquo;跳跃\u0026rdquo;（实际上，这里出现的是一个最大值）：   因此，从上面的解释中，我们可以推断出，检测图像中的边缘的方法可以通过定位梯度高于其邻居的像素位置（或者概括地说，高于一个阈值）来进行。\n  更详细的解释，请参考Bradski和Kaehler的《Learning OpenCV》。\n  Sobel 算子  Sobel算子是一个离散的微分算子，它计算图像强度函数的梯度的近似值。 Sobel算子结合了Gaussian smoothing和微分。  Formulation 假设要操作的图像为 $I$:\n 我们计算两个导数：  水平变化：这是通过用奇数大小的内核 $G_x$ 对 $I$ 进行卷积计算的。例如，对于内核大小为 $3$ ， $G_x$ 将被计算为： $$ G_x=\\begin{bmatrix} -1 \u0026amp; 0 \u0026amp; +1\\\\ -2 \u0026amp; 0 \u0026amp; +2\\\\ -1 \u0026amp; 0 \u0026amp; +1 \\end{bmatrix} * I $$ 垂直变化：这是通过用奇数大小的内核 $G_y$ 对 $I$ 进行卷积计算的。例如，对于内核大小为 $3$ ， $G_y$ 将被计算为： $$ G_y = \\begin{bmatrix} -1 \u0026amp; -2 \u0026amp; -1\\\\ 0 \u0026amp; 0 \u0026amp; 0\\\\ +1 \u0026amp; +2 \u0026amp; + 1 \\end{bmatrix} * I $$   在图像的每一点上，我们通过结合上述两个结果计算出该点的梯度近似值： $$ G = \\sqrt{G_{x}^{2}+G_{y}^{2}} $$ 有时会使用以下更简单的方程式： $$ G = |G_x|+|G_y| $$   当核的大小为 $3$ 时，上面显示的 Sobel核可能会产生明显的不准确（毕竟， Sobel 只是一个导数的近似值）。OpenCV通过使用 Scharr() 函数来解决这种大小为 $3$ 的核的不精确性。这和标准的 Sobel 函数一样快，但比它更准确。它可以实现以下内核 $$ G_x=\\begin{bmatrix} -3 \u0026amp; 0 \u0026amp; +3\\\\ -10 \u0026amp; 0 \u0026amp; +10\\\\ -3 \u0026amp; 0 \u0026amp; +3 \\end{bmatrix}, G_y=\\begin{bmatrix} -3 \u0026amp; -10 \u0026amp; -3\\\\ 0 \u0026amp; 0 \u0026amp; 0\\\\ +3 \u0026amp; +10 \u0026amp; +3 \\end{bmatrix} $$","title":"OpenCV Sobel Derivatives"},{"content":"形态学操作  简而言之：一套基于形状处理图像的操作。形态学操作将一个结构化元素应用于输入图像，并生成一个输出图像。 最基本的形态学操作是。腐蚀和膨胀。它们有广泛的用途，即  去除噪音 隔离单个元素和连接图像中不同的元素 寻找图像中的强度凹凸点或洞   我们将以下面的图像为例，简要地解释膨胀和侵蚀。   Dilation（膨胀）  这种操作包括将图像A与一些kernel B进行卷积，内核可以有任何形状或大小，通常是一个正方形或圆形。 kernel B有一个定义的锚点(anchor point)，通常是核的中心。 当kernel B在图像上扫描时，我们计算出被B重叠的最大像素值，并用该最大值替换锚点位置的图像像素。正如你可以推断的那样，这种最大化的操作会使图像中的明亮区域 \u0026ldquo;增长\u0026rdquo;（因此被称为膨胀）。 膨胀操作： $dst(x, y)=max(x^{'}, y^{'})_{:element(x^{'}, y^{'}) \\ne 0} src(x+x^{'}, y+y^{'})$ 以上面的图像为例。应用膨胀的方法，我们可以得到   腐蚀  它在给定内核的区域内计算局部最小值。当内核B在图像上被扫描时，我们计算出被B重叠的最小像素值，并用该最小值替换锚点下的图像像素。 腐蚀操作为：$dst(x, y)=min(x^{'}, y^{'})_{:element(x^{'}, y^{'}) \\ne 0} src(x+x^{'}, y+y^{'})$ 与膨胀的例子类似，我们可以对原始图像应用腐蚀算子（如上图）。你可以在下面的结果中看到，图像的亮区变薄了，而暗区变大了。   Code #include \u0026#34;basic/erosion_dilatation.hpp\u0026#34; namespace basic { namespace erosion_dilatation { namespace impl { Mat src, erosion_dst, dilation_dst; int erosion_elem = 0; int erosion_size = 0; int dilation_elem = 0; int dilation_size = 0; int const max_elem = 2; int const max_kernel_size = 21; int work(int argc, char **argv) { CommandLineParser parser(argc, argv, \u0026#34;{@input | ./images/LinuxLogo.jpg | input image}\u0026#34;); src = imread(samples::findFile(parser.get\u0026lt;String\u0026gt;(\u0026#34;@input\u0026#34;)), IMREAD_COLOR); if (src.empty()) { cout \u0026lt;\u0026lt; \u0026#34;Could not open or find the image!\\n\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Usage: \u0026#34; \u0026lt;\u0026lt; argv[0] \u0026lt;\u0026lt; \u0026#34; \u0026lt;Input image\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl; return -1; } namedWindow(\u0026#34;Erosion Demo\u0026#34;, WINDOW_AUTOSIZE); namedWindow(\u0026#34;Dilation Demo\u0026#34;, WINDOW_AUTOSIZE); moveWindow(\u0026#34;Dilation Demo\u0026#34;, src.cols, 0); createTrackbar(\u0026#34;Element:\\n0: Rect \\n1: Cross \\n2: Ellipse\u0026#34;, \u0026#34;Erosion Demo\u0026#34;, \u0026amp;erosion_elem, max_elem, Erosion); createTrackbar(\u0026#34;Kernel size:\\n2n +1\u0026#34;, \u0026#34;Erosion Demo\u0026#34;, \u0026amp;erosion_size, max_kernel_size, Erosion); createTrackbar(\u0026#34;Element:\\n0: Rect \\n1: Cross \\n2: Ellipse\u0026#34;, \u0026#34;Dilation Demo\u0026#34;, \u0026amp;dilation_elem, max_elem, Dilation); createTrackbar(\u0026#34;Kernel size:\\n2n +1\u0026#34;, \u0026#34;Dilation Demo\u0026#34;, \u0026amp;dilation_size, max_kernel_size, Dilation); Erosion(0, 0); Dilation(0, 0); waitKey(0); return 0; } void Erosion(int, void *) { int erosion_type = 0; if (erosion_elem == 0) { erosion_type = MORPH_RECT; } else if (erosion_elem == 1) { erosion_type = MORPH_CROSS; } else if (erosion_elem == 2) { erosion_type = MORPH_ELLIPSE; } Mat element = getStructuringElement( erosion_type, Size(2 * erosion_size + 1, 2 * erosion_size + 1), Point(erosion_size, erosion_size)); erode(src, erosion_dst, element); imshow(\u0026#34;Erosion Demo\u0026#34;, erosion_dst); } void Dilation(int, void *) { int dilation_type = 0; if (dilation_elem == 0) { dilation_type = MORPH_RECT; } else if (dilation_elem == 1) { dilation_type = MORPH_CROSS; } else if (dilation_elem == 2) { dilation_type = MORPH_ELLIPSE; } Mat element = getStructuringElement( dilation_type, Size(2 * dilation_size + 1, 2 * dilation_size + 1), Point(dilation_size, dilation_size)); dilate(src, dilation_dst, element); imshow(\u0026#34;Dilation Demo\u0026#34;, dilation_dst); } } // namespace impl } // namespace erosion_dilatation } // namespace basic 程序功能  加载一个图像（可以是BGR或灰度）。 创建两个窗口（一个用于膨胀输出，另一个用于侵蚀） 为每个操作创建一组两个TraceBar  erosion_elem 或 dilation_elem（矩形、十字、椭圆） 内核大小kernel size    结果 References https://docs.opencv.org/4.5.5/db/df6/tutorial_erosion_dilatation.html\n","permalink":"https://fffzlfk.github.io/posts/opencv_erosion_dilatation/","summary":"形态学操作  简而言之：一套基于形状处理图像的操作。形态学操作将一个结构化元素应用于输入图像，并生成一个输出图像。 最基本的形态学操作是。腐蚀和膨胀。它们有广泛的用途，即  去除噪音 隔离单个元素和连接图像中不同的元素 寻找图像中的强度凹凸点或洞   我们将以下面的图像为例，简要地解释膨胀和侵蚀。   Dilation（膨胀）  这种操作包括将图像A与一些kernel B进行卷积，内核可以有任何形状或大小，通常是一个正方形或圆形。 kernel B有一个定义的锚点(anchor point)，通常是核的中心。 当kernel B在图像上扫描时，我们计算出被B重叠的最大像素值，并用该最大值替换锚点位置的图像像素。正如你可以推断的那样，这种最大化的操作会使图像中的明亮区域 \u0026ldquo;增长\u0026rdquo;（因此被称为膨胀）。 膨胀操作： $dst(x, y)=max(x^{'}, y^{'})_{:element(x^{'}, y^{'}) \\ne 0} src(x+x^{'}, y+y^{'})$ 以上面的图像为例。应用膨胀的方法，我们可以得到   腐蚀  它在给定内核的区域内计算局部最小值。当内核B在图像上被扫描时，我们计算出被B重叠的最小像素值，并用该最小值替换锚点下的图像像素。 腐蚀操作为：$dst(x, y)=min(x^{'}, y^{'})_{:element(x^{'}, y^{'}) \\ne 0} src(x+x^{'}, y+y^{'})$ 与膨胀的例子类似，我们可以对原始图像应用腐蚀算子（如上图）。你可以在下面的结果中看到，图像的亮区变薄了，而暗区变大了。   Code #include \u0026#34;basic/erosion_dilatation.hpp\u0026#34; namespace basic { namespace erosion_dilatation { namespace impl { Mat src, erosion_dst, dilation_dst; int erosion_elem = 0; int erosion_size = 0; int dilation_elem = 0; int dilation_size = 0; int const max_elem = 2; int const max_kernel_size = 21; int work(int argc, char **argv) { CommandLineParser parser(argc, argv, \u0026#34;{@input | .","title":"OpenCV Erosion Dilatation"},{"content":"理论   Smoothing也叫blurring（模糊化），是一个简单而常用的图像处理操作。\n  Smoothing有很多原因。在本教程中，我们将重点讨论平滑操作，以减少噪音。\n  为了进行平滑操作，我们将对我们的图像应用一个filter。最常见的filter是线性的，其中输出像素的值（即 $g(i,j)$ ）为输入像素值的加权和（即 $f(i+k,j+l)$ ）。\n  $$ g(i, j) = \\sum_{k, l}{f(i+k, j+l)h(k, l)} $$\n  $h(k,l)$ 被称为kernel，它只不过是filter的系数。这有助于把滤波器想象成一个在图像上滑动的系数窗口。\n  滤波器有很多种类，这里我们将提到最常用的几种。\n  Normalized Box Filter（归一化块滤波器）  这个滤波器是最简单的，每个输出像素都是其内核邻居的平均值（所有的像素都有相同的权重）。  $$ K = \\frac{1}{K_{width} \\cdot k_{height}} \\begin{bmatrix} 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \u0026hellip;\u0026amp; 1\\\\ 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \u0026hellip;\u0026amp; 1\\\\ . \u0026amp; . \u0026amp; . \u0026amp; \u0026hellip;\u0026amp; 1\\\\ 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \u0026hellip;\u0026amp; 1 \\end{bmatrix} $$\nGaussian Filter（高斯滤波器）   可能是最有用的滤波器（尽管不是最快的）。高斯滤波是通过用高斯内核对输入阵列中的每个点进行卷积，然后将它们全部相加来产生输出阵列的。\n  让我们回顾一下1D Gaussian kernel是什么样子：   假设图像是一维的，你可以注意到，位于中间的像素会有最大的权重。它的邻居的权重随着它们与中心像素之间的空间距离增加而减少。\n   一个二维高斯可以表示为： $$ G_0(x, y)=Ae^{\\frac{-(x-\\mu_x)^2}{2\\sigma_x^2}+\\frac{-(y-\\mu_y)^2}{2\\sigma_y^2}} $$ 其中 $\\mu$ 是平均值（峰值）， $\\sigma^2$ 代表方差（每一个变量 $x$ 和 $y$ ）。\n Bilateral Filter（双边滤波器）   到目前为止，我们已经解释了一些主要目标是平滑输入图像的滤波器。然而，有时这些滤波器不仅能消除噪声，还会使边缘变得平滑。为了避免这种情况（至少在一定程度上），我们可以使用一个双边滤波器。\n  类似于高斯滤波器的方式，双边滤波器也考虑了相邻的像素，并为每个像素分配权重。这些权重有两个组成部分，第一个组成部分与高斯滤波器使用的权重相同。第二部分考虑到了相邻像素和被评估像素之间的强度差异。\n  Code  这个程序是做什么的？  加载一张图片 应用4种不同的过滤器（在理论中解释过的），并按顺序显示过滤后的图片   代码链接  函数解释 Normalized Block Filter  OpenCV 提供了blur函数来用这个滤波器进行平滑处理。  src：源图像 dst: 目的图像 ksize: Size(w, h): 定义要使用的内核的大小（宽度为 $w$ 像素，高度为 $h$ 像素）。 anchor: Point(-1, -1): 表示锚点（被评估的像素）相对于邻域的位置。如果有一个负值，那么内核的中心被认为是锚点。    Gaussian Filter  functionGaussianBlur  src：源图像 dst: 目的图像 ksize: Size(w, h): 要使用的核的大小（要考虑的邻居）。 $w$ 和 $h$ 必须是奇数和正数，否则大小将用 $\\sigma_x$ 和 $\\sigma_y$ 参数计算 sigmaX：x的标准偏差。写成 $0$ 意味着用核大小计算的。 sigmaY：y的标准差。写 $0$ 意味着是用内核大小计算的。    Median Filter（中值滤波器）  functionmedianBlur  src：源图像 dst: 目的图像 ksize：内核的大小（只有一个数，因为我们使用的是方形窗口），必须是奇数。    Bilateral Filter（双边滤波）  functionbilateralFilter  src：源图像 dst: 目的图像 d: 每个像素邻域的直径 sigmaColor：色彩空间的标准偏差 sigmaSpace：坐标空间中的标准偏差    结果 原图 归一化块滤波 高斯滤波 中值滤波 双边滤波 References https://docs.opencv.org/4.5.5/d7/da8/tutorial_table_of_content_imgproc.html\n","permalink":"https://fffzlfk.github.io/posts/opencv_blurring/","summary":"理论   Smoothing也叫blurring（模糊化），是一个简单而常用的图像处理操作。\n  Smoothing有很多原因。在本教程中，我们将重点讨论平滑操作，以减少噪音。\n  为了进行平滑操作，我们将对我们的图像应用一个filter。最常见的filter是线性的，其中输出像素的值（即 $g(i,j)$ ）为输入像素值的加权和（即 $f(i+k,j+l)$ ）。\n  $$ g(i, j) = \\sum_{k, l}{f(i+k, j+l)h(k, l)} $$\n  $h(k,l)$ 被称为kernel，它只不过是filter的系数。这有助于把滤波器想象成一个在图像上滑动的系数窗口。\n  滤波器有很多种类，这里我们将提到最常用的几种。\n  Normalized Box Filter（归一化块滤波器）  这个滤波器是最简单的，每个输出像素都是其内核邻居的平均值（所有的像素都有相同的权重）。  $$ K = \\frac{1}{K_{width} \\cdot k_{height}} \\begin{bmatrix} 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \u0026hellip;\u0026amp; 1\\\\ 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \u0026hellip;\u0026amp; 1\\\\ . \u0026amp; . \u0026amp; . \u0026amp; \u0026hellip;\u0026amp; 1\\\\ 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \u0026hellip;\u0026amp; 1 \\end{bmatrix} $$","title":"OpenCV Blurring"},{"content":"硬件   SP(Streaming Processor)：流处理器，是GPU最基本的处理单元，在fermi架构开始被叫做CUDA core。\n  SM(Streaming MultiProcessor)：一个SM由多个CUDA core组成。\n  比如说，如果一个GPU有 $4$ 个SM，并且每个SM有 $768$ 个SP(Aka CUDA core)；那么在某一时刻，真正并行运行的线程数不会超过 $4 \\times 768$ 个。\n软件 threads被组织成blocks。一个block的线程可以用1Dimension(x), 2Dimensions(x, y)或者3Dim indexs(x, y, z) 索引，\n显然，如果你需要 $4 \\times 768$ 个以上的threads的话你需要 $4$ 个以上的blocks。blocks也可以使用1D, 2D或3D索引，这些blocks被放在等待队列上进入GPU执行。\nWrap 当一个kernel被执行时，grid中的线程块被分配到SM上。一个CUDA core可以执行一个thread，一个SM的CUDA core会分成几个wrap，由wrap scheduler负责调度。\n一个wrap中的线程在同一个block中，如果block所含线程数不是wrap的大小的整数倍，那么多出来的那些thread所在的wrap中，会剩余一些inactive的thread。\n一个简单的case 处理一张 $512 \\times 512$ 的图片。\n假设我们希望一个线程处理一个像素pixel(i, j)。\n我们可以使用每 $64$ 个线程的区块。所以我们需要 $\\frac{512 \\times 512 }{64} = 4096$ 个区块（为了拥有 $512 \\times 512 $ 个线程 ）。\n通常情况下，我们将线程组织在2D区块中（为了更容易索引图像像素）。blockDim= $8 * 8$ ，我更喜欢叫它threadsPerBlock。\ndim3 threadsPerBlock(8, 8); 还有2D的gridDim= $64 \\times 64$ （需要 $4096$ 个区块）。我更喜欢叫它numBlocks。\ndim3 numBlocks(imageWidth/threadPerBlock.x, imageHeight/threadPerBlock.y); 这个kernel是这样启动的：\nmyKernel \u0026lt;\u0026lt;\u0026lt;numBlocks, threadsPerBlock\u0026gt;\u0026gt;\u0026gt;(/* params for the kernel function */) 最后，会有一个类似 $4096$ 个区块的队列的东西，其中一个块正在等待被分配到GPU的一个多处理单元中，以获得其 $64$ 个线程的执行。\n在kernel中，一个线程要处理的像素是这样计算的：\nuint i = (blockIdx.x + blockDim.x) + threadIdx.x; uint j = (blockIdx.y + blockDim.y) + threadIdx.y; Reference   Understanding CUDA grid dimensions, block dimensions and threads organization (simple explanation) [closed]\n  CUDA的thread,block,grid和warp\n  ","permalink":"https://fffzlfk.github.io/posts/cuda%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/","summary":"硬件   SP(Streaming Processor)：流处理器，是GPU最基本的处理单元，在fermi架构开始被叫做CUDA core。\n  SM(Streaming MultiProcessor)：一个SM由多个CUDA core组成。\n  比如说，如果一个GPU有 $4$ 个SM，并且每个SM有 $768$ 个SP(Aka CUDA core)；那么在某一时刻，真正并行运行的线程数不会超过 $4 \\times 768$ 个。\n软件 threads被组织成blocks。一个block的线程可以用1Dimension(x), 2Dimensions(x, y)或者3Dim indexs(x, y, z) 索引，\n显然，如果你需要 $4 \\times 768$ 个以上的threads的话你需要 $4$ 个以上的blocks。blocks也可以使用1D, 2D或3D索引，这些blocks被放在等待队列上进入GPU执行。\nWrap 当一个kernel被执行时，grid中的线程块被分配到SM上。一个CUDA core可以执行一个thread，一个SM的CUDA core会分成几个wrap，由wrap scheduler负责调度。\n一个wrap中的线程在同一个block中，如果block所含线程数不是wrap的大小的整数倍，那么多出来的那些thread所在的wrap中，会剩余一些inactive的thread。\n一个简单的case 处理一张 $512 \\times 512$ 的图片。\n假设我们希望一个线程处理一个像素pixel(i, j)。\n我们可以使用每 $64$ 个线程的区块。所以我们需要 $\\frac{512 \\times 512 }{64} = 4096$ 个区块（为了拥有 $512 \\times 512 $ 个线程 ）。","title":"Cuda软件架构"},{"content":"A - Square String? 思路 判断$s[0.. \\frac{n}{2}]$ 和 $s[\\frac{n}{2}..n]$是否相等\n代码 use std::io::stdin; #[derive(Default)] struct Scanner { buffer: Vec\u0026lt;String\u0026gt;, } impl Scanner { fn next\u0026lt;T: std::str::FromStr\u0026gt;(\u0026amp;mut self) -\u0026gt; T { loop { if let Some(token) = self.buffer.pop() { return token.parse().ok().expect(\u0026#34;Failed parse\u0026#34;); } let mut input = String::new(); stdin().read_line(\u0026amp;mut input).expect(\u0026#34;Failed read\u0026#34;); self.buffer = input.split_whitespace().rev().map(String::from).collect(); } } } fn solve(scan: \u0026amp;mut Scanner) { let t: usize = scan.next(); for _ in 0..t { let s: String = scan.next(); let n = s.len(); if s[..n / 2].to_owned() == s[n / 2..].to_owned() { println!(\u0026#34;YES\u0026#34;); } else { println!(\u0026#34;NO\u0026#34;); } } } fn main() { let mut scan = Scanner::default(); solve(\u0026amp;mut scan); } B - Squares and Cubes 思路 使用HashSet就能过\n代码 use std::io::stdin; #[derive(Default)] struct Scanner { buffer: Vec\u0026lt;String\u0026gt;, } impl Scanner { fn next\u0026lt;T: std::str::FromStr\u0026gt;(\u0026amp;mut self) -\u0026gt; T { loop { if let Some(token) = self.buffer.pop() { return token.parse().ok().expect(\u0026#34;Failed parse\u0026#34;); } let mut input = String::new(); stdin().read_line(\u0026amp;mut input).expect(\u0026#34;Failed read\u0026#34;); self.buffer = input.split_whitespace().rev().map(String::from).collect(); } } } use std::collections::HashSet; fn solve(scan: \u0026amp;mut Scanner) { let t: usize = scan.next(); for _ in 0..t { let n: usize = scan.next(); let mut st = HashSet::new(); let c = f64::cbrt(n as f64) as usize; let s = f64::sqrt(n as f64) as usize; for i in 1..=c { st.insert(i * i); st.insert(i * i * i); } for i in c..=s { st.insert(i * i); } println!(\u0026#34;{}\u0026#34;, st.len()); } } fn main() { let mut scan = Scanner::default(); solve(\u0026amp;mut scan); } C - Wrong Addition 思路 模拟\n代码 use std::io::stdin; #[derive(Default)] struct Scanner { buffer: Vec\u0026lt;String\u0026gt;, } impl Scanner { fn next\u0026lt;T: std::str::FromStr\u0026gt;(\u0026amp;mut self) -\u0026gt; T { loop { if let Some(token) = self.buffer.pop() { return token.parse().ok().expect(\u0026#34;Failed parse\u0026#34;); } let mut input = String::new(); stdin().read_line(\u0026amp;mut input).expect(\u0026#34;Failed read\u0026#34;); self.buffer = input.split_whitespace().rev().map(String::from).collect(); } } } fn solve(scan: \u0026amp;mut Scanner) { let t: usize = scan.next(); \u0026#39;outer: for _ in 0..t { let mut a: usize = scan.next(); let mut s: usize = scan.next(); let mut b: Vec\u0026lt;u8\u0026gt; = vec![]; while s != 0 { let mut y = s % 10; let x = a % 10; if y \u0026gt;= x { b.push((y - x) as u8 + b\u0026#39;0\u0026#39;); } else { s /= 10; y += 10 * (s % 10); if y \u0026gt; x \u0026amp;\u0026amp; y \u0026gt;= 10 \u0026amp;\u0026amp; y \u0026lt;= 19 { b.push((y - x) as u8 + b\u0026#39;0\u0026#39;); } else { println!(\u0026#34;-1\u0026#34;); continue \u0026#39;outer; } } a /= 10; s /= 10; } if a != 0 { println!(\u0026#34;-1\u0026#34;); continue; } b.reverse(); let b: usize = String::from_utf8_lossy(\u0026amp;b).parse().unwrap(); println!(\u0026#34;{}\u0026#34;, b); } } fn main() { let mut scan = Scanner::default(); solve(\u0026amp;mut scan); } D - New Year\u0026rsquo;s Problem 思路 二分答案，注意最多只能visit $n-1$ 个转换为存在一个商店买两个人的礼物。\n代码 use std::io::stdin; #[derive(Default)] struct Scanner { buffer: Vec\u0026lt;String\u0026gt;, } impl Scanner { fn next\u0026lt;T: std::str::FromStr\u0026gt;(\u0026amp;mut self) -\u0026gt; T { loop { if let Some(token) = self.buffer.pop() { return token.parse().ok().expect(\u0026#34;Failed parse\u0026#34;); } let mut input = String::new(); stdin().read_line(\u0026amp;mut input).expect(\u0026#34;Failed read\u0026#34;); self.buffer = input.split_whitespace().rev().map(String::from).collect(); } } } fn solve(scan: \u0026amp;mut Scanner) { let n: usize = scan.next(); let m: usize = scan.next(); let mut p: Vec\u0026lt;Vec\u0026lt;u32\u0026gt;\u0026gt; = vec![vec![0; m]; n]; for row in p.iter_mut() { for col in row.iter_mut() { *col = scan.next::\u0026lt;u32\u0026gt;(); } } let (mut l, mut r) = (0, 1e9 as u32); while l \u0026lt; r { let mid = (l + r + 1) \u0026gt;\u0026gt; 1; if check(\u0026amp;p, mid) { l = mid; } else { r = mid-1; } } println!(\u0026#34;{}\u0026#34;, l); } fn check(p: \u0026amp;Vec\u0026lt;Vec\u0026lt;u32\u0026gt;\u0026gt;, mid: u32) -\u0026gt; bool { let mut ok = vec![false; p[0].len()]; let mut has_pair = false; for i in 0..p.len() { let mut ok_cols = 0; for j in 0..p[0].len() { if p[i][j] \u0026gt;= mid { ok[j] = true; ok_cols += 1; } } has_pair = has_pair || ok_cols \u0026gt;= 2; } has_pair \u0026amp;\u0026amp; ok.iter().all(|\u0026amp;x| x) } fn main() { let mut scan = Scanner::default(); let t: usize = scan.next(); for _ in 0..t { solve(\u0026amp;mut scan); } } ","permalink":"https://fffzlfk.github.io/posts/codeforces-762/","summary":"Codeforces Round #762 (Div. 3)","title":"CodeForces 762"},{"content":"模板元编程 #include \u0026lt;cstdint\u0026gt; template \u0026lt;uint64_t N\u0026gt; struct Fact { enum { Value = N * Fact\u0026lt;N - 1\u0026gt;::Value }; }; template \u0026lt;\u0026gt; struct Fact\u0026lt;1\u0026gt; { enum { Value = 1 }; }; template \u0026lt;uint64_t N\u0026gt; struct Fib { enum { Value = Fib\u0026lt;N - 1\u0026gt;::Value + Fib\u0026lt;N - 2\u0026gt;::Value }; }; template \u0026lt;\u0026gt; struct Fib\u0026lt;1\u0026gt; { enum { Value = 1 }; }; template \u0026lt;\u0026gt; struct Fib\u0026lt;2\u0026gt; { enum { Value = 2 }; }; template \u0026lt;uint64_t base, uint64_t exp\u0026gt; struct Pow { enum { Value = base * Pow\u0026lt;base, exp - 1\u0026gt;::Value }; }; template \u0026lt;uint64_t base\u0026gt; struct Pow\u0026lt;base, 1\u0026gt; { enum { Value = base }; }; int main() { auto val1 = Fact\u0026lt;10\u0026gt;::Value; auto val2 = Fib\u0026lt;20\u0026gt;::Value; auto val3 = Pow\u0026lt;2, 10\u0026gt;::Value; return 0; } 如上代码片段我们是用模板实现了在编译期的计算（C++11起支持）。\nconstexpr 从C++14开始，支持使用consrexpr来修饰函数，这样如果我们给这个函数传入常量，那么将会在编译器计算；如果传入变量，只能在运行期计算。这一点可以从生成的汇编代码看出。\n#include \u0026lt;cstdint\u0026gt; constexpr auto fact(uint64_t n) { if (n == 1) { return n; } return fact(n-1) * n; } int main() { constexpr auto val = fact(10); return 0; } fact(int): push rbp mov rbp, rsp sub rsp, 16 mov DWORD PTR [rbp-4], edi cmp DWORD PTR [rbp-4], 1 jne .L2 mov eax, DWORD PTR [rbp-4] jmp .L3 .L2: mov eax, DWORD PTR [rbp-4] sub eax, 1 mov edi, eax call fact(int) imul eax, DWORD PTR [rbp-4] .L3: leave ret main: push rbp mov rbp, rsp sub rsp, 32 mov DWORD PTR [rbp-20], edi mov QWORD PTR [rbp-32], rsi mov DWORD PTR [rbp-4], 3628800 mov eax, DWORD PTR [rbp-20] mov edi, eax call fact(int) mov DWORD PTR [rbp-8], eax mov eax, 0 leave ret constexpr与模板元编程的比较 #include \u0026lt;cstdint\u0026gt; constexpr auto fib(uint64_t n) { if (n \u0026lt;= 1) { return 1; } return fib(n-1) + fib(n-2); } int main(int argc, char *argv[]) { constexpr auto val = fib(40); return 0; } 如果我们采用constexpr这种写法的话，编译器会报错，这是因为这个函数重复计算比较多。\n而我们使用下面模板元编程这种写法的话就可以，这是因为编译器会对其进行记忆化，省去了重复的计算。\n未来编译器可能会支持constexpr函数的记忆化。\ntemplate\u0026lt;uint64_t N\u0026gt; struct Fib { enum { Value = Fib\u0026lt;N-1\u0026gt;::Value + Fib\u0026lt;N-2\u0026gt;::Value }; }; template\u0026lt;\u0026gt; struct Fib\u0026lt;1\u0026gt; { enum { Value = 1 }; }; template\u0026lt;\u0026gt; struct Fib\u0026lt;0\u0026gt; { enum { Value = 1}; }; int main(int argc, char *argv[]) { auto val = Fib\u0026lt;40\u0026gt;::Value; return 0; } constexpr if C++17开始支持constexpr if，这意味着我们可以简化模板元编程的写法，省去了实例化初始值。这样的话即使比较复杂的计算也能够支持，因为模板元编程有记忆化。\n#include \u0026lt;cstdint\u0026gt; template\u0026lt;uint64_t N\u0026gt; struct Fib { static constexpr uint64_t Value = []{ if constexpr (N \u0026lt;= 1) { return 1; } else { return Fib\u0026lt;N-1\u0026gt;::Value + Fib\u0026lt;N-2\u0026gt;::Value; } }(); }; int main(int argc, char *argv[]) { constexpr auto val = Fib\u0026lt;40\u0026gt;::Value; return 0; } ","permalink":"https://fffzlfk.github.io/posts/%E4%BB%8E%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%E5%88%B0constexprc++/","summary":"C++元编程","title":"从模板元编程到constexpr(C++)"},{"content":"创建型 单例模式 饿汉式 package singleton type Singleton struct{} var singleton *Singleton func init() { singleton = \u0026amp;Singleton{} } // 饿汉式 func GetInstance() *Singleton { return singleton } 懒汉式 package singleton import \u0026#34;sync\u0026#34; var ( LazySingleton *Singleton once = \u0026amp;sync.Once{} ) // 懒汉式 func GetLazyInstance() *Singleton { if LazySingleton == nil { once.Do(func() { LazySingleton = new(Singleton) }) } return singleton } 测试结果 ~/go_files/temp/scheme/singleton » go test -benchmem -bench=\u0026#34;.\u0026#34; -v fffzlfk@DESKTOP-U99TE3D === RUN TestGetInstance --- PASS: TestGetInstance (0.00s) === RUN TestGetLazyInstance --- PASS: TestGetLazyInstance (0.00s) goos: linux goarch: amd64 pkg: scheme/singleton cpu: 11th Gen Intel(R) Core(TM) i5-1135G7 @ 2.40GHz BenchmarkGetInstanceParallel BenchmarkGetInstanceParallel-8 1000000000 0.2773 ns/op 0 B/op 0 allocs/op BenchmarkGetLazyInstanceParallel BenchmarkGetLazyInstanceParallel-8 1000000000 0.8395 ns/op 0 B/op 0 allocs/op PASS ok scheme/singleton 1.244s 可以看到饿汉式性能好一点\n","permalink":"https://fffzlfk.github.io/posts/go%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","summary":"Go Design Scheme","title":"Go设计模式"},{"content":"简单版Generic Map func Map(data interface{}, fn interface{}) []interface{} { vdata := reflect.ValueOf(data) vfn := reflect.ValueOf(fn) res := make([]interface{}, vdata.Len()) for i := 0; i \u0026lt; vdata.Len(); i++ { res[i] = vfn.Call([]reflect.Value{vdata.Index(i)})[0].Interface() } return res } 这里用到了reflect\n我们可以下面的代码使用这个简易的Map函数\nfunc main() { square := func(x int) int { return x * x } nums := []int{1, 2, 3, 4} squareArr := Map(nums, square) for _, v := range squareArr { fmt.Print(v, \u0026#34; \u0026#34;) } upCase := func(str string) string { return strings.ToUpper(str) } fmt.Println() strs := []string{\u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;, \u0026#34;ghi\u0026#34;} upperStrs := Map(strs, upCase) for _, v := range upperStrs { fmt.Print(v, \u0026#34; \u0026#34;) } } 但我们知道reflect是runtime时的事情，如果类型出错，就会出错，所以我们给出健壮版的实现\nGeneric Map \u0026hellip;\n","permalink":"https://fffzlfk.github.io/posts/mapreduce_in_go/","summary":"Map-Reduce","title":"MapReduce_in_Go"},{"content":"基本socket函数 创建网络端点  创建socket描述符  int socket (int family, int type, int protocol) Socket地址 TCP/IP协议的socket地址 struct sockaddr_in { short sin_family; /*AF_INET*/ u_short sin_port; /*端口号，网络字节顺序*/ struct n_addr sin_addr; /*IP地址，网络字节顺序*/ char sin_zero[8]; /*填充字节，必须为全零*/ }; struct in_addr { union { struct { u_char s_b1,s_b2,s_b3,s_b4; } S_un_b; struct { u_short s_w1,s_w2; } S_un_w; u_long S_addr; } S_un; }; 地址转换函数  字符串形式地址转换为网络地址形式inet_aton(const char *cp,struct in_addr *inp); 网络地址转换为字符串地址形式char* inet_ntoa(struct in_addr in);  字节顺序 主机字节顺序  little-endian低字节在前 big-endian高字节在前  网络字节顺序 采用big-endian顺序\n主机字节顺序和网络字节顺序的转换 unsigned short int htons(unsigned short int hostshort) unsigned long int htonl(unsigned long int hotlong) unsigned short int ntohs(unsigned short int netshort) unsigned long int ntohl(unsigned long int netlong) 连接服务器 int connect(int sockfd,struct sockaddr *servaddr,int addrlen) 绑定服务器地址和端口 int bind(int sockfd,struct sockaddr *myaddr,int addrlen); 地址可重用 在bind之前\nint on = 1; setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, \u0026amp;on, sizeof(on)); 监听端口 int listen(int sockfd,int backlog)  sockfd－已绑定的socket描述符 backlog－以完成连接，等待接受的队列长度  接收客户端连接 int accept(int sockfd,struct sockaddr *clientaddr,int addrlen); 代码示例 server #include \u0026lt;arpa/inet.h\u0026gt;#include \u0026lt;netinet/in.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; #define MAXDATASIZE 128 #define PORT 3000 #define BACKLOG 5  int main(int argc, char **argv) { int sockfd, new_fd, nbytes, sin_size; char buf[MAXDATASIZE]; struct sockaddr_in srvaddr, clientaddr; // 1.创建网络端点  sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd == -1) { printf(\u0026#34;can;t create socket\\n\u0026#34;); exit(1); } if (argc == 2) { int on = 1; setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, \u0026amp;on, sizeof(on)); printf(\u0026#34;reuse addr\\n\u0026#34;); } //填充地址  bzero(\u0026amp;srvaddr, sizeof(srvaddr)); srvaddr.sin_family = AF_INET; srvaddr.sin_port = htons(PORT); srvaddr.sin_addr.s_addr = htonl(INADDR_ANY); /* if(inet_aton(argv[1],\u0026amp;srvaddr.sin_addr)==-1){ printf(\u0026#34;addr convert error\\n\u0026#34;); exit(1); } */ // 2.绑定服务器地址和端口  if (bind(sockfd, (struct sockaddr *)\u0026amp;srvaddr, sizeof(struct sockaddr)) == -1) { printf(\u0026#34;bind error\\n\u0026#34;); exit(1); } // 3. 监听端口  if (listen(sockfd, BACKLOG) == -1) { printf(\u0026#34;listen error\\n\u0026#34;); exit(1); } for (;;) { // 4.接受客户端连接  sin_size = sizeof(struct sockaddr_in); if ((new_fd = accept(sockfd, (struct sockaddr *)\u0026amp;clientaddr, \u0026amp;sin_size)) == -1) { printf(\u0026#34;accept error\\n\u0026#34;); continue; } printf(\u0026#34;client addr:%s %d\\n\u0026#34;, inet_ntoa(clientaddr.sin_addr), ntohs(clientaddr.sin_port)); // 5.接收请求  getchar(); nbytes = read(new_fd, buf, MAXDATASIZE); buf[nbytes] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;client:%s\\n\u0026#34;, buf); // 6.回送响应  sprintf(buf, \u0026#34;wellcome!\u0026#34;); write(new_fd, buf, strlen(buf)); //关闭socket  close(new_fd); } close(sockfd); return 0; } client #include \u0026lt;arpa/inet.h\u0026gt;#include \u0026lt;errno.h\u0026gt;#include \u0026lt;netdb.h\u0026gt;#include \u0026lt;netinet/in.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; #define MAXDATASIZE 128 #define PORT 3000  int addr_conv(char *address, struct in_addr *inaddr); int main(int argc, char **argv) { int sockfd, nbytes; int port = PORT; char buf[MAXDATASIZE]; struct sockaddr_in srvaddr; if (argc != 2 \u0026amp;\u0026amp; argc != 3) { printf( \u0026#34;usage:./client hostname|ip. Or usage:./client hostname|ip port\\n\u0026#34;); exit(0); } if (argc == 3) port = atoi(argv[2]); // 1.创建网络端点  sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd == -1) { printf(\u0026#34;can;t create socket\\n\u0026#34;); exit(1); } //指定服务器地址（本地socket地址采用默认值）  bzero(\u0026amp;srvaddr, sizeof(srvaddr)); srvaddr.sin_family = AF_INET; srvaddr.sin_port = htons(port); /* if(inet_aton(\u0026#34;127.0.0.1\u0026#34;,\u0026amp;srvaddr.sin_addr)==-1){ printf(\u0026#34;addr convert error\\n\u0026#34;); exit(1); } */ if (addr_conv(argv[1], \u0026amp;srvaddr.sin_addr) == -1) { perror(strerror(errno)); } // 2.连接服务器  if (connect(sockfd, (struct sockaddr *)\u0026amp;srvaddr, sizeof(struct sockaddr)) == -1) { printf(\u0026#34;connect error\\n\u0026#34;); exit(1); } // 3.发送请求  sprintf(buf, \u0026#34;hello\u0026#34;); write(sockfd, buf, strlen(buf)); sprintf(buf, \u0026#34;hello2\u0026#34;); write(sockfd, buf, strlen(buf)); sprintf(buf, \u0026#34;hello3\u0026#34;); write(sockfd, buf, strlen(buf)); // 4.接收响应  if ((nbytes = read(sockfd, buf, MAXDATASIZE)) == -1) { printf(\u0026#34;read error\\n\u0026#34;); exit(1); } buf[nbytes] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;srv respons:%s\\n\u0026#34;, buf); //关闭socket  close(sockfd); return 0; } int addr_conv(char *address, struct in_addr *inaddr) { struct hostent *he; if (inet_aton(address, inaddr) == 1) { printf(\u0026#34;call inet_aton sucess.\\n\u0026#34;); return 0; } printf(\u0026#34;call inet_aton fail.\\n\u0026#34;); he = gethostbyname(address); if (he != NULL) { printf(\u0026#34;call gethostbyname sucess.\\n\u0026#34;); *inaddr = *((struct in_addr *)(he-\u0026gt;h_addr_list[0])); return 0; } return -1; } 高级socket函数 DHCP 动态主机配置协议（Dynamic Host Configuration Protocol）\n分配方式  自动分配 动态分配 人工分配  DHCP过程 域名访问 域名系统——DNS  域名查找过程  域名到IP的转换函数 struct hostent* gethostbyname(const char *name) struct hostent{ char\th_name;\t/*主机正式名称*/ char\t**h_aliases;\t/*别名列表，以NULL结束*/ int h_addrtype;\t/*主机地址类型：AF_INET*/ int h_length;\t/*主机地址长度：4字节32位*/ char **h_addr_list;\t/*主机网络地址列表，以NULL结束*/ } #define h_addr h_addr_list[0]; //主机的第一个网络地址 示例代码\n#include \u0026lt;arpa/inet.h\u0026gt;#include \u0026lt;fcntl.h\u0026gt;#include \u0026lt;netdb.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;sys/stat.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; int main(int argc, char **argv) { if (argc != 2) { printf(\u0026#34;invalid args\\n\u0026#34;); } struct hostent *he; he = gethostbyname(argv[1]); if (he != NULL) { printf(\u0026#34;h_name:%s\\n\u0026#34;, he-\u0026gt;h_name); printf(\u0026#34;h_length:%d\\n\u0026#34;, he-\u0026gt;h_length); printf(\u0026#34;h_addrtype:%d\\n\u0026#34;, he-\u0026gt;h_addrtype); int i; for (i = 0; he-\u0026gt;h_aliases[i] != NULL; i++) printf(\u0026#34;h_aliases[%d]:%s\\n\u0026#34;, i + 1, he-\u0026gt;h_aliases[i]); printf(\u0026#34;first ip:%s\\r\\n\u0026#34;, inet_ntoa(*((struct in_addr *)he-\u0026gt;h_addr))); for (i = 0; he-\u0026gt;h_addr_list[i] != NULL; i++) printf(\u0026#34;ip%d:%s\\n\u0026#34;, i + 1, inet_ntoa(*(struct in_addr *)he-\u0026gt;h_addr_list[i])); } else { printf(\u0026#34;gethostbyname error: %s\\n\u0026#34;, hstrerror(h_errno)); } return 0; } IP到域名的转换函数  查询IP对应的域名  struct hostent *gethostbyaddr(const char *addr, size_t len, in family);  示例代码  #include \u0026lt;arpa/inet.h\u0026gt;#include \u0026lt;netdb.h\u0026gt;#include \u0026lt;netinet/in.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt; int main(int argc, char *argv[]) { struct in_addr addr; inet_aton(argv[1], \u0026amp;addr); struct hostent *he; he = gethostbyaddr((char *)\u0026amp;addr, 4, AF_INET); if (he != NULL) { printf(\u0026#34;h_name: %s\\n\u0026#34;, he-\u0026gt;h_name); } else { printf(\u0026#34;gethostbyaddr error: %s\u0026#34;, hstrerror(h_errno)); } return 0; } 高级Socket函数 recv和send int recv(int sockfd,void* buf,int len, int flags); int send(int sockfd,void* buf,int len,int flags);  flags  MSG_DONTROUTE不路由——主机在本地网，不需路由。多网卡时，逐个搜索 MSG_OBB带外数据——紧急数据 MSG_PEEK不从缓存区移走数据——多进程共享数据，还可以用来查看缓存区数据 MSG_WAITALL等待所有数据——发现文件结束符时（Crtl+D），函数也结束    shutdown关闭连接 int shutdown(int sockfd,int howto);  howto = 0对后来接收到的数据返回确认后丢弃 howto = 1继续发送发送缓冲区未发送完的数据，然后发送FIN字段关闭写通道 howto = 2关闭读写通道，任何进程不能再操作这个socket  与close的区别  shutdown操作连接通道，其他进程不能再使用已被关闭的通道；close操作描述符，其他进程仍然可以使用该socket描述符 close关闭应用程序与socket的接口，调用close之后进程不能再读写这个socket；shutdown可以只关闭一个通道，另一个通道仍然可以操作      UDP与原始Socket编程 UDP Socket编程 recvfrom：接受UDP数据包 int recvfrom(int sockfd, void *buf, int len, unsigned char flags, struct socketaddr *from, socklen_t *addrlen); sendto：发送UDP数据包 int sendto(int sockfd,const void *buf,int len,unsigned char flags, struct socketaddr *to,int tolen); UDP服务器  服务器不接受客户端连接，只需监听端口 循环服务器，可以交替处理各个客户端数据包  #include \u0026lt;arpa/inet.h\u0026gt;#include \u0026lt;errno.h\u0026gt;#include \u0026lt;netdb.h\u0026gt;#include \u0026lt;netinet/in.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;sys/time.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int main(int argc, char **argv) { if (argc != 2) { cout \u0026lt;\u0026lt; \u0026#34;argument invalid\u0026#34; \u0026lt;\u0026lt; endl; return 1; } short port = atoi(argv[1]); int sockfd = socket(AF_INET, SOCK_DGRAM, 0); if (sockfd == -1) { cout \u0026lt;\u0026lt; \u0026#34;create socket error\u0026#34; \u0026lt;\u0026lt; endl; return 1; } sockaddr_in addr; bzero(\u0026amp;addr, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = htonl(INADDR_ANY); //绑定服务器地址  if (bind(sockfd, (struct sockaddr *)\u0026amp;addr, sizeof(addr)) == -1) { cout \u0026lt;\u0026lt; \u0026#34;bind error\u0026#34; \u0026lt;\u0026lt; endl; return 1; } for (;;) { char buf[32]; sockaddr_in client_addr; socklen_t addr_len; //接收客户端数据包  int n = recvfrom(sockfd, buf, 16, 0, (struct sockaddr *)\u0026amp;client_addr, \u0026amp;addr_len); if (n \u0026gt;= 0) { buf[n] = 0; cout \u0026lt;\u0026lt; \u0026#34;recv:\u0026#34; \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; struct timeval tv; gettimeofday(\u0026amp;tv, NULL); sprintf(buf, \u0026#34;%d %d\u0026#34;, (int)tv.tv_sec, (int)tv.tv_usec); //利用recvfron中得到的地址回送数据包  sendto(sockfd, buf, strlen(buf), 0, (struct sockaddr *)\u0026amp;client_addr, sizeof(client_addr)); } } close(sockfd); return 0; } UDP客户端  客户端不用建立连接，第一次调用sendto函数时，UDP协议为这个UDP socket选择一个端口号，以后的发送和接受操作均使用这个端口号。 客户端可以接收来自任何主机的数据报 客户端可能永远阻塞（服务器主机崩溃）  #include \u0026lt;arpa/inet.h\u0026gt;#include \u0026lt;errno.h\u0026gt;#include \u0026lt;netdb.h\u0026gt;#include \u0026lt;netinet/in.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int main(int argc, char **argv) { if (argc \u0026lt; 2) { cout \u0026lt;\u0026lt; \u0026#34;argument invalid\u0026#34; \u0026lt;\u0026lt; endl; return 1; } short port = atoi(argv[1]); int sockfd = socket(AF_INET, SOCK_DGRAM, 0); if (sockfd == -1) { cout \u0026lt;\u0026lt; \u0026#34;create socket error\u0026#34; \u0026lt;\u0026lt; endl; return 1; } sockaddr_in addr; bzero(\u0026amp;addr, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = htonl(INADDR_ANY); if (argc == 3 \u0026amp;\u0026amp; strcmp(argv[2], \u0026#34;-c\u0026#34;) == 0) { //记录服务器地址  connect(sockfd, (struct sockaddr *)\u0026amp;addr, sizeof(addr)); } for (int i = 0; i \u0026lt; 10; i++) { char buf[16]; sprintf(buf, \u0026#34;%d hello\u0026#34;, getpid()); cout \u0026lt;\u0026lt; \u0026#34;send:\u0026#34; \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; int n; if (argc == 3 \u0026amp;\u0026amp; strcmp(argv[2], \u0026#34;-c\u0026#34;) == 0) { //发送时不需要服务器地址  n = sendto(sockfd, buf, strlen(buf), 0, NULL, 0); } else { //发送时需要服务器地址  n = sendto(sockfd, buf, strlen(buf), 0, (struct sockaddr *)\u0026amp;addr, sizeof(addr)); } n = recvfrom(sockfd, buf, 16, 0, NULL, NULL); if (n \u0026gt;= 0) { buf[n] = 0; cout \u0026lt;\u0026lt; \u0026#34;recv:\u0026#34; \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; } sleep(1); } close(sockfd); return 0; } 有连接的UDP Socket  在UDP Socket上调用connect函数，但不会产生3次握手过程，只记录连接另一方的IP和端口，connect函数马上返回  使用UDP Socket的说明  UDP协议不保证数据包可靠到达（超时和重发机制） UDP协议不保证数据报顺序到达（数据报序列号区分） UDP协议没有流控  UDP广播 server #include \u0026lt;arpa/inet.h\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; int main() { int sockfd; if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) \u0026lt; 0) { exit(-1); } int on = 1; setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST | SO_REUSEADDR, \u0026amp;on, sizeof(int)); struct sockaddr_in addr; memset(\u0026amp;addr, 0, sizeof(struct sockaddr_in)); addr.sin_family = AF_INET; addr.sin_addr.s_addr = inet_addr(\u0026#34;255.255.255.255\u0026#34;); addr.sin_port = htons(8080); char msg[] = \u0026#34;Broadcast Message: Hello!\u0026#34;; int n; if ((n = sendto(sockfd, msg, strlen(msg), 0, (struct sockaddr *)\u0026amp;addr, sizeof(addr))) \u0026lt; 0) { exit(-1); } printf(\u0026#34;msg=%s, msgLen=%ld, sendBytes=%d\\n\u0026#34;, msg, strlen(msg), n); close(sockfd); return 0; } client #include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;netinet/in.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; int main() { int sockfd; if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) \u0026lt; 0) { exit(-1); } int on = 1; setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, \u0026amp;on, sizeof on); struct sockaddr_in addr; memset(\u0026amp;addr, 0, sizeof(sockaddr_in)); addr.sin_family = AF_INET; addr.sin_port = htons(8080); addr.sin_addr.s_addr = INADDR_ANY; if (bind(sockfd, (struct sockaddr *)\u0026amp;addr, sizeof(struct sockaddr)) \u0026lt; 0) { exit(-1); } int n; char buf[256]; socklen_t addr_len = sizeof(struct sockaddr_in); if ((n = recvfrom(sockfd, buf, 256, 0, (struct sockaddr *)\u0026amp;addr, \u0026amp;addr_len)) \u0026lt; 0) { exit(-1); } buf[n] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;Received: %s\\n\u0026#34;, buf); close(sockfd); return 0; } 原始Socket编程 概述  TCP、UDP Socket对TCP协议和UDP协议做了封装来简化编程接口，但失去了对IP数据包操作的灵活性 原始Socket直接针对IP数据包编程，具有更强的灵活性 可以编写基于IP协议的高层协议  发送数据包  没有调用connect函数绑定对方地址时必须用sendto或sendmsg发送数据包；调用connect绑定对方IP地址后，可以使用write和send发送数据包  接收数据包  UDP包和TCP包 大多数ICMP包的拷贝将传递给原始socket 其他类型的数据包的拷贝传递给匹配的socket 内核不能识别的IP数据包将传送给匹配的原始socket  Linux进程与信号机制 概述  linux进程是系统进行资源分配和调度的基本单位。 进程的状态：  新建 运行 阻塞 就绪 完成   按继承关系分类  父、子、孙进程 兄弟进程 孤儿进程    创建进程  pid_t fork(void);  功能：创建新的进程，调用者成为父进程，产生的新进程成为子进程 返回值：  \u0026gt; 0, 子进程的id，只在父进程中返回 -1, 调用失败 =0, 只在子进程中返回   头文件：#include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt;   fork的原理  两次返回  调用fork的进程（父进程）返回正整数（子进程ID） 在新创建的进程（子进程）中返回0，表示是子进程   在调用fork时发生了什么  系统创建新进程，并为该进程准备数据段、堆栈段和代码段 代码段使用和父进程相同的代码段 父进程的数据段和堆栈段被复制（copy on write, 写入时复制）给子进程    子进程和父进程共享的内容  代码段 用户标识符 环境变量 打开的文件描述符(Socket描述符) 根目录 当前工作目录 创建文件的模式 :warning: 数据段和堆栈段通过复制方式共享，因此子进程或父进程修改了变量值后不会影响另一个进程，即使是全局变量。   父子进程执行顺序随机   执行另一个程序  int execve(const char *path,char * const argv[],char *envp);只有execve是真正的系统调用 int execl(const char *path, const char * argv,…);   注意：  fork()和exec()这两个函数，前者用于并行执行，父、子进程执行相同正文中的不同部分；后者用于调用其他进程，进程执行新的正文。 fork()以后，父、子进程共享代码段，并只重新创建数据有改变的页（段页式管理） exec()以后，建立新的代码段，用被调用程序的内容填充。 前者的子进程执行后续的公共代码，后者的子进程不执行后续的公共代码    #include \u0026lt;iostream\u0026gt;#include \u0026lt;unistd.h\u0026gt;using namespace std; int main() { pid_t pid; if ((pid = fork()) == 0) { // 子进程  cout \u0026lt;\u0026lt; \u0026#34;Son Process\u0026#34; \u0026lt;\u0026lt; endl; exit(0); } else if (pid \u0026gt; 0) { // 父进程  cout \u0026lt;\u0026lt; \u0026#34;Father Process\u0026#34; \u0026lt;\u0026lt; endl; exit(0); } else { cout \u0026lt;\u0026lt; \u0026#34;Error\u0026#34; \u0026lt;\u0026lt; endl; exit(1); } return 0; } 创建守护进程  fork()子进程，父进程退出 子进程建立新会话setsid() 改变当前工作目录chdir(不是必须) 重设文件掩码(不是必须)  子进程会继承父进程的掩码 增加子进程程序的灵活性 umask(0);   关键文件描述符（不是必须）  close(0), close(1), close(2) 释放资源   执行核心工作  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstdlib\u0026gt;#include \u0026lt;signal.h\u0026gt;#include \u0026lt;sys/param.h\u0026gt;#include \u0026lt;sys/stat.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;fcntl.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; using namespace std; int main(int argc, char const *argv[]) { // 1. 调用fork，父进程退出，子进程继续运行  pid_t pid = fork(); if (pid \u0026lt; 0) { exit(1); } else if (pid \u0026gt; 0) { exit(0); } // 2. 调用setsid变成会长  // 会长就是一个守护进程  setsid(); // 3. 忽略SIGHUP信号  signal(SIGHUP, SIG_IGN); // 再次fork，父进程（session的头进程）退出  if ((pid = fork()) \u0026gt; 0) { exit(0); } else if (pid \u0026lt; 0) { exit(1); } // 4. chdir 改变当前工作目录  chdir(\u0026#34;/tmp\u0026#34;); // 5. 重设文件掩码  umask(0); // 6. 关闭所有打开的文件描述符  for (int i = 0; i \u0026lt; NOFILE; i++) { close(i); } // 7. 为标准输入（0），标准输出（1）、标准错误输出（2）打开新的文件描述符  int fd_rd = open(\u0026#34;/dev/null\u0026#34;, O_RDONLY); int fd_wr = open(\u0026#34;/root/deamon.log\u0026#34;, O_WRONLY); dup(fd_rd); dup(fd_wr); // 8. 处理SICHLD，避免守护进程的子进程称为僵尸进程  signal(SIGCHLD, SIG_IGN); // 让子进程一直活着  while (true) { } return 0; } 信号机制 信号分类  常用信号：  SIGALARM——计时器到时 SIGCHLD——子进程停止时通知父进程 SIGKILL——终止进程 SIGSTOP——停止进程（暂停） SIGINT——中断字符   可靠信号和非可靠信号 实时信号和非实时信号  发送信号  int kill(pid_t pid, int sig) int raise(int sig)向进程自身发送信号 unsigned int alarm(unsigned int seconds) void abort() int sigqueue(pid_t pid, int sig, const union sigval val) 用kill发送信号 用特定的键盘字符产生信号  CTRL+C产生SIGINT CTRL+BACKSPACE产生SIGQUIT    接收信号  int sigcation(int signum, const struct sigaction *act, struct sigaction *oldact); sigaction结构  struct sigaction { void (*sa_handler)(int); // 函数指针 \tvoid (*sa_sigaction)(int, siginfo_t *, void *); //函数指针 \tsigset_t sa_mask; // 屏蔽的信号集 \tint sa_flags;\t// 标志，SA_SIGINFO \tvoid (*sa_restorer)(void); // 已废弃 } 示例 INT信号处理\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;csignal\u0026gt;#include \u0026lt;unistd.h\u0026gt; using namespace std; void signalHandler(int signum) { cout \u0026lt;\u0026lt; \u0026#34;Catched signal: \u0026#34; \u0026lt;\u0026lt; signum \u0026lt;\u0026lt; endl; // exit(signum); } int main() { // 注册信号SIGNAL和信号处理程序  signal(SIGINT, signalHandler); while (true) { cout \u0026lt;\u0026lt; \u0026#34;Going to sleep...\u0026#34; \u0026lt;\u0026lt; endl; sleep(1); } return 0; } 进程终止 exit()\n处理子进程死亡  僵尸进程（zombie）  子进程终止时如果父进程存在且未处理SIGCHLD信号则子进程变为僵尸进程 僵尸进程占据系统进程表项 对比孤儿进程  子进程终止，父进程并没有调用 wait/waitpid 获取子进程的终止状态，且父进程还没有结束（子进程没有被 init 收养），那么当子进程结束后，它的进程描述符仍然保存在系统中，这就成了僵尸进程。 子进程还没有结束，但是父进程结束了，这个时候子进程失去其唯一的父进程，成为了孤儿进程。     清理僵尸进程的方法1  忽略SIGCHLD信号（使用信号处理函数（SIG_IGN) 忽略SIGCHLD信号时，系统将清除子进程的进程表项，这种方法依赖于Linux版本的实现   终端操作  top，查看动态进程状态 `ps -A -ostat, ppid, pid, cmd | grep -e \u0026lsquo;^[Zz]'，查看僵尸进程 kill -HUP xxxx, 清除僵尸   清除僵尸进程的方法2  调用wait或waitpid等待子进程  pid_t wait(int *status);等待任意子进程终止，没有子进程终止时阻塞，如果没有子进程返回-1 pid_t waitpid(int pid, int *status, int option) 此方法没有兼容性问题     清除僵尸进程的方法3  捕获SIGCHLD信号   清除僵尸进程的方法4  调用fork()两次，使得子进程成为孤儿进程，由init管理  这种方法第一次调用fork产生的子进程可能成为僵尸进程 这种方法第二次调用fork产生的子进程由init处理子进程退出，不会成为僵尸进程   通俗点讲，就是爷爷第一次 fork 生一个老爸，老爸出生后立刻 fork 生下儿子，这个时候老爸的任务就结束了，可以死掉了 (exit)，这个时候儿子被强大的 init 收养，爷爷爱干啥干啥，从而儿子永远不会成为僵尸进程。\n     #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;sys/wait.h\u0026gt; int main() { pid_t pid; if ((pid = fork()) == 0) { pid = fork(); if (pid \u0026gt; 0) { // 父亲生下儿子直接退出，儿子会被收养  exit(0); } sleep(0.5); printf(\u0026#34;I\u0026#39;m son after second fork.\\n\u0026#34;); printf(\u0026#34;my parent\u0026#39;s pid: %d\\n\u0026#34;, getppid()); exit(0); } // 爷爷生下父亲后直接等待为其收尸  waitpid(pid, NULL, 0); // 爷爷尽情快活  return 0; } 进程同步 当fork调用成功后，父子进程各做各的事情，但当父进程的工作告一段落，需要用到子进程的结果时，它就停下来调用wait，一直等到子进程运行结束，然后利用子进程的结果继续执行。\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/wait.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; int main() { pid_t pc, pr; int status; pc = fork(); if (pc \u0026lt; 0) printf(\u0026#34;Error occured on forking.\\n\u0026#34;); else if (pc == 0) { /* 子进程的工作 */ printf(\u0026#34;son\\n\u0026#34;); exit(0); } else { /* 父进程的工作 */ printf(\u0026#34;father\\n\u0026#34;); pr = wait(\u0026amp;status); /* 利用子进程的结果 */ } return 0; } Linux进程间通信（IPC) 管道  单向通信，实现双向通信需创建两个管道 只适用于父子间进程通信  使用管道  用pipe创建两个管道pipe1和pipe2 pipe[0]读，pipe[1]写 fork()创建子进程 父进程用pipe1写数据（关闭pipe1读端口），pipe2读数据（关闭pipe2写端口） 子进程用pipe1读数据（关闭pipe1写端口），pipe2写数据（关闭pipe2读端口）  示例 #include \u0026lt;errno.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int main(int argc, char **argv) { int pipe1[2], pipe2[2]; char pstr[] = \u0026#34;parent data\u0026#34;; char cstr[] = \u0026#34;child data\u0026#34;; char buf[100]; if (pipe(pipe1) \u0026lt; 0 || pipe(pipe2) \u0026lt; 0) cout \u0026lt;\u0026lt; \u0026#34;pipe error\u0026#34; \u0026lt;\u0026lt; endl; pid_t pid = fork(); if (pid \u0026gt; 0) { // 父进程,用管道1写数据,管道2读数据  close(pipe1[0]); //关闭pipe1读端口  close(pipe2[1]); //关闭pipe2写端口  write(pipe1[1], pstr, sizeof(pstr)); if (read(pipe2[0], buf, 100) \u0026gt; 0) cout \u0026lt;\u0026lt; \u0026#34;parent received:\u0026#34; \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; } else if (pid == 0) { // 子进程用管道1读数据,管道2写数据  close(pipe1[1]); //关闭pipe1写端口  close(pipe2[0]); //关闭pipe2读端口  if (read(pipe1[0], buf, 100) \u0026gt; 0) cout \u0026lt;\u0026lt; \u0026#34;child received:\u0026#34; \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; write(pipe2[1], cstr, sizeof(cstr)); exit(0); } else cout \u0026lt;\u0026lt; \u0026#34;fork error\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 命名管道 特点  与一个路径名相关联，以文件形式存在于文件系统中 该文件名所对应的文件没有数据只是为了便于其他进程引用 可以在兄弟进程通信  创建 int mkfifo(char *pathname, mode_t mode);\n使用  写进程mkfifo创建命名管道 写进程open以写阻塞方式打开管道 读进程open以读阻塞方式打开管道 写进程调用write写，读进程read读出数据  示例 fifo_server.cpp\n#include \u0026lt;errno.h\u0026gt;#include \u0026lt;fcntl.h\u0026gt;#include \u0026lt;signal.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;sys/stat.h\u0026gt;#include \u0026lt;sys/time.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/wait.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; #define FIFO_NAME \u0026#34;/home/fffzlfk/fifo_test\u0026#34;  int main(int argc, char **argv) { char pstr[] = \u0026#34;server data\u0026#34;; if (mkfifo(FIFO_NAME, O_CREAT | O_EXCL) \u0026lt; 0 \u0026amp;\u0026amp; (errno != EEXIST)) cout \u0026lt;\u0026lt; \u0026#34;create fifo error\u0026#34; \u0026lt;\u0026lt; endl; int fd; if (argc == 2 \u0026amp;\u0026amp; strcmp(argv[1], \u0026#34;-b\u0026#34;) == 0) fd = open(FIFO_NAME, O_WRONLY, 0); else fd = open(FIFO_NAME, O_WRONLY | O_NONBLOCK, 0); if (fd != -1) cout \u0026lt;\u0026lt; \u0026#34;open success\u0026#34; \u0026lt;\u0026lt; endl; else { perror(\u0026#34;open fail\u0026#34;); return 0; } int write_num = write(fd, pstr, sizeof(pstr)); if (write_num == -1) { if (errno = EAGAIN) cout \u0026lt;\u0026lt; \u0026#34;write fifo error,try later:\u0026#34; \u0026lt;\u0026lt; endl; } else cout \u0026lt;\u0026lt; \u0026#34;real write num is:\u0026#34; \u0026lt;\u0026lt; write_num \u0026lt;\u0026lt; endl; return 0; } fifo_client.cpp\n#include \u0026lt;errno.h\u0026gt;#include \u0026lt;fcntl.h\u0026gt;#include \u0026lt;signal.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;sys/stat.h\u0026gt;#include \u0026lt;sys/time.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/wait.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; #define FIFO_NAME \u0026#34;/home/fffzlfk/fifo_test\u0026#34;  int main(int argc, char **argv) { char buf[1024]; int fd; if (argc == 2 \u0026amp;\u0026amp; strcmp(argv[1], \u0026#34;-b\u0026#34;) == 0) fd = open(FIFO_NAME, O_RDONLY, 0); else fd = open(FIFO_NAME, O_RDONLY | O_NONBLOCK, 0); if (fd != -1) cout \u0026lt;\u0026lt; \u0026#34;open success\u0026#34; \u0026lt;\u0026lt; endl; else { perror(\u0026#34;open fail\u0026#34;); return 0; } int read_num = 20; memset(buf, 0, sizeof(buf)); read_num = read(fd, buf, 1024); if (read_num == -1) { if (errno == EAGAIN) cout \u0026lt;\u0026lt; \u0026#34;no data,try later:\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;real read bytes:\u0026#34; \u0026lt;\u0026lt; read_num \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;read data:\u0026#34; \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; } //删除管道文件  // unlink(FIFO_NAME);  return 0; } Unix域Socket  不是真正的网络协议 提供同一台机器的的进程间通信 是双向通道 分为命名和非命名两种  命名Unix域Socket  特点  服务器可以接收多个客户端连接请求 客户端调用函数connect服务器连接  connect使用的socket应该是已打开的UNIX域socket 客户端必须拥有打开socket地址所指文件权限 监听socket的连接队列满时connect立刻返回错误      非命名Unix域Socket  特点  无名的 全双工 不需要连接 父子进程间通信使用socketpair    I/O模型 阻塞I/O模型  产生阻塞的原因——时间片调度算法 好处——阻塞进程不占用CPU时间 产生阻塞的函数——读、写、建立连接、接受连接  读：read、readv、recv、recvfrom和recvmsg 写：write、writev、send、sendto和sendmsg 建立连接：connect 接受连接：accept   超时控制  调用alarm函数设置超时 设置socket选项——设置SO_RCVTIMEO和SO_SNDTIMEO选项    非阻塞I/O模型  设置Socket为非阻塞方式  函数fcntl int flags; flag = fcntl(sockfd,F_GETFL,0); fcntl(sockfd,F_SETFL,flag|O_NONBLOCK);  函数ioctl int on=1; ioctl(sockfd,FIONBIO,\u0026amp;on);    检查操作是否可以完成的方式（轮询）  输入输出多路复用I/O模型 int select(int maxfd, struct fd_set* rdset, struct fd_set* wrset, struct fd_set* exset, struct timeval* timeout); void FD_SET(int fd,fd_set *fdset) //将fd加入到fdset void FD_CLR(int fd,fd_set *fdset) //将fd从fdset里面清除 void FD_ZERO(fd_set *fdset) //从fdset中清除所有的文件描述符 int FD_ISSET(int fd,fd_set *fdset) //判断fd是否在fdset集合中 select()可以设置超时，使长期没有文件描述符就绪时，进程可以跳出阻塞状态。select()的第一个参数 maxfd 是集合中最大的文件描述符加1，如：一个包含3个套接字描述符的集合{12，23，30}，那么 maxfd 就应该是30+1=31。\n在我们调用select( )时，进程会一直阻塞到以下的一种情况发生:\n 有文件可以读，包括出现错误； 有文件可以写，包括出现错误； 超时所设置的时间到； 被信号中断。  信号驱动I/O模型  设置SIGIO信号处理函数 设置socket描述符所有者 允许这个socket进行信号驱动I/O  void sigio_handler(int signo) { ... } int main() { int sockfd; int on = 1; ... signal(SIGIO, sigio_handler); fcntl(sockfd, F_SETOWN, getpid()); // 设置套接字所有者为当前进程  ioctl(sockfd, FIOASYNC, \u0026amp;on); // 启动信号驱动模式  ... } 服务器模型 网络服务器分类  循环服务器：同一时刻只能处理一个客户端请求 并发服务器：同一时刻可以处理多个客户端请求 UDP和TCP服务器模型  UDP服务器通常采用循环服务器模型 TCP服务器通常采用并发服务器模型    循环服务器模型 UDP循环服务器模型 TCP循环服务器模型 并发服务器模型 UCP并发服务器模型 TCP并发服务器模型  一个子进程对应一个客户端  创建子进程开销大，适合长时间客户请求（如FTP） 客户端数量大、请求时间短会大大降低效率（如HTTP）    延迟创建子进程  处理短请求以循环方式完成 处理时间长的请求以并发方式完成    预创建子进程  数量固定  所有进程调用accept，无连接时将睡眠 有连接到来时所有进程被唤醒 某一个进程接受连接后，其余连接继续睡眠    动态子进程数  父进程与子进程通过管道通信 子进程接收连接时给父进程发1，关闭时发0 父进程收到1时，检查空闲子进程数是否小于上限，小于则创建新的子进程 父进程收到0时，检查空闲子进程数是否大于上限，大于则终止一些子进程      多路复用I/O  select函数检查侦听socket是否有连接到达、已连接socket是否有数据到达、已连接socket是否可以写数据 在测试是否可读的描述符集合rdset中同时包含侦听socket和已连接socket，在测试是否可写描述符集合中包含已连接socket，就可以实现多路复用    Linux epoll  一种多路复用模型 对比select   select\nint n = select(maxfd+1, \u0026amp;rds, NULL, NULL, 100); if (n \u0026gt; 0) { for(int i = 0; i \u0026lt; fdset_size; i++) { if (FD_ISSET(allFD[i],\u0026amp;rds)) { handleEvent(allFD[i]); } } }   epoll\nint n = epoll_wait(epfd, events, 10, 100); for(int i = 0; i \u0026lt; n;i++) { handleEvent(events[n]); }     带外数据（OOB） 带外数据（Out Of Band）：传输层使用带外数据发送重要数据\n紧急状态\n 发送方TCP协议保证紧急状态能够立即发送 接收方通过信号SIGURG或select函数得知紧急状态  TCP带外数据发送  TCP只支持1字节带外数据 TCP使用URG标志位和紧急指针指明带外数据：紧急指针=带外数据位置+1   发送TCP带外数据的函数 send函数和标志MSG_OOB\n一个进程已经往TCP连接的发送缓冲区写入了N个字节的普通数据，然后该进程又向这个连接写入了3字节的带外数据“abc”。此时，待发送的TCP报文段头部将被设置为URG标志，并将紧急指针设置为指向带外数据的下一字节。\n 发送单个字节，这个字节被认为是带外数据send(sockfd, \u0026quot;A\u0026quot;, 1, MSG_OOB); 发送多个字节，只有最后一个字节被认为是带外数据send(sockfd, \u0026quot;ABC\u0026quot;, 3, MSG_OOB);，其他数据被当作普通数据。  TCP接收带外数据的过程 TCP接收端在收到紧急指针标志时检查紧急指针，然后根据紧急指针的位置确定带外数据的位置，并将它读入一个特殊的缓存中（1字节），称之为带外缓存。\n 未设置SO_OOBINLINE选项时新到来的带外数据将覆盖未处理的带外数据。 设置了SO_OOBINLINE选项时新到来的带外数据不会覆盖未处理的带外数据，但未处理的带外数据将会变成普通数据。  代码  ./sigurg port，读数据，带外数据在信号处理中 ./oobserver port，接受连接并给客户机发包含带外数据的包 ./oobclient port-i，oob_inline  复习   一台工作于内外网模式的主机，具有一个外网地址IP_OUTTER和一个内网地址192.168.1，内网的掩码为192.168.1.125。该主机可将外网用户的请求广播给内网用户。请设计和实现该主机程序。\n 问题分析和方案设计  TCP协议具有稳定可靠的特性，本题中外网通信属于单播，使用TCP协议能够具有良好性能，因此外网通信使用TCP套接字。 内网涉及到广播，适合使用UDP协议进行工作，因此内网采用UDP套接字工作。 主机采用单进程、阻塞式工作。   编程 #include \u0026lt;arpa/inet.h\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;netinet/in.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; using namespace std; const int port = 8080; int main() { int sockt, connfd, socku; struct sockaddr_in addr, addrX; char buf[2048]; if ((sockt = socket(AF_INET, SOCK_STREAM, 0)) \u0026lt; 0) { exit(-1); } bzero(\u0026amp;addr, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = htonl(INADDR_ANY); if ((bind(sockt, (sockaddr *)\u0026amp;addr, sizeof(addr))) \u0026lt; 0) { exit(-1); } if (listen(sockt, 5) == -1) { exit(-1); } struct sockaddr_in cli_addr; socklen_t sin_size = sizeof(struct sockaddr_in); for (;;) { connfd = accept(sockt, (sockaddr *)\u0026amp;cli_addr, \u0026amp;sin_size); if (connfd \u0026lt; 0) { exit(-1); } int n = read(connfd, buf, 2048); if (n \u0026lt;= 0) { exit(-1); } if ((socku = socket(AF_INET, SOCK_DGRAM, 0)) \u0026lt; 0) { exit(-1); } bzero(\u0026amp;addrX, sizeof(addr)); addrX.sin_family = AF_INET; addrX.sin_port = htons(port); addrX.sin_addr.s_addr = inet_addr(\u0026#34;192.168.1.1\u0026#34;); n = sendto(socku, buf, n, 0, (sockaddr *)\u0026amp;addrX, sizeof(addrX)); close(socku); close(sockt); } return 0; }     有一台服务器，可以为多个客户机同时提供两个整数的乘法和除法运算，请设计和实现该服务器。提示：需考虑应用层协议、僵尸进程的清除等问题。\n 问题分析和方案设计  本题需要同时为多个客户机服务，应采用并发方式； 对于整数、要考虑字节顺序转换； 除法要考虑除0问题； 设计服务器接收数据格式如下：  int mType (运算类型：0-乘、1-除) n1(整数1)，n2(整数2)   服务器发送数据格式如下：  int mRet(0-正确、1-错误) n（运算结果）   工作于TCP方式。   编程 void sigchild_handler(int sig) { wait(NULL); } main() { int sock, connfd; struct sockaddr_in addr; struct sigaction sigact; short mRet, mType; int n, n1, n2; char buf[1024]; sigact.sa_handler = sigchild_handler; sigact.sa_mask = 0; sigact.sa_flags = 0; sigaction(SIGCHILD, \u0026amp;sigact, NULL); if ((sock = socket(AF_INET, SOCK_STREAM, 0))\u0026lt; 0) { exit(-1); } SET_ADDR_PORT; if (bind() \u0026lt; 0) { exit(-1); } if (listen(sock, 5) \u0026lt; 0) { exit(-1); } for (;;) { connfd = accept(); if (connfd \u0026lt; 0) { exit(-1); } if (fork() == 0) { close(sock); int n = read(conndf, buf, 2048); if (n \u0026lt;= 0) { exit(-1); } mRet = 0; ntoh(CharToInt); if (mType == 0) { n = hton(n1*n2); } else if (mType == 1 \u0026amp;\u0026amp; n2 != 0) { n = hton(n1/n2); } else { mRet = hton(1); n = 0; } IntToChar; write(connfd, buf, 2*sizeof(int)); close(connfd); exit(0); } exit(0); } close(sock); }     ","permalink":"https://fffzlfk.github.io/posts/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","summary":"Network Program Design for Application","title":"网络应用程序设计"},{"content":"概述 分布式系统定义 分布式计算：多个通过网络互联的计算节点通过相互协作共同完成计算任务。\n理解分布式系统定义的几个要点  多个计算节点：计算节点抽象为有限状态机（图灵机） 网络互联 独立自治 相互协作共同完成目标 消息传递模型   与并行计算的关系 不同层次的并行计算：\n 指令级并行：多指令并行；单指多数并行（向量指令） CPU多核并行：多线程编程 多CPU并行（一致性内存访问）：多线程编程 多CPU并行（非一致性内存访问）：超级计算机 基于GPU的并行：单指多数并行；CUDA、OpenCL 多机并行：就业消息传递的分布式计算（share nothing）  构建分布式系统的目的  提高计算能力 提高存储能力 提高网络吞吐能力（并发访问能力） 提高可靠性（解决局部失效问题） 提高安全性（解决被局部攻击问题） 提高可扩展性（解决瓶颈问题） 实现资源共享 实现跨越时空的协同服务（发挥不同节点的优势）  衡量分布式系统优劣的特性  可扩展性/可伸缩性（Scalability）  垂直可扩展性（Vertical Scalablility） 水平可扩展性（Horizontal Scalability）   容错性（Fault Tolerance/Reliability）  可用性（Availability） 可恢复性（Recoverability）   透明性（Transparency） 开放性（Openness） 安全性（Security） 可维护性（Maintainability）  设计分布式系统的挑战  异构性 自治 局部视图 开放性 可扩展性 故障处理 安全性 透明性 服务质量保证  关于分布式一致性 几类分布式系统框架模式   客户端-服务器（Client-Server）模式  客户端发出服务请求，服务端根据客户端请求参数完成实际运算，并将运算结果返回给客户端 客户端运算任务轻、服务端运算任务重 客户端生命周期短、服务端生命周期长 服务端一般要应对并发问题 客户端一般负责和用户进行交互 瘦客户端/胖服务端    Client—Cluster模式\n 是Client-Server模式的变种 服务端由多个服务器构成，共同承担计算任务 在宏观逻辑上，多个服务器构成的集群可以视为单一的功能强大的计算节点。客户端感觉不到服务端的实际构成。    主从（Master-Slave）模式\n 主节点（Master）负责将总任务分解为多个自任务分发给各个从节点（Slave，也叫Worker节点） 主节点监视各个从节点的任务执行情况，将执行失败的任务调度给其他的从节点完成 主节点在分配任务时会参考各个节点的当前负载情况    总线模式\n 不同节点通过虚拟总线相连 消息发送者不必知道接收者是谁，接收者也不知道发送者是谁 发送者和接收者之间用异步方式通信 一种松耦合结构 不同节点完成不同功能，分工协作    对等（Peer-to-Peer）模式\n 系统中每个计算节点在任务分工上是完全对等的 完全相同软件在不同的计算机上运行，只是初始化参数不同 结构化P2P：不同节点之间的交互模式遵循固定规律 非结构化P2P：不同节点之间的交互模式没有固定规律    混合模式\n  常用的负载均衡策略  随机 轮询 固定权重值 IP哈希（基于一致性随机散列函数） 最少TCP连接数 最小响应时间 基于各服务器实际负载的动态负载均衡算法  中间件的基本概念 中间件的作用  为开发者提供高层的编程抽象，屏蔽分布式系统的底层的异构型复杂性 提高互操作性和可移植性 提供分布式系统的基础设施服务  常用的中间件  远程过程调用中间件 分布式对象中间件 分布式组件中间件 消息队列中间件 Web服务中间件 P2P中间件  中间件的表现形式  作为独立的后台进程存在 作为运行时的函数库/类库存在（LIB静态库、DLL动态库、Jar包等） 作为源代码级的函数库/类库存在 作为高级语言解释器的一部分存在 作为辅助编译工具存在 作为高级语言编译器的一部分存在  抽象理论模型  交互模式  同步模型 异步模型   信息故障模式 节点故障模式  失效停止模式（Fail—Stop） 失效停止恢复模式 拜占庭模式 发送者验证拜占庭模式 理性拜占庭模式    分布式节点之间的通信技术 TCP/IP网络体系介绍  TCP/IP先于OSI模型，不完全符合OSI标准  TCP/IP四层模型（也可分为五层，将网络接口分为两层）   Socket 什么是Socket 网络层和传输层提供给应用层的标准化编程接口（或称为编程接口） 套接字分类-Socket类型   流式套接字\n  数据报套接字\n  原始套接字\n  如何标识一个Socket   五元组：\u0026lt;SIP, sPort, dIP, dPort, 协议\u0026gt;\n 本地IP地址 本地端口号（通常临时分配：1024~5000） 远程IP地址 远程端口号（通常使用保留端口号1~1023） 协议类型（注意TCP 53和UDP 53是不同的）    TCP套接字编程典型模型   UDP套接字编程典型模型   并发服务技术  基于多线程的并发服务技术 基于线程池的并发服务技术  示例程序  基于TCP协议的Client-Server通信程序示例  Server Client    第一次作业   将基于UDP协议的Client-Server通信程序示例的服务器端程序改造成多线程版。\n  将基于TCP协议的Client-Server通信程序示例的服务器端程序改造成线程池版。\n代码实现\n  远程调用RPC和RMI 远程调用RPC 远程过程调用（Remote Procedure Call，RPC）：使应用程序可以像调用本地节点上的过程那样去调用一个远程节点上的子程序。\n远程方法调用RMI 远程方法调用（Remote Method Invocation， RMI）：将面向对象的编程模型扩展到了分布式环境。\nRPC/RMI中间件的作用  定义并利用Socket服务接口实现了一套调用者和被调用者之间的通信协议——远程调用协议 实现了过程参数以及运算结果的序列化和反序列化 通信过程中的错误处理 过程服务进程（或远程对象）的集中注册与发现——目录服务 远程对象的统一标识和生命周期管理 在服务端支持并发访问（多采用多线程技术）  注册中心  用于服务端注册远程服务以及客户端发现服务 可以实现负载均衡  RPC/RMI中间件的实现原理  在调用者进程中注入stu/proxy模块 在被调用者进程中注入skeleton模块 stub和skeleton之间利用Socket进行通信 skeleton相当于服务器端  gRPC中间件  通信协议基于HTTP协议标准，对象序列化基于**ProtoBuf(Protocol Buffers)**序列化协议 Protocol Buffers(简称Protobuf) 是Google设计的序列化标准协议和序列化中间件。  程序中应用Protobuf的方法  在.proto文件中定义要序列化的对象（使用独立于具体编程语言的标准格式Protocol Buffers） 利用代码自动生成工具（eg：Windows下protoc.exe）生成所有要序列化对象的工厂类 将生成的工厂类源码添加到应用工程中 需要创建一个可序列化对象时，用工厂对象创建 调用可序列化对象的writeTo方法将对象序列化成字节流并存入外部存储介质 调用工厂对象的parseFrom方法可以实现反序列化，并根据反序列化结果生成一个新的对象  程序中应用gRPC的方法  将RPC服务接口定义为标准.proto文件 用Protobuf提供的代码自动生成工具根据.proto文件生成RPC服务中所有要序列化对象的工厂类 利用gRPC提供的代码自动生成工具根据.proto文件生成RPC服务的stub类和skeleton类 将工具自动生成的序列化对象工厂相关源程序、RPC服务的stub类和skeleton类相关源程序加入的RPC服务端工程中 RPC服务端工程基于skeleton类中相关基类实现RPC服务功能的核心逻辑和监听服务器 将工具自动生成的序列化对象工厂相关源程序、RPC服务的stub类和skeleton类相关源程序加入的RPC客户端工程中 RPC客户端工程基于stub类实现调用RPC服务的相关逻辑  第二次作业 利用RPC技术实现一个书籍信息管理系统，具体要求：\n 客户端实现用户交互，服务器端实现书籍信息存储和管理。客户端与服务器端利用RPC机制进行通信。可以选择Java RMI、gRPC、Dubbo等任意RPC中间件。 服务器端至少暴露如下RPC接口：  bool add(Book b) 添加一个书籍对象。（注意Book对象序列化问题） Book queryByID(int bookID) 查询指定ID号的书籍对象。 BookList queryByName(String name) 按书名查询书籍对象列表。 bool delete((int bookID) 删除指定ID号的书籍对象。    实现\n微服务 各个模块独立（大多采用容器技术（如Docker）），模块之间使用RPC通信。\n基于消息中间件的通信技术 点到点通信技术的缺点  关系复杂，耦合度高 可扩展性差：增加生产者或消费者对多个节点产生影响 容错性差：节点失效或生产者和消费者速度不匹配会丢失数据  解决方案——增减中介节点  降低了耦合性 提高了容错性：中介节点具有数据缓存功能 提高了可扩展性：增加生产者或消费者对其他节点无影响  面向消息中间件（Message Oriented Middleware，MOM） 使分布式应用程序可以通过发送和接收消息来进行异步通信和交换数据。\nMOM两种通信模式   消息队列模式\n 消息队列中的消息一旦被某个消费者取走，该消息就从队列中删除 可以实现负载均衡    主题订阅模式（类似微信公众号订阅）\n 多个订阅同一主题的消费者可以同时接收发布到该消息主题的消息 可以实现广播     三种接收方式  阻塞接收（同步） 轮询接收 回调接收（异步）  第三次作业 利用MOM消息队列技术实现一个分布式随机信号分析系统，具体要求：\n 随机信号产生器每隔10毫秒左右就产生一个正态分布的随机数字，并作为一个消发布 多个随机信号分析模块订阅并接收该随机数字，然后对信号进行分析并实时显示分结果。至少包含如下分析模块：  计算随机信号的均值； 计算过去N个随机信号的方差（N为常量，可设置） 实现基于正态分布的异常点检测 实时绘制过去一段时间内随机信号的折线图（选作）    基于NSQ的Golang实现\n分布式存储 分布式存储要达到的目标  提高存储容量：多个存储节点容量的聚合（水平可扩展） 提高数据吞吐量 提高可靠性/可用性：部分存储节点发生故障时数据不丢失，部分节点失效时用户依然可以访问（容错性） 低时延：就近的服务器上（CDN）  基本手段：复制（replica）  用途  如果一些节点不可用，剩余的节点仍然可以提供服务 提高吞吐率   带来的问题  硬件成本 多数据副本之间的一致性问题    基本手段：分区（Partitioning) 将一个大型数据库文件（或数据库）拆分成较小的子集（称为分区partition或切片shard）派分给不同的节点\n 带来的问题  跨区处理（分布式索引问题） 合理、动态分区问题（大数据如何拆分） 负载均衡 分布式事务处理    基于领导者的复制（主从复制）  客户端要向数据存储系统写入数据时，它必须将请求发送给领导者；领导者将新数据写入本地存储，同时也会将数据变更发送给所有的追随者。 当客户想要从数据存储系统读取数据时，它可以向领导者或追随者查询。 适合于读多写少的应用场景。  同步复制和异步复制  同步  异步   多副本分布式存储中的一致性问题  强一致性  一个客户端写入成功，其他客户端后续都可以读出新版本的值 每个读操作一定不会读出比上一次更旧的版本   顺序一致性 因果一致性 最终一致性  CAP定理 Consistensy（一致性）、Partition Tolerance（切割容忍性）、Availability（可用性）三者只能取其二，不可兼得三者。\n很多时候只能取CP或AP，因为一般无法保证网络每时每刻畅通\nBASE定理 对CAP中的一致性和可用性权衡的结果：基本可用（Basically Available）、软件态（Soft State）、最终一致性（Eventually Consistency）\n数据分区的基本方法 根据主键范围进行分区 一般都是非均匀分布的，所以需要建立全局索引\n根据主键的哈希值进行分区 哈希函数  输入：长度不定的01串 输出：长度固定的01串 值域空间：$[0, 2^{n}-1]$ 特性  确定性 ”随机性“ 无碰撞性：任何两个输入，它们输出值相等的概率为$2^{-n}$    主要思想 $$ hash(key)\\mod N $$\n优点  一定程度上避免了偏斜和热点问题 无须全局索引  缺点 当节点数量变动时，需要大量的数据迁移。\n基于一致性哈希算法的分区——哈希环 当新增节点后，仅仅需要迁移少量数据。\n缺点：只能在节点之间新增新节点，这样会导致负载分配不均衡。\n使用虚拟节点改进的一致性哈希 每个物理节点有若干个虚拟节点，这样一个物理节点可以通过虚拟节点的方式均匀分散在哈希环的各个部分，解决了数据倾斜问题。\nHDFS分布式文件系统 NameNode维护的两张表  文件名——数据块对应表：每个文件被切片之后对应若干个有唯一标识号的数据块 数据块——物理节点对应表：每个数据块在不同DataNode存储3份（3备份策略）  写流程  Client向NameNode请求增加数据块（维护文件名——数据块对应表） NameNode返回数据块号及分配的3个DataNode IP地址（3备份策略） Client与NameNode流水线方式写入数据块（完成后维护数据块——物理节点对应表）  读流程  客户端向请求NameNode，传送参数：文件名、偏移量、长度 NameNode查找文件名——数据块对应表和数据块——物理节点对应表，将对应DataNode的IP地址返回给CLient Client向最近的DataNode建立连接完成读取  MapReduce模型和分布式计算框架 MapReduce并行计算模型 单词计数的例子 Hadoop MapReduce计算模型  Client类  设置工作参数 设置Map Reduce Job对象 设置要上传给Hadoop平台的Jar包或Class 指定Mapper类 指定Combiner类（可选） 指定Reducer类 设定输出数据的格式 设定输入、输出文件路径 启动该Job直到运行结束   Mapper类：实现Map接口(K1, V1)-\u0026gt;(K2, V2) Combiner类：实现Reduce接口(K2, list(V2))-\u0026gt;list(K3, V3) Reducer类：实现Reduce接口(K3, list(V3))-\u0026gt;list(K4, V4)  Spark平台和基于RDD-DAG的计算模型 Spark简介 Spark是一个快速、通用、可扩展的分布式计算平台。\nSpark平台体系结构 分布式弹性数据集RDDs RDDs全称Resilient Distributed Datasets是Spark最基本的数据抽象，它是只读的、分区存储的、分布式的数据集合。\n可以将RDDs看作一个分布式存储的“大数组”，应用程序只需关心如何由一个RDDs转换为另一个RDDs，不用关心RDD在底层是如何分区、如何分布到多个节点上、如何在内存中缓存、内存缓存丢失后如何重新生成。\n容错性 如果RDDs的某个分区失效，Spark会根据DAG往回查看并重新恢复数据。\n将计算任务抽象为有向无环图 ","permalink":"https://fffzlfk.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/","summary":"Distributed Computing","title":"分布式计算"},{"content":"Code is like humor. When you have to explain it, it's bad.\nHey，我是fffzlfk一名西电CS在读本科生 学习之余，我还是一个喜欢折腾的人\n你可以在下面找到我  GitHub Email  ","permalink":"https://fffzlfk.github.io/about/","summary":"Code is like humor. When you have to explain it, it's bad.\nHey，我是fffzlfk一名西电CS在读本科生 学习之余，我还是一个喜欢折腾的人\n你可以在下面找到我  GitHub Email  ","title":"About"},{"content":"第一章 引言 语言之间的翻译 编译器与解释器 语言翻译两种基本形态  先翻译后执行 边翻译边执行  编译器的工作原理和基本组成 通用程序设计语言的主要成分 声明+定义\n以阶段划分编译器 编译器的分析/综合模式 作业题  何谓编译器的前端和后端？  前端主要由与源语言有关但与目标机无关的部分组成，通常包括词法分析、语法分析、语义分析和中间代码生成，有的代码优化工作也可包括在前端。 后端包括编译程序中与目标机有关的部分，如与目标机有关的代码优化和目标代码生成等。通常，后端不依赖源语言而仅仅依赖中间语言。   画出编译程序的总体结构图，简述各部分的主要功能。  词法分析：输入源程序，输出单词符号 语法分析：对单词符号进行语法分析（根据语法规则进行推导或归约），识别出各类语法单位，最终判断输入串是否构成语法上正确的”程序“。 语义分析与中间代码生成：按照语义规则对语法分析器归约出（或推导出）的语法单位进行语义分析并把它们翻译成一定形式的中间代码 中间代码优化：对中间代码进行优化处理 目标代码生成：把中间代码翻译成目标程序 符号表管理：编译程序在工作中保持一系列的表格，以登记源程序的各类信息的编译中各阶段的进展状况。 出错处理：如果程序中发现错误，编译器就将信息发送给用户。   试分析编译程序是否分遍应考虑的因素及多遍扫描的优缺点。  决定遍数的因素：  计算机存储容量大小 编译程序功能强弱 源语言繁简 目标程序优化程度 设计和实现编译程序时使用工具的先进程度 参与人员多少和素质等   多遍扫描的优点：  加工充分 出错处理细致 目标程序质量高   多遍扫描的缺点：  编译时间长，开销大     编译程序：一种能够把高级语言程序翻译成低级语言（汇编语言、机器语言）程序的程序 语义：一种语言的单词符号和语法单位的意义 语法：所谓一个语言的语法是这样的一组规则，用它可以形成和产生一个合式的程序 遍：遍就是对源程序的中间结构从头到尾扫描一次，并做有关的加工处理，生成新的中间结果或目标程序。  第二章 词法分析 词法分析中的若干问题 记号、模式与单词    单词的基本分类      关键字（保留字） key(key word, or reversed word)   标识符 id(identifier)   字面量 literal   特殊符号 ks(key symbol, or special symbol)    记号=记号的类别+记号的属性\n模式的形式化描述 字符串与语言   定义2.1：语言$L$是有限字母表$\\sum$上有限长度字符串的集合。\n  字符串：由字母表中的符号组成的任意有穷序列。\n  字符串的长度：字符串中的符号个数。\n  字符串基本概念    表示、术语 举例     $|S|$ $|abc|= 3$   $\\varepsilon$ $| \\varepsilon| = 0$   $S1S2$ $\u0026ldquo;abc\u0026quot;\u0026ldquo;def\u0026rdquo;=\u0026ldquo;abcdef\u0026rdquo;$   $S^n$（幂） $\u0026ldquo;abc\u0026rdquo;^3 =\u0026ldquo;abcabcabc\u0026rdquo;$   $S$的前缀 $\u0026ldquo;abc\u0026rdquo;$的前缀可以是：$ε，a，ab, abc$   $S$的后缀 $\u0026ldquo;abc\u0026rdquo;$的后缀可以是：$ε，c，bc, abc$   $S$的子串 $\u0026ldquo;abc\u0026rdquo;$的子串可以是$ε，a，b, c, …$   $S$的真前缀 $\u0026ldquo;abc\u0026rdquo;$的真前缀：$a, ab$   $S$的真后缀 $\u0026ldquo;abc\u0026rdquo;$的真后缀：$c, bc$   $S$的真子串 $\u0026ldquo;abc\u0026rdquo;$的真子串：$a, b, c, ab, bc $   $S$的子序列 $\u0026ldquo;abdf\u0026rdquo;$是$\u0026ldquo;abcdef\u0026rdquo;$的一个子序列（$S$中去掉$0$或若干个不一定连续的字符后形成的字符串）   $S$的逆转$S^R$ $S=abc,S^R=cba$    字符串集合的运算    表示、术语 意义     $\\varnothing$ 空集合   ${\\epsilon}$ 空串作为唯一元素的集合   $X = L \\cup M$ 集合的并：$ X = \\{ s | \\in L\\ or\\ s \\in M \\} $   $X = L \\cap M$ 集合的交：$ X = \\{ s | \\in L\\ and\\ s \\in M \\} $   $X = L \\cap M$ 集合的连接：$ X = \\{ st | \\in L\\ and\\ s \\in M\\} $   $X = L^0$ 集合的连接：$ L^0 = \\{ \\epsilon \\} $   $X = L^*$ 集合的Kleene闭包：$X=L^0 \\cup L^1 \\cup L^2 \\cup \u0026hellip; $   $X = L^+$ 集合的正闭包：$X=L^1 \\cup L^2 \\cup L^3 \\cup \u0026hellip; $    正规式与正规集 正规式的递归定义  $\\epsilon$和$\\varnothing$都是$\\sum$上的正规式，它表示$L(\\epsilon)=\\{ \\epsilon \\}$和$\\varnothing$ 若$a$是$\\sum$上的字符，则$a$是正规式，表示$L(a)=\\{a\\}$ 若正规式$r$和$s$分别表示$L(r)$和$L(s)$:  $r | s$是正规式，表示集合$L(r)\\cup L(s)$ $rs$ 是正规式，表示集合$L(r)L(s)$ $r^* $ 是正规式，表示集合 $(L(r))* $ $r$是正规式，表示集合仍是$L(r)$    运算  运算符的优先级与结合性  三种运算均具有左结合性质 优先级从高到低排列顺序为：闭包运算、连接运算、或运算   正规式的等价：若正规式$P$和$Q$表示了同一个正规集，则称P和Q是等价的，记为$P=Q$ 正规式等价的判定（证明）  根据定义 利用代数性质  $ r|s = s|r $ $r|(s|t) = (r|s)|t$ $r(s|t) = rs|rt$ $(s|t)r = sr|tr $ $(rs)t = r(st)$ $εr = rε = r$ $r^* = (r+|ε) $ $r^{**} = r^* $      记号的说明 例如：\nrelation = \u0026lt; | \u0026lt;= | \u0026lt;\u0026gt; | \u0026gt; | \u0026gt;= | = id = (a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z |A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z) (a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z |A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z |0|1|2|3|4|5|6|7|8|9)* num = (0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)* (ε|.(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)*) (ε|E(+|-|ε)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)*)  简化正规式描述  正闭包：$r^+ = rr^* = r^* r，r^* = r^+|ε$ 可缺省：$r?=r|ε$ 字符组：如$[abc]$，它等价于：$a|b|c$ 非字符组：$[^r]$   引入辅助定义  char = [a-zA-Z] digit = [0-9] digits = digit+ optional_fraction = ( . digits )? optional_exponent = ( E (+|-)? digits )? id = char ( char|digit )* num = digits optional_fraction optional_exponent 记号的识别-有限自动机 不确定的有限自动机（Nondeterministic Finite Automaton，NFA） 定义：$M=(S, \\sum, move, s_0, F) $\n $S$是有限个状态(state)的集合 $\\sum$是有限个输入字符 包括 $ε$ 的集合 $move(s_i, ch)=s_j$ $s_0$是唯一的初态 $F$是终态集  直观的表示方式  状态转换图 状态转换矩阵   NFA存在的问题  只有尝试了全部可能的路径，才能确定一个输入序列不被接受，而这些路径的条数随着路径长度的增长成指数增长 识别过程中需要大量的回溯，时间复杂度升高且算法趋于复杂  确定的有限自动机（Deterministic Finite Automaton，DFA） 定义：DFA是NFA的一个特例，其中\n 没有状态具有$\\epsilon$状态转移$(\\epsilon -transition)$，即状态图中没有标记$\\epsilon$的边 对每个状态$s$和每个字符$a$，最多有一个下一状态  模拟DFA算法 s := s0; ch := nextchar; -- 初值 while ch != eof -- 循环 loop s := move(s, ch); ch := nextchar; end loop; if s in F then return \u0026quot;yes\u0026quot;; else return \u0026quot;no\u0026quot;; end if; 从正规式到词法分析器 构造词法分析器的方法和步骤  用正规式描述模式 构造NFA 确定化（转换成等价的DFA） 最小化（优化DFA） 从优化后的DFA构造词法分析器  从正规式到NFA Thompson算法\n 对$\\epsilon$，$N(\\epsilon)$：  对于$\\sum$上的每个字符$a$，$N(a)$：  若$N(p)$和$N(q)$是正规式$p$和$q$的NFA  对于$p|q$，构造$N(p|q)$： 对于正规式$pq$，构造NFA $N(pq)$： 对于正规式$p^* $，构造NFA $N(p^{*})$：    从NFA到DFA 并行方法  $smove(S, a)$：从状态集$S$中的每个状态出发，经过标记为$a$的边直接到达的下一状态全体 $\\epsilon$-闭包：从状态T出发，经过若干次$\\epsilon$转移到达的状态全体  $\\epsilon$-闭包 的定义\n T中的所有状态属于$\\epsilon$-闭包 如果$t$属于$\\epsilon$-闭包(T)且$move(t, \\epsilon)=u$，则$u$属于$\\epsilon$-闭包(T) 再无其它状态属于$\\epsilon$-闭包(T)  求$\\epsilon$-闭包 的算法\nfunction ε-闭包(T) is begin for T中的每个状态t loop 加入t到U; push(t); end loop; while 栈不空 loop pop(t); for 每个u=move(t, ε) loop if u不在U中 then 加入u到U中; push(u); endif; end loop; end loop; return U; end ε-闭包; 模拟NFA\nS := ε-闭包({s0}); -- 所有可能初态的集合 a := nextchar; while a != eof loop S := ε-闭包(smove(S, a)); -- 所有下一状态的集合 a := nextchar; end loop; if S and F != nil then return \u0026quot;yes\u0026quot;; else return \u0026quot;no\u0026quot;; end if; 子集法构造DFA Dstates = {ε-闭包({s0})}; // Dstates中仅有一个状态且未标记 while Dstates有尚未标记的状态T loop 标记T; for 每一个输入字符a loop U := ε-闭包(smove(T, a)) if U 非空 then Dtran[T, a] := U; if U 不在Dstates中 then U作为尚未标记的状态加入Dstates; end if; end if; end loop; end loop; 例如用上述算法构造(a|b)*abb的DFA：\nε-闭包({0}) = {0, 1, 2, 4, 7}* A ε-闭包(smove(A, a)) = {3, 8, 6, 7, 1, 2, 4}* B ε-闭包(smove(A, b)) = {5, 6, 7, 1, 2, 4}* C ε-闭包(smove(B, a)) = {3, 8, 6, 7, 1, 2, 4} B ε-闭包(smove(B, b)) = {9, 5, 6, 7, 1, 2, 4}* D ε-闭包(smove(C, a)) = {3, 8, 6, 7, 1, 2, 4} B ε-闭包(smove(C, b)) = {5, 6, 7, 1, 2, 4} C ε-闭包(smove(D, a)) = {3, 8, 6, 7, 1, 2, 4} B ε-闭包(smove(D, b)) = {5, 10, 6, 7, 1, 2, 4} E ε-闭包(smove(E, a)) = {3, 8, 6, 7, 1, 2, 4} B ε-闭包(smove(E, b)) = {5, 6, 7, 1, 2, 4} C 最小化DFA 可区分:对于DFA中的任何两个状态$t$和$s$，若从一状态出发接受输入字符串$\\omega$，而从另一状态出发不接受$\\omega$，则称 $\\omega$区分状态$t$和$s$。如果存在某个能够区分状态$s$和状态$t$的串，那么它们是可区分的。\n最小化DFA算法\n 初始划分$\\Pi=\\{S-F, F\\}, \\Pi_{new} = \\Pi$。$F$是终态集，$S-F$是非终态集 应用下述过程构造新的划分$\\Pi_{new}$:  for $\\Pi$的每一个组$G$ loop 划分$G$, $G$的两个状态$s$和$t$在同一组中的充要条件是： $$\\forall a \\in \\Sigma \\forall G_i \\in \\Pi (move(s, a) \\in G_i \\leftrightarrow move(t, a) \\in G_i)$$用新的划分组替代$G$, 形成新的划分$\\Pi_{new}$;\nend loop   若$\\Pi_{new}=\\Pi$，令$\\Pi_{final} = \\Pi$，转4，否则令$\\Pi = \\Pi_{new}$并重复步骤2 选代表并修改状态转移 删除死状态，即不是终态且对所有输入字符均转向自身，或从初态不可到达的状态  由DFA构造词法分析器  表驱动的词法分析器(自动生成) 直接编码的词法分析器      表驱动 直接编码     分析器的速度 慢 快   程序与模式的关系 无关 有关   分析器的规模 较大 较小   适合编写的方法 工具生成 手工编写    正规式转换为正规文法  令$V_T = \\sum$ 令文法的开始符号$S = R$ 对形如$A \\rightarrow ab$的规则转换为$A \\rightarrow aB$和$ B \\rightarrow b$ 在新的文法中，将形如$A \\rightarrow a^{*}b$的规则进一步转换为$A \\rightarrow aA | b$ 不断利用3和4，直到每条规则的右部最多只含有一个终结符为止  作业  表示源程序中信息单元的字符序列叫做记号 LEX源程序的三个组成部分：定义部分、识别规则部分、辅助函数部分 词法分析器的功能：依次扫描字符串形式的源程序中的各个字符，逐个识别其中的单词，并将其转换为内部编码形式的单词符号作为输出。 简要叙述从正规式构造词法分析器的一般方法和过程  用正规式对模式进行描述 为每一个正规式构造NFA 确定化 最小化 从简化后的DFA构造词法分析器   简述DFA与NFA有何区别？  NFA可以有$\\epsilon$转移，而DFA没有 DFA的状态转移将产生一个状态机和而不是单个状态   正规式：又称正规式或正则表达式，是按照一组定义规则，由较简单的正规式构成的，每个正规式$r$表示一个语言$L(r)$。定义规则告诉我们$L(r)$是怎样以各种方式从$r$的子正规式所表示的语言组合而成的。  第三章 语法分析 基本术语 语法分析器的作用  根据词法分析器提供的记号流，为语法正确的输入构造语法树。 检查输入中的语法（可能还包含词法错误），并调用出错处理器进行适当处理。  语法错误的处理原则 基本恢复策略  紧急方式恢复：使用同步记号 短语级恢复：采用串替换的方式 出错产生式：捕获错误 全局纠正  例：\nx := a + b y := c + d;  紧急方式——丢弃b后若干记号，知道遇见+x := a + b + d; 短语级恢复——加入分号，使之成为一个赋值句y := c + d;  上下文无关法（Context Free Grammer，CFG） 上下文无关文法就是说这个文法中所有产生式左边只有一个非终结符。\nCFG定义及表示 四元组$G=(N, T, P, S)$，其中\n $N$——非终结符（Nonterminals）有限集合 $T$——终结符（Terminals）有限集合，$N \\cup T = \\emptyset $ $P$——产生式（Productions）有限集合，$A\\rightarrow a$，其中$A \\in N$(左部)，$a \\in (N\\cup T)^*$ (右部)，若$a = \\epsilon$，则称$A \\rightarrow \\epsilon$为空产生式 $S$——$S$是非终结符，称为开始符号  由产生式集表示CFG  $E \\rightarrow E + E$ $E \\rightarrow E * E$ $E \\rightarrow (E)$ $E \\rightarrow -E$ $E \\rightarrow id$  终结符与非终结符书写上的约定  大写字母$A、B、C$表示非终结符 小写字母$a、b、c$表示终结符 小写希腊字母$\\alpha、\\beta、\\delta $表示任意文法符号序列  CFG产生语言的基本方法——推导  直接推导：$\\alpha A \\beta =\u0026gt; \\alpha \\gamma \\beta $ 零布或多步推导 至少一步推导  由CFG所产生的语言L(G) $$L(G) = \\{ \\omega | S \\overset{+}{\\Rightarrow} and \\ \\omega \\in T^* \\} $$ $L(G)$称为 上下文无关语言 （Context Free Language, CFL）$\\omega$称为句子，若$S \\overset{ * }{\\Rightarrow} \\alpha, \\alpha \\in (N \\cup T)^{ * } $，则称$\\alpha$为$G$的一个 句型 。\n最左推导和最右推导（规范推导） 最左推导产生的句型称为左句型\n最右推导被称为规范推导 规范归约是指最右推导的逆过程\n推导与语法树 语法树和抽象语法树 二义性与二义性的消除   二义性：一个句子可能对应多棵语法树\n 文法二义性：若文法$G$对同一句子产生不止一棵语法树，则称语法树$G$是二义的。或者说，若文法$G$对同一个句子存在两个不同的最左（最右）推导，则称文法$G$是二义的。 语言的二义性：如果产生上下文无关语言的每一个文法都是二义的，则此语言是二义的    二义性的消除\n 改写二义文法为非二义性文法  引入一个新的非终结符，增加一个子结构并提高一级优先级 递归非终结符在终结符左边，运算具有左结合性，否则具有右结合性 消除“悬空else”问题\n   为文法符号规定优先级和结合性 修改语言的语法end if    语言与文法简介 正规式与上下文无关法 正规式到CFG的转换  若$0$为初态，则$A_0$为开始符号 对于$move(i,a)=j$，引入产生式$A_i→aA_j$ 对于$move(i,ε)=j$，引入产生式$A_i→A_j$ 若$i$是终态，则引入产生式$A_i →ε$。  上下文有关语言  不能用CFG描述的语言  $L1=\\{ \\omega c \\omega | \\omega \\in (a | b)^* \\}$标识符声明与引用一致性的抽象 $L2=\\{a^nb^mc^nd^m|n \\ge 1\\ and\\ m \\ge 1\\}$ 形参与实参一致性的抽象 $L3=\\{ a^nb^nc^n|n \\ge 1\\}$ 计数问题的抽象   相近的CFL  $L1^{'}=\\{ \\omega c \\omega^r | \\omega \\in (a | b)^* \\} (S\\rightarrow aSa\\ |\\ bSb\\ |c)$ $L2^{'}=\\{ a^nb^mc^md^n|n\\ge 1, m \\ge 1\\} (S \\rightarrow aSd\\ | aAd\\ A \\rightarrow bAc\\ |\\ bc)$ $L2^{''}=\\{ a^nb^nc^md^m | n \\ge 1, m \\ge 1\\} (S \\rightarrow AB\\ A\\rightarrow aAb\\ |\\ ab \\ B\\rightarrow cBd\\ | cd) $ $ L3^{'}=\\{ a^mb^mc^m | m, n \\ge 1\\}\\ (S \\rightarrow aAb | ab\\ C\\rightarrow cC|c)$    形式语言与自动机简介  0型文法：若文法 $G=(N, T, P, S)$ 的每个产生式 $α→β$ 中 均有 $α∈(N∪T)^* $ 且至少含有一个非终结符 $β∈(N∪T)^*$则称 G 为 0 型文法 。 限制  $G $的任何产生式 $α→β$ ($S→ε$ 除外) 满足$ |α|≤|\\beta |$ $G$ 的任何产生式形如 $A→β$ 其中 $A∈N\\ β∈(N∪T)^*$ $G$ 的任何产生式形如 $A→a$ 或者 $A→aB$( 或者 $A→Ba$) 其中 $A$ 和 $B$$∈N$ $a∈T$       文法 语言 自动机     短语文法（0型） 短语结构语言 图灵机   CSG（1型） CSL 线性界限自动机   CFG（2型） CFL 下推自动机   正规文法 （3型） 正规集 有限自动机    自上而下语法分析 一般方法（试探＋回溯，边推导边匹配） 消除左递归  消除直接左递归: $A\\rightarrow Aα|β$替换为$A \\rightarrow \\beta A^{'}\\ \\ A^{'} \\rightarrow \\alpha A^{'} | \\epsilon$ 消除文法的左递归（直接/间接左递归）：将不是左递归的非终结符右部展开到其它产生式中。 合理排序非终结符：$A_1,A_2,…,A_n$(排序方法不唯一) 用$A_j→δ_1|δ_2|\u0026hellip;|δ_k$右部替换$A_i→A_jγ$中的$A_j$，得到$A_i→δ_1 γ|δ_2 γ|\u0026hellip;|δ_k γ$； (如果有)消除$A_i$产生式中的直接左递归；   提取公因子 将$A \\rightarrow \\alpha {\\beta}_1 | \\alpha {\\beta}_2$替换为$ A \\rightarrow \\alpha A^{'} \\ A^{'} \\rightarrow {\\beta}_1|{\\beta}_2$\n递归下降分析 \u0026hellip;\n预测分析器   非递归（表驱动）预测分析器的工作模式\n 工作方式  格局：三元组(栈内容^top，剩余输入^ip，改变格局的动作) 改变格局的动作  匹配终结符：若^top = ^ip(但≠‘#’)，则pop且next(ip)； 展开非终结符：若^top = X且^ip=a且M[X, a] = α(X→α)，则pop且push(α)（α逆序入栈）; 报告分析成功：若^top = ^ip = #，则分析成功并结束; 报告出错：其它情况，调用错误恢复例程。     预测分析表     FIRST集合和FOLLOW集合\n  FIRST集合：$FIRST(\\alpha) = \\{ a | \\alpha \\overset{*}{=\u0026gt;} a\u0026hellip;, a \\in T \\} $ $\\alpha$的FIRST集合就是由从$\\alpha$开始可导出的文法符号序列的开头终结符构成的集合。\n 求解  直接收取：对形如$U \\rightarrow a\u0026hellip;$ 的产生式（其中$a$是终结符），把$a$收入到$FIRST(U)$中 反复传送：对形如$U \\rightarrow P\u0026hellip;$ 的产生式（其中$P$是非终结符，把$FIRST(P)$的内容传送到$FIRST(U)$中      FOLLOW集合：$FOLLOW(A)=\\{ a | S \\overset{*}{=\u0026gt;} Aa \\}$ $A$的$FOLLOW$集合，就是由从开始符号可导出的含A的文法符号序列中紧邻A之后的终结符构成的集合。\n 求解  加入$ \\# $到$FOLLOW(S)$ 若有产生式$A \\rightarrow \\alpha B \\beta $，则除$\\epsilon$ 外，$FIRST(\\beta)$的全体加入到$FOLLOW(B)$ 若有产生式$A \\rightarrow \\alpha B$或$A \\rightarrow \\alpha B \\beta 且 \\epsilon \\in FIRST(\\beta)$，则$FOLLOW(A)$的全体加入$FOLLOW(B)$      例题\n    构造预测分析表\n 对文法的每个产生式$A \\rightarrow \\alpha$，执行2和3； 对$FIRST(\\alpha)$的每个终结符$a$，将$A \\rightarrow \\alpha$加入到$M[A, a]$中； 对$\\epsilon \\in FIRST(\\alpha )$，则对$FOLLOW(A)$中的每个终结符$b$（包括$\\#$)，将$A \\rightarrow a$加入到$M[A, b]$中。    LL(1)文法\n 判断LL(1)文法的方法  构造分析表 推论判断：$G$是$LL(1)$的，当且仅当$G$的任何两个产生式$A \\rightarrow \\alpha | \\beta$条件  $FIRST(\\alpha) \\cap FIRST(\\beta) = \\emptyset$ 若$\\beta \\overset{*}{=\u0026gt;} \\epsilon$，则$FIRST(\\alpha) \\cap FOLLOW(A)=\\emptyset$     弱点  难写、难懂 应用范围有限，往往写不出来某些语言的$LL(1)$文法 实际编译器中使用更多的是一类$LL(1)$文法的真超集，即$LR(1)$文法。      自下而上语法分析 短语 设$\\alpha \\beta \\delta$是文法$G$的一个句型，若存在$S \\overset{*}{=\u0026gt;} \\alpha A \\delta$，$A \\overset{+}{=\u0026gt;}\\beta$，则称$\\beta$是句型$\\alpha \\beta \\delta$(相对于$A$)的短语。\n 直接短语：$A \\rightarrow \\beta$ 句柄：一个句型地最左直接短语被称为句柄  最左归约——”剪句柄“过程 LR(k)文法 $L$表示从左到右扫描输入序列，$R$表示逆序的最右推导，$k$表示为确定下一动作向前看的终结符个数\nLR分析法  ACTION[s, a]：栈顶状态为s面临a时采取什么动作(shift or reduce) GOTO[s, X]：归约后对应的状态  LR(0)分析表的构造 活前缀：为了描述LR分析中栈内的符号的特点 如果在符号序列$\\alpha$的右边增添零个或多个终结符之后，能够形成一个右句型并且$\\alpha$不含该句型句柄之后的任何符号，则称$\\alpha$为文法$G$的活前缀。\n对于规范句型$\\alpha \\beta \\delta$，$\\beta$为句柄，如果$\\alpha \\beta = u_1 u_2 \u0026hellip; u_r$，则符号串$u_1 u_2 \u0026hellip;u_i(1 \\le i \\le r)$时$\\alpha \\beta \\delta$的活前缀\n 举例说明以下文法的活前缀 $G: S \\rightarrow aABe | aAbBec \\ A \\rightarrow b | bA \\ B \\rightarrow d $ 活前缀：$a, aA, aAB, aABe, aAb, aAbBec, aAbd, aAd, ab, abb, abbb, ab+$  LR(0)项目 一个$LR(0)$项目(简称项目)是这样一个产生式，在它右部的某个位置有一个点$“.”$。对于$A \\rightarrow \\epsilon$，它仅有一个项目$A \\rightarrow .$\n 意义  $A \\rightarrow . XYZ$，说明希望从后面输入串中看到可以从$XYZ$推出的符号串，需要移进； $A \\rightarrow X . YZ$，说明已经从输入串中看到可以从$X$推出的符号串，希望进一步看到可以从$YZ$推出的符号串，需要继续移进。 $A→ XYZ . $，说明当前栈顶已经形成句柄，可以归约。    识别文法G的活前缀的NFA  若状态$i$为$X \\rightarrow X_1 \u0026hellip; X_{i-1} . X_i \u0026hellip; X_n$，状态$j$为$X \\rightarrow X_1 \u0026hellip; X_{i-1} X_i . X_{i+1} \u0026hellip; X_n$，则从状态$i$连一条$X_i$有向边到状态$j$ 若状态$i$为$X \\rightarrow \\alpha .A \\beta$，A为非终结符，则从$i$连一条$\\epsilon$到所有状态$A \\rightarrow . \\gamma$  确定化后的DFA LR(0)项目集规范族的构造  拓广文法$G^{'}= G \\cup \\{ S^{'} \\rightarrow S\\}$：为了使得最终构造的DFA状态集中具有唯一的接收状态 NFA（项目）-\u0026gt; DFA（项目集）  $CLOSURE(I)$：从项目集$I$不经过任何文法符号到达的项目全体 $GO(I, X)$：所有从$I$经文法符号$X$能到达的项目全体（与$somve$不同，$GO$含有闭包计算）   $CLOSURE(I)$计算方法：  $I$的任何项目属于$CLOSURE(I)$ 若$A \\rightarrow \\alpha . B \\beta$属于$CLOSURE(I)$，项目$B \\rightarrow .\\gamma$也属于$CLOSURE(I)$ 重复以上步骤直到$CLOSURE(I)$不再增大   $GO(I, X)=CLOSURE(J)$  有效项目 若存在最右推导$S^{'} \\overset{*}{=\u0026gt;}\\alpha A \\omega =\u0026gt; \\alpha \\beta_1 \\beta_2 \\omega $，则称项目$A \\rightarrow \\beta_1 . \\beta_2$对活前缀$\\alpha \\beta_1$有效\n 意义  到目前为止语法分析是正确的 指导下一步的分析  $A \\rightarrow \\alpha a. \\beta$（可移进项） $B \\rightarrow \\beta.$（可归约项）      LR(0)分析表的构造  圆点后是终结符，需要填ACTION移进 圆点后是非终结符，需要填GOTO表 圆点后为空，需要填ACTION归约  SLR(1)分析表的构造 $LR(0)$规范族的一个项目集中含有m个移进项目：$A_1 \\rightarrow \\alpha_1. a_1 \\beta_1, A_2 \\rightarrow \\alpha_2. a_2 \\beta_2 \u0026hellip; ,A_m \\rightarrow \\alpha_m. a_m \\beta_m$，同时有$n$个归约项目：$B_1 \\rightarrow \\alpha_1., B_2 \\rightarrow \\alpha_2., \u0026hellip;, B_n \\rightarrow \\alpha_n., $\n如果集合$\\{a_1, \u0026hellip;, a_m\\}, FOLLOW(B_1), \u0026hellip;, FOLLOW(B_n)$两两不相交,则可以用SLR(1)来解决。\n对于当前输入符号$a$\n 若$a \\in \\{ a_1, \u0026hellip;, a_m \\}$，则移进 若$a \\in FOLLOW(B_i)$，则用产生式$B_i \\rightarrow \\alpha_i$归约 否则，报错  非SLR(1)文法  二义文法 非二义文法的非SLR(1)文法  作业  LR分析法中，分析栈中存放的状态是识别规范句型活前缀的DFA状态。 一个上下文无关法所含的四个组成部分是一组终结符、一组非终结符、一个开始符号、一组产生式 自下而上的语法分析方法的基本思想是：从给定的终结符开始，根据文法的规则一步一步地向上进行直接归约，试图归约到文法的开始符号。 $LR(0)$分析法的名称中，L的含义是从左向右扫描输入串，$R$的含义是最左归约，$0$的含义是向后查看$0$个输入符号。 仿照最左推导和左句型的定义，试叙述最右推导和右句型的定义。  最右推导：在推导过程中，若每次直接推导均替换句型最右边的非终结符，称为最右推导 右句型：在最右推导产生的句型被称为右句型   简述自上而下分析的宗旨 对给定输入串$w$，试图用一切可能的办法，从文法开始符号$S$出发，自上而下，从左到右地为输入串建立起一棵以$S$为根结点的语法树。或者说，为输入串寻找最左推导$S \\overset{*}{=\u0026gt;} w$。这种分析过程本质上是一种试探过程，是反复使用不同的产生式谋求匹配输入串的过程，如果这一试探得到成功，则证明$w$是相应文法的一个句子，反之，则不是。 根据程序错误性质可以分为哪几种错误？  词法错误 语法错误 静态语义错误 动态语义错误   自下而上分析法的思想  自下而上的思想就是从输入串开始，逐步进行”归约“，直至归约到文法的开始符号；或者说从语法树的末端开始，步步向上”归约“，直到根结点。   简述构造$LR$分析表的技术  $LR(0)$表构造。这种方法局限性大，但是它是建立其他较一般LR分析法的基础。 简单$LR$表$(SLR)$构造：虽然一些文法构造不出$SLR$分析表，但是这是一种比较容易实现又极有使用价值的方法。 规范$LR$表构造法：这种分析表能力最强，能够适应一大类文法，但是实现代价过高。 向前$LR$表$(LALR)$构造法：这种分析表的能力介于SLR和规范LR之间，可以高效的实现。   活前缀：右句型的前缀且不包含句柄之后的符号  第四章 语法制导翻译与中间代码生成 语法制导翻译简介 属性文法 $$ A \\rightarrow \\alpha \\ \\ b := f(c_1, c_2, \u0026hellip;, c_k)$$\n 综合属性：$b$是$A$的属性，$c_1, c_2, \u0026hellip;, c_k$是$\\alpha$中的文法符号的属性或$A$的其他属性，则称$b$是$A$的综合属性 继承属性：$b$是$\\alpha$中的文法符号$X_i$的属性，$c_1, c_2, \u0026hellip;, c_k$是$A$的属性或$\\alpha$中的其他文法符号属性，则称$b$是$X_i$的继承属性 $b$依赖于$c_1, c_2, \u0026hellip;, c_k$ 虚拟属性：$f(c_1, c_2, \u0026hellip;, c_k)$  中间代码简介 后缀式（逆波兰） 例：$a := 1 + 2 * 3$ 后缀式为：$a 1 2 3 * + := $\n三地址码   形式：\n $result := arg1\\ op\\ arg2$ $result := op\\ arg1$ $op\\ arg1$    种类\n 三元式：(i)(op, arg1, arg2)对应三地址码(i) := arg1 op arg2 四元式：(op, arg1, arg2, result)对应三地址码result := arg1 op arg2  四元式的运算结果与其位置无关，为代码优化提供了极大的方便。      图形表示 树的语法制导翻译\n mknode：生成根或内部节点 mkleaf：生成叶子节点  (1)A → id := E\t{A.nptr := mknode(:=, mkleaf(entry(id.name)), E.nptr)} (2)E → E1 + E2\t{E.nptr := mknode(+, E1.nptr, E2.nptr)} (3)E → E1 * E2\t{E.nptr := mknode(*, E1.nptr, E2.nptr)} (4)E → (E1)\t{E.nptr := E1.nptr} (5)E → - E1\t{E.nptr := mknode(@, E1.nptr, )} (6)E → id\t{E.nptr := mkleaf(entry((id.name))}  优化表示——有向无环图  先查看所要构造的节点是否已经存在，若存在则无需构造新的节点，直接返回指向已存在节点的指针即可。\n符号表简介 相当于是一个内存，连接声明与引用的桥梁，一个名字在声明时，相关信息被填写进符号表，在引用时根据符号表中的信息生成可执行语句。\n 静态作用域规则——总方针 最近嵌套规则——总方针下的具体规则  声明语句的翻译 变量声明的文法 D -\u0026gt; D ; D | id : T {enter(id.name, T.type, offset); offset := offset + T.width; } T -\u0026gt; int {T.type = integer; T.width := 4; } | real {T.type = real; T.width := 8; } | array [num] of T1 {T.type = array(num.val, T1.type); T.width := num.val * T1.width; } | ^T {T.type = pointer(T1.type); T.width := 4; } 例：a : array[10] of int; x : int\n过程的定义与声明  左值和右值  左值必须具有存储空间，右值可以仅仅是一个值 左值是容器，右值是内容   参数传递  值调用：C参数传递 引用调用：C++引用传递 复写——恢复 换名调用：宏定义    简单算术表达式与赋值句 x := -a * b + c的语法制导翻译，x、a、b是整型数，c是实型数。\n布尔表达式 直接计算 ","permalink":"https://fffzlfk.github.io/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/","summary":"Compiler Principles","title":"编译原理"},{"content":"牛顿迭代法  如图，一条曲线$y=f(x)$，在$f(x_n)$处画一条切线交x轴于点$x_{n+1}$，接着在$f(x_{n+1})$处画切线交x轴于点$x_{n+2}$，继续…… 在这个过程中交点$x_{n+m}$会无限逼近曲线零点，即得到方程$f(x) = 0$的解。  求平方根 思路  即求函数$f(x) = x^2 - n $的零点 导函数$f^{'}(x) = 2x $ 在点$(x_n, x_n^2-n)$处的切线方程为$y - x_n^2 + n = 2x_n (x-x_n) $，即$y = 2x_nx - x_n^2 - n$ 则切线与x轴的交点$x_{n+1}$为$$\\frac {x_n^2 - n} {2x_n}$$ 重复迭代直到得到精度满意的值  代码实现 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func Sqrt(x float64) float64 { z := 1.0 for math.Abs(z * z - x) \u0026gt; 1e-12 { z -= (z * z - x) / (2 * z) } return z } func main() { fmt.Println(Sqrt(2)) } 求k次方根 思路  $$x_{n+1} = x_{n} - \\frac {f(x_n)} {f^{'}(x_n)}$$ $$x_{n+1} = x_n - \\frac {x_n(1 - nx_n^{-k})} k$$  代码实现 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func getRoot(x, k float64) float64 { z := 1.0 for math.Abs(math.Pow(z, k) - x) \u0026gt; 1e-9 { z -= z * (1 - x * math.Pow(z, -k)) / k } return z } func main() { fmt.Println(getRoot(27, 3)) } ","permalink":"https://fffzlfk.github.io/posts/%E7%89%9B%E9%A1%BF%E6%B3%95%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9/","summary":"Newton\u0026rsquo;s method for the square root","title":"牛顿法求平方根"},{"content":"两数之和 题目链接\n代码 class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { unordered_map\u0026lt;int, int\u0026gt; M; for (int i = 0; i \u0026lt; nums.size(); i++) { if (M.count(target - nums[i])) { return {M[target - nums[i]], i}; } else { M[nums[i]] = i; } } return {0, 0}; } }; 三数之和 题目链接\n思路 双指针 $O(n^2)$\n代码 class Solution { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; a) { sort(begin(a), end(a)); ans.clear(); const int n = a.size(); for (int i = 0; i \u0026lt; n; i++) { if (i \u0026amp;\u0026amp; a[i-1] == a[i]) continue; int j = i + 1, k = n - 1; while (j \u0026lt; k) { if (a[i] + a[j] + a[k] \u0026lt; 0) ++j; else if (a[i] + a[j] + a[k] \u0026gt; 0) --k; else { ans.push_back({a[i], a[j], a[k]}); while (j \u0026lt; k \u0026amp;\u0026amp; a[j] == a[j+1]) j++; while (j \u0026lt; k \u0026amp;\u0026amp; a[k] == a[k-1]) k--; j++, k--; } } } return ans; } }; 扩展-最接近的三数之和 代码 class Solution { public: int threeSumClosest(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { sort(begin(nums), end(nums)); const int n = nums.size(); int ans, diff = INT_MAX; auto update = [\u0026amp;](int sum) { if (abs(sum - target) \u0026lt; diff) { diff = abs(sum - target); ans = sum; } }; for (int i = 0; i \u0026lt; n - 2; i++) { if (i \u0026amp;\u0026amp; nums[i] == nums[i-1]) continue; int l = i + 1, r = n - 1; while (l \u0026lt; r) { int s = nums[i] + nums[l] + nums[r]; if (s == target) return target; update(s); if (s \u0026lt; target) { while (l \u0026lt; r \u0026amp;\u0026amp; nums[l] == nums[l+1]) l++; l++; } else { while (l \u0026lt; r \u0026amp;\u0026amp; nums[r] == nums[r-1]) r--; r--; } } } return ans; } }; 四数之和 题目链接\n思路 双指针 $O(n^3)$\n代码 class Solution { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; fourSum(vector\u0026lt;int\u0026gt;\u0026amp; a, int target) { ans.clear(); sort(a.begin(), a.end()); const int n = a.size(); for (int i = 0; i \u0026lt; n; i++) { if (i \u0026amp;\u0026amp; a[i] == a[i-1]) continue; for (int j = i + 1; j \u0026lt; n; j++) { if (j \u0026gt; i + 1 \u0026amp;\u0026amp; a[j] == a[j-1]) continue; int l = j + 1, r = n - 1; while (l \u0026lt; r) { if (a[i] + a[j] + a[l] + a[r] \u0026lt; target) l++; else if (a[i] + a[j] + a[l] + a[r] \u0026gt; target) r--; else { ans.push_back({a[i], a[j], a[l], a[r]}); while (l \u0026lt; r \u0026amp;\u0026amp; a[l] == a[l+1]) l++; while (l \u0026lt; r \u0026amp;\u0026amp; a[r] == a[r-1]) r--; l++; r--; } } } } return ans; } }; 组合总和 题目链接\n每个数字在每个组合中可以使用无限次。\n代码 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; vector\u0026lt;int\u0026gt; tmp; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combinationSum(vector\u0026lt;int\u0026gt;\u0026amp; candidates, int target) { ans.clear(); tmp.clear(); dfs(candidates, target, 0); return ans; } void dfs(vector\u0026lt;int\u0026gt;\u0026amp; cand, int target, int idx) { if (idx == cand.size()) return; if (target == 0) { ans.emplace_back(tmp); return; } dfs(cand, target, idx+1); if (target-cand[idx] \u0026gt;= 0) { tmp.emplace_back(cand[idx]); dfs(cand, target-cand[idx], idx); tmp.pop_back(); // dfs(cand, target-cand[idx], idx+1);  } } }; 组合总和 II 题目链接\n每个数字在每个组合中只能使用一次。\n代码 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; vector\u0026lt;int\u0026gt; tmp; vector\u0026lt;int\u0026gt; candidates; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combinationSum2(vector\u0026lt;int\u0026gt; \u0026amp;candidates, int target) { ans.clear(); tmp.clear(); sort(candidates.begin(), candidates.end()); this-\u0026gt;candidates = candidates; dfs(0, target); return ans; } void dfs(int idx, int target) { if (target == 0) { ans.emplace_back(tmp); return; } for (int i = idx; i \u0026lt; candidates.size() \u0026amp;\u0026amp; (target \u0026gt;= candidates[i]); i++) { if (i \u0026gt; idx \u0026amp;\u0026amp; (candidates[i] == candidates[i-1])) continue; tmp.emplace_back(candidates[i]); dfs(i+1, target-candidates[i]); tmp.pop_back(); } } }; 组合总和 III 题目链接\n思路 二进制状态压缩\n代码 class Solution { public: vector\u0026lt;int\u0026gt; tmp; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combinationSum3(int k, int n) { for (int i = 0; i \u0026lt; (1\u0026lt;\u0026lt;9); i++) { if (check(i, k, n)) ans.emplace_back(tmp); } return ans; } bool check(int cur, int k, int n) { tmp.clear(); for (int i = 0; i \u0026lt; 9; i++) { if ((1\u0026lt;\u0026lt;i) \u0026amp; cur) tmp.emplace_back(i+1); } return (tmp.size() == k \u0026amp;\u0026amp; accumulate(tmp.begin(), tmp.end(), 0) == n); } }; ","permalink":"https://fffzlfk.github.io/posts/%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E9%97%AE%E9%A2%98/","summary":"the Sum of Subsequence","title":"子数组和问题"},{"content":"引入 当我们想在一个函数执行前后干点什么事情的时候，可以这么写：\ndef foo(): print(\u0026#39;foo()!!!\u0026#39;) def bar(): print(\u0026#39;Before\u0026#39;) foo() print(\u0026#39;After\u0026#39;) bar() 装饰器实现 但这样看着总是很别扭，我们可以写成这样：\ndef foo(): print(\u0026#39;foo()!!!\u0026#39;) def bar(func): def inner(): print(f\u0026#39;Before {func.__name__}\u0026#39;) func() print(f\u0026#39;After {func.__name__}\u0026#39;) return inner bar(foo)()  在Python中function是第一公民，所以可以它作为参数\n 这样我们就实现了一个简单的装饰器，我们可以发现这样在调用的时候比较麻烦，Python还提供了这样了一个语法糖：\ndef bar(func): def inner(): print(f\u0026#39;In Bar Before {func.__name__}\u0026#39;) func() print(f\u0026#39;In Bar After {func.__name__}\u0026#39;) return inner @bar def foo(): print(\u0026#39;foo()!!!\u0026#39;) foo() 除此之外，Python装饰器可以有多个，相当与一层层的包裹：\ndef bar(func): def inner(): print(f\u0026#39;In Bar Before {func.__name__}\u0026#39;) func() print(f\u0026#39;In Bar After {func.__name__}\u0026#39;) return inner def baz(func): def inner(): print(f\u0026#39;In Baz Before {func.__name__}\u0026#39;) func() print(f\u0026#39;In Baz After {func.__name__}\u0026#39;) return inner @bar @baz def foo(): print(\u0026#39;foo()!!!\u0026#39;) foo() 上述代码的输出为：\nIn Bar Before inner\rIn Baz Before foo\rfoo()!!!\rIn Baz After foo\rIn Bar After inner\r一个应用场景 我们有一个这样的函数：\nimport time def slow_method(): time.sleep(2) print(\u0026#39;Done!\u0026#39;) 我们想知道这个函数的运行时间，我们可以用装饰器来实现:\nimport time def timeit(func): def inner(): s = time.time() func() e = time.time() print(f\u0026#39;{func.__name__}Finished in {e - s}s.\u0026#39;) return inner @timeit def slow_method(): time.sleep(2) print(\u0026#39;Done!\u0026#39;) slow_method() 运行结果：\nDone!\rslow_method Finished in 2.0159008502960205s.\r这样我们就实现了我们的需求。\n当被装饰的函数有参数时，同样可以：\nimport time def timeit(func): def inner(*args): s = time.time() func(*args) e = time.time() print(f\u0026#39;{func.__name__}Finished in {e - s}s.\u0026#39;) return inner @timeit def slow_method(a, b): time.sleep(2) print(f\u0026#39;{a}+ {b}= {a+b}\u0026#39;) print(\u0026#39;Done!\u0026#39;) slow_method(1, 2) 运行结果\n1 + 2 = 3\rDone!\rslow_method Finished in 2.0069477558135986s.\r巧用装饰器来实现记忆化递归 首先我们有一个朴素的Fibonacci函数：\ndef fib(n): if n \u0026lt;= 1: return 1 return fib(n - 1) + fib(n - 2) 很明显我们知道这个函数是十分低效的，我们可以使用记忆化递归来优化这个函数。\ncache = {} def fib(n): if n in cache: return cache[n] if n \u0026lt;= 1: return 1 cache[n] = fib(n - 1) + fib(n - 2) return cache[n] print(fib(333)) 这样我们就能使fib函数快很多。但实现稍微有点麻烦，我们可以用装饰器来简化代码：\nclass MyCache(object): def __init__(self, func): self.func = func self.cache = {} def __call__(self, *args): if args not in self.cache: self.cache[args] = self.func(*args) return self.cache[args] @MyCache def fib(n): if n \u0026lt;= 1: return 1 return fib(n - 1) + fib(n - 2) print(fib(333)) 这样我们就非常优雅的实现了fib函数。\nReference 装饰器 Decorator - Python Weekly EP3\n","permalink":"https://fffzlfk.github.io/posts/python%E8%A3%85%E9%A5%B0%E5%99%A8/","summary":"Python decorator","title":"Python装饰器"},{"content":"Week 1 货仓选址 题目链接\n思路 绝对值不等式：$|a_1 - x| + |a_2 - x| + |a_3 - x| + \u0026hellip; + |a_n - x| \\ge |a_n-a_1| + |a_{n-1}-a_{2}|+\u0026hellip; $ 结论：当n为奇数，x应在中位数；当n为偶数时，x应在中间两个数之间。\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int N = 100005; int a[N]; int n; int main() { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; sort(a, a + n); int ans = 0; for (int i = 0; i \u0026lt; n; i++) ans += abs(a[i]-a[n/2]); cout \u0026lt;\u0026lt; ans; return 0; } 数字三角形-DP 题目链接\n思路 从下到上，$ f[i][j] = max(f[i+1][j]+w[i][j], f[i+1][j+1]+w[i][j]) $\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int N = 505; int f[N][N], w[N][N]; int n; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= i; j++) cin \u0026gt;\u0026gt; w[i][j]; for (int i = 1; i \u0026lt;= n; i++) f[n][i] = w[n][i]; for (int i = n-1; i \u0026gt;= 1; i--) for (int j = 1; j \u0026lt;= i; j++) f[i][j] = max(f[i+1][j]+w[i][j], f[i+1][j+1]+w[i][j]); cout \u0026lt;\u0026lt; f[1][1]; return 0; } 简化(等价变换)版代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int N = 505; int f[N][N]; int n; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= i; j++) cin \u0026gt;\u0026gt; f[i][j]; for (int i = n-1; i \u0026gt;= 1; i--) for (int j = 1; j \u0026lt;= i; j++) f[i][j] += max(f[i+1][j], f[i+1][j+1]); cout \u0026lt;\u0026lt; f[1][1]; return 0; } Week 2 蛇形矩阵 题目链接\n代码 #include \u0026lt;iostream\u0026gt;using namespace std; const int N = 105; int n, m; const int dx[]{-1, 0, 1, 0}, dy[]{0, 1, 0, -1}; int q[N][N]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int x = 0, y = 0, d = 1; for (int i = 1; i \u0026lt;= n * m; i++) { q[x][y] = i; int a = x + dx[d], b = y + dy[d]; if (a \u0026lt; 0 || a \u0026gt;= n || b \u0026lt; 0 || b \u0026gt;= m || q[a][b]) { d = (d + 1) % 4; a = x + dx[d], b = y + dy[d]; } x = a, y = b; } for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) cout \u0026lt;\u0026lt; q[i][j] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; } return 0; } 红与黑-Flood Fill算法 题目链接\n思路 Flood-Fill\n BFS（最短距离）  while 队列为空\r{\r取出队头t\r枚举t的4个邻格\rif 格子是陆地并且未开发\r标记为已被开发\r插入队列\r}\r DFS（更方便）  dfs(x, y)\r{\r将(x, y)标记为已开发\r枚举(x, y)的四个邻格\rif 格子是陆地并且未开发\rdfs该格子\r}\r代码 BFS #include \u0026lt;iostream\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;algorithm\u0026gt;#define x first #define y second  using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int N = 25; int n, m; char g[N][N]; int bfs(int sx, int sy) { queue\u0026lt;PII\u0026gt; Q; Q.push({sx, sy}); g[sx][sy] = \u0026#39;#\u0026#39;; int res = 0; const int dx[]{-1, 0, 1, 0}, dy[]{0, 1, 0, -1}; while (!Q.empty()) { auto t = Q.front(); Q.pop(); res++; for (int i = 0; i \u0026lt; 4; i++) { int nx = t.x + dx[i], ny = t.y + dy[i]; if (nx \u0026lt; 0 || nx \u0026gt;= n || ny \u0026lt; 0 || ny \u0026gt;= m || g[nx][ny] != \u0026#39;.\u0026#39;) continue; g[nx][ny] = \u0026#39;#\u0026#39;; Q.emplace(nx, ny); } } return res; } int main() { while (cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n , n || m) { for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; g[i]; int x, y; for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; m; j++) if (g[i][j] == \u0026#39;@\u0026#39;) { x = i; y = j; } cout \u0026lt;\u0026lt; bfs(x, y) \u0026lt;\u0026lt; endl; }\treturn 0; } DFS #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int N = 25; char g[N][N]; int n, m; const int dx[]{-1, 0, 1, 0}, dy[]{0, 1, 0, -1}; int dfs(int x, int y) { g[x][y] = \u0026#39;#\u0026#39;; int res = 1; for (int i = 0; i \u0026lt; 4; i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx \u0026lt; 0 || nx \u0026gt;= n || ny \u0026lt; 0 || ny \u0026gt;= m || g[nx][ny] != \u0026#39;.\u0026#39;) continue; res += dfs(nx, ny); } return res; } int main() { while (cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n, n || m) { int x, y; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; g[i]; for (int j = 0; j \u0026lt; m; j++) if (g[i][j] == \u0026#39;@\u0026#39;) { x = i; y = j; } } cout \u0026lt;\u0026lt; dfs(x, y) \u0026lt;\u0026lt; endl; } return 0; } 回文平方 题目链接\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; char get(int n) { return n \u0026lt;= 9 ? \u0026#39;0\u0026#39; + n : \u0026#39;A\u0026#39; - 10 + n; } string base(int n, int b) { string s = \u0026#34;\u0026#34;; while (n) { s += get(n % b); n /= b; } reverse(s.begin(), s.end()); return s; } bool check(const string \u0026amp;s) { for (int i = 0, j = s.length() - 1; i \u0026lt; s.length(); i++, j--) if (s[i] != s[j]) return false; return true; } int main() { int b; cin \u0026gt;\u0026gt; b; for (int i = 1; i \u0026lt;= 300; i++) { auto t = base(i * i, b); if (check(t)) { cout \u0026lt;\u0026lt; base(i, b) \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; t \u0026lt;\u0026lt; endl; } } return 0; } 剪绳子-浮点数二分 题目链接\n思路 二分 最优化-\u0026gt;判定问题\n 情况1：可以[mid, r] 情况2：不可以[l, mid)  保留k位小数：r-l \u0026lt; 1e-4\n代码 #include \u0026lt;iostream\u0026gt;using namespace std; const int N = 100005; int n, m; int w[N]; bool check(double mid) { int cnt = 0; for (int i = 0; i \u0026lt; n; i++) cnt += w[i] / mid; return cnt \u0026gt;= m; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; w[i]; double l = 0.0, r = 1e9; for (int i = 0; i \u0026lt; 100; i++) { // while (r-l \u0026gt; 1e-4)  double mid = (l + r) / 2; if (check(mid)) l = mid; else r = mid; } printf(\u0026#34;%.2f\\n\u0026#34;, l); return 0; } 扩展题 题目链接\n#include \u0026lt;iostream\u0026gt; using namespace std; double n; bool check(double mid) { return mid*mid*mid \u0026lt; n; } int main() { cin \u0026gt;\u0026gt; n; double l = -22.0, r = 22.0; while (r - l \u0026gt; 1e-8) { double mid = (l+r) / 2; if (check(mid)) l = mid; else r = mid; } printf(\u0026#34;%.6f\\n\u0026#34;, l); return 0; } 分巧克力-整数二分 题目链接\n思路 $ \\sum_{i=0}^{n-1} \\lfloor \\frac {h_i} {mid} \\rfloor \\times \\lfloor \\frac{w_i}{mid} \\rfloor\\ge k $\n 成立：$[mid, r], l = mid$ 不成立：$[l, mid-1], r = mid-1 $  代码 #include \u0026lt;iostream\u0026gt;using namespace std; using ll = long long; const int N = 1e5+5; int h[N], w[N]; int n, k; bool check(int mid) { ll s = 0; for (int i = 0; i \u0026lt; n; i++) { s += 1LL * (h[i]/mid) * (w[i]/mid); if (s \u0026gt;= k) return true; } return false; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; h[i] \u0026gt;\u0026gt; w[i]; int l = 0, r = 1e5; while (l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (check(mid)) l = mid; else r = mid-1; } cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; endl; return 0; } 二分模板 int bsearch_1(int l, int r) { while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; else l = mid+1; } return l } int bsearch_2(int l, int r) { while (l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (check(mid)) l = mid; else r = mid-1; } } 扩展题   数的范围\n题目链接\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; int n, q; int a[100010]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; int k; while (q--) { cin \u0026gt;\u0026gt; k; int l = lower_bound(a, a+n, k)-a; int r = upper_bound(a, a+n, k)-a; printf(\u0026#34;%d \u0026#34;, a[l]==k? l : -1); printf(\u0026#34;%d\\n\u0026#34;, a[r-1]==k? r-1 : -1); } return 0; }   旋转数组的最小数字-不具有单调性，但具有二段性\n题目链接\nclass Solution { public: int findMin(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if (nums.empty()) return -1; int n = nums.size(); while (n \u0026gt; 1 \u0026amp;\u0026amp; nums[0] == nums[n-1]) n--; if (nums[0] \u0026lt;= nums[n-1]) return nums[0]; int l = 0, r = n-1; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (nums[0] \u0026gt; nums[mid]) r = mid; else l = mid+1; } return nums[r]; } };   校门外的树-区间合并 题目链接\n思路 先求出所有移动树木的操作的区间的并集，那么马路上剩余部分即为最终剩下树木的部分。\n区间合并算法\n 将所有区间按左端点从小到大排序 从左到右遍历每个区间[L, R]  $ l_i \\le R $， $R = max(R, r_i) $ $ l_i \u0026gt; R$, 则将[L, R] 存下来，L, R\u0026lt;- $ l_i, r_i $    代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; #define x first #define y second const int N = 105; pair\u0026lt;int, int\u0026gt; seg[N]; int l, m; int main() { cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; m; i++) cin \u0026gt;\u0026gt; seg[i].x \u0026gt;\u0026gt; seg[i].y; sort(seg, seg+m); int res = l + 1; int L = seg[0].x, R = seg[0].y; for (int i = 1; i \u0026lt; m; i++) if (seg[i].x \u0026lt;= R) R = max(R, seg[i].y); else { res -= R - L + 1; L = seg[i].x; R = seg[i].y; } res -= R - L + 1; cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } 扩展题-挤牛奶 题目链接\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; #define x first #define y second const int N = 5005; pair\u0026lt;int, int\u0026gt; seg[N]; int n; int main() { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; seg[i].x \u0026gt;\u0026gt; seg[i].y; sort(seg, seg+n); int L = seg[0].x, R = seg[0].y; int a = 0, b = 0; for (int i = 1; i \u0026lt; n; i++) if (seg[i].x \u0026lt;= R) R = max(R, seg[i].y); else { b = max(b, seg[i].x-R); a = max(a, R-L); L = seg[i].x; R = seg[i].y; } a = max(a, R-L); cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; return 0; } 奖学金 题目链接\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;queue\u0026gt;using namespace std; int cnt = 0; struct node { int id; int grades[3]; int get_sum() const { int s = 0; for (int i = 0; i \u0026lt; 3; i++) s += grades[i]; return s; } friend istream\u0026amp; operator\u0026gt;\u0026gt;(istream\u0026amp; in, node \u0026amp;a) { a.id = ++cnt; for (int i = 0; i \u0026lt; 3; i++) in \u0026gt;\u0026gt; a.grades[i]; return in; } friend bool operator\u0026lt;(const node \u0026amp;a, const node \u0026amp;b) { int sa = a.get_sum(), sb = b.get_sum(); if (sa != sb) return sa \u0026lt; sb; else if (a.grades[0] != b.grades[0]) return a.grades[0] \u0026lt; b.grades[0]; else return a.id \u0026gt; b.id; } }; int n; priority_queue\u0026lt;node\u0026gt; Q; int main() { cin \u0026gt;\u0026gt; n; node tmp; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; tmp; Q.push(tmp); } for (int i = 0; i \u0026lt; 5; i++) { auto t = Q.top(); Q.pop(); cout \u0026lt;\u0026lt; t.id \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; t.get_sum() \u0026lt;\u0026lt; endl; } return 0; } Week 3 翻硬币-递推 题目链接\n思路 枚举递推：每一个操作是唯一确定的\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; string a, b; void turn(int i) { a[i] == \u0026#39;*\u0026#39; ? a[i] = \u0026#39;o\u0026#39; : a[i] = \u0026#39;*\u0026#39;; } int main() { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; int res = 0; for (int i = 0; i \u0026lt; a.length()-1; i++) if (a[i] != b[i]) { turn(i); turn(i+1); ++res; } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } 扩展题-费解的开关  思路  枚举第一行的点击方法，共32种，完成第一行的点击后，固定第一行， 从第一行开始递推，若达到第n行不全为0，说明这种点击方式不合法。 在所有合法的点击方式中取点击次数最少的就是答案。 对第一行的32次枚举涵盖了该问题的整个状态空间，因此该做法是正确的  时间复杂度：32*20*5*500 = 一百六十万 对第一行操作有32种可能 * 对前四行有20种操作可能 * 每一次操作都要改变5个灯的状态 * 最多读入的时候可能有500次light矩阵 最关键的两个性质 每一个位置最多只会被点击一次 如果固定了第一行，那么满足题意的点击方案最多只有一种   代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;climits\u0026gt;#include \u0026lt;cstring\u0026gt;using namespace std; char s[5][5]; void turn(int i, int j) { const int dx[]{0, -1, 0, 1, 0}, dy[]{0, 0, 1, 0, -1}; for (int k = 0; k \u0026lt; 5; k++) { int nx = i + dx[k], ny = j + dy[k]; if (nx \u0026lt; 0 || nx \u0026gt;= 5 || ny \u0026lt; 0 || ny \u0026gt;= 5) continue; s[nx][ny] ^= 1; } } int work() { int res = INT_MAX; for (int k = 0; k \u0026lt; 1 \u0026lt;\u0026lt; 5; k++) { char back[5][5]; memcpy(back, s, sizeof s); int cnt = 0; for (int j = 0; j \u0026lt; 5; j++) { if ((k \u0026gt;\u0026gt; j) \u0026amp; 1) { turn(0, j); ++cnt; } } for (int i = 0; i \u0026lt; 4; i++) for (int j = 0; j \u0026lt; 5; j++) if (s[i][j] == \u0026#39;0\u0026#39;) { turn(i+1, j); ++cnt; } bool ok = true; for (int j = 0; j \u0026lt; 5; j++) if (s[4][j] == \u0026#39;0\u0026#39;) ok = false; if (ok) res = min(res, cnt); memcpy(s, back, sizeof back); } return res \u0026lt;= 6 ? res : -1; } int main() { int n; cin \u0026gt;\u0026gt; n; while (n--) { for (int i = 0; i \u0026lt; 5; i++) cin \u0026gt;\u0026gt; s[i]; cout \u0026lt;\u0026lt; work() \u0026lt;\u0026lt; endl; } return 0; }   找硬币 题目链接\n哈希表做法$O(n)$ 思路 对于当前的元素t，查看之前集合中是否存在m-t，若存在则更新答案，否则添加到集合中。\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;climits\u0026gt;#include \u0026lt;unordered_set\u0026gt;using namespace std; int n, m; unordered_set\u0026lt;int\u0026gt; S; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int v1 = INT_MAX, v2; int a, b; while (n--) { cin \u0026gt;\u0026gt; a; b = m - a; if (S.count(b)) { if (a \u0026gt; b) swap(a, b); if (v1 \u0026gt; a) { v1 = a; v2 = b; } } else S.insert(a); } printf(v1 == INT_MAX ? \u0026#34;No Solution\u0026#34; : \u0026#34;%d %d\\n\u0026#34;, v1, v2); return 0; } 双指针做法$O(nlogn)$ 思路 .notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Note\n双指针算法：如果i++和j--单调性相反就能用双指针做法。\n $a[i]+a[j] \\le m \\ and \\ j 最大$\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; int n, m; const int N = 1e5+5; int a[N]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; sort(a, a+n); for (int i = 0, j = n-1; i \u0026lt; n; i++) { while (i \u0026lt; j \u0026amp;\u0026amp; a[i] + a[j] \u0026gt; m) j--; if (i \u0026lt; j \u0026amp;\u0026amp; a[i]+a[j] == m) { cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; a[j] \u0026lt;\u0026lt; endl; return 0; } } cout \u0026lt;\u0026lt; \u0026#34;No Solution\u0026#34;; return 0; } 十三号星期五 题目链接\n思路  枚举每个月第一天距离1900-1-1过了多少天days 星期：$(days+12)\\ mod \\ 7 $  代码 #include \u0026lt;iostream\u0026gt;using namespace std; const int month[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; int n; int weekdays[7]; int main() { cin \u0026gt;\u0026gt; n; int days = 0; for (int year = 1900; year \u0026lt; 1900+n; year++) { for (int i = 1; i \u0026lt;= 12; i++) { weekdays[(days + 12) % 7]++; days += month[i]; if (i == 2 \u0026amp;\u0026amp; (year % 4 == 0 \u0026amp;\u0026amp; year % 100 != 0 || year % 400 == 0)) days++; } } for (int i = 5, j = 0; j \u0026lt; 7; i = (i+1) % 7, j++) cout \u0026lt;\u0026lt; weekdays[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; return 0; } 平方矩阵 II 题目链接\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; int n; int main() { while (cin \u0026gt;\u0026gt; n, n) { for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) cout \u0026lt;\u0026lt; abs(j-i) + 1 \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } cout \u0026lt;\u0026lt; endl; } return 0; } Longest-increasing-subsequence 题目链接\n思路  dp[i]: 长度为i的LIS的最后一个元素的最小值 eg:[0,3,1,6,2,2,7] for each x:  0, dp = [0] 3, dp = [0, 3] 1, dp = [0, 1] 6, dp = [0, 1, 6] 2, dp = [0, 1, 2] 2, dp = [0, 1, 2] 7, dp = [0, 1, 2, 7]   ans = len(dp)  代码 class Solution: def lengthOfLIS(self, nums: List[int]) -\u0026gt; int: dp = [] for x in nums: i = bisect_left(dp, x) if i == len(dp): dp.append(x) else: dp[i] = x return len(dp) 棋盘挑战-八皇后问题 题目链接\n思路  如何判断某些位置能不能填：对角线用截距编号  dg: y=x+b, b = y-x+n udg: y=-x+b, b = y+x    代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int N = 15; int path[N], col[N], dg[2*N], udg[2*N]; int n, ans; void dfs(int x) { if (x \u0026gt; n) { ans++; if (ans \u0026lt;= 3) { for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; path[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } for (int y = 1; y \u0026lt;= n; y++) { if (!col[y] \u0026amp;\u0026amp; !dg[y-x+n] \u0026amp;\u0026amp; !udg[y+x]) { path[x] = y; col[y] = dg[y-x+n] = udg[y+x] = true; dfs(x+1); col[y] = dg[y-x+n] = udg[y+x] = false; // path[x] = 0;  } } } int main() { cin \u0026gt;\u0026gt; n; dfs(1); cout \u0026lt;\u0026lt; ans; return 0; } 扩展题-解数独 题目链接\nclass Solution { public: vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; P; bool check(const vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, int r, int c, char n) { for (int i = 0; i \u0026lt; 9; i++) if (board[r][i] == n || board[i][c] == n) return false; r = r / 3 * 3; c = c / 3 * 3; for (int i = r; i \u0026lt; r + 3; i++) for (int j = c; j \u0026lt; c + 3; j++) if (board[i][j] == n) return false; return true; } bool dfs(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, int idx) { if (idx == (int)P.size()) return true; int r = P[idx].first, c = P[idx].second; for (int i = 1; i \u0026lt;= 9; i++) if (check(board, r, c, i+\u0026#39;0\u0026#39;)) { board[r][c] = i+\u0026#39;0\u0026#39;; if (dfs(board, idx+1)) return true; board[r][c] = \u0026#39;.\u0026#39;; } return false; } void solveSudoku(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board) { for (int i = 0; i \u0026lt; 9; i++) for (int j = 0; j \u0026lt; 9; j++) if (board[i][j] == \u0026#39;.\u0026#39;) P.emplace_back(i, j); dfs(board, 0); } }; 货币系统-完全背包 题目链接\n思路 代码 #include \u0026lt;iostream\u0026gt;using namespace std; using ll = long long; const int N = 30, M = 10005; ll f[N][M]; int n, m; int w[N]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; w[i]; f[0][0] = 1; for (int i = 1; i \u0026lt;= n; i++) for (int j = 0; j \u0026lt;= m; j++) for (int k = 0; k * w[i] \u0026lt;= j; k++) f[i][j] += f[i-1][j-k*w[i]]; cout \u0026lt;\u0026lt; f[n][m] \u0026lt;\u0026lt; endl; return 0; } 时间优化  $ f[i][j] = f[i-1][j]+f[i-1][j-w[i]]+f[i-1][j-2w[i]]+\u0026hellip;+f[i-1][j-kw[i]] $ $ f[i][j-v] = f[i-1][j-w[i]]+f[i-1][j-2w[i]]+\u0026hellip;+f[i-1][j-kw[i]] $ 由1-2得：$ f[i][j] = f[i-1][j]+f[i][j-v] $  #include \u0026lt;iostream\u0026gt;using namespace std; using ll = long long; const int N = 30, M = 10005; ll f[N][M]; int n, m; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; f[0][0] = 1; for (int i = 1; i \u0026lt;= n; i++) { int v; cin \u0026gt;\u0026gt; v; for (int j = 0; j \u0026lt;= m; j++) { f[i][j] = f[i-1][j]; if (j \u0026gt;= v) f[i][j] += f[i][j-v]; } } cout \u0026lt;\u0026lt; f[n][m] \u0026lt;\u0026lt; endl; return 0; } 空间优化 #include \u0026lt;iostream\u0026gt;using namespace std; using ll = long long; const int N = 30, M = 10005; ll f[M]; int n, m; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; f[0] = 1; for (int i = 1; i \u0026lt;= n; i++) { int v; cin \u0026gt;\u0026gt; v; for (int j = v; j \u0026lt;= m; j++) { f[j] += f[j-v]; // f[i][j] = f[i-1][j] + f[i][j-v]  } } cout \u0026lt;\u0026lt; f[m] \u0026lt;\u0026lt; endl; return 0; } 阶乘 题目链接\n思路  $ n! = 2^{\\alpha}*5^{\\beta}*x $ $ ans = \\frac{n!}{10^k}\\ mod\\ 10=$  我们进行观察，因为0只可能由2的倍数和5的倍数相乘得到，所以在进行乘法的过程中，我们将2和5的倍数给清理掉，这样就保证了不会出现0，然后我们控制其范围，每次相乘取其个位，因为个位肯定是非零元素，十位以后的数字完全没有必要保留下来，最后，我们将多处理的2或者5重新乘回去再取余即可\n代码 #include \u0026lt;iostream\u0026gt;using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; int d2 = 0, d5 = 0; int ans = 1; for (int i = 2; i \u0026lt;= n; i++) { int x = i; while (x % 2 == 0) x /= 2, d2++; while (x % 5 == 0) x /= 5, d5++; ans = ans * x % 10; } for (int i = 0; i \u0026lt; d2-d5; i++) ans = ans * 2 % 10; cout \u0026lt;\u0026lt; ans; return 0; } Week 4 滑雪场设计-枚举 思路  最优解中，所有的高度都在$[0, 100]$之间 只需枚举所有可能的区间  代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;climits\u0026gt;using namespace std; const int N = 1005; int a[N]; int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; int ans = INT_MAX; for (int l = 0; l \u0026lt;= 100-17; l++) { int r = l+17, cost = 0; for (int i = 0; i \u0026lt; n; i++) if (a[i] \u0026lt; l) cost += (l-a[i])*(l-a[i]); else if (a[i] \u0026gt; r) cost += (a[i]-r)*(a[i]-r); ans = min(ans, cost); } cout \u0026lt;\u0026lt; ans; return 0; } 整数集合划分-贪心 题目链接\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; int a[100005], res; int main() { #ifndef ONLINE_JUDGE \tfreopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif \tint n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; } sort(a, a + n); for (int i = 0; i \u0026lt; n; i++) { if (i \u0026gt;= n \u0026gt;\u0026gt; 1) res += a[i]; else res -= a[i]; } cout \u0026lt;\u0026lt; n % 2 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; res; return 0; } 扩展题-双向搜索 题目链接\n  思路\n 先搜索前N/2个物品可以凑出来的所有重量，存到数组中去 对所有重量排序，判重 在搜索后一半物品可以凑出来的所有重量y，在前一半物品搜索出来的重量二分出一个y，使得x+y\u0026lt;=w, x+y最大    优化\n 从大到小枚举所有重量，使得搜索到的和更快达到目标 均衡两次搜索时间    #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; using ll = long long; const int N = 46; int n, w, g[N], k, cnt, wgt[1 \u0026lt;\u0026lt; (23 + 2)]; void dfs_1(int x, int s) { if (x == k) { wgt[cnt++] = s; return; } if (s * 1ll + g[x] \u0026lt;= w) dfs_1(x + 1, s + g[x]); dfs_1(x + 1, s); } int ans; void dfs_2(int x, int s) { if (x == n) { int l = 0, r = cnt - 1; while (l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (s * 1ll + wgt[mid] \u0026lt;= w) l = mid; else r = mid - 1; } if (s * 1ll + wgt[l] \u0026lt;= w) ans = max(ans, s + wgt[l]); return; } if (s * 1ll + g[x] \u0026lt;= w) dfs_2(x + 1, s + g[x]); dfs_2(x + 1, s); } int main() { #ifndef ONLINE_JUDGE \tfreopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif \tscanf(\u0026#34;%d%d\u0026#34;, \u0026amp;w, \u0026amp;n); for (int i = 0; i \u0026lt; n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;g[i]); sort(g, g + n, greater\u0026lt;int\u0026gt;()); k = n / 2 + 2; dfs_1(0, 0); sort(wgt, wgt + cnt); cnt = unique(wgt, wgt + cnt) - wgt; dfs_2(k, 0); cout \u0026lt;\u0026lt; ans; return 0; } 合唱队形-LIS 题目链接\n思路  f[i]: 从前往后，以a[i]结尾的最长上升子序列的长度 g[i]: 从后往前，以a[i]结尾的最长上升子序列的长度 $ ans = n - max(f[i]+g[i]) + 1$  代码 $ n^2 $\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int N = 105; int n, a[N]; int f[N], g[N]; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; i++) { f[i] = 1; for (int j = 1; j \u0026lt; i; j++) if (a[i] \u0026gt; a[j]) f[i] = max(f[i], f[j]+1); } for (int i = n; i \u0026gt;= 1; i--) { g[i] = 1; for (int j = n; j \u0026gt; i; j--) if (a[i] \u0026gt; a[j]) g[i] = max(g[i], g[j]+1); } int ans = 0; for (int k = 1; k \u0026lt;= n; k++) ans = max(ans, f[k] + g[k]); cout \u0026lt;\u0026lt; n - ans + 1; return 0; $ nlogn $\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int N = 105; int f[N], g[N], a[N], n; int len1[N], len2[N]; int main() { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; int cnt = 0; for (int i = 0; i \u0026lt; n; i++) { auto it = lower_bound(f, f+cnt, a[i])-f; if (it == cnt) f[cnt++] = a[i]; else f[it] = a[i]; len1[i] = cnt; } cnt = 0; for (int i = n-1; i \u0026gt;= 0; i--) { auto it = lower_bound(g, g+cnt, a[i])-g; if (it == cnt) g[cnt++] = a[i]; else g[it] = a[i]; len2[i] = cnt; } int ans = 0; for (int i = 0; i \u0026lt; n; i++) ans = max(ans, len1[i]+len2[i]); cout \u0026lt;\u0026lt; n - ans + 1; return 0; } 火星人-排列 思路 实现next_permutation()\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int N = 10005; int n, m, a[N]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; while (m--) { int k = n-1; while (a[k-1] \u0026gt; a[k]) k--; k--; int t = k; while (t \u0026lt; n-1 \u0026amp;\u0026amp; a[t+1] \u0026gt; a[k]) t++; swap(a[t], a[k]); reverse(a+k+1, a+n); } for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; return 0; } 星空之夜-Flood-fill 思路  判断形状是否相似  哈希：两两之间的距离之和    代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;cmath\u0026gt;using namespace std; using P = pair\u0026lt;int, int\u0026gt;; #define x first #define y second  const int N = 105; P c[N*N]; int cnt; char g[N][N]; int n, m; inline double get_dist(P a, P b) { return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)); } double get_hash() { double s = 0; for (int i = 0; i \u0026lt; cnt; i++) for (int j = i+1; j \u0026lt; cnt; j++) s += get_dist(c[i], c[j]); return s; } char get_id(double d) { static double hash[30]; static int idx = 0; for (int i = 0; i \u0026lt; idx; i++) { if (fabs(hash[i] - d) \u0026lt; 1e-8) return \u0026#39;a\u0026#39; + i; } hash[idx++] = d; return \u0026#39;a\u0026#39; + idx - 1; } void dfs(int i, int j) { g[i][j] = \u0026#39;0\u0026#39;; c[cnt++] = {i, j}; for (int x = i-1; x \u0026lt;= i+1; x++) for (int y = j-1; y \u0026lt;= j+1; y++) { if (x \u0026lt; 0 || x \u0026gt;= n || y \u0026lt; 0 || y \u0026gt;= m || g[x][y] == \u0026#39;0\u0026#39;) continue; dfs(x, y); } } int main() { cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; g[i]; for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; m; j++) { if (g[i][j] == \u0026#39;1\u0026#39;) { cnt = 0; dfs(i, j); auto d = get_hash(); auto id = get_id(d); for (int k = 0; k \u0026lt; cnt; k++) g[c[k].x][c[k].y] = id; } } for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; g[i] \u0026lt;\u0026lt; endl; return 0; } 摘花生-DP 题目链接\n思路  状态表示  集合：定义f[i][j]为从(1, 1)到达(i, j)的所有方案 属性：最大值   状态转移  (i, j)从(i-1, j)即上方过来 (i, j)从(i, j-1)即左方过来   空间压缩  f[i][j]只需要用到这一层和上一层的f元素，所以可以压缩成滚动数组。在此之上，还可以直接压缩成一维数组。    代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt;using namespace std; const int N = 105; int f[N]; int n, m, t; int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) { cin \u0026gt;\u0026gt; t; f[j] = max(f[j], f[j-1]) + t; } cout \u0026lt;\u0026lt; f[m] \u0026lt;\u0026lt; endl; memset(f, 0, sizeof f); } } 最大的和-最大子矩形 题目链接\n思路  前缀和数组A[i][j]表示 $ \\sum_{i=1}^{n}{a[i][j]} $ 枚举矩形上下边界 求最大连续子序列和  代码 package main import ( \u0026#34;fmt\u0026#34; ) var M [201][201]int var n int func main() { fmt.Scanf(\u0026#34;%d\u0026#34;, \u0026amp;n) for i := 1; i \u0026lt;= n; i++ { for j := 1; j \u0026lt;= n; j++ { fmt.Scanf(\u0026#34;%d\u0026#34;, \u0026amp;M[i][j]) M[i][j] += M[i-1][j] } } ans := int(-1e9) for i := 1; i \u0026lt;= n; i++ { for j := i; j \u0026lt;= n; j++ { s := 0 for k := 1; k \u0026lt;= n; k++ { s = max(0, s) + M[j][k] - M[i-1][k] ans = max(ans, s) } } } fmt.Println(ans) } func max(a, b int) int { if a \u0026gt; b { return a } return b } 最大的和-线性DP 题目链接\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;climits\u0026gt;using namespace std; const int N = 50005; int n, a[N], f[N], g[N]; // f[i]: 1~i最大连续子段和，g[i]:n~i最大连续子段和  int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); fill(f, f+n+2, INT_MIN); fill(g, g+n+2, INT_MIN); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); int s = 0; for (int i = 1; i \u0026lt;= n; i++) { s = max(s, 0) + a[i]; f[i] = max(f[i-1], s); } s = 0; for (int i = n; i \u0026gt;= 1; i--) { s = max(s, 0) + a[i]; g[i] = max(g[i+1], s); } int ans = INT_MIN; for (int i = 1; i \u0026lt; n; i++) ans = max(ans, f[i] + g[i+1]); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } 最大异或对-trie 题目链接\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int N = 1e5+5, M = 3e6+5; int a[N], son[M][2], idx, n; void insert(int x) { int p = 0; for (int i = 30; ~i; i--) { int t = x \u0026gt;\u0026gt; i \u0026amp; 1; if (!son[p][t]) son[p][t] = ++idx; p = son[p][t]; } } int query(int x) { int p = 0, res = 0; for (int i = 30; ~i; i--) { int t = x \u0026gt;\u0026gt; i \u0026amp; 1; if (son[p][!t]) { res += 1 \u0026lt;\u0026lt; i; p = son[p][!t]; } else { p = son[p][t]; } } return res; } int main() { cin \u0026gt;\u0026gt; n; int ans = 0; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; insert(a[i]); ans = max(ans, query(a[i])); } cout \u0026lt;\u0026lt; ans; return 0; } 牛亦或-trie+前缀和 题目链接\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int N = 1e5+5, M = 2e6+5; int son[M][2], a[N], id[M], idx, n; void insert(int x, int k) { int p = 0; for (int i = 20; ~i; i--) { int t = x \u0026gt;\u0026gt; i \u0026amp; 1; if (!son[p][t]) son[p][t] = ++idx; p = son[p][t]; } id[p] = k; } int query(int x) { int p = 0; for (int i = 20; ~i; i--) { int t = x \u0026gt;\u0026gt; i \u0026amp; 1; if (son[p][!t]) { p = son[p][!t]; } else { p = son[p][t]; } } return id[p]; } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; a[i] ^= a[i-1]; } insert(0, 0); int ans = -1, l, r; for (int i = 1; i \u0026lt;= n; i++) { int k = query(a[i]); int s = a[i] ^ a[k]; if (s \u0026gt; ans) { ans = s; l = k + 1, r = i; } insert(a[i], i); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; return 0; } Week 5 开心的金明-01背包 题目链接\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; int f[30005]; int n, m; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int v, w; for (int i = 0; i \u0026lt; m; i++) { cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; for (int j = n; j \u0026gt;= v; j--) f[j] = max(f[j], f[j-v]+w*v); } cout \u0026lt;\u0026lt; f[n] \u0026lt;\u0026lt; endl; return 0; } K倍区间-前缀和 题目链接\n思路 求区间和，可以通过前缀和来求出。sum[r]−sum[l−1]就是区间[l,r]的和。如果区间[l,r]的和是k的倍数则有(sum[r]−sum[l−1])，即sum[r]。因此，我们可以得到一个结论，对前缀和取模之后，两个相等的前缀和就能组成一个k倍区间。\n有了这个结论之后，我们就可以使用两层for循环来计数k倍区间的个数，但是由于数据比较大，我们不能这样做。那么我们能不能在计算前缀和的过程中同时来统计k倍区间的个数呢？当然可以。我们可以用一个数组cnt，规定cnt[i]表示当前位置之前，前缀和取模后等于i的个数，以后每出现一次前缀和（取模后）和它相等，那么k倍区间就加上cnt[sum[i]]，然后cnt[sum[i]]++。这样似乎不容易理解，我们用样例举个例子。\n对于数列 1 2 3 4 5，k = 2\n对前1个数的和模k后为1，在此之前有0个前缀和取模后为1，总个数+0\n对前2个数的和模k后为1，在此之前有1个前缀和取模后为1，总个数+1\n对前3个数的和模k后为0，在此之前有0个前缀和取模后为0, 总个数+0\n对前4个数的和模k后为0，在此之前有1个前缀和取模后为0，总个数+1\n对前5个数的和模k后为1，在此之前有2个前缀和取模后为1，总个数+2\n但是我们还忽略了一点，就是我们这样做我们少计算了区间·[0,i]构成的k倍区间，其个数为cnt[0]。\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int N = 1e5+5; int a[N], n, k, cnt[N]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; long ans = 0; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; a[i] = (a[i] + a[i-1]) % k; ans += cnt[a[i]]; cnt[a[i]]++; } cout \u0026lt;\u0026lt; ans + cnt[0]; return 0; } 数独检查-模拟 题目链接\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt;using namespace std; const int N = 7; int n, m; int g[N*N][N*N]; bool st[N*N]; bool check_row() { for (int i = 0; i \u0026lt; m; i++) { memset(st, false, sizeof st); for (int j = 0; j \u0026lt; m; j++) { int t = g[i][j]; if (t \u0026lt; 1 || t \u0026gt; m) return false; if (st[t]) return false; st[t] = true; } } return true; } bool check_col() { for (int i = 0; i \u0026lt; m; i++) { memset(st, false, sizeof st); for (int j = 0; j \u0026lt; m; j++) { int t = g[j][i]; if (t \u0026lt; 1 || t \u0026gt; m) return false; if (st[t]) return false; st[t] = true; } } return true; } bool check_cell() { for (int i = 0; i \u0026lt; m; i += n) for (int j = 0; j \u0026lt; m; j += n) { memset(st, false, sizeof st); for (int dx = 0; dx \u0026lt; n; dx++) for (int dy = 0; dy \u0026lt; n; dy++) { int t = g[i+dx][j+dy]; if (t \u0026lt; 1 || t \u0026gt; m) return false; if (st[t]) return false; st[t] = true; } } return true; } int main() { int T; cin \u0026gt;\u0026gt; T; for (int t = 1; t \u0026lt;= T; t++) { cin \u0026gt;\u0026gt; n; m = n * n; for (int i = 0; i \u0026lt; m; i++) for (int j = 0; j \u0026lt; m; j++) cin \u0026gt;\u0026gt; g[i][j]; printf(check_row() \u0026amp;\u0026amp; check_col() \u0026amp;\u0026amp; check_cell() ? \u0026#34;Case #%d: Yes\\n\u0026#34; : \u0026#34;Case #%d: No\\n\u0026#34;, t); } return 0; } 最长公共子序列-LCS 题目链接\n思路 代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int N = 1005; int n, m, f[N][N]; char a[N], b[N]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; a + 1 \u0026gt;\u0026gt; b + 1; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) if (a[i] == b[j]) f[i][j] = f[i-1][j-1] + 1; else f[i][j] = max(f[i-1][j], f[i][j-1]); cout \u0026lt;\u0026lt; f[n][m]; return 0; } 数独简单版-数独 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; char g[10][10]; bool row[10][10], col[10][10], cell[3][3][10]; bool dfs(int x, int y) { if (y == 9) { x++, y = 0; } if (x == 9) { for (int i = 0; i \u0026lt; 9; i++) cout \u0026lt;\u0026lt; g[i] \u0026lt;\u0026lt; endl; return true; } if (g[x][y] != \u0026#39;.\u0026#39;) return dfs(x, y+1); for (int i = 1; i \u0026lt;= 9; i++) { if (!row[x][i] \u0026amp;\u0026amp; !col[y][i] \u0026amp;\u0026amp; !cell[x/3][y/3][i]) { g[x][y] = i + \u0026#39;0\u0026#39;; row[x][i] = col[y][i] = cell[x/3][y/3][i] = true; if (dfs(x, y+1)) return true; row[x][i] = col[y][i] = cell[x/3][y/3][i] = false; g[x][y] = \u0026#39;.\u0026#39;; } } return false; } int main() { for (int i = 0; i \u0026lt; 9; i++) { cin \u0026gt;\u0026gt; g[i]; for (int j = 0; j \u0026lt; 9; j++) if (g[i][j] != \u0026#39;.\u0026#39;) { int t = g[i][j] - \u0026#39;0\u0026#39;; row[i][t] = col[j][t] = cell[i/3][j/3][t] = true; } } dfs(0, 0); } 献给阿尔吉侬的花束-BFS 题目链接\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;queue\u0026gt;using namespace std; const int N = 205; const int dx[]{-1, 0, 1, 0}, dy[]{0, 1, 0, -1}; char g[N][N]; int dist[N][N]; int r, c; bool bfs(int x, int y) { memset(dist, 0, sizeof dist); queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; Q; Q.push({x, y}); while (!Q.empty()) { auto [tx, ty] = Q.front(); Q.pop(); if (g[tx][ty] == \u0026#39;E\u0026#39;) { cout \u0026lt;\u0026lt; dist[tx][ty] \u0026lt;\u0026lt; endl; return true; } for (int i = 0; i \u0026lt; 4; i++) { int nx = tx + dx[i], ny = ty + dy[i]; if (nx \u0026lt; 0 || nx \u0026gt;= r || ny \u0026lt; 0 || ny \u0026gt;= c || g[nx][ny] == \u0026#39;#\u0026#39;) continue; Q.push({nx, ny}); if (g[nx][ny] != \u0026#39;E\u0026#39;) g[nx][ny] = \u0026#39;#\u0026#39;; dist[nx][ny] = dist[tx][ty] + 1; } } cout \u0026lt;\u0026lt; \u0026#34;oop!\u0026#34; \u0026lt;\u0026lt; endl; return false; } int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; r \u0026gt;\u0026gt; c; for (int i = 0; i \u0026lt; r; i++) cin \u0026gt;\u0026gt; g[i]; bool is_break = false; for (int i = 0; i \u0026lt; r; i++) { for (int j = 0; j \u0026lt; c; j++) if (g[i][j] == \u0026#39;S\u0026#39;) { bfs(i, j); is_break = true; break; } if (is_break) break; } } return 0; } a^b-位运算 题目链接\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; using ll = long long; int main() { ll a, b, p; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; p; ll res = 1; while (b) { if (b \u0026amp; 1) res = res * a % p; a = a * a % p; b \u0026gt;\u0026gt;= 1; } cout \u0026lt;\u0026lt; res % p \u0026lt;\u0026lt; endl; return 0; } 耍杂技的牛-贪心 题目链接\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;climits\u0026gt;using namespace std; const int N = 50005; int n; pair\u0026lt;int, int\u0026gt; a[N]; int main() { cin \u0026gt;\u0026gt; n; int w, s; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; w \u0026gt;\u0026gt; s; a[i] = {w+s, w}; } sort(a, a+n); int ans = INT_MIN, sum_w = 0; for (int i = 0; i \u0026lt; n; i++) { w = a[i].second, s = a[i].first - w; ans = max(ans, sum_w - s); sum_w += w; } cout \u0026lt;\u0026lt; ans; return 0; } 数列-二进制 题目链接\n思路 使用n的二进制表示\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; int pow(int a, int b) { int res = 1; while (b) { if (b \u0026amp; 1) res *= a; a *= a; b \u0026gt;\u0026gt;= 1; } return res; } int main() { int k, n; cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; n; int ans = 0; for (int i = 0; i \u0026lt; 10; i++) { if (n \u0026gt;\u0026gt; i \u0026amp; 1) ans += pow(k, i); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } 借教室-二分\u0026amp;差分 题目链接\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; using ll = long long; const int N = 1e6 + 5; int r[N], d[N], s[N], t[N]; int n, m; ll b[N]; bool check(int mid) { for (int i = 1; i \u0026lt;= n; i++) b[i] = r[i] - r[i-1]; for (int i = 1; i \u0026lt;= mid; i++) { b[s[i]] -= d[i]; b[t[i]+1] += d[i]; } for (int i = 1; i \u0026lt;= n; i++) { b[i] += b[i-1]; if (b[i] \u0026lt; 0) return false; } return true; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; r[i]; for (int i = 1; i \u0026lt;= m; i++) cin \u0026gt;\u0026gt; d[i] \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; t[i]; int l = 0, r = m; while (l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (check(mid)) l = mid; else r = mid - 1; } if (l == m) puts(\u0026#34;0\u0026#34;); else printf(\u0026#34;-1\\n%d\u0026#34;, l + 1); return 0; } 关押罪犯-二分\u0026amp;染色法判断二分图 题目链接\n思路  二分答案，判断能否以当前答案大的点构成二分图 使用染色判断能否构成二分图  代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt;using namespace std; const int N = 20005, M = 200005; int n, m; int h[N], ne[M], e[M], w[M], idx; int color[N]; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; } bool dfs(int u, int c, int mid) { color[u] = c; for (int i = h[u]; ~i; i = ne[i]) { if (w[i] \u0026lt;= mid) continue; int v = e[i]; if (color[v]) { if (color[v] == c) return false; } else if (!dfs(v, 3-c, mid)) return false; } return true; } bool check(int mid) { memset(color, 0, sizeof color); for (int i = 1; i \u0026lt;= n; i++) if (!color[i]) if (!dfs(i, 1, mid)) return false; return true; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); int a, b, c; memset(h, -1, sizeof h); while (m--) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); add(a, b, c); add(b, a, c); } int l = 0, r = 1e9; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; else l = mid + 1; } printf(\u0026#34;%d\u0026#34;, l); return 0; } Week 6 乌龟棋-线性DP 题目链接\n思路   状态表示：f[b1,b2,b3,b4] 表示所有第 i 种卡片使用了 bi 张的走法的最大分值。\n  状态计算：将 f[b1,b2,b3,b4] 表示的所有走法按最后一步选择哪张卡片分成四类：第 i 类为最后一步选择第 i 种卡片。比如 i=2，则这一类的最大分值是 f[b1,b2−1,b3,b4]+score[b1+2b2+3b3+4b4]。\n  代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int N = 45; int f[N][N][N][N], b[4], w[355]; int n, m; int main() { cin \u0026gt;\u0026gt; n\u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; w[i]; while (m--) { int t; cin \u0026gt;\u0026gt; t; b[t-1]++; } for (int A = 0; A \u0026lt;= b[0]; A++) for (int B = 0; B \u0026lt;= b[1]; B++) for (int C = 0; C \u0026lt;= b[2]; C++) for (int D = 0; D \u0026lt;= b[3]; D++) { int score = w[A * 1 + B * 2 + C * 3 + D * 4]; int \u0026amp;v = f[A][B][C][D]; v = score; if (A) v = max(v, f[A-1][B][C][D] + score); if (B) v = max(v, f[A][B-1][C][D] + score); if (C) v = max(v, f[A][B][C-1][D] + score); if (D) v = max(v, f[A][B][C][D-1] + score); } cout \u0026lt;\u0026lt; f[b[0]][b[1]][b[2]][b[3]]; return 0; } 比例简化-枚举 题目链接\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } int main() { int A, B, L; cin \u0026gt;\u0026gt; A \u0026gt;\u0026gt; B \u0026gt;\u0026gt; L; int a, b; double t = A * 1.0 / B; double delta = 1e9; for (int i = 1; i \u0026lt;= L; i++) { for (int j = 1; j \u0026lt;= L; j++) { if (gcd(i, j) == 1) { double x = i * 1.0 / j; if (x \u0026gt;= t \u0026amp;\u0026amp; x - t \u0026lt; delta) { delta = x - t; a = i, b = j; } } } } cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; b; return 0; } 计算系数 题目链接\n思路  二项式定理：$ ans = C_k^n x^n y^m $ Pascal公式：$ C_n^k = C_{n-1}^{k} + C_{n-1}^{k-1} $  代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int mod = 10007; const int N = 1005; int C[N][N]; int pow(int a, int b) { int res = 1; a %= mod; while (b) { if (b \u0026amp; 1) res = res * a % mod; a = a * a % mod; b \u0026gt;\u0026gt;= 1; } return res % mod; } int main() { int a, b, k, n, m; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; k \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt;= k; i++) for (int j = 0; j \u0026lt;= i; j++) { if (!j) C[i][j] = 1; else C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod; } cout \u0026lt;\u0026lt; C[k][n] * pow(a, n) % mod * pow(b, m) % mod; return 0; } 合并果子 代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;queue\u0026gt;using namespace std; int n; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; Q; int main() { cin \u0026gt;\u0026gt; n; int x; while (n--) { cin \u0026gt;\u0026gt; x; Q.push(move(x)); } int ans = 0; while (Q.size() \u0026gt; 1) { auto a = Q.top(); Q.pop(); auto b = Q.top(); Q.pop(); Q.push(a + b); ans += a + b; } cout \u0026lt;\u0026lt; ans; return 0; } 积木大赛-贪心\u0026amp;差分 题目链接\n思路 从后往前操作，如果当前的 bi\u0026gt;0，则将其减1，并将其后的某个负数加1。\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int N = 100005; int n, h[N]; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; h[i]; int res = 0; for (int i = n; i \u0026gt;= 1; i--) res += max(0, h[i]-h[i-1]); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } LeetCode-1755 最接近目标值的子序列和 题目链接\n思路  generate sums for all subset: DP  $ sum_i = sum_{i-1} \\cup (sum_{i-1}+ nums[i]) $    将sum of subset分成两部分，遍历前一部分二分后一部分，并且排序 去重优化  代码 参考链接\nclass Solution { public: int minAbsDifference(vector\u0026lt;int\u0026gt;\u0026amp; nums, int goal) { const int n = nums.size(); int ans = abs(goal); vector\u0026lt;int\u0026gt; t1{0}, t2{0}; t1.reserve(1 \u0026lt;\u0026lt; (n / 2 + 1)), t2.reserve(1 \u0026lt;\u0026lt; (n / 2 + 1)); for (int i = 0; i \u0026lt; n / 2; i++) for (int j = t1.size() - 1; j \u0026gt;= 0; j--) t1.push_back(nums[i] + t1[j]); for (int i = n / 2; i \u0026lt; n; i++) for (int j = t2.size() - 1; j \u0026gt;= 0; j--) t2.push_back(nums[i] + t2[j]); auto it = unique(begin(t1), end(t1)); t1.resize(distance(begin(t1), it)); sort(begin(t1), end(t1), greater\u0026lt;int\u0026gt;()); it = unique(begin(t2), end(t2)); t2.resize(distance(begin(t2), it)); sort(begin(t2), end(t2)); for (const auto \u0026amp;e : t1) { auto it = lower_bound(begin(t2), end(t2), goal - e); if (it != t2.end()) ans = min(ans, abs(goal - e - *it)); if (it != t2.begin()) ans = min(ans, abs(goal - e - *(--it))); } return ans; } }; Week 7 机器人跳跃问题-二分 思路 注意mid大于等于1e5时，一定可以完成游戏\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int N = 1e5 + 5; int h[N], n; bool check(long mid) { for (int i = 1; i \u0026lt;= n; i++) { mid += mid - h[i]; if (mid \u0026gt; 1e5) return true; if (mid \u0026lt; 0) return false; } return true; } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; h[i]; int l = 0, r = 1e5; while (l \u0026lt; r) { const int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; else l = mid + 1; } cout \u0026lt;\u0026lt; l; return 0; } Z字形扫描 题目链接\n思路  下标之和为偶数，从下到上遍历 下标之和为奇数，从上到下遍历  代码 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int N = 505; int g[N][N], n; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= n; j++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;g[i][j]); for (int i = 2; i \u0026lt;= 2 * n; i ++) { if (i % 2 == 0) { for (int j = i; j \u0026gt;= 1; j--) { if (j \u0026gt;= 1 \u0026amp;\u0026amp; j \u0026lt;= n \u0026amp;\u0026amp; i - j \u0026gt;= 1 \u0026amp;\u0026amp; i - j \u0026lt;= n) printf(\u0026#34;%d \u0026#34;, g[j][i-j]); } } else { for (int j = 1; j \u0026lt;= n; j++) { if (j \u0026gt;= 1 \u0026amp;\u0026amp; j \u0026lt;= n \u0026amp;\u0026amp; i - j \u0026gt;= 1 \u0026amp;\u0026amp; i - j \u0026lt;= n) printf(\u0026#34;%d \u0026#34;, g[j][i-j]); } } } return 0; } 动态求连续区间和-线段树 题目链接\n线段树-代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int N = 1e5 + 5; struct node { int l, r, sum; } tree[N \u0026lt;\u0026lt; 2]; int n, m, a[N]; void build(int u, int l, int r) { if (l == r) tree[u] = {l, r, a[l]}; else { const int mid = l + r \u0026gt;\u0026gt; 1; build(u\u0026lt;\u0026lt;1, l, mid), build(u\u0026lt;\u0026lt;1|1, mid+1, r); tree[u] = {l, r, tree[u\u0026lt;\u0026lt;1].sum + tree[u\u0026lt;\u0026lt;1|1].sum}; } } void update(int u, int i, int v) { if (tree[u].l == i \u0026amp;\u0026amp; tree[u].r == i) tree[u].sum += v; else { const int mid = tree[u].l + tree[u].r \u0026gt;\u0026gt; 1; if (i \u0026lt;= mid) update(u\u0026lt;\u0026lt;1, i, v); else update(u\u0026lt;\u0026lt;1|1, i, v); tree[u].sum = tree[u\u0026lt;\u0026lt;1].sum + tree[u\u0026lt;\u0026lt;1|1].sum; } } int query(int u, int l, int r) { if (tree[u].l == l \u0026amp;\u0026amp; tree[u].r == r) return tree[u].sum; const int mid = tree[u].l + tree[u].r \u0026gt;\u0026gt; 1; if (r \u0026lt;= mid) return query(u\u0026lt;\u0026lt;1, l, r); else if (l \u0026gt; mid) return query(u\u0026lt;\u0026lt;1|1, l, r); else return query(u\u0026lt;\u0026lt;1, l, mid) + query(u\u0026lt;\u0026lt;1|1, mid+1, r); } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); build(1, 1, n); int k, a, b; while (m--) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;k, \u0026amp;a, \u0026amp;b); if(!k) printf(\u0026#34;%d\\n\u0026#34;, query(1, a, b)); else update(1, a, b); } return 0; } 树状数组-代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int N = 1e5 + 5; int C[N], n, m; void add(int x, int k) { for (int i = x; i \u0026lt;= n; i += i \u0026amp; -i) C[i] += k; } int get_sum(int x) { int s = 0; for (int i = x; i \u0026gt;= 1; i -= i \u0026amp; -i) s += C[i]; return s; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); int t; for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); add(i, t); } int k, a, b; while (m--) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;k, \u0026amp;a, \u0026amp;b); if (!k) printf(\u0026#34;%d\\n\u0026#34;, get_sum(b) - get_sum(a-1)); else add(a, b); } return 0; } 奇怪的数-组合计数 题目链接\n思路  划分为两类  0、1：$k$位, $ 2 \\le k \\le n - 2 $ 2、3：$n-k$位   放0、1：第一位不能放, 剩下$n-1$位可以放$k$个0、1-\u0026gt; $ C_{n-1}^{k} $ 0的个数：$1 \\le cnt_0 \\le k-1$, 共$k-1$种可能，2的个数：$1 \\le cnt_2 \\le n-k-1$，共$n-k-1$种可能 $ ans = \\sum_{k=2}^{n-2}{C_{n-1}^{k}(k-1)(n-k-1)} $  代码 #include \u0026lt;iostream\u0026gt;using namespace std; const int N = 1005; int n, C[N][N]; const int mod = 1e9 + 7; int main() { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt;= n; i++) for (int j = 0; j \u0026lt;= i; j++) if (!j) C[i][j] = 1; else C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod; int ans = 0; for (int k = 2; k \u0026lt;= n - 2; k++) { ans = (ans + C[n-1][k] * 1ll * (k - 1) % mod * (n - k - 1)) % mod; } cout \u0026lt;\u0026lt; ans; return 0; } 最优配餐-多源BFS 题目链接\n思路 将起点都入队列进行BFS\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;queue\u0026gt;using namespace std; const int N = 1005; int n, m, k, d, dist[N][N], w[N][N]; queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; Q; void bfs() { const int dx[]{-1, 0, 1, 0}, dy[]{0, 1, 0, -1}; while (!Q.empty()) { auto [x, y] = Q.front(); Q.pop(); for (int i = 0; i \u0026lt; 4; i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx \u0026lt;= 0 || nx \u0026gt; n || ny \u0026lt;= 0 || ny \u0026gt; n || dist[nx][ny] != -1) continue; dist[nx][ny] = dist[x][y] + 1; Q.push({nx, ny}); } } } int main() { scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;k, \u0026amp;d); memset(dist, -1, sizeof dist); int x, y; while (m--) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); Q.push({x, y}); dist[x][y] = 0; } int c; for (int i = 0; i \u0026lt; k; i++) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;c); w[x][y] += c; } for (int i = 0; i \u0026lt; d; i++) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); dist[x][y] = -2; } bfs(); long ans = 0; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= n; j++) { if (w[i][j]) ans += w[i][j] * dist[i][j] * 1ll; } printf(\u0026#34;%ld\\n\u0026#34;, ans); return 0; } LeetCode-995 K 连续位的最小翻转次数 题目链接\n思路 差分数组d[i]表示i位置需要翻转的次数 - i-1位置需要翻转的次数 cnt表示当前位置需要翻转的次数 若A[i]+cnt是偶数则需要翻转：cnt++, d[i+k]++ 若i+K \u0026gt; n则不可能\n代码 class Solution { public: int minKBitFlips(vector\u0026lt;int\u0026gt;\u0026amp; A, int K) { const int n = A.size(); vector\u0026lt;int\u0026gt; d(n + 1, 0); int cnt = 0, ans = 0; for (int i = 0; i \u0026lt; n; i++) { cnt += d[i]; if (!((A[i] + cnt) \u0026amp; 1)) { if (i + K \u0026gt; n) return -1; ++cnt; ++ans; d[i+K]--; } } return ans; } }; 最小生成树 题目链接\nPrim #include \u0026lt;algorithm\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;queue\u0026gt;using namespace std; using P = pair\u0026lt;int, int\u0026gt;; const int N = 2e5 + 5; vector\u0026lt;P\u0026gt; g[N]; bool vis[N]; int n, m; priority_queue\u0026lt;P\u0026gt; Q; int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); int a, b, c; while (m--) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); g[a].push_back({b, c}); g[b].push_back({a, c}); } Q.push({0, 1}); long ans = 0; for (int i = 0; i \u0026lt; n; i++) { while (true) { auto [w, v] = Q.top(); Q.pop(); if (vis[v]) continue; vis[v] = true; ans += -w; for (auto [_v, _w] : g[v]) { if (vis[_v]) continue; Q.push({-_w, _v}); } break; } } printf(\u0026#34;%ld\\n\u0026#34;, ans); return 0; } Kruskal #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;queue\u0026gt;using namespace std; class UF { vector\u0026lt;int\u0026gt; id, sz; public: UF(int N) { id.resize(N); sz.resize(N); for (int i = 0; i \u0026lt; N; i++) { id[i] = i; sz[i] = 1; } } int find(int p) { while (p != id[p]) { id[p] = id[id[p]]; p = id[p]; } return p; } bool _union(int p, int q) { int i = find(p), j = find(q); if (i == j) return false; if (sz[i] \u0026lt; sz[j]) { id[i] = j; sz[j] += sz[i]; } else { id[j] = i; sz[i] += sz[j]; } return true; } }; struct node { int w, u, v; friend bool operator\u0026lt;(const node \u0026amp;a, const node\u0026amp; b) { if (a.w == b.w) { return make_pair(a.u, a.v) \u0026gt; make_pair(b.u, b.v); } return a.w \u0026gt; b.w; } }; int n, m; priority_queue\u0026lt;node\u0026gt; Q; int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); UF uf(n); int a, b, c; while (m--) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); Q.push({c, a, b}); } int cnt = 0; long ans = 0; while (!Q.empty() \u0026amp;\u0026amp; cnt \u0026lt; n - 1) { auto [w, u, v] = Q.top(); Q.pop(); if (uf._union(u-1, v-1)) { ans += w; ++cnt; } } printf(\u0026#34;%ld\\n\u0026#34;, ans); return 0; } 单源最短路 题目链接\n代码 #include \u0026lt;algorithm\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;cstring\u0026gt;using namespace std; using P = pair\u0026lt;int, int\u0026gt;; const int N = 2505, M = 12500; int h[N], e[M], ne[M], w[M], idx; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; } int n, m, dist[N]; bool st[N]; priority_queue\u0026lt;P\u0026gt; Q; void dijkstra(int s, int t) { memset(dist, 0x3f, sizeof dist); Q.push({0, s}); dist[s] = 0; while (!Q.empty()) { auto [d, u] = Q.top(); Q.pop(); if (st[u]) continue; st[u] = true; for (int i = h[u]; ~i; i = ne[i]) { int v = e[i]; if (dist[v] \u0026gt; -d + w[i]) { dist[v] = -d + w[i]; Q.push({-dist[v], v}); } } } } int main() { memset(h, -1, sizeof h); int s, t; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;s, \u0026amp;t); int a, b, c; while (m--) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); add(a, b, c); add(b, a, c); } dijkstra(s, t); printf(\u0026#34;%d\\n\u0026#34;, dist[t]); return 0; } 网络延时-树形DP 题目链接\n思路 树形DP模板\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt;using namespace std; const int N = 20005; int h[N], e[N], ne[N], idx; int n, m, f[N]; // f[u]: 表示u到最远叶节点的距离。显然如果u是节点，则f[u]=0 void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; } int ans = 0; void dfs(int u) { // 求以u为根节点到叶节点的最大距离  int a = 0, b = 0; // a记录u到最远叶节点的距离，b记录u到次远叶节点的距离  for (int i = h[u]; ~i; i = ne[i]) { int v = e[i]; dfs(v); //求子节点j到最远叶节点的距离  int t = f[v] + 1; //u通过j能到的最远叶节点的距离  //更新a, b  if (t \u0026gt;= a) b = a, a = t; else if (t \u0026gt; b) b = t; } f[u] = a; // 最后的答案就是u所能到的最远叶节点距离和次远叶节点距离之和  ans = max(ans, a + b); } int main() { memset(h, -1, sizeof h); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); int j; for (int i = 2; i \u0026lt;= n + m; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;j); add(j, i); // 因为是自根向下DP，所以建一条边即可  } dfs(1); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } 序列化二叉树 题目链接\n代码 class Solution: def serialize(self, root): ans = \u0026#34;\u0026#34; def dfs_s(root): nonlocal ans if not root: ans += \u0026#39;None \u0026#39; return else: ans += str(root.val) + \u0026#39; \u0026#39; dfs_s(root.left) dfs_s(root.right) dfs_s(root) return ans def deserialize(self, data): A = data.split() k = 0 def dfs_d(): nonlocal A, k if k == len(A): return None if A[k] == \u0026#39;None\u0026#39;: k += 1 return None root = TreeNode(int(A[k])) k += 1 root.left = dfs_d() root.right = dfs_d() return root return dfs_d() 最大亦或和-线性基 题目链接\n思路  构造线性基的方法如下：对于集合中的每个数x转为二进制，从高位向低位扫，对于第i位是1的，如果p[i]不存在，那么p[i] = x结束扫描，如果存在，令x = x ^ p[i] 查询集合内任意几个元素xor最大值：从高位向低位扫，若xor上当前扫到的p[i]答案变大，就把答案xor上p[i] 查询原集合内任意几个元素xor的最小值，就是线性基集合所有元素中最小的那个  代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; using ull = unsigned long long; ull p[65]; int n; int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); auto insert = [](ull x) { for (int i = 63; ~i; i--) { if (!(x \u0026gt;\u0026gt; i \u0026amp; 1)) continue; if (!p[i]) { p[i] = x; break; } x ^= p[i]; } }; ull x; while (n--) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;x); insert(x); } ull ans = 0; for (int i = 63; ~i; i--) ans = max(ans, ans ^ p[i]); printf(\u0026#34;%lld\u0026#34;, ans); return 0; } 通信网络-枚举+dfs 题目链接\n代码 #include \u0026lt;algorithm\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt;using namespace std; const int N = 1005, M = 10005; int h[N], e[M], ne[M], idx; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; } int n, m; bool st[N][N]; void dfs(int s, int u) { st[s][u] = true; for (int i = h[u]; ~i; i = ne[i]) { int v = e[i]; if (st[s][v]) continue; dfs(s, v); } } int main() { memset(h, -1, sizeof h); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); int a, b; while (m--) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); add(a, b); } for (int i = 1; i \u0026lt;= n; i++) dfs(i, i); int ans = 0; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) if (st[i][j]) st[j][i] = true; } for (int i = 1; i \u0026lt;= n; i++) { int j = 1; for (; j \u0026lt;= n; j++) if(!st[i][j]) break; if (j \u0026gt; n) ++ans; } cout \u0026lt;\u0026lt; ans; return 0; } 压缩编码-区间DP 思路  状态表示f[i][j]  集合：所有将[i, j]合并成一堆的方案的集合 属性：最小值   状态计算：f[i][j] = min(f[i][j], f[i][k] + f[k+1][j] + s[j] - s[i-1])  代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;climits\u0026gt;using namespace std; const int N = 1005; int n, f[N][N], s[N]; int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;s[i]); s[i] += s[i-1]; } for (int len = 2; len \u0026lt;= n; len++) for (int i = 1; i + len - 1 \u0026lt;= n; i++) { int j = i + len - 1; f[i][j] = INT_MAX; for (int k = i; k \u0026lt; j; k++) f[i][j] = min(f[i][j], f[i][k] + f[k+1][j] + s[j] - s[i-1]); } cout \u0026lt;\u0026lt; f[1][n]; } 杂题记录 后序遍历 题目链接\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;unordered_map\u0026gt;#include \u0026lt;functional\u0026gt; using namespace std; const int N = 30; struct node { char c; node *l, *r; node(char _c) : c(_c), l(nullptr), r(nullptr) {} }; void print(node *root) { if (!root) return; print(root-\u0026gt;l); print(root-\u0026gt;r); printf(\u0026#34;%c\u0026#34;, root-\u0026gt;c); } unordered_map\u0026lt;char, int\u0026gt; M; string A, B; node* dfs(int pl, int pr, int il, int ir) { if (pl \u0026gt; pr) return nullptr; auto it = M[A[pl]]; node *root = new node(A[pl]); root-\u0026gt;l = dfs(pl + 1, pl + 1 + it - il - 1, il, it - 1); root-\u0026gt;r = dfs(pl + 1 + it - il, pr, it + 1, ir); return root; }; int main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); cin \u0026gt;\u0026gt; A \u0026gt;\u0026gt; B; const int n = A.size(); for (int i = 0; i \u0026lt; n; i++) M[B[i]] = i; auto root = dfs(0, n - 1, 0, n - 1); print(root); return 0; } 树的遍历-中序后序求层次 题目链接\n代码 package main import \u0026#34;fmt\u0026#34; type TreeNode struct { val int left, right *TreeNode } var n int func main() { fmt.Scan(\u0026amp;n) after, in := make([]int, n), make([]int, n) for i := range after { fmt.Scan(\u0026amp;after[i]) } for i := range in { fmt.Scan(\u0026amp;in[i]) } mp := make(map[int]int) for i := range in { mp[in[i]] = i } var dfs func(il, ir, al, ar int) (*TreeNode) dfs = func(il, ir, al, ar int) (*TreeNode) { if al \u0026gt; ar { return nil } idx := mp[after[ar]] root := \u0026amp;TreeNode{ val: after[ar], left: dfs(il, idx-1, al, al+idx-il-1), right: dfs(idx+1, ir, al+idx-il, ar-1), } return root } root := dfs(0, n-1, 0, n-1) que := make([](*TreeNode), 0) que = append(que, root) for len(que) != 0 { front := que[0] fmt.Printf(\u0026#34;%d \u0026#34;, front.val) que = que[1:] if front.left != nil { que = append(que, front.left) } if front.right != nil { que = append(que, front.right) } } } 树中的最长路 题目链接\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;unordered_map\u0026gt;#include \u0026lt;functional\u0026gt;#include \u0026lt;cstring\u0026gt; using namespace std; const int N = 1e5 + 5; int h[N], e[N], ne[N], idx; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; } int n, f[N], ans; void dfs(int u) { int a = 0, b = 0; for (int i = h[u]; ~i; i = ne[i]) { int v = e[i]; dfs(v); int t = f[v] + 1; if (t \u0026gt;= a) b = a, a = t; else if (t \u0026gt; b) b = t; } f[u] = a; ans = max(ans, a + b); } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif  ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); memset(h, -1, sizeof h); cin \u0026gt;\u0026gt; n; int a, b; for (int i = 0; i \u0026lt; n - 1; i++) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; add(a, b); } dfs(1); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } RMQ问题再临 题目链接\n代码 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int N = 1e4 + 5; struct node { int l, r, minv; } tree[N \u0026lt;\u0026lt; 2]; int n, m, a[N]; void build(int u, int l, int r) { if (l == r) tree[u] = {l, r, a[l]}; else { const int mid = l + r \u0026gt;\u0026gt; 1; build(u\u0026lt;\u0026lt;1, l, mid), build(u\u0026lt;\u0026lt;1|1, mid+1, r); tree[u] = {l, r, min(tree[u\u0026lt;\u0026lt;1].minv, tree[u\u0026lt;\u0026lt;1|1].minv)}; } } void update(int u, int i, int v) { if (tree[u].l == i \u0026amp;\u0026amp; tree[u].r == i) tree[u].minv = v; else { const int mid = tree[u].l + tree[u].r \u0026gt;\u0026gt; 1; if (i \u0026lt;= mid) update(u\u0026lt;\u0026lt;1, i, v); else update(u\u0026lt;\u0026lt;1|1, i, v); tree[u].minv = min(tree[u\u0026lt;\u0026lt;1].minv, tree[u\u0026lt;\u0026lt;1|1].minv); } } int query(int u, int l, int r) { if (tree[u].l == l \u0026amp;\u0026amp; tree[u].r == r) return tree[u].minv; const int mid = tree[u].l + tree[u].r \u0026gt;\u0026gt; 1; if (r \u0026lt;= mid) return query(u\u0026lt;\u0026lt;1, l, r); else if (l \u0026gt; mid) return query(u\u0026lt;\u0026lt;1|1, l, r); else return min(query(u\u0026lt;\u0026lt;1, l, mid), query(u\u0026lt;\u0026lt;1|1, mid+1, r)); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; cin \u0026gt;\u0026gt; m; build(1, 1, n); int a, b, c; while (m--) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; if (!a) cout \u0026lt;\u0026lt; query(1, b, c) \u0026lt;\u0026lt; endl; else update(1, b, c); } return 0; } 无间道之并查集 题目链接\n代码 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; class UF { vector\u0026lt;int\u0026gt; id, sz; public: UF(int N) { id.resize(N), sz.resize(N); for (int i = 0; i \u0026lt; N; i++) id[i] = i, sz[i] = 1; } int find(int x) { while (x != id[x]) { id[x] = id[id[x]]; x = id[x]; } return x; } bool is_connected(int p, int q) { int i = find(p), j = find(q); return i == j; } bool _union(int p, int q) { int i = find(p), j = find(q); if (i == j) return false; if (sz[i] \u0026lt; sz[j]) { id[i] = j; sz[j] += sz[i]; } else { id[j] = i; sz[i] += sz[j]; } return true; } }; unordered_map\u0026lt;string, int\u0026gt; M; int idx; int get_hash(const string \u0026amp;str) { if (M.count(str)) return M[str]; else return M[str] = idx++; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; UF uf(n); int op; string a, b; while (n--) { cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; int i = get_hash(a), j = get_hash(b); if (!op) uf._union(i, j); else { puts(uf.is_connected(i, j) ? \u0026#34;yes\u0026#34; : \u0026#34;no\u0026#34;); } } return 0; } 二分图判定 题目链接\n思路 染色法\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;unordered_map\u0026gt;#include \u0026lt;functional\u0026gt;#include \u0026lt;cstring\u0026gt; using namespace std; const int N = 1e4 + 5, M = 1e5; int h[N], e[M], ne[M], idx; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; } int n, m, color[N]; bool dfs(int u, int c) { color[u] = c; for (int i = h[u]; ~i; i = ne[i]) { int v = e[i]; if (color[v]) { if (color[v] == c) return false; } else if (!dfs(v, 3 - c)) return false; } return true; } int main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin \u0026gt;\u0026gt; T; while (T--) { idx = 0; memset(h, -1, sizeof h); memset(color, 0, sizeof color); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int a, b; while (m--) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; add(a, b); add(b, a); } bool is_break = false; for (int i = 1; i \u0026lt;= n; i++) if (!color[i] \u0026amp;\u0026amp; !dfs(i, 1)) { is_break = true; break; } puts(is_break ? \u0026#34;Wrong\u0026#34; : \u0026#34;Correct\u0026#34;); } return 0; } 猜字谜 题目链接\n代码 class Solution { public: vector\u0026lt;int\u0026gt; findNumOfValidWords(vector\u0026lt;string\u0026gt;\u0026amp; words, vector\u0026lt;string\u0026gt;\u0026amp; puzzles) { unordered_map\u0026lt;int, int\u0026gt; mp; vector\u0026lt;int\u0026gt; ans(puzzles.size()); for (const auto \u0026amp;e : words) { int t = 0; for (const auto \u0026amp;c : e) t |= 1 \u0026lt;\u0026lt; (c - \u0026#39;a\u0026#39;); auto tmp = bitset\u0026lt;26\u0026gt;(t); if (tmp.count() \u0026gt; 7) continue; mp[t]++; } for (int i = 0; i \u0026lt; puzzles.size(); i++) { string p = puzzles[i]; int mask = 0; for (int i = 1; i \u0026lt; 7; i++) mask |= 1 \u0026lt;\u0026lt; (p[i] - \u0026#39;a\u0026#39;); int subset = mask; do { int t = subset | (1 \u0026lt;\u0026lt; (p[0] - \u0026#39;a\u0026#39;)); if (mp.count(t)) ans[i] += mp[t]; subset = (subset - 1) \u0026amp; mask; } while (subset != mask); } return ans; } }; 至少有K个重复字符的最长子串 题目链接\nCode in Golang func longestSubstring(s string, k int) (ans int) { if s == \u0026#34;\u0026#34; { return 0 } cnt := [26]int{} for _, v := range(s) { cnt[v-\u0026#39;a\u0026#39;]++ } var split byte for i, v := range(cnt) { if (v \u0026gt; 0 \u0026amp;\u0026amp; v \u0026lt; k) { split = \u0026#39;a\u0026#39; + byte(i) break } } if split == 0 { return len(s) } for _, v := range strings.Split(s, string(split)) { ans = max(ans, longestSubstring(v, k)) } return ans } func max(a, b int) int { if a \u0026gt; b { return a } return b } Code in Python class Solution: def longestSubstring(self, s: str, k: int) -\u0026gt; int: if len(s) \u0026lt; k: return 0 for v in set(s): if s.count(v) \u0026lt; k: return max(self.longestSubstring(t, k) for t in s.split(v)) return len(s) 找到 K 个最接近的元素 堆-$nlogk$做法 class Solution { public: vector\u0026lt;int\u0026gt; findClosestElements(vector\u0026lt;int\u0026gt;\u0026amp; arr, int k, int x) { priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; Q; for (const auto \u0026amp;e : arr) { Q.push({abs(e - x), e}); if (Q.size() \u0026gt; k) Q.pop(); } vector\u0026lt;int\u0026gt; ans(k); int idx = 0; while (!Q.empty()) { ans[idx++] = Q.top().second; Q.pop(); } sort(ans.begin(), ans.end()); return ans; } }; 二分+双指针-$logn+k$做法(Rust) impl Solution { pub fn find_closest_elements(arr: Vec\u0026lt;i32\u0026gt;, k: i32, x: i32) -\u0026gt; Vec\u0026lt;i32\u0026gt; { let n: i32 = arr.len() as i32; let mut l: i32 = 0; let mut r: i32 = n - 1; while l \u0026lt; r { let mid: usize = ((l + r) / 2) as usize; if arr[mid] \u0026gt;= x { r = mid as i32; } else { l = (mid + 1) as i32; } } if r \u0026gt; 0 { let a = (i32::abs(arr[(r-1) as usize] - x), arr[(r-1) as usize]); let b = (i32::abs(arr[r as usize] - x), arr[r as usize]); if a \u0026lt; b { r -= 1; } } let mut i: i32 = r; let mut j: i32 = r; for u in 0..k-1 { if ((i - 1) \u0026lt; 0) { j += 1; } else if j + 1 \u0026gt;= n { i -= 1; } else { let a = (i32::abs(arr[(i-1) as usize] - x), arr[(i-1) as usize]); let b = (i32::abs(arr[(j+1) as usize] - x), arr[(j+1) as usize]); if a \u0026lt; b { i -= 1; } else { j += 1; } } } let mut ans = Vec::new(); for u in i..j+1 { ans.push(arr[u as usize]); } return ans; } } 二维区域和检索 - 矩阵不可变 题目链接\n思路 二位前缀和  构造: S[i][j] = a[i][j] + S[i-1][j] + S[i][j-1] - S[i-1][j-1] 计算: ans = S[x2][y2] - S[x1-1][y2] - S[x2][y1-1] + S[x1-1][y1-1]  代码 class NumMatrix { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; C; public: NumMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { if (matrix.empty()) return; const int n = matrix.size(), m = matrix[0].size(); C = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(n+1, vector\u0026lt;int\u0026gt;(m+1, 0)); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { C[i][j] = matrix[i-1][j-1] + C[i-1][j] + C[i][j-1] - C[i-1][j-1]; } } } int sumRegion(int row1, int col1, int row2, int col2) { int sum = C[row2+1][col2+1] - C[row1-1+1][col2+1] - C[row2+1][col1-1+1] + C[row1-1+1][col1-1+1]; return sum; } }; 比特位计数-动态规划 题目链接\n思路  y=x \u0026amp; (x - 1): y为将x的最低设置位从1变成0之后的数 状态定义：f[i]: i的比特位中1的个数 状态计算: f[i] = f[i \u0026amp; (i-1)]  代码 class Solution { public: vector\u0026lt;int\u0026gt; countBits(int num) { vector\u0026lt;int\u0026gt; f(num+1); for (int i = 1; i \u0026lt;= num; i++) f[i] = f[i\u0026amp;(i-1)] + 1; return f; } }; class Solution: def countBits(self, num: int) -\u0026gt; List[int]: f = [0] * (num + 1) for i in range(1, num + 1): f[i] = f[i \u0026amp; (i - 1)] + 1 return f class Solution { public int[] countBits(int num) { int[] f = new int[num+1]; for (int i = 1; i \u0026lt;= num; i++) f[i] = f[i \u0026amp; (i - 1)] + 1; return f; } } func countBits(num int) []int { f := make([]int, num+1) for i := 1; i \u0026lt;= num; i++ { f[i] = f[i \u0026amp; (i - 1)] + 1 } return f } 俄罗斯套娃信封问题-LIS 题目链接\n解题思路 LIS变形\n代码 $O(n^2)$ class Solution { public: int maxEnvelopes(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; E) { if (E.empty()) return 0; sort(begin(E), end(E), [](vector\u0026lt;int\u0026gt; a, vector\u0026lt;int\u0026gt; b) { return (a[0] \u0026lt; b[0] || (a[0] == b[0] \u0026amp;\u0026amp; a[1] \u0026gt; b[1])); }); const int n = E.size(); vector\u0026lt;int\u0026gt; f(n); for (int i = 0; i \u0026lt; n; i++) { f[i] = 1; for (int j = 0; j \u0026lt; i; j++) { if (E[i][1] \u0026gt; E[j][1]) f[i] = max(f[i], f[j] + 1); } } return *max_element(begin(f), end(f)); } }; $O(nlogn)$ class Solution { public: int maxEnvelopes(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; E) { if (E.empty()) return 0; sort(begin(E), end(E), [](vector\u0026lt;int\u0026gt; a, vector\u0026lt;int\u0026gt; b) { return (a[0] \u0026lt; b[0] || (a[0] == b[0] \u0026amp;\u0026amp; a[1] \u0026gt; b[1])); }); const int n = E.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f; for (int i = 0; i \u0026lt; n; i++) { auto it = lower_bound(begin(f), end(f), E[i], [](vector\u0026lt;int\u0026gt; a, vector\u0026lt;int\u0026gt; b) {return a[1] \u0026lt; b[1];}); if (it == f.end()) f.push_back(E[i]); else *it = E[i]; } for (int i = 0; i \u0026lt; f.size(); i++) cout \u0026lt;\u0026lt; f[i][0] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; f[i][1] \u0026lt;\u0026lt; endl; return f.size(); } }; 用栈实现队列-双栈 题目链接\n思路  双栈实现队列  当peek()和pop()时，如果输出栈为空，则将输入栈内容依次弹出，并压入输出栈 代码    代码 class MyQueue { stack\u0026lt;int\u0026gt; _in, out; void work() { while (!_in.empty()) { out.push(_in.top()); _in.pop(); } } public: /** _initialize your data structure here. */ MyQueue() { } /** Push element x to the back of queue. */ void push(int x) { _in.push(x); } /** Removes the element from _in front of queue and returns that element. */ int pop() { if (out.empty()) work(); auto res = out.top(); out.pop(); return res; } /** Get the front element. */ int peek() { if (out.empty()) work(); auto res = out.top(); return res; } /** Returns whether the queue is empty. */ bool empty() { return _in.empty() \u0026amp;\u0026amp; out.empty(); } }; /** * Your MyQueue object will be _instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj-\u0026gt;push(x); * _int param_2 = obj-\u0026gt;pop(); * _int param_3 = obj-\u0026gt;peek(); * bool param_4 = obj-\u0026gt;empty(); */ 下一个更大元素-单调栈 题目链接\n思路  单调栈内对应元素单调不增 当遇到一个比当前栈顶元素大的元素，则出栈，并且出栈元素下一个更大元素为当前元素 因为环，所以将下标映射至1..2n-1  代码 C++ class Solution { public: vector\u0026lt;int\u0026gt; nextGreaterElements(vector\u0026lt;int\u0026gt;\u0026amp; nums) { const int n = nums.size(); vector\u0026lt;int\u0026gt; ans(n, -1); stack\u0026lt;int\u0026gt; the_stack; for (int i = 0; i \u0026lt; 2 * n; i++) { while (!the_stack.empty() \u0026amp;\u0026amp; nums[i % n] \u0026gt; nums[the_stack.top()]) { ans[the_stack.top()] = nums[i % n]; the_stack.pop(); } the_stack.push(i % n); } return ans; } }; Java class Solution { public int[] nextGreaterElements(int[] nums) { final var n = nums.length; var ans = new int[n]; Arrays.fill(ans, -1); Stack\u0026lt;Integer\u0026gt; S = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 2 * n; i++) { while (!S.isEmpty() \u0026amp;\u0026amp; nums[S.peek()] \u0026lt; nums[i % n]) ans[S.pop()] = nums[i % n]; S.push(i % n); } return ans; } } Python3 class Solution: def nextGreaterElements(self, nums: List[int]) -\u0026gt; List[int]: n = len(nums) ans = [-1] * n the_stack = [] for i in range(2 * n): while the_stack and (nums[i % n] \u0026gt; nums[the_stack[-1]]): ans[the_stack.pop()] = nums[i % n] the_stack.append(i % n) return ans Golang func nextGreaterElements(nums []int) []int { n := len(nums) ans := make([]int, n) for i := range(ans) { ans[i] = -1 } stack := []int{} for i := 0; i \u0026lt; 2 * n; i++ { for len(stack) \u0026gt; 0 \u0026amp;\u0026amp; nums[i % n] \u0026gt; nums[stack[len(stack)-1]] { ans[stack[len(stack)-1]] = nums[i % n] stack = stack[:len(stack)-1] } stack = append(stack, i % n) } return ans } 分割回文串 题目链接\n思路 dfs + DP预处理 f[i][j] = f[i+1][j-1] \u0026amp;\u0026amp; (s[i] == s[j])\n代码 class Solution { public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; partition(string s) { const int n = s.length(); vector\u0026lt;string\u0026gt; tmp; vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; ans; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; f(n, vector\u0026lt;bool\u0026gt;(n, true)); for (int i = n - 1; i \u0026gt;= 0; i--) { for (int j = i + 1; j \u0026lt; n; j++) f[i][j] = f[i+1][j-1] \u0026amp;\u0026amp; (s[i] == s[j]); } function\u0026lt;void(int)\u0026gt; dfs = [\u0026amp;](int i) { if (i \u0026gt;= n) { ans.push_back(tmp); return; } for (int j = i; j \u0026lt; n; j++) { if (f[i][j]) { tmp.push_back(s.substr(i, j - i + 1)); dfs(j+1); tmp.pop_back(); } } }; dfs(0); return ans; } }; 从第一个节点出发到最后一个节点的受限路径数-记忆化搜索 题目链接\n思路 单源最短路+记忆化搜索\n代码 const int N = 2e4 + 5, M = 8e4 + 10; int h[N], e[M], ne[M], w[M], idx; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; } class Solution { public: int countRestrictedPaths(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges) { idx = 0; memset(h, -1, sizeof h); for (const auto \u0026amp;e : edges) { add(e[0], e[1], e[2]); add(e[1], e[0], e[2]); } vector\u0026lt;int\u0026gt; dist(n + 1, INT_MAX); vector\u0026lt;bool\u0026gt; st(n + 1, false); priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; Q; Q.push({0, n}); dist[n] = 0; while (!Q.empty()) { auto [wgt, u] = Q.top(); Q.pop(); if (st[u]) continue; st[u] = true; dist[u] = -wgt; for (int i = h[u]; ~i; i = ne[i]) { int v = e[i]; if (-wgt + w[i] \u0026lt; dist[v]) { dist[v] = -wgt + w[i]; Q.push({-dist[v], v}); } } } const int mod = 1e9 + 7; vector\u0026lt;int\u0026gt; f(n + 1, INT_MAX); function\u0026lt;int(int)\u0026gt; dfs = [\u0026amp;](int u) { if (u == n) return 1; if (f[u] != INT_MAX) return f[u]; int ans = 0; for (int i = h[u]; ~i; i = ne[i]) { int v = e[i]; if (dist[u] \u0026gt; dist[v]) ans = (ans + dfs(v)) % mod; } return f[u] = ans; }; return dfs(1); } }; 公共钥匙盒-模拟 题目链接\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;tuple\u0026gt;using namespace std; const int N = 1005; pair\u0026lt;int, int\u0026gt; T[N]; int n, k, a[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); priority_queue\u0026lt;tuple\u0026lt;int, bool, int\u0026gt;\u0026gt; Q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; int w, s, c; for (int i = 1; i \u0026lt;= n; i++) a[i] = i; while (k--) { cin \u0026gt;\u0026gt; w \u0026gt;\u0026gt; s \u0026gt;\u0026gt; c; T[w] = {s, c}; Q.push({ -s, false, -w}); Q.push({ -(s + c), true, -w}); } while (Q.size()) { auto it = Q.top(); auto t = get\u0026lt;0\u0026gt;(it); auto b = get\u0026lt;1\u0026gt;(it); auto w = get\u0026lt;2\u0026gt;(it); Q.pop(); if (!b) { for (int i = 1; i \u0026lt;= n; i++) if (a[i] == -w) { a[i] = 0; break; } } else { for (int i = 1; i \u0026lt;= n; i++) if (!a[i]) { a[i] = -w; break; } } } for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; return 0; } 基本计算器-栈 题目链接\n代码 class Solution { public: int calculate(string s) { stack\u0026lt;int\u0026gt; sign; sign.push(1); int cur = 1; int ans = 0; const int n = s.length(); for (int i = 0; i \u0026lt; n; i++) { if (s[i] == \u0026#39; \u0026#39;) continue; else if (s[i] == \u0026#39;+\u0026#39;) cur = sign.top(); else if (s[i] == \u0026#39;-\u0026#39;) cur = -sign.top(); else if (s[i] == \u0026#39;(\u0026#39;) sign.push(cur); else if (s[i] == \u0026#39;)\u0026#39;) sign.pop(); else { int sum = 0; while (i \u0026lt; n \u0026amp;\u0026amp; s[i] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; s[i] \u0026lt;= \u0026#39;9\u0026#39;) { sum = sum * 10 + (s[i] - \u0026#39;0\u0026#39;); ++i; } --i; ans += sum * cur; } } return ans; } }; 基本计算器II-栈 题目链接\n思路  如果数字前是+, 将数字压栈 如果数字前是-, 将数字相反数压栈 如果数字前是*, 将栈顶元素乘以数字 如果数字前是/, 将栈顶元素除以数字  代码 func calculate(s string) int { stack := []int{} num := 0 pre := \u0026#39;+\u0026#39; for i, v := range(s) { if v \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; v \u0026lt;= \u0026#39;9\u0026#39; { num = num * 10 + int(v - \u0026#39;0\u0026#39;) } if (!(v \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; v \u0026lt;= \u0026#39;9\u0026#39;) \u0026amp;\u0026amp; v != \u0026#39; \u0026#39;) || i == len(s)-1 { switch pre { case \u0026#39;+\u0026#39;: stack = append(stack, num) case \u0026#39;-\u0026#39;: stack = append(stack, -num) case \u0026#39;*\u0026#39;: stack[len(stack)-1] *= num case \u0026#39;/\u0026#39;: stack[len(stack)-1] /= num } pre = v num = 0 } } ans := 0 for _, v := range(stack) { ans += v } return ans } 验证二叉树的前序序列化 题目链接\n解题思路 遍历过程中：\n 根结点提供两个出度 除了根结点以外的非空结点提供一个入度数、两个出度 空结点提供一个入度  还没遍历结束时候满足：入度 \u0026lt; 出度\n代码 func isValidSerialization(preorder string) bool { if preorder == \u0026#34;#\u0026#34; { return true } res := strings.Split(preorder, \u0026#34;,\u0026#34;) in, out := 0, 0 for i := range(res) { if i == 0 { if res[i] == \u0026#34;#\u0026#34; { return false } out += 2 continue } if res[i] == \u0026#34;#\u0026#34; { in++ } else { in++ out += 2 } if i != len(res)-1 \u0026amp;\u0026amp; out \u0026lt;= in { return false } } return in == out } 设计哈希集合 题目链接\n思路 拉链法\n代码 C++ constexpr int N = 10007; class MyHashSet { int h[N], e[N], ne[N], idx; public: /** Initialize your data structure here. */ MyHashSet() { idx = 0; memset(h, -1, sizeof h); } void add(int key) { if (!contains(key)) { int k = key % N; e[idx] = key; ne[idx] = h[k]; h[k] = idx++; } } void remove(int key) { int k = key % N; if (h[k] == -1) return; if (e[h[k]] == key) // 第一个结点就是  h[k] = ne[h[k]]; for (int i = h[k]; ~i \u0026amp;\u0026amp; ~ne[i]; i = ne[i]) { if (e[ne[i]] == key) { ne[i] = ne[ne[i]]; } } } /** Returns true if this set contains the specified element */ bool contains(int key) { int k = key % N; for (int i = h[k]; ~i; i = ne[i]) { if (e[i] == key) return true; } return false; } }; Golang const N = 10007 type MyHashSet struct { h []int e []int ne []int idx int } /** Initialize your data structure here. */ func Constructor() MyHashSet { t := make([]int, N) for i := range(t) { t[i] = -1 } return MyHashSet{t, make([]int, N), make([]int, N), 0} } func (this *MyHashSet) Add(key int) { if !this.Contains(key) { k := (key % N + N) % N this.e[this.idx] = key this.ne[this.idx] = this.h[k] this.h[k] = this.idx this.idx++ } } func (this *MyHashSet) Remove(key int) { k := (key % N + N) % N if this.h[k] == -1 { return } if this.e[this.h[k]] == key { this.h[k] = this.ne[this.h[k]] } for i := this.h[k]; i != -1 \u0026amp;\u0026amp; this.ne[i] != -1; i = this.ne[i] { if this.e[this.ne[i]] == key { this.ne[i] = this.ne[this.ne[i]] } } } /** Returns true if this set contains the specified element */ func (this *MyHashSet) Contains(key int) bool { k := (key % N + N) % N for i := this.h[k]; i != -1; i = this.ne[i] { if this.e[i] == key { return true } } return false } 设计哈希映射 题目链接\n思路 拉链法\n代码 const N = 10007 type Pair struct { k int v int } type MyHashMap struct { h []int e []Pair ne []int idx int } /** Initialize your data structure here. */ func Constructor() MyHashMap { h := make([]int, N) for i := range(h) { h[i] = -1 } return MyHashMap{h, make([]Pair, N), make([]int, N), 0} } /** value will always be non-negative. */ func (this *MyHashMap) Put(key int, value int) { if this.Get(key) == -1 { k := (key % N + N) % N this.e[this.idx] = Pair{key, value} this.ne[this.idx] = this.h[k] this.h[k] = this.idx this.idx++ } else { k := (key % N + N) % N for i := this.h[k]; i != -1; i = this.ne[i] { if this.e[i].k == key { this.e[i].v = value } } } } /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */ func (this *MyHashMap) Get(key int) int { k := (key % N + N) % N for i := this.h[k]; i != -1; i = this.ne[i] { if this.e[i].k == key { return this.e[i].v } } return -1 } /** Removes the mapping of the specified value key if this map contains a mapping for the key */ func (this *MyHashMap) Remove(key int) { k := (key % N + N) % N if this.h[k] == -1 { return } if this.e[this.h[k]].k == key { this.h[k] = this.ne[this.h[k]] } for i := this.h[k]; i != -1 \u0026amp;\u0026amp; this.ne[i] != -1; i = this.ne[i] { if this.e[this.ne[i]].k == key { this.ne[i] = this.ne[this.ne[i]] } } } 不同的子序列-DP 思路 $$ f[i][j] = \\begin{cases} f[i+1][j+1] + f[i+1][j], \u0026amp;s[i] = t[j]\u0026amp; \\cr f[i+1][j], \u0026amp;s[i] \\ne t[j] \\end{cases} $$\n代码 func numDistinct(s string, t string) int { n, m := len(s), len(t) if n \u0026lt; m { return 0 } f := make([][]int, n+1) for i := range f { f[i] = make([]int, m+1) f[i][m] = 1 } for i := n-1; i \u0026gt;= 0; i-- { for j := m-1; j \u0026gt;= 0; j-- { if s[i] == t[j] { f[i][j] = f[i+1][j+1] + f[i+1][j] } else { f[i][j] = f[i+1][j] } } } return f[0][0] } 反转链表II 题目链接\n思路  创建头结点 a := m-1 将[m+1,n]指针反转 a-\u0026gt;next-\u0026gt;next = n+1 a-\u0026gt;next = n  代码 func reverseBetween(head *ListNode, left int, right int) *ListNode { dummy := \u0026amp;ListNode{0, head} a := dummy for i := 0; i \u0026lt; left-1; i++ { a = a.Next } pre, cur := a.Next, a.Next.Next for i := 0; i \u0026lt; right-left; i++ { tmp := cur.Next cur.Next = pre pre = cur cur = tmp } a.Next.Next = cur a.Next = pre return dummy.Next } 反转链表 题目链接\n迭代法 func reverseList(head *ListNode) *ListNode { var pre *ListNode cur := head for cur != nil { tmp := cur.Next cur.Next = pre pre = cur cur = tmp } return pre } 递归法 思路  首先我们先考虑 reverseList 函数能做什么，它可以翻转一个链表，并返回新链表的头节点，也就是原链表的尾节点。 所以我们可以先递归处理 reverseList(head-\u0026gt;next)，这样我们可以将以head-\u0026gt;next为头节点的链表翻转，并得到原链表的尾节点tail，此时head-\u0026gt;next是新链表的尾节点，我们令它的next指针指向head，并将head-\u0026gt;next指向空即可将整个链表翻转，且新链表的头节点是tail  代码 func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } tail := reverseList(head.Next) head.Next.Next = head head.Next = nil return tail } 表达式求值-栈 题目链接\n思路  使用两个栈，一个存操作数，另一个存运算符 遇到左括号入栈，遇到右括号进行计算直到栈顶为左括号  代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;unordered_map\u0026gt;#include \u0026lt;stack\u0026gt;using namespace std; int main() { string str; cin \u0026gt;\u0026gt; str; const int n = str.length(); stack\u0026lt;int\u0026gt; stk; stack\u0026lt;char\u0026gt; op; auto calculate = [\u0026amp;]() { int a = stk.top(); stk.pop(); int b = stk.top(); stk.pop(); char c = op.top(); op.pop(); switch (c) { case \u0026#39;+\u0026#39;: stk.push(b + a); break; case \u0026#39;-\u0026#39;: stk.push(b - a); break; case \u0026#39;*\u0026#39;: stk.push(b * a); break; case \u0026#39;/\u0026#39;: stk.push(b / a); break; } }; unordered_map\u0026lt;char, int\u0026gt; mp = {{\u0026#39;+\u0026#39;, 1}, {\u0026#39;-\u0026#39;, 1}, {\u0026#39;*\u0026#39;, 2}, {\u0026#39;/\u0026#39;, 2}}; for (int i = 0; i \u0026lt; n; i++) { auto c = str[i]; if (isdigit(c)) { int j = i; int num = 0; while (j \u0026lt; n \u0026amp;\u0026amp; isdigit(str[j])) { num = num * 10 + str[j] - \u0026#39;0\u0026#39;; j++; } stk.push(num); i = j - 1; } else if (c == \u0026#39;(\u0026#39;) { op.push(c); } else if (c == \u0026#39;)\u0026#39;) { while (op.size() \u0026amp;\u0026amp; op.top() != \u0026#39;(\u0026#39;) { calculate(); } op.pop(); } else { while (op.size() \u0026amp;\u0026amp; mp[op.top()] \u0026gt;= mp[c]) { calculate(); } op.push(c); } } while (op.size()) { calculate(); } cout \u0026lt;\u0026lt; stk.top() \u0026lt;\u0026lt; endl; return 0; } 矩阵置零 题目链接\n思路  用两个变量记录第一行和第一列是否有0。 遍历整个矩阵，用矩阵的第一行和第一列记录对应的行和列是否有0。 把含有0的行和列都置成0。  代码 func setZeroes(matrix [][]int) { n, m := len(matrix), len(matrix[0]) r0, c0 := 1, 1 // 第0行是否应该置为0  for i := 0; i \u0026lt; m; i++ { if matrix[0][i] == 0 { r0 = 0 } } // 第0列是否应该置为0  for i := 0; i \u0026lt; n; i++ { if matrix[i][0] == 0 { c0 = 0 } } for i := 1; i \u0026lt; n; i++ { for j := 1; j \u0026lt; m; j++ { if matrix[i][j] == 0 { matrix[i][0] = 0 matrix[0][j] = 0 } } } // matrix[0][i]表示第i列是否该置为0  // matrix[i][0]表示第i行是否该置为0  // 把含有0的行和列都置成0 用第0行和第0列标记  for i := 1; i \u0026lt; m; i++ { if matrix[0][i] == 0 { for j := 1; j \u0026lt; n; j++ { matrix[j][i] = 0 } } } for i := 1; i \u0026lt; n; i++ { if matrix[i][0] == 0 { for j := 1; j \u0026lt; m; j++ { matrix[i][j] = 0 } } } if r0 == 0 { for i := 0; i \u0026lt; m; i++ { matrix[0][i] = 0 } } if c0 == 0 { for i := 0; i \u0026lt; n; i++ { matrix[i][0] = 0 } } } 不用加减乘除做加法 题目链接\n思路  两个整数做异或运算，得到不进位加法的运算结果 两个整数做与运算，然后左移一位，得到进位的运算结果 将上面得到的两个结果相加，即重复上述步骤直到进位的结果为0  代码 func add(num1 int, num2 int) int { for num2 != 0 { sum, carry := num1 ^ num2, (num1 \u0026amp; num2) \u0026lt;\u0026lt; 1 num1, num2 = sum, carry } return num1 } 132模式-单调栈 题目链接\n思路  从右到左维护一个单调递减的栈 维护一个次大值(初始值为INT_MIN) 如果当前的值小于次大值则找到132子序列  代码 func find132pattern(nums []int) bool { n := len(nums) stk := make([]int, 0) second := math.MinInt64 for i := n - 1; i \u0026gt;= 0; i-- { if nums[i] \u0026lt; second { return true } for len(stk) \u0026gt; 0 \u0026amp;\u0026amp; stk[len(stk)-1] \u0026lt; nums[i] { second = stk[len(stk)-1] stk = stk[:len(stk)-1] } stk = append(stk, nums[i]) } return false } 直方图中最大矩形-单调栈 题目链接\n思路 单调栈可以解决：左边比当前值大或小的第一个数\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; constexpr int N = 100005; int n, h[N], l[N], r[N], stk[N]; void work() { for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;h[i]); // 设置边界为-1 \th[0] = h[n+1] = -1; // 寻找左边界 \tstk[0] = 0; int tt = 0; for (int i = 1; i \u0026lt;= n; i++) { while (h[stk[tt]] \u0026gt;= h[i]) { tt--; } l[i] = stk[tt]; stk[++tt] = i; } // 寻找左边界 \tstk[0] = n+1; tt = 0; for (int i = n; i \u0026gt;= 1; i--) { while (h[stk[tt]] \u0026gt;= h[i]) { tt--; } r[i] = stk[tt]; stk[++tt] = i; } long long ans = 0; for (int i = 1; i \u0026lt;= n; i++) { ans = max(ans, h[i] * 1ll * (r[i]-l[i]-1)); } printf(\u0026#34;%lld\\n\u0026#34;, ans); } int main() { while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;n)) { if (!n) return 0; work(); } return 0; } 删除排序链表中的重复元素 题目链接\n思路  pre保存当前结点前驱结点 找到右边第一个不相等的结点right 如果cur.Next == right则不用删，否则pre.Next = right删除  代码 func deleteDuplicates(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } pre := \u0026amp;ListNode{0, head} ans, cur := pre, head for cur != nil { right := cur for right != nil \u0026amp;\u0026amp; right.Val == cur.Val { right = right.Next } if cur.Next == right { pre = cur } else { pre.Next = right } cur = right } return ans.Next } 可达性统计-拓扑排序 题目链接\n思路  从x出发能够到达的点，是从“x的各个后续节点y”出发能够到达的点的并集，再加上x点本身 可以求出拓扑序，按照拓扑序逆序进行计算  代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;bitset\u0026gt;using namespace std; const int N = 30005; int h[N], ne[N], e[N], idx, d[N]; int n, m; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; } int seq[N], cnt; bitset\u0026lt;N\u0026gt; f[N]; void toposort() { int que[N]; int hh = 0, tt = -1; for (int i = 1; i \u0026lt;= n; i++) if (!d[i]) que[++tt] = i; while (hh \u0026lt;= tt) { int front = que[hh++]; seq[cnt++] = front; for (int i = h[front]; ~i; i = ne[i]) { int j = e[i]; if (--d[j] == 0) que[++tt] = j; } } } int main() { memset(h, -1, sizeof h); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); int a, b; while (m--) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); add(a, b); d[b]++; } toposort(); for (int i = n-1; ~i; i--) { int j = seq[i]; f[j][j] = 1; for (int k = h[j]; ~k; k = ne[k]) { f[j] |= f[e[k]]; } } for (int i = 1; i \u0026lt;= n; i++) printf(\u0026#34;%lld\\n\u0026#34;, f[i].count()); return 0; } 二叉树的下一个结点 题目链接\n思路  若当前结点有右儿子，则右子树中最左侧的结点就是当前结点的后继 如果当前没有右儿子，则要沿着father域一直向上找，找到第一个是其father左儿子的结点，该结点的father就是当前结点的后继  代码 func inorderSuccessor(p *TreeNode) *TreeNode { if p.Right != nil { p = p.Right for p.Left != nil { p = p.Left } return p } for (p.Father != nil \u0026amp;\u0026amp; p == p.Father.Right) { p = p.Father } return p.Father } 二叉搜索树迭代器-中序遍历非递归 题目链接\n思路  将根节点的左链入栈 当取出一个元素后，如果这个结点有右子树，则将其右子树的左链入栈  代码 type BSTIterator struct { stk []*TreeNode } func Constructor(root *TreeNode) BSTIterator { stk := make([](*TreeNode), 0) for root != nil { stk = append(stk, root) root = root.Left } return BSTIterator{stk} } func (this *BSTIterator) Next() int { root := this.stk[len(this.stk)-1] this.stk = this.stk[:len(this.stk)-1] ret := root.Val root = root.Right for root != nil { this.stk = append(this.stk, root) root = root.Left } return ret } func (this *BSTIterator) HasNext() bool { return len(this.stk) \u0026gt; 0 } 翻转单词顺序 题目链接\n思路  将整个字符串翻转 翻转每个单词     时间复杂度 空间复杂度     $O(n)$ $O(1)$    代码 class Solution { public: string reverseWords(string s) { const int n = s.length(); reverse(begin(s), end(s)); for (int i = 0; i \u0026lt; n; i++) { int j = i + 1; while (j \u0026lt; n \u0026amp;\u0026amp; s[j] != \u0026#39; \u0026#39;) ++j; reverse(begin(s) + i, begin(s) + j); i = j; } return s; } }; 搜索二维矩阵-二分 题目链接\n代码    时间复杂度 空间复杂度     $O(log(n^2)) = O(logn)$ $O(1)$    func searchMatrix(M [][]int, target int) bool { n, m := len(M), len(M[0]) l, r := 0, n * m - 1 for l \u0026lt; r { mid := (l + r + 1) \u0026gt;\u0026gt; 1 if M[mid/m][mid%m] \u0026lt;= target { l = mid } else { r = mid - 1 } } return M[l/m][l%m] == target } 二维数组中的查找 题目链接\n思路 我们可以发现：x左边的数都小于等于x，x下边的数都大于等于x\n 如果 x 等于target，则说明我们找到了目标值，返回true； 如果 x 小于target，则 x 左边的数一定都小于target，我们可以直接排除当前一整行的数 如果 x 大于target，则 x 下边的数一定都大于target，我们可以直接排序当前一整列的数     时间复杂度 空间复杂度     $O(m+n)$ $O(1)$    代码 func findNumberIn2DArray(M [][]int, target int) bool { if len(M) == 0 { return false } i, j := 0, len(M[0]) - 1 for i \u0026lt; len(M) \u0026amp;\u0026amp; j \u0026gt;= 0 { if M[i][j] == target { return true } else if (M[i][j] \u0026lt; target) { i++ } else { j-- } } return false } 子集II 思路  先排序，把所有相同的元素放在一起，之后统计相同元素个数，对于每个相同元素可以选择的次数为0-t(t表示元素出现次数) 将所有元素的所有次数可能相互组合即可得到所有解集     时间复杂度 空间复杂度     $O(n2^n)$ $O(n)$    代码 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsetsWithDup(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); sort(begin(nums), end(nums)); vector\u0026lt;int\u0026gt; tmp; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; function\u0026lt;void(int)\u0026gt; dfs = [\u0026amp;](int u){ if (u \u0026gt;= n) { ans.emplace_back(tmp); return; } int k = 0; while (u + k \u0026lt; n \u0026amp;\u0026amp; nums[u] == nums[u+k]) k++; for (int i = 0; i \u0026lt;= k; i++) { dfs(u + k); tmp.emplace_back(nums[u]); } for (int i = 0; i \u0026lt;= k; i++) tmp.pop_back(); }; dfs(0); return ans; } }; 递归实现组合型枚举 题目链接\n思路    时间复杂度 空间复杂度     $O(2^n)$ $O(n)$    代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int N = 30; int n, m; int path[N]; // u是层数，start是起始值 void dfs(int u, int start) { if (u \u0026gt; m) { for (int i = 1; i \u0026lt;= m; i++) cout \u0026lt;\u0026lt; path[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; return; } for (int i = start; i \u0026lt;= n; i++) { path[u] = i; dfs(u + 1, i + 1); path[u] = 0; } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; dfs(1, 1); return 0; } 直方图的水量-单调栈|DP 题目链接\n单调栈 思路  维护一个单调栈（严格递减），那么一定有height[t] \u0026gt; height[left](left是栈顶下面的元素) 若height[i] \u0026gt; height[t]则可形成一个盛水区域，宽度为i-left-1，高度为min(height[i], height[left])-height[t]     时间复杂度 空间复杂度     $O(n)$ $O(n)$    代码 func trap(height []int) int { stk := make([]int, 0) ans := 0 for i := range height { for len(stk) \u0026gt; 0 \u0026amp;\u0026amp; height[i] \u0026gt;= height[stk[len(stk)-1]] { top := stk[len(stk)-1] stk = stk[:len(stk)-1] if len(stk) \u0026lt;= 0 { break } left := stk[len(stk)-1] ans += (i - left - 1) * (min(height[i], height[left])-height[top]) } stk = append(stk, i) } return ans } func min(a, b int) int { if a \u0026lt; b { return a } return b } DP 思路 对于下标 i，水能到达的最大高度等于下标 i 两边的最大高度的最小值，下标 i 处能接的水的量等于下标 i 处的水能到达的最大高度减去 height[i]。\n   时间复杂度 空间复杂度     $O(n)$ $O(n)$    代码 func trap(height []int) int { n := len(height) if n == 0 { return 0 } left, right := make([]int, n), make([]int, n) left[0] = height[0] for i := 1; i \u0026lt; n; i++ { left[i] = max(left[i-1], height[i]) } right[n-1] = height[n-1] for i := n-2; i \u0026gt;= 0; i-- { right[i] = max(right[i+1], height[i]) } ans := 0 for i := range height { ans += min(left[i], right[i]) - height[i] } return ans } func min(a, b int) int { if a \u0026lt; b { return a } return b } func max(a, b int) int { if a \u0026gt; b { return a } return b } 雨-最短路变形 题目链接\n思路  将海水抽象为一个源点 求海水到每个点所经过的点的最大权值的最短路  代码 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;container/heap\u0026#34; ) type Node struct { x int y int d int } type NodeHeap []Node func (n NodeHeap) Len() int { return len(n) } func (n NodeHeap) Swap(i, j int) { n[i], n[j] = n[j], n[i] } func (n NodeHeap) Less(i, j int) bool { return n[i].d \u0026lt; n[j].d } func (n *NodeHeap) Push(h interface{}) { *n = append(*n, h.(Node)) } func (n *NodeHeap) Pop() (x interface{}) { x = (*n)[len(*n)-1] *n = (*n)[:len(*n)-1] return } func main() { var T int fmt.Scan(\u0026amp;T) var n, m int for C := 1; C \u0026lt;= T; C++ { fmt.Scan(\u0026amp;n, \u0026amp;m) h := make([][]int, n+1) dist := make([][]int, n+1) st := make([][]bool, n+1) for i := 1; i \u0026lt;= n; i++ { h[i] = make([]int, m+1) st[i] = make([]bool, m+1) dist[i] = make([]int, m+1) for j := 1; j \u0026lt;= m; j++ { fmt.Scan(\u0026amp;h[i][j]) dist[i][j] = int(^uint(0)\u0026gt;\u0026gt;1) } } hp := \u0026amp;NodeHeap{} heap.Init(hp) for i := 1; i \u0026lt;= n; i++ { heap.Push(hp, Node{i, 1, h[i][1]}) dist[i][1] = h[i][1] heap.Push(hp, Node{i, m, h[i][m]}) dist[i][m] = h[i][m] } for i := 2; i \u0026lt;= m; i++ { heap.Push(hp, Node{1, i, h[1][i]}) dist[1][i] = h[1][i] heap.Push(hp, Node{n, i, h[n][i]}) dist[n][i] = h[n][i] } ans := 0 dx, dy := [4]int{-1, 0, 1, 0}, [4]int{0, 1, 0, -1} for hp.Len() \u0026gt; 0 { top := heap.Pop(hp).(Node) st[top.x][top.y] = true ans += top.d - h[top.x][top.y] for i := range dx { nx, ny := top.x + dx[i], top.y + dy[i] if nx \u0026lt; 1 || nx \u0026gt; n || ny \u0026lt; 1 || ny \u0026gt; m || st[nx][ny] { continue } if dist[nx][ny] \u0026gt; max(top.d, h[nx][ny]) { dist[nx][ny] = max(top.d, h[nx][ny]) heap.Push(hp, Node{nx, ny, dist[nx][ny]}) } } } fmt.Printf(\u0026#34;Case #%d: %d\\n\u0026#34;, C, ans) } } func max(a, b int) (x int) { if a \u0026gt; b { x = a } else { x = b } return } 密码脱落-LCS 题目链接\n思路 求字符串及其翻转串的LCS长度\n   时间复杂度 空间复杂度     $O(n^2)$ $O(n^2)$    代码 package main import \u0026#34;fmt\u0026#34; func reverse(s string) (res string) { a := []rune(s) n := len(a) for i, j := 0, n-1; i \u0026lt; j; i, j = i+1, j-1 { a[i], a[j] = a[j], a[i] } return string(a) } func main() { var a, b string fmt.Scanf(\u0026#34;%s\u0026#34;, \u0026amp;a) n := len(a) b = reverse(a) f := make([][]int, n+1) for i := range f { f[i] = make([]int, n+1) } for i := 1; i \u0026lt;= n; i++ { for j := 1; j \u0026lt;= n; j++ { if a[i-1] == b[j-1] { f[i][j] = f[i-1][j-1] + 1 } else { f[i][j] = max(f[i-1][j], f[i][j-1]) } } } fmt.Println(n - f[n][n]) } func max(a, b int) int { if a \u0026gt; b { return a } return b } 森林中的兔子 题目链接\n思路  统计每种$x$出现的次数 若$x$出现了$k$次为了使得兔子数量最小，则兔子种类数为 $\\lceil \\frac{k}{x+1} \\rceil$, 且每种兔子数量为$x+1$ 则兔子总数为$\\sum_i^n{ \\lceil \\frac{k_i}{x_i+1} \\rceil \\times (x_i+1)}$ 例如有13只兔子回答5，则至少有六只同一种类兔子记为红色，还有六只另一种类记为蓝色，还剩下一只兔子回答5，则必然还有五只兔子与这一只兔子颜色相同记为白色。综上有$\\lceil \\frac{13}{5+1} \\rceil \\times (5+1) = 18$只兔子。     时间复杂度 空间复杂度     $O(n)$ $O(n)$    代码 func numRabbits(answers []int) int { mp := make(map[int]int) for i := range answers { mp[answers[i]]++ } ret := 0 for k, v := range mp { ret += (v + k) / (k + 1) * (k + 1); } return ret; } 石子合并-区间DP 题目链接\n思路  $f[i][j]$表示将表示将 $i$ 到 $j$ 合并成一堆的方案的集合，属性是最小值 $f[i][j]=min_{i≤k≤j−1}\\{f[i][k]+f[k+1][j]+s[j]−s[i−1]\\}$     时间复杂度 空间复杂度     $O(n^3)$ $O(n^2)$    代码 package main import \u0026#34;fmt\u0026#34; const N = 305 var n int var s [N]int var f [N][N]int func main() { fmt.Scan(\u0026amp;n) for i := 1; i \u0026lt;= n; i++ { fmt.Scan(\u0026amp;s[i]) s[i] += s[i-1] } for len := 2; len \u0026lt;= n; len++ { for i := 1; i + len - 1 \u0026lt;= n; i++ { j := i + len - 1 f[i][j] = int(^uint(0) \u0026gt;\u0026gt; 1) for k := i; k \u0026lt; j; k++ { f[i][j] = min(f[i][j], f[i][k] + f[k+1][j] + s[j] - s[i-1]) } } } fmt.Println(f[1][n]) } func min(a, b int) int { if a \u0026lt; b { return a } return b } 环形石子合并 题目链接\n思路  破环成链 求所有区间长度为n的链形石子合并 枚举长度为n的区间，取max  代码 package main import \u0026#34;fmt\u0026#34; const ( N = 405 INT_MAX = int(^uint(0) \u0026gt;\u0026gt; 1) INT_MIN = -INT_MAX - 1 ) var ( n int f [N][N]int g [N][N]int s [N]int a [N]int ) func main() { fmt.Scan(\u0026amp;n) for i := 1; i \u0026lt;= n; i++ { fmt.Scan(\u0026amp;a[i]) a[i+n] = a[i] } for i := 1; i \u0026lt;= 2*n; i++ { s[i] = s[i-1] + a[i] } for l := 2; l \u0026lt;= n; l++ { for i := 1; i+l-1 \u0026lt;= 2*n; i++ { j := i + l - 1 f[i][j], g[i][j] = INT_MAX, INT_MIN for k := i; k \u0026lt; j; k++ { f[i][j], g[i][j] = min(f[i][j], f[i][k]+f[k+1][j]+s[j]-s[i-1]), max(g[i][j], g[i][k]+g[k+1][j]+s[j]-s[i-1]) } } } minv, maxv := INT_MAX, INT_MIN for i := 1; i \u0026lt;= n; i++ { minv = min(minv, f[i][i+n-1]) maxv = max(maxv, g[i][i+n-1]) } fmt.Println(minv) fmt.Println(maxv) } func min(a, b int) int { if a \u0026lt; b { return a } return b } func max(a, b int) int { if a \u0026gt; b { return a } return b } 合并两个有序数组 题目链接\n解题思路  指针从后往前移动 每次将较大值插到后面     时间复杂度 空间复杂度     $O(m+n)$ $O(1)$    代码 func merge(A []int, m int, B []int, n int) { i, j := m-1, n-1 for k := m+n-1; k \u0026gt;= 0; k-- { if i == -1 { A[k] = B[j] j-- } else if j == -1 { A[k] = A[i] i-- } else if A[i] \u0026gt; B[j] { A[k] = A[i] i-- } else { A[k] = B[j] j-- } } } 删除有序数组中的重复项II 题目链接\n思路  k指向新数组的末尾 遍历数组，若当前元素不等于nums[k-2]则插入新数组的末尾     时间复杂度 空间复杂度     $O(n)$ $O(1)$    代码 func removeDuplicates(nums []int) int { n := len(nums) if n \u0026lt;= 2 { return n } k := 2 for i := 2; i \u0026lt; n; i++ { if nums[i] != nums[k-2] { nums[k] = nums[i] k++ } } return k } 搜索旋转排序数组II-二分 题目链接\n思路  nums[l] == nums[mid]：不能确定哪一个区间是有序的，l++ nums[l] \u0026lt; nums[mid]：左区间是有序的 nums[l] \u0026gt; nums[mid]：右区间是有序的     时间复杂度 空间复杂度     $O(n)$ $O(1)$    代码 func search(nums []int, target int) bool { n := len(nums) if n == 0 { return false } l, r := 0, n-1 for l \u0026lt;= r { mid := (l + r) \u0026gt;\u0026gt; 1 if nums[mid] == target { return true } else if nums[l] == nums[mid] { l++ continue } else if nums[l] \u0026lt; nums[mid] { if nums[l] \u0026lt;= target \u0026amp;\u0026amp; target \u0026lt; nums[mid] { r = mid - 1 } else { l = mid + 1 } } else { if nums[mid] \u0026lt; target \u0026amp;\u0026amp; target \u0026lt;= nums[r] { l = mid + 1 } else { r = mid - 1 } } } return false } 0到n-1中缺失的数字-二分 题目链接\n思路 \u0026lt;img src=\u0026ldquo;https://cdn.acwing.com/media/article/image/2019/05/31/1_37a28f4683-%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97.png\u0026quot; position=\u0026ldquo;center\u0026rdquo; style=\u0026ldquo;zoom: 80% ;\u0026rdquo;\n   时间复杂度 空间复杂度     $O(logn)$ $O(1)$    代码 class Solution { public: int getMissingNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) { const int n = nums.size(); if (!n) { return 0; } if (nums[n-1] == n-1) { return n; } int l = 0, r = n-1; while (l \u0026lt; r) { const int mid = (l + r) \u0026gt;\u0026gt; 1; if (nums[mid] != mid) { r = mid; } else { l = mid + 1; } } return l; } }; 移去K位数字-贪心 题目链接\n思路  如果字符串已经是有序的，则应该删除后$k$位 如果出现逆序，则应该把前一个元素删除     时间复杂度 空间复杂度     $O(n)$ $O(1)$    代码 package main import ( \u0026#34;fmt\u0026#34; ) func main() { var s string var k int fmt.Scan(\u0026amp;s, \u0026amp;k) ans := \u0026#34;0\u0026#34; for _, v := range s { for k \u0026gt; 0 \u0026amp;\u0026amp; ans[len(ans)-1] \u0026gt; byte(v) { ans = ans[:len(ans)-1] k-- } ans += string(v) } for k \u0026gt; 0 { ans = ans[:len(ans)-1] k-- } i := 0 for i \u0026lt; len(ans) - 1 \u0026amp;\u0026amp; ans[i] == \u0026#39;0\u0026#39; { i++ } fmt.Println(ans[i:]) } 二叉搜索树节点最小距离 题目链接\n思路 二叉搜索树中序遍历有序\n   时间复杂度 空间复杂度     $O(n)$ $O(1)$    代码 const MAX int = int(^uint(0) \u0026gt;\u0026gt; 1) func minDiffInBST(root *TreeNode) (ans int) { ans = MAX var last int is_first := false var dfs func(root *TreeNode) dfs = func(root *TreeNode) { if root == nil { return } dfs(root.Left) if (!is_first) { is_first = true } else { ans = min(ans, root.Val - last) } last = root.Val dfs(root.Right) } dfs(root) return } func min(a, b int) int { if a \u0026lt; b { return a } return b } 实现Trie树 思路  字典树  代码 type Trie struct { son [26]*Trie isEnd bool } /** Initialize your data structure here. */ func Constructor() Trie { return Trie{} } func (this *Trie) query(word string) (res *Trie) { node := this for _, v := range word { t := v - \u0026#39;a\u0026#39; if node.son[t] == nil { res = nil return } node = node.son[t] } res = node return } /** Inserts a word into the trie. */ func (this *Trie) Insert(word string) { node := this for _, v := range word { t := v - \u0026#39;a\u0026#39; if node.son[t] == nil { node.son[t] = \u0026amp;Trie{} } node = node.son[t] } node.isEnd = true } /** Returns if the word is in the trie. */ func (this *Trie) Search(word string) bool { node := this.query(word) return node != nil \u0026amp;\u0026amp; node.isEnd } /** Returns if there is any word in the trie that starts with the given prefix. */ func (this *Trie) StartsWith(prefix string) bool { return this.query(prefix) != nil } 前缀统计-Trie 题目链接\n链表代码 package main import \u0026#34;fmt\u0026#34; type Trie struct { son [26]*Trie isEnd bool cnt int } func NewTrie() *Trie { return \u0026amp;Trie{} } func (t *Trie) insert(word string) { node := t for _, v := range word { c := v - \u0026#39;a\u0026#39; if node.son[c] == nil { node.son[c] = NewTrie() } node = node.son[c] } node.cnt++ node.isEnd = true } func (t *Trie) query(word string) (ans int) { node := t for _, v := range word { c := v - \u0026#39;a\u0026#39; if node.son[c] == nil { return ans } node = node.son[c] ans += node.cnt } return } func main() { var n, m int fmt.Scan(\u0026amp;n, \u0026amp;m) var s string t := NewTrie() for i := 0; i \u0026lt; n; i++ { fmt.Scan(\u0026amp;s) t.insert(s) } for i := 0; i \u0026lt; m; i++ { fmt.Scan(\u0026amp;s) fmt.Println(t.query(s)) } } 数组代码 package main import \u0026#34;fmt\u0026#34; const N = 1e6 + 5 var ( n, m int son [N][26]int idx int cnt [N]int ) func insert(word string) { p := 0 for _, v := range word { t := v - \u0026#39;a\u0026#39; if son[p][t] == 0 { idx++ son[p][t] = idx } p = son[p][t] } cnt[p]++ } func query(word string) (ans int) { p := 0 for _, v := range word { t := v - \u0026#39;a\u0026#39; if son[p][t] == 0 { return } p = son[p][t] ans += cnt[p] } return } func main() { fmt.Scan(\u0026amp;n, \u0026amp;m) var s string for i := 0; i \u0026lt; n; i++ { fmt.Scan(\u0026amp;s) insert(s) } for i := 0; i \u0026lt; m; i++ { fmt.Scan(\u0026amp;s) fmt.Println(query(s)) } } 打家劫舍II-DP 解题思路    时间复杂度 空间复杂度     $O(n)$ $O(n)$    代码 func rob(nums []int) int { n := len(nums) if n == 1 { return nums[0] } f := make([][2]int, n) f[0][0], f[0][1] = math.MinInt64, nums[0] for i := 1; i \u0026lt; n; i++ { f[i][0] = max(f[i-1][0], f[i-1][1]) f[i][1] = f[i-1][0] + nums[i] } res := f[n-1][0] f[0][0], f[0][1] = 0, math.MinInt64 for i := 1; i \u0026lt; n; i++ { f[i][0] = max(f[i-1][0], f[i-1][1]) f[i][1] = f[i-1][0] + nums[i] } return max(res, max(f[n-1][0], f[n-1][1])) } func max(a, b int) int { if a \u0026gt; b { return a } return b } 扰乱字符串-DP 题目链接\n思路  状态表示f[i][j][k]  集合：s1[i..i+k-1]和s2[j..j+k-1]所有匹配的方案的集合 属性：集合是否为空集   状态计算：f[i][j][k]按s1第一段的长度划分成k-1类，有两种匹配方案  f[i][j][u] \u0026amp;\u0026amp; f[i+u][j+u][k-u] f[i][j+k-u][u] \u0026amp;\u0026amp; f[i+u][j][k-u]       时间复杂度 空间复杂度     $O(n^4)$ $O(n^3)$    代码 func isScramble(s1 string, s2 string) bool { n := len(s1) f := make([][][]bool, n) for i := range f { f[i] = make([][]bool, n) for j := range f[i] { f[i][j] = make([]bool, n+1) } } for k := 1; k \u0026lt;= n; k++ { for i := 0; i+k-1 \u0026lt; n; i++ { for j := 0; j+k-1 \u0026lt; n; j++ { if k == 1 { if s1[i] == s2[j] { f[i][j][k] = true } } else { for u := 1; u \u0026lt; k; u++ { if f[i][j][u] \u0026amp;\u0026amp; f[i+u][j+u][k-u] || f[i][j+k-u][u] \u0026amp;\u0026amp; f[i+u][j][k-u] { f[i][j][k] = true break } } } } } } return f[0][0][n] } 重复元素III-滑动窗口 题目链接\n思路  有序集合中查找大于等于 x - t 的最小的元素 y，如果 y 存在，且 y \u0026lt;= x + t则存在 有序集合中元素数量超过了 k，将有序集合中最早被插入的元素删除即可     时间复杂度 空间复杂度     $O(nlogk)$ $O(k)$    代码 class Solution { public: bool containsNearbyAlmostDuplicate(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k, int t) { set\u0026lt;long\u0026gt; st; const int n = nums.size(); for (int i = 0; i \u0026lt; n; i++) { auto it = st.lower_bound(nums[i]*1l-t); if (it != end(st) \u0026amp;\u0026amp; *it \u0026lt;= nums[i]*1l+t) { return true; } st.insert(nums[i]); if (i-k \u0026gt;= 0) st.erase(nums[i-k]); } return false; } }; 解码方法-dp 题目链接\n思路  状态表示：$f[i]$表示前 $i$ 个数字共有多少种解码方式。 状态转移：  如果第 $i$ 个数字不是$0$，则 $i$ 个数字可以单独解码成一个字母，此时的方案数等于用前 $i−1$ 个数字解码的方案数，即 $f[i−1]$ 如果第 $i−1$个数字和第 $i$个数字组成的两位数在 $10$ 到 $26$ 之间，则可以将这两位数字解码成一个字符，此时的方案数等于用前 $i−2$ 个数字解码的方案数，即 $f[i−2]$       时间复杂度 空间复杂度     $O(n)$ $O(n)$    代码 func numDecodings(s string) int { n := len(s) f := make([]int, n+1) f[0] = 1 for i := 1; i \u0026lt;= n; i++ { if s[i-1] != \u0026#39;0\u0026#39; { f[i] += f[i-1] } if i \u0026gt; 1 { t := (s[i-2] - \u0026#39;0\u0026#39;) * 10 + s[i-1] - \u0026#39;0\u0026#39; if t \u0026gt;= 10 \u0026amp;\u0026amp; t \u0026lt;= 26 { f[i] += f[i-2] } } } return f[n] } 矩形区域不超过 K 的最大数值和-前缀和 题目链接\n思路  二重循环枚举矩形的上边界和下边界，时间复杂度O(n^2) 在一维数组求和不超过K的最大子数组的和，我们可以在O(nlogn)的时间复杂度内求解。我们知道可以使用前缀和求解子区间和：sum(A[i:j])=preSum[j]−preSum[i−1]。那么对于每一个preSum[j]，我们可以将遇到过的前缀后存入一个set中，再从set中找到一个大于等于preSum[j]−k的最小值，这样他们的差值就是小于等于kk的最大值。这种查找的时间复杂度是logn的，总共需要查找n次，所以总共的时间复杂度为O(nlogn)     时间复杂度 空间复杂度     $O(m^2nlogn)$ $O(n)$    代码 class Solution { public: int maxSumSubmatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; A, int k) { const int m = A.size(), n = A[0].size(); int ans = INT_MIN; for (int i = 0; i \u0026lt; m; i++) { vector\u0026lt;int\u0026gt; sum(n); for (int j = i; j \u0026lt; m; j++) { for (int k = 0; k \u0026lt; n; k++) { sum[k] += A[j][k]; } set\u0026lt;int\u0026gt; st{0}; int s = 0; for (const auto \u0026amp;e : sum) { s += e; auto it = st.lower_bound(s - k); if (it != st.end()) { ans = max(ans, s - *it); } st.insert(s); } } } return ans; } }; 最大整除子集-dp 题目链接\n解题思路  前提：升序 状态集合：$f[i]$表示最大元素为$nums[i]$的有效解子集 属性：有效子集大小 状态计算：$f[i]=max(f[i], f[j]+1), j=0..i-1$ 倒序遍历$f$找到集合元素     时间复杂度 空间复杂度     $O(n^2)$ $O(n)$    代码 func largestDivisibleSubset(nums []int) []int { sort.Ints(nums) n := len(nums) f := make([]int, n) for i := range f { f[i] = 1 } maxLen := 1 for i := range f { for j := 0; j \u0026lt; i; j++ { if nums[i] % nums[j] == 0 { f[i] = max(f[i], f[j] + 1) maxLen = max(maxLen, f[i]) } } } ans := make([]int, maxLen) end := true for i := n-1; i \u0026gt;= 0 \u0026amp;\u0026amp; maxLen \u0026gt; 0; i-- { if f[i] == maxLen \u0026amp;\u0026amp; (end || ans[maxLen] % nums[i] == 0) { ans[maxLen-1] = nums[i] end = false maxLen-- } } return ans } func max(a, b int) int { if a \u0026gt; b { return a } return b } 整数拆分-完全背包 题目链接\n思路 完全背包\n 状态表示：$f[i]$表示$i$的不同拆分方式数 状态计算：$f[i]=f[j]+f[j-2^i], 0 \\le 2^i \\le n$     时间复杂度 空间复杂度     $O(nlogn)$ $O(n)$    代码 package main import \u0026#34;fmt\u0026#34; const ( N = 1e6 + 5 mod = 1e9 ) var ( n int f [N]int ) func main() { fmt.Scan(\u0026amp;n) f[0] = 1 for i := 0; 1\u0026lt;\u0026lt;i \u0026lt;= n; i++ { for j := 1\u0026lt;\u0026lt;i; j \u0026lt;= n; j++ { f[j] = (f[j] + f[j-1\u0026lt;\u0026lt;i]) % mod } } fmt.Println(f[n]) } func max(a, b int) int { if a \u0026gt; b { return a } return b } 组合总和IV-DP 题目链接\n思路 考虑顺序背包-\u0026gt;先枚举体积，再枚举物品\n   时间复杂度 空间复杂度     $O(mn)$ $O(n)$    代码 func combinationSum4(nums []int, target int) int { f := make([]int, target+1) f[0] = 1 for i := 0; i \u0026lt;= target; i++ { for _, v := range nums { if i \u0026gt;= v { f[i] += f[i-v] } } } return f[target] } 最大的和-前缀和\u0026amp;滑动窗口 题目连接\n代码 package main import \u0026#34;fmt\u0026#34; const N = 1e5 + 5 var ( n int k int A [N]int B [N]bool ) func main() { fmt.Scan(\u0026amp;n, \u0026amp;k) for i := 0; i \u0026lt; n; i++ { fmt.Scan(\u0026amp;A[i]) } sum := 0 for i := 0; i \u0026lt; n; i++ { fmt.Scan(\u0026amp;B[i]) if B[i] { sum += A[i] } } ans := 0 for i := 0; i \u0026lt; n; i++ { if !B[i] { sum += A[i] } if i \u0026gt;= k \u0026amp;\u0026amp; !B[i-k] { sum -= A[i-k] } ans = max(ans, sum) } fmt.Println(ans) } func max(a, b int) int { if a \u0026gt; b { return a } return b } 八数码-A* 题目链接\n代码 #include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;unordered_map\u0026gt;using namespace std; const int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1}; const string go = \u0026#34;urdl\u0026#34;; string s, t = \u0026#34;12345678x\u0026#34;; int get_f(const string \u0026amp;sts, int g) { int f = g; for (int i = 0; i \u0026lt; 9; i++) { if (sts[i] != t[i]) { f++; } } return f; } unordered_map\u0026lt;string, int\u0026gt; mp; priority_queue\u0026lt;pair\u0026lt;int, string\u0026gt;\u0026gt; que; unordered_map\u0026lt;string, pair\u0026lt;char, string\u0026gt;\u0026gt; path; int get_x(const string \u0026amp;sts) { for (int i = 0; i \u0026lt; 9; i++) { if (sts[i] == \u0026#39;x\u0026#39;) return i; } return -1; } void dfs(const string \u0026amp;tmp) { if (!path.count(tmp)) return; dfs(path[tmp].second); printf(\u0026#34;%c\u0026#34;, path[tmp].first); } bool check(const string \u0026amp;tmp) { int cnt = 0; for (int i = 0; i \u0026lt; 9; i++) { if (tmp[i] == \u0026#39;x\u0026#39;) continue; for (int j = i + 1; j \u0026lt; 9; j++) { if (tmp[j] != \u0026#39;x\u0026#39; \u0026amp;\u0026amp; tmp[i] \u0026gt; tmp[j]) cnt++; } } return (cnt \u0026amp; 1) == 0; } void bfs() { que.push({0, s}); mp[s] = 0; if (!check(s)) { puts(\u0026#34;unsolvable\u0026#34;); return; } while (que.size()) { auto [_, sts] = que.top(); que.pop(); if (sts == t) { break; } auto idx = get_x(sts); auto x = idx / 3, y = idx % 3; for (int i = 0; i \u0026lt; 4; i++) { auto cp = sts; auto nx = x + dx[i], ny = y + dy[i]; if (nx \u0026gt;= 0 \u0026amp;\u0026amp; nx \u0026lt;= 2 \u0026amp;\u0026amp; ny \u0026gt;= 0 \u0026amp;\u0026amp; ny \u0026lt;= 2) { swap(cp[nx * 3 + ny], cp[idx]); if (mp.count(cp)) continue; path[cp] = {go[i], sts}; mp[cp] = mp[sts] + 1; que.push({-get_f(cp, mp[cp]), cp}); } } } dfs(t); } int main() { char tmp; for (int i = 0; i \u0026lt; 9; i++) { cin \u0026gt;\u0026gt; tmp; s += tmp; } bfs(); return 0; } 最长递增子序列的个数-LIS 题目链接\n代码 func findNumberOfLIS(nums []int) int { n := len(nums) dp, cnt := make([]int, n), make([]int, n) maxLen, ans := 0, 0 for i := range nums { dp[i], cnt[i] = 1, 1 for j := 0; j \u0026lt; i; j++ { if nums[i] \u0026gt; nums[j] { if dp[j] + 1 \u0026gt; dp[i] { dp[i] = dp[j] + 1 cnt[i] = cnt[j] } else if dp[j] + 1 == dp[i] { cnt[i] += cnt[j] } } } if maxLen \u0026lt; dp[i] { maxLen = dp[i] ans = cnt[i] } else if maxLen == dp[i] { ans += cnt[i] } } return ans } ","permalink":"https://fffzlfk.github.io/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/","summary":"Algorithms Problems","title":"每日一题"},{"content":"SQL概述 SQL的特点  综合统一：集DQ、DDL、DML、DCL于一体 高度非过程化：不用考虑如何实现，只需提出“做什么”，不关心“怎么做” 面向集合的操作方式：查询、插入、删除、更新操作对象及结果都是集合 以同一种语法结构提供两种使用方法：可交互式和嵌入式使用 以简捷的自然语言实现对数据库的定义、操作和控制功能：定义了少量的关键字实现对数据库的定义、操纵和控制功能  SQL所使用的动词（核心功能）    SQL功能 动词     数据查询 SELECT   数据定义 CREATE, DROP, ALTER   数据操作 INSERT, UPDATE, DELETE   数据控制 GRANT, REVOKE    数据定义 SQL的数据定义语句 SQL中的数据类型 基本表的定义 创建基本表 CREATE TABLE \u0026lt;表名\u0026gt; ( \u0026lt;列名\u0026gt; \u0026lt;数据类型\u0026gt;[\u0026lt;列级完整性约束条件\u0026gt;] [, \u0026lt;列名\u0026gt; \u0026lt;数据类型\u0026gt;[\u0026lt;列级完整性约束条件\u0026gt;] ] … [, \u0026lt;表级完整性约束条件\u0026gt; ] ) ;  常用的完整性约束  主码约束：PRIMARY KEY (\u0026lt;列名1\u0026gt;, \u0026lt;列名2\u0026gt;,…) 非空值约束：NOT NULL 唯一性约束：UNIQUE 参照完整性约束：FOREIGN KEY (\u0026lt;列名\u0026gt;) REFERENCES \u0026lt;表名\u0026gt;(\u0026lt;列名\u0026gt;) 一般性约束：CHECK(\u0026lt;谓词\u0026gt;)    删除基本表 DROP TABLE \u0026lt;表名\u0026gt; [RESTRICT|CASCADE];   RESTRICT：删除表是有限制的：\n 欲删除的基本表不能被其他表的约束所引用 如果存在依赖该表的对象，则此表不能被删除    CASCADE：级联，删除该表没有限制。 在删除基本表的同时，相关的依赖对象一起删除\n:warning:缺省是RESTRICT\n  修改基本表 ALTER TABLE \u0026lt;表名\u0026gt; [ADD[COLUMN] \u0026lt;新列名\u0026gt; \u0026lt;数据类型\u0026gt; [ 完整性约束 ]] [ADD \u0026lt;表级完整性约束\u0026gt;] [DROP [ COLUMN ] \u0026lt;列名\u0026gt; [CASCADE|RESTRICT]] [DROP CONSTRAINT\u0026lt;完整性约束名\u0026gt;[RESTRICT|CASCADE]] [ALTER COLUMN\u0026lt;列名\u0026gt; \u0026lt;数据类型\u0026gt;];  \u0026lt;表名\u0026gt;：要修改的基本表 ADD子句：增加新列和新的完整性约束条件 DROP COLUMN子句: 用于删除表中的列 DROP CONSTRAINT子句：删除指定的完整性约束条件 ALTER COLUMN子句：用于修改列名和数据类型  :warning:删除属性列\n 间接删除(由DBA或表的Owner操作)  把表中要保留的列及其内容复制到一个新表中 删除原表 再将新表重命名为原表名   直接删除(SQL-99)\n例：ALTER TABLE S Drop Scome ;  索引的定义 索引的分类  普通索引(Normal Index)：一个索引值可能对应多条存储记录 单一索引(Unique Index)：每一个索引值只对应唯一的数据记录。 聚簇索引(Cluster Index)：基本表按照索引项顺序组织存储。  一个基本表上最多只能建立一个聚簇索引 在最经常查询的列上建立聚簇索引 经常更新的列不宜建立聚簇索引    创建索引 CREATE [UNIQUE] | [CLUSTER] INDEX \u0026lt;索引名\u0026gt; ON \u0026lt;表名\u0026gt;(\u0026lt;列名\u0026gt;[\u0026lt;次序\u0026gt;][,\u0026lt;列名\u0026gt;[\u0026lt;次序\u0026gt;] ]…);  用\u0026lt;表名\u0026gt;指定要建索引的基本表名字 索引可以建立在该表的一列或多列上，各列名之间用逗号分隔 用\u0026lt;次序\u0026gt;指定索引值的排列次序。升序：ASC，降序：DESC，缺省值：ASC UNIQUE表明此索引的每一个索引值对应唯一的数据记录 CLUSTER表示要建立的索引是聚簇索引  例7: 为学生表S和选课表SC建立索引。其中S表按学号升序建唯一索引，按年龄降序建立普通索引，SC表按学号升序和课程号降序建唯一索引。\nCREATE UNIQUE INDEX Stusno ON S (Sno); CREATE INDEX Stusage ON S (Sage DESC); CREATE UNIQUE INDEX SCno ON SC(Sno ASC, Cno DESC); 删除索引 DROP INDEX \u0026lt;索引名\u0026gt;;\n修改索引 ALTER INDEX \u0026lt;旧索引名\u0026gt; RENAME TO \u0026lt;新索引名\u0026gt;;\n数据查询   查询语法\nSELECT [ALL | DISTINCT] \u0026lt;目标列表达式\u0026gt; [,\u0026lt;目标列表达式\u0026gt;] … FROM \u0026lt;表名或视图名\u0026gt;[, \u0026lt;表名或视图名\u0026gt; ] … [ WHERE \u0026lt;条件表达式\u0026gt; ] [ GROUP BY \u0026lt;列名1\u0026gt; [ HAVING \u0026lt;条件表达式\u0026gt; ] ] [ ORDER BY \u0026lt;列名2\u0026gt; [ ASC | DESC ] ] ;   单表查询   目标列为表达式的查询\nSELECT Sname, 1996 - Sage FROM Student ;   使用别名改变查询结果的列标题\nSELECT Sname NAME, \u0026#39;Year of Birth:\u0026#39; BIRTH, 1996 - Sage BIRTHYEAR, ISLOWER ( Sdept ) DEPARTMENT   消除结果中重复的行\nSELECT **DISTINCT** Sno FROM SC ;   限定查询范围\n   查询条件 谓　词     比　较 = , \u0026lt; , \u0026gt; , \u0026lt;= , \u0026gt;= , \u0026lt;\u0026gt; , != , !\u0026gt; , !\u0026lt; ; NOT + 上述比较符   确定范围 BETWEEN … AND … , NOT BETWEEN … AND …   确定集合 IN, NOT IN   字符匹配 LIKE, NOT LIKE   空　值 IS NULL, IS NOT NULL   多重条件 AND, OR -      确定范围\nSELECT Sname, Sdept, Sage FROM Student WHERE Sage BETWEEN 20 AND 23 ;   确定集合\nSELECT Sname, Ssex FROM Student WHERE Sdept NOT IN (\u0026#39;IS\u0026#39;, \u0026#39;MA\u0026#39;, \u0026#39;CS\u0026#39;) ;   字符串匹配\n[NOT] LIKE ‘\u0026lt;匹配模板\u0026gt;’ [ESCAPE ‘\u0026lt;换码字符\u0026gt;’]   %(百分号)：代表任意长度(可以为0)的字符串。\n例：a%b表示以a开头，以b结尾的任意长度的字符串。如acb，addgb，ab 等都满足该匹配串。\n  _(下横线)：代表任意单个字符。\n例：a_b表示以a开头，以b结尾的长度为3的任意字符串。如acb，afb等都满足该匹配串，一个汉字两个下横线\n  当要查询的字符串本身就含有 % 或 _ 时，要使用 ESCAPE '\u0026lt;换码字符\u0026gt;'短语对通配符进行转义。\nSELECT Cno, Ccredit FROM Course WHERE Cname LIKE \u0026#39;DB\\_Design\u0026#39; ESCAPE \u0026#39;\\\u0026#39; ; ;转义符‘\\’表示模板中出现在其后的第一个字符不再是通配符，而是字符本身。     涉及空值的查询\n使用谓词 IS NULL 或 IS NOT NULL，“IS NULL” 不能用 “= NULL” 代替！\n    排序输出\nORDER BY  升序：ASC ，排列为空值的元组最后显示 （空值最大） 降序：DESC    聚集函数\n 计数 COUNT (使用 DISTINCT 避免重复计数) 计算总和 SUM 计算平均值 AVG 求最大值 MAX 求最小值 MIN  [ GROUP BY \u0026lt;列名1\u0026gt;[, 列名2…] [ HAVING \u0026lt;条件表达式\u0026gt; ] ] 未对查询结果分组，集函数将作用于整个查询结果\n对查询结果分组后，集函数将分别作用于每个组\n:warning:使用GROUP BY子句后，SELECT子句的列名表中只能出现分组属性和集函数\n集函数只能用于SELECT子句和 HAVING短语之中，而绝对不能出现在 WHERE 子句中(WHERE子句执行过程是对记录逐一检验，并没有结果集，故无法施加集函数)。\n  连接查询   等值连接、自然连接\nSELECT子句和WHERE子句中出现的两个同名属性前要加所属表名作前辍以区别，无同名则可省前辍。\n  自身连接\n需要给表起别名以示区别，由于所有的属性名都是同名属性， 因此必须使用别名前缀\n  外连接 Outer Join\n 左外连接：在连接的右边出现空行 右外连接：在连接的左边出现空行 左右外链接：在连接的左右出现空行  .notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Note\n连接类型\n- 内连接（INNER JOIN）\n- 左外连接（LEFT OUTER JOIN）\n- 右外连接（RIGHT OUTER JOIN）\n- 全外连接（FULL OUTER JOIN）\n   嵌套查询 带有IN谓词的子查询 带有比较运算符的子查询  :warning:特别注意：子查询一定要跟在比较符之后！  带有ANY(SOME)或ALL谓词的查询 带有EXISTS谓词的子查询   EXISTS谓词的意义：\n 是存在量词在SQL中的应用 带有EXISTS谓词的子查询不返回任何数据，只产生逻辑真值“true”或逻辑假值“false”  若内层查询结果非空，则返回真值 若内层查询结果为空，则返回假值   由EXISTS引出的子查询，其目标列表达式通常都用*：因为带EXISTS的子查询只返回真值或假值，给出列名无实际意义     嵌套查询小结 嵌套查询分为相关子查询和不相关子查询\n 不相关子查询的执行不依赖于父查询的任何条件  语句上不出现父查询中的属性 执行上首先运行，且只运行一次即可得到确定的结果 子查询的结果集将作为父查询的条件使用   相关子查询的执行与父查询的当前值相关  语句上出现父查询中的属性 执行上父查询的当前值会作为子查询的条件   子查询的属性不会出现在父查询的输出上(Select 子句) 子查询不能使用ORDER BY子句， ORDER BY子句只能对最终结果排序  集合查询 将两个SELECT-FROM-WHERE查询块用集合操作命令联结起来的查询\n集合操作命令  并操作（UNION） 交操作（INTERSECT） 差操作（EXCEPT）  语句形式 \u0026lt;查询块\u0026gt; UNION [ALL] | INTERSECT | EXCEPT \u0026lt;查询块\u0026gt; ; 数据更新 插入数据 插入单个元组 插入子查询结果 INSERT INTO \u0026lt;表名\u0026gt; [(\u0026lt;属性列1\u0026gt; [, \u0026lt;属性列2\u0026gt;… )] 子查询 ; 修改数据 删除数据 DELETE FROM \u0026lt;表名\u0026gt; [WHERE \u0026lt;条件\u0026gt;] ; 注意事项 DBMS在执行插入、删除、修改语句时必须保证数据库的完整性和一致性。\n","permalink":"https://fffzlfk.github.io/posts/sql/","summary":"SQL 语句","title":"SQL"},{"content":"单核处理器8086/8088 寄存器结构 通用寄存器    Reg 特殊用途     AX,AL I/O 指令的数据寄存器；乘法指令存放被乘数或积(隐含)，除法指令存放被除数或商(隐含)   AH LAHF指令的目标寄存器(隐含)   AL 数制转换或十进制运算指令和XLAT指令的累加器(隐含)   BX 间接寻址的基址寄存器 XLAT指令的基址寄存器(隐含)   CX 串操作和LOOP指令的计数器(隐含)   DX 字乘法/除法指令存放乘积高16位或被除数高位或余数(隐含) 间接寻址的 I/O 端口地址   SI 串操作的源变址寄存器(隐含)、间接寻址的变址寄存器   DI 串操作的目标变址寄存器(隐含)、间接寻址的变址寄存器   BP 对堆栈区间接寻址的基址指针   SP 堆栈操作的堆栈顶部指针    标志寄存器   6个状态标志位\n  CF，进位标志。本次运算最高位有进位或借位发生，则CF=1。STC（CLC）指令使CF=1（=0），CMC指令使之取反。（用于无符号数）\n  PF，奇偶校验标志：低 8 位有偶数个 1 则 PF = 1\n  AF：辅助进位标志\n低 4 位向高四位有进位或借位， AF = 1 （用于 BCD 计算）\n  ZF：全零标志\n运算结果为 0 时，ZF = 1；\n  SF：符号标志\n运算结果最高位为1，SF = 1 （表示负数）\n  OF：溢出标志\n运算产生溢出 （两负数相加为正）（有符号数）时， OF =1\n    3 个控制标志位\n TF：单步标志 IF：中断标志：IF = 1 允许，IF=0 禁止 CPU 响应可屏蔽中断 （INTR） DF：方向标志，串操作指令的地址变化方向    主存结构 双体结构 既能实现16位存储，也可以实现8位存储。 分段结构 68320H + 1280H -------- 695A0H 芯片引脚 8086芯片引脚 8088芯片引脚 8086vs.8088  指令预取序列：4Bytes\u0026lt;=\u0026gt;6Bytes AD7~AD0\nAD15~AD0 =\u0026gt; 总线传递数据更快 8088：$ \\overline{SSO} $, 8086: $ \\overline{BHE} / S7 $ 8088: $ IO/\\overline M $, 8086: $ M/\\overline{IO} $  工作时序  时钟周期：CPU处理动作最小单位 总线周期：存储器读写、I/O读写、中断响应 指令周期：取指+执行  主存读时序分析 习题 2.2 若8086CPU工作在最小模式下：\n 当CPU访问储存器时，要利用哪些信号？   $AD0 \\sim AD15、A16\\sim A19、ALE、\\overline{BHE}、DT/\\overline{R}、\\overline{DEN}、M/\\overline{IO}、\\overline{RD}、\\overline{WR}$\n 当CPU访问外设端口时，要利用哪些信号？   $AD0 \\sim AD15、ALE、\\overline{BHE}、DT/\\overline{R}、\\overline{DEN}、M/\\overline{IO}、\\overline{RD}、\\overline{WR}$\n 当HOLD有效并得到回应时，CPU的哪些信号置高阻？   CPU所有三态输出的地址、数据和相关控制信号。\n 2.2 若8086CPU工作在最大模式下：\n S0、S1、S2可以表示哪些CPU的状态？   INTA周期、I/O读周期、I/O写周期、暂停、取值周期、存储器读周期、存储器写周期\n CPU的$ \\overline{RQ}/\\overline{GT} $信号的作用是什么？   $ \\overline{RQ}/\\overline{GT} $是裁决总线使用权的请求/允许信号\n Intel指令系统与程序设计 程序框架 STACK SEGMENT STACK DB 100 DUP(0) STACK ENDS DATA SEGMENT NUM8 DB 16,25 NUM16 DW 36,64 ARRAY8 DB 20 DUP(0) ……… ………… DATA ENDS CODE SEGMENT ASSUME CS:CODE,DS:DATA,SS:STACK START: MOV AX,DATA MOV DS,AX ………… MOV AX,4C00H INT 21H CODE ENDS END START 子程序结构\n…… CALL SUB1 …… SUB1 PROC PUSH … …… POP … RET SUB1 ENDP 数据传送、寻址、算术运算指令 数据传送   MOV指令\n MOV指令必须遵从的的规则：  两个操作数的尺寸必须一致 两个操作数不能同为操作数 目的操作数不能位CS, EIP和IP 立即数不能直接送至段寄存器  mov r/m16,sreg mov sreg,r/m16  MOV指令格式 mov reg, reg mov mem, reg mov reg, mem mov mem, imm mov reg, emm     整数的零/符号扩展\n MOVZX MOVSZ    XCHG指令\n交换两个操作数的内容\n  加法和减法   INC和DEC指令\ninc reg/mem dec reg/mem \u0026lt; notice tip \u0026gt; INC和DEC指令不影响进位标志 \u0026lt; /notice \u0026gt;\n  ADD、SUB、NEG指令\n影响的标志位：CF, ZF, SF, OF, AF, PF\n  和数据相关的操作符和伪指令   OFFSET操作符\n  PTR操作符\n 用来重载操作数的默认尺寸 必须和标准数据类型联合使用  .data myDouble DWORD 12345678h .code mov ax, myDouble ; 错误 mov ax, WORD PTR myDouble ; ax = 5678h mov ax, WORD PTR [myDouble+2] ; ax = 1234h mov bl, BYTE PTR myDouble ; bl = 78h   TYPE操作符 返回按字节计算的变量的单个元素的大小\n  LENGTHOF操作符 计算数组元素的个数\n  SIZEOF操作符 SIZEOF返回值=LENGTHOF返回值*TYPE返回值\n  间接寻址   间接操作数(寄存器间接寻址)\nPTR与间接操作数的联合使用：\ninc [esi] ; error: operand must have size inc BYTE PTR [esi]   数组\n例：三个双字相加\n.data arrayD DWORD 10000h,20000h,30000h .code mov esi, OFFSET arrayD mov eax, [esi] add esi, 4 add eax, [esi] add esi, 4 add eax, [esi]   变址操作数(寄存器相对寻址)\n例：\n.data arrayB BYTE 10h, 20h, 30h .code mov esi, 0 mov al, [arrayB+esi] ; AL = 10h mov al, arrayB[esi] ; 同上，另一种格式 mov esi, OFFSET arrayB mov al, [esi] ; AL = 10h mov al, [esi+1] ; AL = 20h mov al, [esi+2] ; AL = 30h   JMP和LOOP指令  JMP：无条件转移 LOOP:条件转移  在实地址模式下，用做默认循环计数器的是CX而不是ECX 在任何模式下，LOOPD指令都使用ECX作为循环计数器，LOOPW都使用CX作为循环计数器 循环的目的地址与当前地址只能在相距-128到+127字节的范围之内。机器指令平均在3字节左右，因此一个循环平均最多只能包含大约42条指令 循环的嵌套 .data count DWORD ? .code mov ecx, 100 L1: mov count, ecx mov ecx, 20 L2: ... ... loop L2 mov ecx, count loop L1     小结：操作数类型（寻址方式）  直接操作数（直接寻址） 变量的名字，代表变量的地址 直接偏移操作数 在变量的名字上加一个偏移量 间接操作数（寄存器间接寻址） 用方括号括起的包含数据地址的寄存器 变址操作数（寄存器相对寻址） 把常量和间接操作数结合在一起  过程 与外部库链接  程序中要用PROTO伪指令声明要调用的程序: WriteString PROTO 用一条CALL指令执行WriteString过程: call WriteString 当程序被编译时，编译器为CALL指令的目标地址留出空白，该空白将有链接器填充 连接器在链接库中查找WriteString这个名字，从库中把合适的机器指令拷贝到程序的可执行文件中，并把WriteString的地址插入到CALL指令中  堆栈操作  堆栈   压栈操作： 32位的压栈（PUSH）操作将堆栈指针减4，并将进栈数据拷贝到堆栈指针所指向的位置\n  出栈操作： 出栈（POP）操作从堆栈顶端移走一个值并将其置于寄存器或变量中。在值从栈顶弹出后，堆栈指针相应增加。\n  堆栈的用途：\n 临时保存区域 CALL指令用堆栈保存当前过程的:warning:返回地址 调用过程时,通过堆栈::warning:传递参数 过程内的:warning:局部变量在堆栈上创建，过程结束时，这些变量被丢弃     PUSH和POP指令   PUSH指令\n 执行过程  减小ESP的值  16位操作数：ESP减2 32位操作数：ESP减4   将一个16位或32位的源操作数拷贝至堆栈上   指令格式 push r/m16\rpush r/m32\rpush imm32\r 保护模式下的立即数总是32位的； 在实地址模式下，如果未使用.386（或更高）处理器伪指令，默认的立即数是16位的    POP指令\n 执行过程  将ESP所指向的堆栈元素拷贝到16位或32位的目的操作数中 增加ESP的值  16位操作数：ESP加2 32位操作数：ESP加4   指令格式 pop r/m16\rpop r/m32\r      PUSHFD和POPFD指令\n 32位：  PUSHFD：在堆栈压入32位EFLAGS寄存器的值 POPFD：将堆栈顶部的值弹出并送至EFLAGS寄存器   实地址模式：  PUSHF：在堆栈上压入16位FLAGS寄存器的值 POPF：将堆栈顶部的值弹出并送至FLAGS寄存器      PUSHAD,PUSHA,POPAD和POPA指令\n 32位：  PUSHAD：将EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI按顺序压入堆栈 POPAD：按相反顺序弹出这些通用寄存器   80286：  PUSHA：以用样的顺序压入AX、CX、DX、BX、SP、BP、SI、DI POPA：以相反的顺序弹出        过程的定义和使用   PROC伪指令\nSumof PROC add eax, ebx add eax, ecx ret Sumof ENDP   CALL和RET指令\n  调用和返回的例子   可嵌套使用\n  局部标号和全局标号\nL1:: ; global label  ... L2: ; local babel  ...     条件处理 布尔和比较指令  AND指令：按位与  影响的标志位：  总是清除OF和CF； 根据结果修改SF，ZF，PF   主要用途：对特定的位清0 大写字母和小写字母的ASCII码之间的关系：  \u0026lsquo;a\u0026rsquo;: 61h, 01100001b \u0026lsquo;A\u0026rsquo;: 41h, 01000001b     OR指令：按位或  主要用途：对特定的位置1   XOR指令：按位异或  用途：  对某些位取反 判断16位或32位值的奇偶性 mov ax, 64C1h ; 0110 0100 1100 0001 xor ah, al ; PE, 奇偶位被设置  简单数据加密 将某个操作数与同样的操作数执行两次异或操作之后，其值保持不变 $$ (X\\oplus Y) \\oplus Y = X $$     NOT指令：取反 \u0026lt; notice warning \u0026gt; NOT指令不影响任何状态标志 \u0026lt; /notice \u0026gt; TEST指令：两操作数按位与，根据结果设置标志位，但不回送结果（不修改目的操作数）  用途：测试某一位是“0”还是“1” test al, 00001001b ; test bits 0 and 3 判断ZF是否等于1 影响的标志位：清除OF、CF；修改SF、ZF、PF   CMP指令   功能：与减法指令一样执行减法操作，但不回送结果，只影响标志位\n  影响的标志位：根据相减结果修改OF、SF、ZF、CF、AF、PF\n  无符号操作数的比较\n   CMP的结果 ZF CF     目的 \u0026lt; 源 0 1   目的 \u0026gt; 源 0 0   目的 = 源 1 0      有符号操作数的比较\nmov ax, 5 cmp ax, 10 ; CF = 1  mov si, 105 cmp si, 0 ; ZF = 0, CF = 0  mov ax, 1000 mov cx, 1000 cmp ax, cx ; ZF = 1   设置和清除单个CPU标志\ntest al, 0 ; 设置零标志 and al, 0 ; 设置零标志 or al, 0 ; 设置零标志  or al, 80h ; 设置符号标志 and al, 7Fh ; 清楚符号标志  stc ; 设置进位标志 clc ; 清除进位标志  mov al, 7Fh ; AL = +127 inc al ; AL = 80h or eax, 0 ; 清除溢出标志     条件跳转   条件结构\n  使用CMP、TEST、AND之类的指令修改CPU标志\n  使用条件跳转指令测试标志值，已决定是否向新的分支转移\ncmp al, 0 jz L1 ; jump if ZF = 1  ... L1: and dl, 10110000b jnz L2 ; jump if ZF = 0  ... L2:     Jcond指令\n 功能：  条件标志为真：分支转移到新的目标标号处 条件标志为假：执行紧跟在条件跳转指令之后的指令   格式： 例： mov ax, 5 mov ax, 5 mov ax, 5 cmp ax, 5 cmp ax, 6 mov ax, 6 je L1 j1 L1 jg L1     条件跳转指令的类型\n  基于特定CPU标志值\n   助记符 描述 标志值     JZ 为零则跳转 ZF = 1   JNZ 不为零则跳转 ZF = 0   JC 如果设置进位标志则跳转 CF = 1   JNC 如果未设置进位标志则跳转 CF = 0   JO 如果设置溢出标志则跳转 OF = 1   JNO 如果未设置溢出标志则跳转 OF = 0   JS 如果设置符号标志则跳转 SF = 1   JNS 如果未设置符号标志则跳转 SF = 0   JP 如果设置了奇偶标志则跳转（偶） PF = 1   JNP 如果未设置奇偶标志则跳转（奇） PF = 0      依据相等比较的跳转指令\n   助记符 描述     JE 相等则跳转   JNE 不相等则不跳转   JCXZ CX = 0 则跳转   JECXZ ECX = 0 则跳转      基于无符号整数比较结果的跳转指令\n A:Above, B: Below, E:Equal\n    助记府 描述     JA 大于则跳转(leftOp \u0026gt; rightOp)   JNBE 不（小于或等于）（同JA）   JAE 大于或等于则跳转 (leftOp \u0026gt;= rightOp)   JNB 不小于则跳转 （同JAE）   JB 小于则跳转(leftOp \u0026lt; rightOp)   JNAE 不（大于或等于）（同JB）   JBE 小于或等于则跳转(leftOp \u0026lt;= rightOp)   JNA 不大于则跳转（同JBE）      基于有符号整数比较结果的跳转指令\n G: Grater, L: Less, E: Equal\n    助记府 描述     JG 大于则跳转(leftOp \u0026gt; rightOp)   JNLE 不（小于或等于）（同JA）   JGE 大于或等于则跳转 (leftOp \u0026gt;= rightOp)   JNL 不小于则跳转 （同JAE）   JL 小于则跳转(leftOp \u0026lt; rightOp)   JNGE 不（大于或等于）（同JB）   JLE 小于或等于则跳转(leftOp \u0026lt;= rightOp)   JNG 不大于则跳转（同JBE）    mov al, 7Fh ; (7Fh or +127) cmp al, 80h ; (80h or -128) ja IsAbove ; no : 7F not \u0026gt; 180h  mov al, 7Fh ; (7Fh or +127) cmp al, 80h ; (80h or -128) jg IsAbove ; yes: +127 \u0026gt; -128     条件循环指令   LOOPZ和LOOPE指令\n 含义：Loop if zero，Loop if equal 二者等价 执行逻辑： ECX = ECX - 1\nif ECX \u0026gt; 0 and ZF = 1, jump to destination    LOOPNZ和LOOPNE指令\n 含义：Loop if not zero， Loop if not equal 二者等价 执行逻辑： ECX = ECX - 1\nif ECX \u0026gt; 0 and ZF = 0, jump to destination  ; 扫描数组中的每个数值，直到发现正数为止 .data array SWORD -3,-6,-1,-10,10,30,40,4 sentinel SWORD 0 .code mov esi, OFFSET array mov ecx, LENGTHOF array next: test WORD PTR [esi], 8000h ; test highest bit  pushfd ; push flags on stack  add esi, TYPE array popfd ; pop flags from stack  loopnz next ; continue  jnz quit ; none found  sub esi, TYPE array ; SI points to value   整数运算指令 移位和循环移位指令 \u0026lt; notice note \u0026gt; Shift Left Right Arithmetic Rotate Carry \u0026lt; /notice \u0026gt;\n  移位指令\n   助记符 描述     SHL 逻辑左移   SHR 逻辑右移   SAL 算数左移   SAR 算数右移   ROL 循环左移   ROR 循环右移   RCL 带进位的循环左移   RCR 带进位的循环右移   SHLD 双精度左移   SHRD 双精度右移      上述指令影响OF、CF\n  逻辑移位和算术移位   循环左移ROL和循环右移ROR   带进位的循环左移RCL和右移RCR   SHLD/SHRD指令\n 格式：SHLD 目的操作数，源操作数，移位位数 要求至少是Intel386处理器 SHLD：双精度左移，Shift Left Double\n将目的操作数左移指定的位数，低位空出来的位用源操作数的高位填充 SHRD：双精度右移，Shift Right Double\n将目的操作数右移指定的位数，空出来的位由源操作数的低位来填充。    格式：\n助记符 目的操作数，移位位数\nSHL reg, imm8 SAL mem, imm8 ROR reg, CL RCL mem, CL  8088/8086要求imm8必须等于1；80286以上，imm8可以为“任意”整数 CL方式可用于任何Intel x86处理器    乘法和除法指令   MUL指令\n 格式（操作数为乘数）：\nMUL r/m8\nMUL r/m16\nMUL r/m32 功能：无符号乘法。将8位、16位或32位的操作数与AL、AX或EAX相乘    被乘数 乘数 积 CF = 1的条件     AL r/m8 AX AH $\\neq$ 0   AX r/m16 DX:AX DX $\\neq$ 0   EAX r/m32 EDX:EAX EDX $\\neq$ 0        IMUL指令：有符号乘法\n如果累积的高半部分不是低半部分的符号扩展（换而言之就是低半部分不足够表示累积），则设置CF和OF\n例：\nmov al, 48 ; 48D = 30H mov bl, 4 imul bl ; AX = 00C0h, OF = 1  mov al, -4 mov bl, 4 imul bl ; AX = FFF0h, OF = 0  mov ax, 48 mov bx, 4 imul ax ; DX:AX = 000000C0h, OF = 1   DIV指令：无符号除法\n   被除数 除数 商 余数     AX r/m8 AL AH   DX:AX r/m16 AX DX   EDX:EAX r/m32 EAX EDX      有符号整数除法\n CBW, CWD, CDQ指令  CBW(Convert Byte to Word): 将AL中的符号位扩展到AH CWD(Convert Word to Doubleword): 将AX中的符号位扩展到DX CDQ(Convert DoubleWord QuadWord): 将EAX中的符号位扩展到EDX   IDIV指令：有符号数整数的除法运算\n例： .data byteVal SBYTE -48 .code mov al, byteVal cbw ; extend AL into AH  mov bl, 5 idiv bl ; AL = -9, AH = -3  .data wordVal SWORD -5000 .code mov ax, wordVal cwd ; extend AX into DX  mov bx, 256 idiv bx ; AX = -19, DX = -136  除法溢出  当除法产生的商太大而无法容纳在目的操作数中的时候，将导致除法溢出，使CPU触发一个中断，当前程序被终止 试图除以0也会发生相同的情况 解决办法  使用32位的除数来减小除法溢出的可能性 测试除数，如果除数等于0则跳过除法指令        扩展加法和减法  ADC指令：扩展加法\n目的操作数 + 源操作数 + 进位标志-\u0026gt;目的操作数 SBB指令：扩展减法\n目的操作数 + 源操作数 - 进位标志-\u0026gt;目的操作数  ASCII和压缩十进制算数  AAA：加法之后进行ASCII码调整 mov ag, 0 mov al, \u0026#39;8\u0026#39; ; AX = 0038h add al, \u0026#39;2\u0026#39; ; AX = 006Ah aaa ; AX = 0100h or ax, 3030h ; AX = 3130h = \u0026#39;10\u0026#39;  AAS：减法之后进行ASCII码调整 AAM：乘法之后进行ASCII码调整 AAD：除法之后进行ASCII码调整 压缩的十进制整数  DAA指令：将ADD或ADC指令执行后AL中的结果转换成压缩的十进制格式 DAS指令：将SUB或SBB指令执行后AL中的结果转换成压缩的十进制格式 例： mov al, 35h add al, 48h ; AL = 7Dh daa ; AL = 83h  mov bl, 48h mov al, 85h sub al, bl ; AL = 3Dh das ; AL = 37h     字符串与数组 基本字符串操作指令    指令 描述     MOVSB, MOVSW, MOVSD 移动字符串数据：拷贝DS:(E)SI寻址的内存操作数至ES:(E)DI   CMPSB, SMPSW, CMPSD 比较字符串：比较内存中由DS:(E)SI寻址和ES:(E)DI寻址的字符串。源-目的   SCASB, SCASW, SCASD 扫描字符串：扫描ES:(E)DI指向的内存字符串查找与累加器匹配的值   STOSB, STOSW, STOSD 存储字符串：将累加器内容存储到由ES:(E)DI寻址的内存中   LODSB, LODSW, LODSD 将字符串数据装入累加器：将由DS:(E)SI寻址的内存单元装入累加器中      使用重复前缀\n 字符串操作指令每次只能处理一个内存值。 通过增加一个重复前缀，字符串指令就会使用ECX作为计数器进行重复 —— 实现用一条指令处理整个数组。 可以使用的重复前缀    REP ECX \u0026gt; 0时重复     REPZ, REPE 当ZF＝1且ECX＞0时重复   REPNE, REPNZ 当ZF＝0且ECX＞0时重复     方向标志：简单字符串指令使用方向标志来决定ESI和EDI是自动增加还是自动减少。  方向标志位 DF＝0：ESI、EDI 自动增加； 方向标志位 DF＝1：ESI、EDI 自动减少。   方向标志可以通过CLD和STD指令改变： CLD\t; 清除方向标志 STD\t; 设置方向标志     MOVSB、MOVSW 和 MOVSD 指令\n.data source DWORD 20 DUP(0FFFFFFFFh) target DWORD 20 DUP(?) .code cld\t; direction = forward mov ecx,LENGTHOF source\t; set REP counter mov esi,OFFSET source\t; ESI points to source mov edi,OFFSET target\t; EDI points to target rep movsd\t; copy doublewords   CMPSB、CMPSW 和 CMPSD 指令\n隐含执行：源-目的，这与 CMP 指令相反\nmov esi,OFFSET source mov edi,OFFSET target cld\t; direction = up mov ecx,count\t; repetition counter repe cmpsd\t; repeat while equal   SCASB、SCASW 和 SCASD 指令\n 将AL/AX/EAX中的值同目标内存(由DI寻址)中的字节、字或双字相比较。 例:扫描一个匹配字符：在字符串变量alpha中查找字母“F” .data alpha BYTE \u0026#34;ABCDEFGH\u0026#34;,0 .code mov edi,OFFSET alpha\t; EDI points to the string  mov al,\u0026#39;F\u0026#39;\t; search for the letter F  mov ecx,LENGTHOF alpha ; set the search count  cld\t; direction = up  repne scasb\t; repeat while not equal  jnz quit\t; quit if letter not found  dec edi\t; found: back up EDI quit:     STOSB、STOSW 和 STOSD 指令\n 将AL/AX/EAX的内容存储在EDI指向的内存单元中，同时EDI的值根据方向标志增加或减少。可与REP前缀联合使用。 例：将string1的每个字节初始化为0FFh。 .data count = 100 string1 BYTE count DUP(?) .code mov al,0FFh\t; value to be stored  mov edi,OFFSET string1 ; ES:DI points to target  mov ecx,count\t; character count  cld\t; direction = forward  rep stosb\t; fill with contents of AL     LODSB、LODSW 和 LODSD 指令\n 从ESI指向的内存位置向AL/AX/EAX中装入一个值，同时ESI的值根据方向标志增加或减少。 一般不与REP前缀联合使用。    二维数组  基址变址操作数：将两个寄存器的值相加(称为基址寄存器、变址寄存器)来产生偏移地址  保护模式程序中，可使用任意两个32位通用寄存器 实地址模式下，16位寄存器允许的组合是：[bx+si], [bx+di], [bp+si], [bp+di]\n:warning:应尽量避免使用BP寄存器，除非要访问堆栈操作数  .data array WORD 1000h,2000h,3000h .code mov ebx,OFFSET array mov esi,2 mov ax,[ebx+esi]\t; AX = 2000h  表格的例子    相对基址变址操作数:有效地址偏移＝偏移＋基址寄存器＋变址寄存器  几种常见的格式：  [base + index + displacement] displacement[base + index] displacement[base][index]   偏移(Displacement)：变量的名字；常量表达式 基址、变址：  保护模式：任意32位寄存器 实地址模式：BX、BP；SI、DI   表格的例子：tableB[ebx + esi]    习题 3.8 在DATA为首地址的内存区域中存放100个无符号数，试编写程序找出其中最大的数，并将其放在KVFF中。\nstack segment stack db 512 dup(?) stack ends data segment nums db 170, 248, 69, 67, 81, 104, 76, 178, 226, 201 db 234, 230, 194, 85, 206, 92, 63, 28, 211, 237, 195, 240, 225 db 126, 117, 173, 162, 78, 179, 252, 9, 202, 23, 152, 125, 32, 16 db 86, 165, 27, 190, 137, 37, 172, 13, 228, 112, 146, 75, 225, 65 db 92, 150, 38, 77, 43, 233, 94, 88, 118, 60, 127, 214, 69, 44, 25 db 134, 137, 154, 209, 167, 32, 174, 13, 178, 65, 74, 35, 234, 95 db 70, 179, 98, 140, 185, 159, 14, 114, 105, 239, 137, 147, 227, 238 db 228, 198, 135, 220, 203, 255 KVFF db ? data ends code segment assume CS:code, DS:data, SS:stack start: mov ax, data mov ds, ax mov dl, 0 mov si, OFFSET nums mov cx, 100 comp: cmp dl, BYTE PTR [si] jb exch L: inc si loop comp mov KVFF, dl mov ah, 4ch int 21h exch: mov dl, BYTE PTR [si] jmp L code ends end start 3.13 试编写程序，给从内存40000H到4BFFFH的每个单元均写入55H，并逐个单元读出比较。若写入的与读出的完全一致，则将AL置7EH，否则将AL置81H。\nstack segment stack db 512 dup(?) stack ends code segment assume cs:code, ss:stack start: mov ax, 4000h mov ds, ax mov si, 0000h mov cx, 0BFFFh write: mov BYTE PTR [si], 55h inc si loop write mov si, 0000h mov cx, 0BFFFh read: cmp BYTE PTR [si], 55h jnz not_equal equal: inc si loop read mov al, 7eh mov ax, 4c00h int 21h not_equal: mov al, 81h mov ax, 4c00h int 21h code ends end start 总线技术 总线概述 总线的分类  按连接的层次  片内总线 元件级总线 系统总线（内总线） 通信总线（外总线、I/O总线）    按数据传输位数  并行总线 串行总线    标准化总线 内总线  ISA总线(Industry Stanrard Architechure)  ISA特点  支持8位、16位操作 将将XT与AT总线的运行速度提升至8MHz 更强调I/O处理能力：64KB的I/O空间、11级硬件中断、7级DMA通道 地址、数据多路复用 是多主控设备总线、带处理器的智能卡都可以成为ISA的主控设备 曾广泛流行，支持的厂商众多   信号定义  数据总线为16位（支持8位、16位操作）  提速：$ \\overline{0WS} $，零等待状态，也叫$ \\overline{NOWS} $（No Wait State） 升位：$ \\overline{MEMCS16},\\overline{IOCS16} $ 位数可选：$ \\overline{SBHE} $   寻址能力达到16MB，地址、数据线不复用 中断扩充为11个（PC/XT位6个） DMA扩充为7个（PC/XT位4个） ISA是一种多主控总线：$\\overline{MASTER} $ 速度：CLK(B20, Output)\n4.77MHz-\u0026gt;8.33MHz-\u0026gt;12MHz     PCI总线(Peripheral Component Interconnect Local Bus)  PCI总线的特点  不依赖于处理器 扩充性好、多总线共存 具有自动配置能力，支持即插即用（PnP） 数据、地址奇偶校验功能 数据宽度32位，可扩展为64位；2.0版本支持33MHz时钟，2.1版本增加了对66MHz总线操作的支持 信号复用，支持无限读写突发操作 支持多主控设备 适应性广 并行总线操作   信号定义  PCI总线定义的信号可分为九类  系统信号 数据和地址信号 接口控制信号 仲裁信号 错误报告信号 中断信号 高速缓存支持信号 64位扩展信号 JTAG信号   PCI总线定义的信号也可分为必备和可选两大类  主控设备需要49个必备信号\n目标设备需要47必备信号 可选信号线共51个，主要用于  64位扩展 中断请求 高速缓存支持 等         PCIE总线（PCI Express）  外总线（通信总线）  RS-232C串行通信接口  特点  串行异步总线 传输信号线少  定义了20多个信号线 实际应用中一般只用到3至7条   传输距离较远。一般为15米 采用不归零编码（NRZ）和负逻辑：逻辑1为-15V至-3V，逻辑0为+3V至+15V 采用非平衡传输方式，即单端通信 传输速率较低   电气特性、引脚功能：25针/9针 D型连接器  信号  传送信息信号\nTxD：发送数据线 (DTE-\u0026gt;DCE)\nRxD：接收数据线 (DTE\u0026lt;-DCE) 联络信号\nRTS：请求发送 (DTE-\u0026gt;DCE)\nCTS：清楚发送 (DTE\u0026lt;-DCE)\nDTR：DTE准备就绪 (DTE-\u0026gt;DCE)\nDSR：SCE准备就绪 (DTE\u0026lt;-DCE)\nDCD：数据载波检测 (DTE\u0026lt;-DCE)\nRI：振铃指示 (DTE\u0026lt;-DCE)   电平     数据信号 控制信号     逻辑1 -3~-15V（传号） +3~+15V（接通，ON状态）   逻辑0 +3~+15V（空号） -3~-15V（断开，OFF状态）    （一般为12V）      例：信息格式\n传送ASCII码“C”（43H）    RS-232的应用  使用Modem连接 软硬件系统调试：控制台、超级终端 直接连接：计算机（DTE）\u0026lt;-\u0026gt; 计算机（DTE）  交叉连接方式 三线经济方式     RS423、RS422、RS485：  RS423：单端输出、差分接收（非平衡传输）  1200米 1Kbps 90米 100Kbps   RS422、RS485：差分输出、差分接收（平衡差分传输）  1200米 100Kbps 100米 1Mbps 12米 10Mbps       USB总线（Universal Serial Bus）  USB总线各版本参数比较  翻转不归零（NRZ-I）编码  当数据为0时，电平翻转；数据为1时，电平不翻转 比特填充技术：当数据中出现连续6个'1\u0026rsquo;时就必须插入1个'0' 发送数据：并行数据-\u0026gt;串行数据，比特填充，NRZI编码 接收数据：NRZI解码，去除填充比特，转换成并行数据   8b/10b编码  传送的信息以每8比特为一组被编码为一个10比特的数据；接收端将10比特数据解码还原为8比特数据 目的：使得整个比特流中尽量保持了0和1的平衡 SATA、PCI-Express也使用了8b/10b编码 USB3.2使用128b/132b编码     对USB的需求  当时PC机I/O模式的缺点  PC外设日益丰富，接口、扩展槽有限；种类日益繁多的接口电缆线 I/O资源分配(I/O空间、IRQ、DMA)-\u0026gt;接口卡一多，上述资源可能耗尽 热插拔、PnP的需求   USB2.0的特点/优点  单一接口类型 每个USB总线支持127个外设 整个USB系统只用一个端口、一个中断-\u0026gt;节省系统资源 支持热插拔、动态加载驱动程序；带电拔出后自动回收资源；PnP，自动配置 三种速率，适应不同类型外设 设备供电 四种传输类型  控制传输 同步传输 中断传输 批量传输       USB3.0   ATA总线  PATA SATA    总线的驱动和控制 总线竞争与负载  总线竞争：同一总线上，同一时刻，有两个或两个以上的器件输出其状态  TTL：此时总线上会是一种不高不低的非TTL电平，严重时会烧坏器件  对集电极开路输出：线与逻辑（Open Collector）  用三态电路严格，控制逻辑    总线的负载  直流负载  输出高电平时，驱动门的$ I_{OH} \\ge \\sum_{i=1}^{N}{IH_i} $ 输出高电平时，驱动门的$ I_{OL} \\ge \\sum_{i=1}^{N}{IL_i} $   交流负载：$ C_P \\ge (\\sum_{i=1}^{N}{C_{Ii}+$电路板布线引入的电容$+$传输线引入的电容}) $     总线驱动设计   几种常用的芯片\n 单向驱动器（三态输出）  双向驱动器（三态输出）  锁存器（三态输出）     系统总线的驱动与控制\n  扩展插件板（卡）的板内驱动\n  例题\n 某内存板，板内地址为A0000H～FFFFFH，试画出板内双向数据总线驱动与控制电路。  防止总线竞争原则：只有当CPU读本电路板内的内存地址时，才允许双向驱动器指向系统总线的三态门是导通的。 对板内内存地址进行分析，找出地址特征。A0000H～FFFFFH  设计译码电路，用来控制双向数据总线驱动器，使之满足防止总线竞争原则。    某微型机电路板上有内存C0000H～EFFFFH和接口A000H～BFFFH，试画出该电路板板内双向数据总线驱动与控制电路。（P128，例4.3）  防止总线竞争原则：只有当CPU读板内内存或读板内接口时，才允许双向数据驱动器指向系统总线的三态门是导通的。 地址分析（内存地址、接口地址）  画驱动与控制电路  几种可供选择的译码方式  基本门电路 译码器，如74LS138 译码PROM CPLD、FPGA       采用8086 CPU的微机系统，其主存地址范围为C0000H～C7FFFH，由4块大小为8k8b的芯片构成主存板，试画出板内双向数据总线驱动控制电路及单向信号驱动电路。  主存地址分析  双向数据总线驱动控制电路\u000b及单向信号驱动电路       总线设计中的工程问题 总线交叉串扰  减少总线长度 增加总线间的距离 降低总线上的负载 降低总线信号的工作频率 两条信号线之间加一条地线 减少总线的平行走向 圆滑脉冲信号的边缘 采用双绞线  总线的延时  尽量减少总线长度 采用延时小、输出输出电容小、驱动能力强的元器件 需要同步的信号线，布线时候应匹配长度  总线信号的反射  在满足系统功能的前提下，降低传输信号的频率 尽量使信号源内阻、总线特性阻抗、负载阻抗三者相匹配 限制总线长度  PC中的总线 8086微处理器16位微机：ISA总线  总线信号依据8086处理器信号定义 8086处理器与ISA总线可以实现直接对接 利用ISA总线可以直接读写主存或I/O接口  80386微处理器32位微机：与CPU无关的PCI总线  PCI总线具有较快的数据传输速率 PCI总线支持即插即用和热插拔 基于PCI总线的微机系统还支持多总线结构，进而使系统具有一定的并行操作能力  存储技术 概述 存储器的分类 主要性能指标  容量 速度：存取时间 成本：价格  常用存储器芯片及连接使用 静态随机读/写存储器（SRAM）及接口设计   静态随机读写存储器（Static Random Access Memory\n  分类\n 同步型 异步型    异步SRAM\n 典型芯片：6264（8K $\\times $ 8bit）  引线  工作过程、时序  写入时序  读出时序      连接使用  全地址译码与部分地址译码  SRAM 6264全地址译码连接  SRAM 6264部分地址译码连接    译码电路的选择  利用译码芯片  使用ROM作译码器\n现在要用4片6264构成一个存储容量为32KB的存储器，其地址空间为E0000H～E7FFFH。用一块512×4的PROM芯片63S241作为ROM译码器  利用数字比较器作译码器  利用PLD做译码器     存取时间  控制信号的连接：8088/8086 最小模式、最大模式$ M/\\overline{IO},\\overline{RD},\\overline{WR} =\u0026gt; \\overline{MEMR},\\overline{MEMW} $ 例：已知8088微处理器时钟为4.77MHz，地址延时时间$t_{da}＝110ns$，存储系统各种附加的延时时$t_D$＝200ns。问：用存取周期为250ns的存储芯片能否满足系统要求？\n$$ \\begin{align} t(R,W)+t_{da}+t_D \u0026amp;{\\le} 3T \\cr t(R,W) \u0026amp;{\\le} 3T－ t_{da}－ t_{D} \\cr 3×210－200－110 \u0026amp;＝ 320ns \\cr \\end{align} $$ 为存储器提供的存取时间\n存储器要求的存取时间为250ns → 能满足系统要求      只读存储器（ROM）及接口设计   EPROM（紫外线可擦除只读存储器）：2764芯片（8K$\\times 8bit）\n 引线  A12~A0 D7~D0 $\\overline{CE}$：片选 $\\overline{OE}$：数据输出允许 $\\overline{PGM}$：编程时：编程脉冲输入；读时：“1”   连接：若利用全地址译码将EPROM 2764接在首地址为A0000H的内存区，试画连接图  编程  擦除：紫外线 15～20min → 每单元内容均为FFH EPROM编程       EEPROM\n 典型EERROM芯片介绍：98C64A  优点：可单字节随机读写（不需擦除，直接读写） 缺点：存储密度高，单位成本高   连接使用：将55H写满98C64A     闪存EEPROM：FLASH\n NOR型  独立数据、地址总线，可以随机快速读取 读操作速度快，擦除、编程速度慢   NAND型  以页(256或512B)为单位读/编程 以块(4K、8K、16K)为单位擦除（最多4ms） 串行读取快、随机读取慢      其他存储器  双端口存储器 先进先出（FIFO）存储器 铁电存储器（FRAM）  Intel 16/32位微机系统的主存设计（SRAM部分） 8086、8088处理器的内存接口   存储器SRAM 6116（$ 2K\\times 8bit）$ 与8088的8位总线连接\n  SRAM 6116与8086的16位总线连接\n $ \\overline{A0}$选偶地址 $ \\overline{BHE} $选奇地址    存储器的字扩充   存储器的位扩充  6264与8086系统总线的连接     80386、80486的内存接口  与内存接口相关的信号  地址信号A2～A31共30个地址信号，其编码可寻址1G个32位的存储单元。这里没有A0和A1，这两个信号已在80386、80486内部译码，用于产生4个体选择信号。 体选择信号$ \\overline{BE0}～\\overline{BE3} $ 32位的数据信号D0～D31分为4个字节，分别是D0～D7、D8～D15、D16～D23 和 D24～D31。 控制信号$ M/\\overline{IO} $ $D/\\overline{C}$（数据/控制）信号，低电平为处理器中止或正在响应中断，高电平表示正在传送数据； $W/\\overline{R}$（读/写）信号，低电平表示读内存或接口，高电平表示写内存或接口     Pentium处理器的内存组织 动态随机读/写存储器（DRAM）及接口设计 简单异步DRAM  引线  地址线复用：先输入行地址，再输入列地址 $\\overline{WE}$写允许 $D_{IN}、D_{OUT} $   工作方式及时序  读操作  写操作  提前写  读变写      刷新：2-4ms刷新一次 连接使用/接口设计  行列信号的形成  读写 刷新     同步动态存储器SDRAM   概述\n SDR SDRAM（Single Data Rate Synchronous Dynamic RAM）：单倍速率同步动态随机存储器  只在时钟的上升沿传输命令、地址和数据   DDR(Double Date Rate)  时钟上升沿、下降沿各传送一次数据 从DDR2开始，接口的频率开始高于存储单元的核心频率    SDRAM和标准DRAM的主要不同  同步和异步 内部组织结构  SDRAM内部分体 标准的DRAM可以看成内部只有一个体的SDRAM   读写方式不同  SDRAM具有突发读写能力  突发(Burst)是指在同一行中相邻的存储单元连续进行数据传输的方式。 连续传输所涉及到的存储单元(列)的数量就是突发长度(Burst Lengths，BL)     智能化  在SDRAM芯片内部设置有模式寄存器 一般的标准DRAM只有一种工作模式        典型的SDRAM芯片(三星K4S511632D(32M×16 bit SDRAM))\n 引线  地址输入  行地址：RA0~RA12 列地址：CA0~CA9   bank地址输入 数据输入/输出 输出允许   常用指标  容量：存储单元×体×每单元存储位数 时钟周期 存取时间 CAS的延迟时间（Cas latency） 综合性能的评价：总延迟时间=系统时钟周期×CL模式数+存取时间   时序     SDRAM控制器\n 实现方式  以南北桥芯片组为主要核心的PC机系统 某些为微处理器中集成了SDRAM控制器 设计与CPU或系统总线连接的独立SDRAM控制器，SDRAM芯片连接在SDRAM控制器上   SDRAM的基本操作  对SDRAM的访问的三种情况  当前访问的行所在的存储体中，行缓冲器是关闭的  发送激活命令 发送读写命令和列地址 读写延迟中等   当前访问的行的数据，刚好保存在相应存储体的行缓冲器中  直接发送读/写命令和列地址 读写延迟最小   当前访问的行所在的存储体中，行缓冲器打开，存的是另一个行的数据  先发送Percharge或Precharge All命令关闭行缓冲器 再发送激活命令激活该行 最后发送读/写和列地址 读/写延迟最大       SDRAM控制器的基本组成  连续内存地址映射  交错内存地址映射：将连续的逻辑地址映射到不同的存储体中    SDRAM的控制优化  行关闭优先策略（Close-Page Policy）：行激活、列读/写、预充电 行打开优先策略（Open-Page Policy）  访问请求空间局部性很好，大大减少读写延迟 访问请求空间分布很分散，造成较大读写延迟        DDR SDRAM  DDR SDRAM与SDRAM的不同  初始化 时钟 数据选取脉冲 写入延时 突发长度和写入掩码  DDR SDRAM，突发长度只有2、4、8，没有SDRAM的随机存取的操作和全页触发方式；同时，突发长度的定义不再指所连续寻址的存储单元数量，而是指连续的传输周期数 对于突发写入，如果其中有不想存取的数据，仍可以使用DM信号进行屏蔽   延迟锁定回路    习题 5.5 已有两片6116，现在欲将它们连接到8088系统中去，其地址范围为40000H~40FFFH，试画连接电路图，写入某数据并读出与之比较；如有错，则在DL中写入01H；若每个单元均对，则在DL中写入EEH，试编写此检测程序。\n5.10 将4片6264连接到8086系统总线上，要求内存地址范围为7000H~77FFFH，画出连接图。\n5.16 现有容量为32K×4bit的SRAM芯片。\n在8086系统中，利用这样的芯片构成从88000H～97FFFH的内存，画出最大模式下包括总线驱动在内的此芯片与系统总线的连接图（译码器件自行选择）\n输入输出技术 I/O概述 基本输入/输出方法  程序控制I/O方式  无条件传送方式：输入接口、输出接口 查询方式：单外设、多外设 中断防守   DMA（直接存储器）方式  I/O接口概述  I/O接口能做什么  提供信息通道 进行数据格式转换 CPU和外设速度匹配 负载匹配 时序匹配 总线隔离 提供中断、DMA能力   外设接口与端口  统一编址的优点  CPUduiI/O端口的读写操作可是使用全部存储器的读/写数据操作指令 内存与外设地址的分配可以用统一的分配图 不需要专门的输入、输出操作指令   统一编址的缺点  使得系统中实际可以直接寻址的内存单元数减少 给检修、维护增加了难度 一般系统中I/O端口数远小于内存单元数，所以统一编址使得指令代码较长，读/写执行时间也较长 Motorola的M68系列采用统一编址，Intel的86x86系列CPU采用独立编址方式      I/O端口地址译码 基本的并行输入（三态门）/输出（锁存器）接口  并行输入接口  并行输出接口   程序查询I/O方式 无条件传送方式 查询方式  多外设的查询控制   中断方式 8086/8088中断系统  中断源类型  与中断有关的控制线：$ NMI、INTR、\\overline{INTA} $ 8088系统中的中断源  内部中断  除法溢出：类型号为0 单步中断：类型号为1 断点中断：类型号为3 溢出中断：类型号为4 软件中断：即INT n指令   外部中断  非屏蔽中断NMI：类型号为2，不可用软件屏蔽，CPU必须响应它 可屏蔽中断INTR：类型号由PIC提供。IF=1时CPU才能响应它       中断向量表（IVT）  用于存放各类中断服务程序的入口地址（段和偏移） 表的地址位于内存的00000H~003FFH，大小为1KB，共256个入口 每个入口占4 Bytes 中断向量在IVT中的存放地址 = 4 * 中断类型号    可编程中断控制器8259   8259内部结构  中断请求寄存器IRR 中断服务寄存器ISR 中断屏蔽寄存器IMR 中断优先权判别电路    引脚功能   8259工作方式\n 中断结束方式  非自动：在中断程序中提供EOI命令 自动：无需EOI命令、第2个$\\overline{INTA}$后沿   缓冲方式：缓冲、非缓冲 嵌套方式  一般嵌套：单片使用；级联方式从属 特殊嵌套：级联方式主控制器   屏蔽方式：一般屏蔽、特殊屏蔽 优先级规定：固定优先级、循环优先级     8259级联   8259编程使用\n 内部寄存器的寻址方法  初始化命令字ICW  注意  写ICW1意味着重新初始化8259 写ICW1后，8259的状态如下  清除ISR和IMR（全0） 将中断优先级设置为初始状态 设置为一般屏蔽方式 采用非自动中断结束方式 状态读出逻辑预置为读IRR     ICW1：初始化字  ICW2：中断向量码  ICW3：级联控制字  ICW4：中断结束方式字    操作命令字OCW  OCW1：中断屏蔽字  OCW2：中断结束和优先级循环  OCW3：屏蔽方式和读出控制字       中断方式及实现方法  连接8259  编写中断初始化程序  初始化8259  设置中断向量表  中断服务程序框架     直接存取器（DMA）方式 DMA工作过程  通过特殊硬件DMA控制器实现，传输速率高 外设直接与存储器进行数据交换，CPU不再作为中介者 总线由DMA控制器（DMAC）进行控制，CPU放弃总线控制权，内存/外设的地址和读写控制信号均由DMAC提供  习题 6.6 叙述8086/88软件中断指令INT n的执行过程\n CPU取INT n指令，经指令译码获知这是一条中断指令，且该软件中断的中断向量码为n 将PSW、CS、IP压入堆栈保护起来，并关中断 $ n \\times 4 $ 得到中断向量表地址，从该地址开始的顺序两个字节的内容送IP，下两个字节的内容送CS，即$n \\times 4\\to IP,(n\\times4+2)\\to CS $ 开始执行中断服务程序。（中断服务程序的入口地址早已填入中断向量表中） 中断服务程序的最后一条指令IRET，从堆栈恢复IP、CS、PSW，中断返回  6.8 输入接口地址为04E5H，输出接口地址为E504H。 编程序： 若输入接口的bit3、bit4和bit7同时为1，将以DATA为首地址的10个内存数据连续由输出接口输出，若不满足条件则等待\n6.9 若：系统只有一片8259，8259地址为E010H和E011H，允许8个中断源边沿触发，不需要缓冲，以一般嵌套方式工作，中断向量为40H，非自动EOI方式\n 编写初始化程序  若允许中断嵌套，编写中断服务程序框架，包括返回前发送EOI命令。中断服务程序名称为IPROC40  编程序，将上述中断处理程序的入口地址填入中断向量表   常用接口器件 计算机和外设之间如何通过接口传送数据（非DMA） 可编程并行接口8255 内部结构及外部总线 8255的工作方式  工作方式0：基本输入输出方式  A口（PA0~PA7）：输入（无锁存能力）或输出（有锁存能力） B口（PB0~PB7）：输入（无锁存能力）或输出（有锁存能力） C口（PC4~PC7）：输入（无锁存能力）或输出（有锁存能力） C口（PC0~PC3）：输入（无锁存能力）或输出（有锁存能力）   工作方式1：选通输入输出方式  工作方式2：双向输入输出方式（仅A口）  PC3-PC7：A口方式2下的控制线 PC0-PC2：输入或输出或B口方式1下的控制线 B口：方式0或方式1    8255的方式控制字及状态字  控制字  状态字   8255的寻址及连接使用 8255的初始化及应用举例  方式0——打印机接口  方式1——打印机接口  程序查询方式  中断方式     可编程定时器8253 工作方式  方式0：计数结束产生中断  方式1：可编程单稳  方式2：频率发生器  方式3：方波发生器  方式4：软件触发选通  方式5：硬件触发选通   8253的控制字 习题 7.1 若8253芯片可利用8088的外设接口地址为D0D0H～D0D3H，试画出电路连接图。设加到8253上的时钟信号为2MHz。 若利用计数器0、1和2产生周期为100μs的对称方波以及每1s、10s产生一个负脉冲，试说明8253如何连接，并编写初始化程序。 7.2  若8255芯片可占用的地址为FE00～FEFFH，试画出它与8086总线的连接图。 A/D变换器的引线及工作时序图如下，试将此A/D变换器与8255相连接，并编写包括初始化程序在内的、变换一次数据并将数据放在DATA中的程序  7.3 说明8253的6种工作方式。若如加到8235上的时钟频率为0.5MHz，则一个计数器的最长定时时间是多少？若要求美10min产生一次定时中断，试提出解决方案\n 方式0：计数结束中断，输出一个正跳变 方式1：硬件可重复触发的单稳态触发器，输出一个宽度可调的负脉冲 方式2：比率发生器，输出序列负脉冲 方式3：方波发生器 方式4：软件触发延时选通脉冲发生器 方式5：硬件触发延时选通脉冲发生器  加到8253上的时钟频率是0.5MHz，则一个计数器的最长定时时间是$\\frac {65536} {0.5\\times 10^6}=0.131072 s$（初值为0）\n计数器0和计数器1都工作于方式3（循环计数，产生周期性方波），两个计数器串联，计数器0的输出作为计数器1的时钟，计数器1的输出作为cpu中断信号用于产生定时中断。设计数器0的计数值=30000，计数器1的计数值=10000，则每计数30000×10000=3×1e8次，也即每2μs×3×108=600s=10min 产生一次定时中断\n基于总线的I/O接口设计 基于ISA总线的I/O接口设计 LED接口  接口电路  用通用并行接口芯片作接口  用LED译码器作接口：DM9368 利用上图电路中的4个数码管，实现将存储单元 BUF中的4位十六进制数加以显示，并每经过1秒，重新读取BUF单元数据，更新显示，则控制程序如下：    动态显示的接口电路  用通用接口芯片  用专用接口芯片：MM74C912/917     键盘接口  非编码式键盘   ","permalink":"https://fffzlfk.github.io/posts/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/","summary":"西电微机原理","title":"微机原理"},{"content":"复制构造函数 :laptop:笔者在学习OOP时，看到一个讲C++复制构造函数在什么情况下会执行的代码片段，如下：\nclass Student { public: Student(){}; Student returnS(Student s) { return s; } Student(const Student \u0026amp;e) { cout \u0026lt;\u0026lt; \u0026#34;Copy Constructure\\n\u0026#34;; } ~Student() { cout \u0026lt;\u0026lt; \u0026#34;Destructure\\n\u0026#34;; } }; int main() { Student stu1; stu1.returnS(stu1); return 0; } 于是乎，笔者在电脑上敲了一边，确实按照预期复制构造函数执行了两次，第一次在构造形参对象时执行，第二次在返回值复制到主函数产生临时对象时执行。\n接着笔者将主函数修改为\nint main() { Student stu1; Student stu2 = stu1.returnS(stu1); return 0; } 心想：不出意外在构造stu2时，会再执行一次复制构造函数，然而当笔者看到运行结果后，发现并非如此，复制构造函数还是执行了两次，于是笔者陷入了大思考。\n想到可能是聪明的编译器是不是帮我优化掉了临时对象，直接复制构造了stu2。导致了上面的代码经过优化之后和这样写其实是一样的：\nint main() { Student stu1; Student \u0026amp;\u0026amp;stu2 = stu1.returnS(stu1); return 0; } 右值引用\nC++中，引用（reference）是指绑定到内存中的相应对象上。左值引用是绑定到左值对象上；右值引用是绑定到临时对象上。这里的左值对象是指可以通过取地址\u0026amp;运算符得到该对象的内存地址；而临时对象是不能用取地址\u0026amp;运算符获取到对象的内存地址。\n于是经过几番搜索，找到了这个东西：\n-fno-elide-constructors\nThe C++ standard allows an implementation to omit creating a temporary that is only used to initialize another object of the same type. Specifying this option disables that optimization, and forces G++ to call the copy constructor in all cases.\n果然不出所料，当笔者加上这个参数之后\ng++ test_ref.cpp -o test -fno-elide-constructors 一切都对劲了起来:smile:！\n移动构造函数 使用移动构造函数可以提高内存资源的利用效率，从而改进程序的执行性能。\n示例程序\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; class A { public: int *i; A(int _i) : i(new int(_i)) { cout \u0026lt;\u0026lt; \u0026#34;A(int) \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ~A() { cout \u0026lt;\u0026lt; \u0026#34;delete pointer: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; delete i; } // 复制构造函数  A(const A \u0026amp;a) : i(new int(*a.i)) { cout \u0026lt;\u0026lt; \u0026#34;A(const A\u0026amp;) \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } // 移动构造函数  A(A \u0026amp;\u0026amp;a) : i(new int(*a.i)) { cout \u0026lt;\u0026lt; \u0026#34;A(const A\u0026amp;\u0026amp;) \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; a.i = nullptr; } }; A getA(A para) { A tmp(2); cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; tmp.i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return tmp; } int main() { A a(1); A b = getA(a); cout \u0026lt;\u0026lt; a.i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 运行结果\nA(int) 0x8016eb0 构造a对象\rA(const A\u0026amp;) 0x80172e0 参数复制构造para\rA(int) 0x8017300 构造tmp对象\r0x8017300\rA(const A\u0026amp;\u0026amp;) 0x8017320 调用移动构造函数(临时对象构造返回值)\rdelete pointer: 0 析构临时对象\rA(const A\u0026amp;\u0026amp;) 0x8017340 调用移动构造函数(返回值移动到b对象)\rdelete pointer: 0 析构临时对象(指返回值)\rdelete pointer: 0x80172e0 析构函数para\r0x8016eb0 delete pointer: 0x8017340 析构b对象\rdelete pointer: 0x8016eb0 析构a对象\r","permalink":"https://fffzlfk.github.io/posts/c++%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E6%9E%90/","summary":"关闭编译器优化","title":"C++(临时对象的分析)"},{"content":"Union-Find quickfind Java implementation public class QuickFindUF { private int[] id; private int count; public QuickFindUF(int n) { id = new int[n]; for (int i = 0; i \u0026lt; n; i++) id[i] = i; count = n; } public int count() { return count; } public int find(int p) { return id[p]; } public boolean connected(int p, int q) { return find(p) == find(q); } public void union(int p, int q) { int pid = find(p); int qid = find(q); if (pid != qid) { for (int i = 0; i \u0026lt; id.length; i++) if (id[i] == pid) { id[i] = qid; } } count--; } public static void main(String[] args) { Scanner in = new Scanner(System.in); QuickFindUF uf = new QuickFindUF(10); while (in.hasNext()) { int p = in.nextInt(), q = in.nextInt(); if (uf.connected(p, q)) continue; uf.union(p, q); } } } analysis The find() operation is certainly quick, as it only accesses the id[] array once in order to complete the operation. But quick-find is typically not useful for large problems because union() needs to scan through the whole id[] array for each input pair.\nquick-union implementation import java.util.Scanner; public class QuickUnionUF { private int[] id; private int count; public QuickUnionUF(int n) { id = new int[n]; for (int i = 0; i \u0026lt; n; i++) id[i] = i; count = n; } public int count() { return count; } public int find(int p) { while (p != id[p]) { p = id[p]; } return p; } public boolean connected(int p, int q) { return find(p) == find(q); } public void union(int p, int q) { int pRoot = find(p); int qRoot = find(q); if (pRoot != qRoot) { id[pRoot] = qRoot; } else return; count--; } public static void main(String[] args) { Scanner in = new Scanner(System.in); QuickUnionUF uf = new QuickUnionUF(10); while (in.hasNext()) { int p = in.nextInt(), q = in.nextInt(); if (uf.connected(p, q)) continue; uf.union(p, q); } } } quick-union worst case Weighted quick-union import java.util.Scanner; public class WeightedQuickUnionUF { private int[] id; private int[] sz; private int count; public WeightedQuickUnionUF(int N) { count = N; id = new int[N]; sz = new int[N]; for (int i = 0; i \u0026lt; N; i++) { id[i] = i; } for (int i = 0; i \u0026lt; N; i++) sz[i] = 1; } public int find(int p) { while (p != id[p]) { id[p] = id[id[p]]; // path compression by halving  p = id[p]; } return p; } public boolean connected(int p, int q) { return find(p) == find(q); } public void union(int p, int q) { int i = find(p); int j = find(q); if (i == j) return; if (sz[i] \u0026lt; sz[j]) { id[i] = j; sz[j] += sz[i]; } else { id[j] = i; sz[i] += sz[j]; } count--; } public static void main(String[] args) { Scanner in = new Scanner(System.in); WeightedQuickUnionUF uf = new WeightedQuickUnionUF(10); while (in.hasNext()) { int p = in.nextInt(), q = in.nextInt(); if (uf.connected(p, q)) continue; uf.union(p, q); } } } Performance characteristics of union-find algorithms    algorithm constructor union find     quick-find N N 1   quick-union N tree height tree height   weighted quick-union N lgN lgN   weighted quick-union with path compression N very, very nearly, but not quite 1 same as union   impossible N 1 1    Analysis of Algorithms Scientific method The very same approach that scientists use to understand the natural world is effective for studying the running time of programs.\n Observe some feature of the natural world, generally with precise measurement. Hypothesize a model that is consistent with observations. Predict events using the hypothesis. Verify the predictions by making further observations. Valitate by repeating until the hypothesis and observations agree.  Mathematical models  Tilde approximations. We use tilde approximations, where we throw away low-order terms that complicate formulas. We write ~f(N) to represent any function that when divided by f(N) approaches 1 as N grows. We write g(N)~f(N) to indicate that g(N)/f(N) approaches 1 as N grows. Order-of-growth classifications. Most often, we work with tilde approximations of the form g(N)~af(N) where $ f(N) = N^b log_c N $ and refer to f(N) as the The order of growth of g(N). We use just a few structural primitives (statements, conditionals, loops, nesting, and method calls) to implement algorithms, so very often the order of growth of the cost is one of just a few functions of the problem size N.     function tilde approximation order of growth     $ \\frac{N^3}{6}-\\frac{N^2}{2}+\\frac N 3 $ $~\\frac{N^3}{6} $ $N^3$   $ \\frac{N^3}{2}-\\frac N 2$ $ ~\\frac{N^2}{2} $ $N^2$   $lgN+1 $ $~lgN$ $lgN$   3 ~3 1     Cost model. We focus attention on properties of algorithms by articulating a cost model that defines the basic operations. For example, an appropriate cost model for the 3-sum problem is the number of times we access an array entry, for read or write.  Commonly-used Notations in the Theory of Algorithms    notation provides example shorthand for used to     Big Theta asympatotic order of growth $ \\Theta (N^2) $ $\\frac 1 2 N^2, 5N^2+22NlogN+3N$ classify algorithms   Big Oh $\\Theta (N^2)$and smaller $O(N^2)$ $10N^2,\\ 100N, 22NlogN+3N $ develop upper bounds   Big Omega $\\Theta (N^2)$and larger $\\Omega (N^2)$ $\\frac 1 2 N^2, N^5, N^3+22NlogN+3N $ develop lower bounds    1.4.6 Give the order of growth (as a function of N ) of the running times of each of the following code fragments:\nint sum = 0; for (int n = N; n \u0026gt; 0; n /= 2) for(int i = 0; i \u0026lt; n; i++) sum++; $$ N+\\frac N 2+\\frac N 4+\\frac N 8+\u0026hellip;+1=2N-1\\ \\ \\sim 2N $$ 所以是线性\nint sum = 0; for (int i = 1 i \u0026lt; N; i *= 2) for (int j = 0; j \u0026lt; i; j++) sum++; $$ 1+2+4+8+\u0026hellip;+2^{\\lfloor lgN \\rfloor}=2^{\\lfloor lgN \\rfloor + 1}-1\\ \\ \\sim 2N$$ 所以是线性\nint sum = 0; for (int i = 1 i \u0026lt; N; i *= 2) for (int j = 0; j \u0026lt; N; j++) sum++; $$ NlgN $$ 线性对数\n1.4.15 Faster 3-sum. As a warmup, develop an implementation TwoSumFaster that uses a linear algorithm to count the pairs that sum to zero after the array is sorted (in stead of the binary-search-based linearithmic algorithm). Then apply a similar idea to develop a quadratic algorithm for the 3-sum problem.\npublic static int twoSumFaster(int[] a) { int lo = 0, hi = a.length - 1; int cnt = 0; while (lo \u0026lt; hi) { if (a[lo] + a[hi] == 0) { cnt++; lo++; hi--; } else if (a[lo] + a[hi] \u0026gt; 0) hi--; else lo++; } return cnt; } public static int threeSumFaster(int[] a) { int cnt = 0; for (int i = 0; i \u0026lt; a.length; i++) { int lo = i + 1, hi = a.length - 1; while (lo \u0026lt; hi) { if (a[i] + a[lo] + a[hi] == 0) { cnt++; lo++; hi--; } else if (a[i] + a[lo] + a[hi] \u0026gt; 0) hi--; else lo++; } } return cnt; } MegerSort Implementation public class Merge { private static boolean isSorted(Comparable[] a, int lo, int hi) { for (int i = lo + 1; i \u0026lt;= hi; i++) if (less(a[i], a[i - 1])) return false; return true; } private static boolean less(Comparable v, Comparable w) { return v.compareTo(w) \u0026lt; 0; } private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) { assert isSorted(a, lo, mid); assert isSorted(a, mid + 1, hi); for (int k = lo; k \u0026lt;= hi; k++) aux[k] = a[k]; int i = lo, j = mid + 1; for (int k = lo; k \u0026lt;= hi; k++) { if (i \u0026gt; mid) a[k] = aux[j++]; else if (j \u0026gt; hi) a[k] = aux[i++]; else if (less(aux[j], aux[i])) a[k] = aux[j++]; else a[k] = aux[i++]; } assert isSorted(a, lo, hi); } private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) { if (hi \u0026lt;= lo) return; int mid = lo + (hi - lo) / 2; sort(aux, a, lo, mid); sort(aux, a, mid+1, hi); merge(a, aux, lo, mid, hi); } public static void sort(Comparable[] a) { Comparable[] aux = new Comparable[a.length]; sort(a, aux, 0, a.length - 1); } public static void main(String[] args) { int N = StdIn.readInt(); Comparable[] a = new Comparable[N]; for (int i = 0; i \u0026lt; N; i++) a[i] = StdRandom.uniform(-10000,10000); Stopwatch stopwatch = new Stopwatch(); sort(a); for (var i : a) { System.out.print(i + \u0026#34; \u0026#34;); } System.out.println(); System.out.println(stopwatch.elapsedTime()); } } Empirical analysis The number of compares $C(N)$ and array accesses $A(N)$ to mergesort an array of size N satisfy the recurrences:\n$$ C(N) \\le C(\\lceil{\\frac N 2}\\rceil) + C(\\lfloor{\\frac N 2}\\rfloor) + N\\ \\ for N \u0026gt; 1,with \\ C(1)=0. $$ $$ A(N) \\le A(\\lceil{\\frac N 2}\\rceil) + A(\\lfloor{\\frac N 2}\\rfloor) + 6N\\ \\ for N \u0026gt; 1,with \\ A(1)=0. $$ we solve the recurrence when $ N $ is a power of 2. $$ D(N) = 2D(\\frac N 2) + N, for N \u0026gt; 1, with\\ D(1) = 0. $$\nDivide-and-conquer recurrence:   proof by picture\n  proof by expansion\n$$ \\begin{aligned} D(N)\u0026amp;=2D(N/2)+N \\cr {D(N)} /{N} \u0026amp;= 2D(N / 2)/N + 1\\cr \u0026amp;= D(N/2)/(N/2)+1 \\cr \u0026amp;= D(N/4)/(N/4) + 1 + 1\\cr \u0026amp;= D(N/8)/(N/8) + 1 + 1 + 1\\cr \u0026hellip;\\cr \u0026amp;= D(N/N)/(N/N)+1+1+\u0026hellip;+1\\cr \u0026amp;= lgN \\end{aligned} $$\n  proof by induction\n Base case: $N = 1$ Induction hypothesis: $D(N)=Nlg(N)$. Goal: showthat $ D(2N) = (2N)lg(2N).$  $$ \\begin{aligned} D(2N) \u0026amp;= 2D(N)+2N \\cr \u0026amp;= 2NlgN+2N \\cr \u0026amp;= 2N(lgN+1) \\cr \u0026amp;= 2Nlg(2N) \\end{aligned} $$\n  practical improvements private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) { // Use insertion sort for samll subarrays.  final int CUTOFF = 7; if (hi \u0026lt;= lo + CUTOFF - 1) { Insertion.sort(a, lo, hi); return; } int mid = lo + (hi - lo) / 2; sort(a, aux, lo, mid); sort(a, aux, mid + 1, hi); // Stop if already sorted.  if (!less(a[mid+1], a[mid])) return; merge(a, aux, lo, mid, hi); } Eliminate the copy to the auxiliary array.\nprivate static void merge(Comparable[] a,Comparable[] aux, int lo, int mid, int hi) { int i = lo, j = mid + 1; for (int k = lo; k \u0026lt;= hi; k++) { if (i \u0026gt; mid) aux[k] = a[j++]; else if (j \u0026gt; hi) aux[k] = a[i++]; else if (less(a[j], a[i])) aux[k] =a[j++]; else aux[k] = a[i++]; } } private static void sort(Comparable[] a,Comparable[] aux, int lo, int hi) { if (hi \u0026lt;= lo) return; int mid = lo + (hi - lo) / 2; //switch soles of aux[] and a[]  sort(aux, a, lo, mid); sort(aux, a, mid+1, hi); merge(a, aux, lo, mid, hi); } Bottom-up mergesort Implementation private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) { for (int k = lo; k \u0026lt;= hi; k++) aux[k] = a[k]; int i = lo, j = mid + 1; for (int k = lo; k \u0026lt;= hi; k++) { if (i \u0026gt; mid) a[k] = aux[j++]; else if (j \u0026gt; hi) a[k] = aux[i++]; else if (less(aux[j], aux[i])) a[k]= aux[j++]; else a[k] = aux[i++]; } } public static void sort(Comparable[] a) { int N = a.length; Comparable[] aux = new Comparable[N]; for (int sz = 1; sz \u0026lt; N; sz = sz + sz) for (int lo = 0; lo \u0026lt; N - sz; lo +=sz + sz) merge(a, aux, lo, lo + sz -1,Math.min(lo+sz+sz-1, N-1)); } public static void main(String[] args) { int N = StdIn.readInt(); Comparable[] a = new Comparable[N]; for (int i = 0; i \u0026lt; N; i++) a[i] = StdRandom.uniform(-1000010000); Stopwatch stopwatch = new Stopwatch(); sort(a); for (var i : a) { System.out.print(i + \u0026#34; \u0026#34;); } System.out.println(); System.out.println(stopwatch.elapsedTim()); } Sorting Complexity  Model of computation: decision tree. Cost model: # compares. Upper bound: $\\sim NlgN $from mergesort Lower bound: ? Optimal algorithm: ?  Compare-based lower bound for sorting   Proposition. Any Compare-based sorting algorothm must use at least $lg(N!)\\sim NlogN $(Stirling formula) compares in the worst-case.\n  Pf.\n Assume array consists of $N$ distinct values $a_1$ through $ a_n $. Worst case dictated by height $h$ of decision tree. Binary tree of height $h$ has at most $2^h$ leaves. $N! $different orderings $\\Rightarrow$ at least $ N!$ leaves.  $$ \\begin{aligned} 2^h \\ge ＃leaves \\ge N! \\cr \\Rightarrow h \\ge lg(N!)\\sim NlgN \\end{aligned}$$\n  Stability  Insertion sort is stable: Equal items never move fast each other. private static void insertionSort(Comparable[] a) { int N = a.length; for (int i = 0; i \u0026lt; N; i++) { for (int j = i; j \u0026gt; 0 \u0026amp;\u0026amp; less(a[j], a[j - 1]); j--) exch(a, j, j - 1); } }  Selection sort is not stable: Long-distance exchange might move an item past some equal item. private static void selectionSort(Comparable[] a) { int N = a.length; for (int i = 0; i \u0026lt; N; i++) { int min = i; for (int j = i + 1; j \u0026lt; N; j++) if (less(a[j], a[min])) min = j; exch(a, i, min); } }  Shellsort is not stable: Long-distence exchange. private static void shellSort(Comparable[] a) { int N = a.length; int h = 1; while (h \u0026lt; N / 3) h = 3 * h + 1; while (h \u0026gt;= 1) { for (int i = h; i \u0026lt; N; i++) { for (int j = i; j \u0026gt; h \u0026amp;\u0026amp; less(a[j], a[j - h]); j -= h) exch(a, j, j - h); } h /= 3; } }  Mergesort is stable.: Suffices to verify that merge operation is table.  2.2.2 Give traces, in the style of the trace given with Algorithm 2.4, showing how the keys E A S Y Q U E S T I O N are sorted with top-down mergesort.\n          a[]            lo mid hi 0 1 2 3 4 5 6 7 8 9 10 11      E A S Y Q U E S T I O N   0 0 1 A E S Y Q U E S T I O N   0 1 2 A E S Y Q U E S T I O N   3 3 4 A E S Q Y U E S T I O N   3 4 5 A E S Q U Y E S T I O N   0 2 5 A E Q S U Y E S T I O N   6 6 7 A E Q S U Y E S T I O N   6 7 8 A E Q S U Y E S T I O N   9 9 10 A E Q S U Y E S T I O N   9 10 11 A E Q S U Y E S T I N O   6 8 11 A E Q S U Y E I N O S T   0 5 11 A E E I N O Q S S T U Y      A E E I N O Q S S T U Y    2.2.3 Answer Exercise 2.2.2 for bottom-up mergesort.\n          a[]            lo mid hi 0 1 2 3 4 5 6 7 8 9 10 11      E A S Y Q U E S T I O N   0 0 1 A E S Y Q U E S T I O N   2 2 3 A E S Y Q U E S T I O N   4 4 5 A E S Y Q U E S T I O N   6 6 7 A E S Y Q U E S T I O N   8 8 9 A E S Y Q U E S I T O N   10 10 11 A E S Y Q U E S I T N O   0 1 3 A E S Y Q U E S I T N O   4 5 7 A E S Y E Q S U I T N O   8 9 11 A E S Y E Q S U I N O T   0 3 7 A E E Q S S U Y I N O T   0 7 11 A E E I N O Q S S T U Y      A E E I N O Q S S T U Y    2.2.4 Does the abstract in-place merge produce proper output if and only if the two input subarrays are in sorted order? Prove your answer, or provide a counterexample.(是否当且仅当两个输入的数组都有序时原地归并的抽象方法才能得到正确的结果？证明你的结论，或者给出一个反例。)\n 是的，只有当两个输入数组都有序时采用原地归并才能得到正确的结果。 反例：数组1：[4, 2, 3],数组2：[1, 5, 8];\n按归并算法归并后得到[1,4,2,3,5,8]; 可以看到归并后元素的相对位置不变，故得到错误的结果。  2.2.5 Give the sequence of subarray sizes in the merges performed by both the top-down and the bottom-up mergesort algorithms, for N = 39. (当输入数组的大小N=39时，给出自顶向下和自底向上的归并排序中各归并子数组的大小及顺序。)\n自顶向下 2, 3, 2, 5, 2, 3, 2, 5, 10, 2, 3, 2, 5, 2, 3, 2, 5, 10, 20, 2, 3, 2, 5, 2, 3, 2, 5, 10, 2, 3, 2, 5, 2, 2, 4, 9, 19, 39\n自底向上 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 8, 8, 8, 8, 7, 16, 16, 32, 39\nQuickSort quicksort Basic plan:\n Shuffle the array Partition so that, for some j  entry a[j] in place no larger entry to the left of j no smaller entry to the right of j   Sort each piece recursively.  Java implementation public class Quick { private static boolean less(Comparable v, Comparable w) { return v.compareTo(w) \u0026lt; 0; } private static void exch(Comparable[] a, int i, int j) { Comparable t = a[i]; a[i] = a[j]; a[j] = t; } private static int partition(Comparable[] a, int lo, int hi) { int i = lo, j = hi + 1; while (true) { while (less(a[++i], a[lo])) if (i == hi) break; while (less(a[lo], a[--j])) if (j == lo) break; if (i \u0026gt;= j) break; exch(a, i, j); } exch(a, lo, j); return j; } private static void sort(Comparable[] a) { StdRandom.shuffle(a); sort(a, 0, a.length - 1); } private static void sort(Comparable[] a, int lo, int hi) { if (lo \u0026gt;= hi) return; int j = partition(a, lo, hi); sort(a, lo, j - 1); sort(a, j + 1, hi); } } average-case analysis $C_N $ satisfies the recurrence $C_0 = C_1=0$ and for $ N\\ge 2 $:\n$$ C_N = (N + 1) + (\\frac{C_0+C_{N-1}}{N})+ (\\frac{C_1+C_{N-2}}{N})+ \u0026hellip; +(\\frac{C_{N-1}+C_{0{N}}}) $$\n  Multiply both sides by N and collect terms: $$ NC_N = N(N+1)+2(C_0+C_1+\u0026hellip;+C_{N-1}) $$\n  Substract this from the same equation for $N - 1$: $$ NC_N-(N-1)C_{N-1}=2N+2C_{N-1} $$\n  Rearrage terms and devide by $N(N+1)$: $$ \\frac{C_N}{N+1} = \\frac{C_{N-1{N}}} + \\frac{2}{N+1} $$\n  Repeatedly apply above equation: $$ \\begin{aligned} \\frac{C_N}{N+1} \u0026amp;= \\frac{C_{N-1}}{N}+\\frac{2}{N+1} \\cr \u0026amp;= \\frac{C_{N-2}}{N-1}+\\frac{2}{N}+\\frac{2}{N+1} \\cr \u0026amp;= \\frac{C_{N-3}}{N-2}+\\frac{2}{N-1}+\\frac{2}{N}+\\frac{2}{N+1} \\cr \u0026amp;= \\frac 2 3 + \\frac 2 4 + \\frac 2 5 +\u0026hellip;+\\frac 2 {N+1} \\end{aligned} $$\n  Approximate sum by an integral: $$ \\begin{aligned} C_N \u0026amp;= 2(N+1)(\\frac 1 3 + \\frac 1 4 + \\frac 1 5 +\u0026hellip;+ \\frac{1}{N+1}) \\cr \u0026amp; \\sim 2(N+1) \\int_{3}^{N+1}{\\frac{1}{x}dx} \\end{aligned} $$\n  Finally, the desired result: $$ C_N \\sim 2(N+1)lnN \\sim 1.39NlgN $$\n  3-way quicksort template \u0026lt;typename T\u0026gt; void threeWayQuickSort(T a[], int lo, int hi) { if (hi \u0026lt;= lo) return; int lt = lo, gt = hi; T v = a[lo]; int i = lo; while (i \u0026lt;= gt) { if (a[i] \u0026lt; v) swap(a[lt++], a[i++]); else if (a[i] \u0026gt; v) swap(a[gt--], a[i]); else i++; } threeWayQuickSort(a, lo, lt - 1); threeWayQuickSort(a, gt + 1, hi); } 2.3.1 Show, in the style of the trace given with partition(), how that method patitions the array E A S Y Q U E S T I O N.\n   i j 0 1 2 3 4 5 6 7 8 9 10 11     0 12 E A S Y Q U E S T I O N   2 6 E A S Y Q U E S T I O N   2 6 E A E Y Q U S S T I O N   3 2 E A E Y Q U S S T I O N    2 E A E Y Q U S S T I O N    2.3.2 Show, in the style of the quicksort trace given in this section, how quicksort sorts the array E A S Y Q U E S T I O N (for the purposes of this exercise, ignore the initial shuffle).\n2.3.3 What is the maximum number of times during the execution of Quick.sort() that the largest item can be exchanged, for an array of length N ? (对于长度为N的数组，在Quick.sort()执行时，其最大的元素最多会被交换多少次？)\n在Quick.sort()中，一个元素被交换可分为两种情况：\n 该元素是枢轴，在partition最后一步和j交换 该元素在本次partition中不是枢轴，出现在了枢轴错的一侧，需要被交换到另一侧   如果该元素是枢轴，那么在交换后它的位置就固定下来了，之后不再涉及交换，因此要使交换次数最大，这个元素应该是在每次partition时都位于枢轴错误的一侧，因为是最大的元素，所以应该总是在枢轴的左侧。 为了使得partition的次数尽可能的多，需要使得每次移动的距离短，这里我们先考虑每次移动一位，如数组[5,9,1,6,7]：  枢轴为5，交换后变为[5,1,9,6,7] 枢轴交换，变为[1,5,9,6,7] 我们发现在下一次partition中最大元素9会成为枢轴，不再被交换   所以考虑每次移动两位，如数组[2,10,4,1,6,3,8,5,7,9]  枢轴为2，交换后[2,1,4,10,6,3,8,5,7,9] 枢轴交换，变为[1,2,4,10,6,3,8,5,7,9] 枢轴为4，交换后[1,2,4,3,6,10,8,5,7,9] 枢轴交换，变为[1,2,3,4,6,10,8,5,7,9] 枢轴为6，交换后[1,2,3,4,6,5,8,10,7,9] 枢轴交换，变为[1,2,3,4,5,6,8,10,7,9] 枢轴为8，交换后[1,2,3,4,5,6,8,7,10,9] 枢轴交换，变为[1,2,3,4,5,6,7,8,10,9] 枢轴为10，交换后[1,2,3,4,5,6,7,8,9,10]   在上面这个N=10的数组中，“10”这个最大的元素一共被交换了5次，所以我们可以认为对于N个元素的数组，在执行Quick.sort()时最大元素最多会被交换N/2次。  2.3.4 Suppose that the initial random shuffle is omitted. Give six arrays of ten elements for which Quick.sort() uses the worst-case number of compares.\n如果始终选第一个元素作为枢轴的话，要使比较次数达到最坏情况的话，输入数组应为升序。比较次数达到$ N + N-1 + N-2 + N-3 +\u0026hellip;+1 = \\frac{N(N+1)}{2} \\sim N^2/2 $ 例如：\n [1,2,3,4,5,6,7,8,9,10] [2,4,6,8,10,12,14,16,18,20] [-1,1,3,5,7,9,11,13,15,17] [10,20,30,40,50,60,70,80,90,100] [5,10,15,20,25,30,35,40,45,50] [0,2,3,4,6,7,8,9,10,12]  2.3.5 Give a code fragment that sorts an array that is known to consist of items having just two distinct keys.\nstatic void sort(Comparable[] a) { int lo = 0, hi = a.length - 1; int i = 0; while (i \u0026lt;= hi) { int tmp = a[i].compareTo(a[lo]); if (tmp \u0026lt; 0) exch(a, lo++, i++); else if (tmp \u0026gt; 0) exch(a, i, hi--); else i++; } } Priority Queues API binary-heap Java implementation public class MaxPQ\u0026lt;Key extends Comparable\u0026lt;Key\u0026gt;\u0026gt; { private Key[] pq; private int N = 0; public MaxPQ(int maxN) { pq = (Key[]) new Comparable[maxN + 1]; } public boolean isEmpty() { return N == 0; } public int size() { return N; } public void insert(Key v) { pq[++N] = v; swim(N); } public Key delMax() { Key max = pq[1]; exch(1, N--); sink(1); pq[N+1] = null; return max; } private boolean less(int i, int j) { return pq[i].compareTo(pq[j]) \u0026lt; 0; } private void exch(int i, int j) { Key tmp = pq[i]; pq[i] = pq[j]; pq[j] = tmp; } private void swim(int k) { while (k \u0026gt; 1 \u0026amp;\u0026amp; less(k / 2, k)) { exch(k / 2, k); k /= 2; } } private void sink(int k) { while (2 * k \u0026lt;= N) { int j = 2 * k; if (j \u0026lt; N \u0026amp;\u0026amp; less(j, j + 1)) j++; if (!less(k, j)) break; exch(k, j); k = j; } } } heapsort Basic plan for in-place sort  Create max-heap with all N keys. Repatedly remove the maximum key.  Java implementation public class Heap { public static void sort(Comparable[] a) { int N = a.length; for (int k = N / 2; k \u0026gt;= 1; k--) sink(a, k, N); while (N \u0026gt; 1) { exch(a, 1, N); sink(a, 1, --N); } } private static boolean less(Comparable a[], int i, int j) { return a[i - 1].compareTo(a[j - 1]) \u0026lt; 0; } private static void exch(Comparable a[], int i, int j) { Comparable t = a[i - 1]; a[i - 1] = a[j - 1]; a[j - 1] = t; } private static void sink(Comparable[] a, int k, int N) { while (2 * k \u0026lt;= N) { int j = 2 * k; if (j \u0026lt; N \u0026amp;\u0026amp; less(a, j, j + 1)) j++; if (!less(a, k, j)) break; exch(a, k, j); k = j; } } } mathematical analysis   Proposition. Heap construction uses $ \\le 2N $ compares and exchanges.\n  Proposition. Heapsort uses $ \\le 2NlgN $ compares and exchanges.\n  Significance. In-place sorting algorithm with $ NlgN $ worst-case.\n Mergesort: no, linear extra space. Quicksort: no, quadratic time in worst case. Heapsort: yes!    Bottom line. Heapsort is optimal for both time and space but:\n Inner loop longer than quicksort\u0026rsquo;s. Makes poor use of cache memory. Not stable.    sorting-algorithms: summary 2.4.2 Criticize the following idea: To implement find the maximum in constant time, why not use a stack or a queue, but keep track of the maximum value inserted so far, then return that value for find the maximum?\n如果用这种方法，当最大元素被删除之后，不能在常量时间内更新最大元素\n2.4.3 Provide priority-queue implementations that support insert and remove the maximum, one for each of the following underlying data structures: unordered array, ordered array, unordered linked list, and linked list. Give a table of the worst-case bounds for each operation for each of your four implementations.\n数组实现 public abstract class ArrayPQ\u0026lt;Key extends Comparable\u0026lt;Key\u0026gt;\u0026gt; { protected Key[] pq; protected int n; public ArrayPQ(int capacity) { pq = (Key[]) new Comparable[capacity]; n = 0; } public boolean isEmpty() {return n == 0;} public int size() {return n;} public abstract void insert(Key x); public abstract Key delMax(); protected boolean less(int i, int j) {return pq[i].compareTo(pq[j]) \u0026lt; 0; } protected void exch(int i, int j) { Key t = pq[i]; pq[i] = pq[j]; pq[j] = t; } public static void main(String[] args) { OrderedArrayMaxPQ pq = new OrderedArrayMaxPQ(10); pq.insert(\u0026#34;this\u0026#34;); pq.insert(\u0026#34;is\u0026#34;); pq.insert(\u0026#34;a\u0026#34;); pq.insert(\u0026#34;test\u0026#34;); while (!pq.isEmpty()) System.out.println(pq.delMax()); } } class UnorderedArrayMaxPQ\u0026lt;Key extends Comparable\u0026lt;Key\u0026gt;\u0026gt; extends ArrayPQ\u0026lt;Key\u0026gt; { public UnorderedArrayMaxPQ(int capacity) { super(capacity); } @Override public void insert(Key x) { pq[n++] = x; } @Override public Key delMax() { int max = 0; for (int i = 1; i \u0026lt; n; i++) { if (less(max, i)) max = i; exch(max, n-1); } return pq[--n]; } } class OrderedArrayMaxPQ\u0026lt;Key extends Comparable\u0026lt;Key\u0026gt;\u0026gt; extends ArrayPQ\u0026lt;Key\u0026gt;{ public OrderedArrayMaxPQ(int capacity) { super(capacity); } @Override public void insert(Key x) { int i = n - 1; while (i \u0026gt;= 0 \u0026amp;\u0026amp; x.compareTo(pq[i]) \u0026lt; 0) { pq[i+1] = pq[i]; i--; } pq[i+1] = x; n++; } @Override public Key delMax() { return pq[--n]; } } 链表实现 public abstract class LinkedListPQ\u0026lt;Key extends Comparable\u0026lt;Key\u0026gt;\u0026gt; { protected LinkedList\u0026lt;Key\u0026gt; pq; public LinkedListPQ() { pq = new LinkedList\u0026lt;Key\u0026gt;(); } public boolean isEmpty() { return pq.size() == 0; } public int size() { return pq.size(); } public abstract void insert(Key x); public abstract Key delMax(); protected boolean less(Key a, Key b) { return a.compareTo(b) \u0026lt; 0; } public static void main(String[] args) { UnorderedLinkedMaxPQ pq = new UnorderedLinkedMaxPQ(); pq.insert(\u0026#34;this\u0026#34;); pq.insert(\u0026#34;is\u0026#34;); pq.insert(\u0026#34;a\u0026#34;); pq.insert(\u0026#34;test\u0026#34;); while (!pq.isEmpty()) System.out.println(pq.delMax()); } } class UnorderedLinkedMaxPQ\u0026lt;Key extends Comparable\u0026lt;Key\u0026gt;\u0026gt; extends LinkedListPQ\u0026lt;Key\u0026gt; { @Override public void insert(Key x) { pq.addLast(x); } @Override public Key delMax() { int i = 0; int idx = 0; var max = pq.getFirst(); for (var e : pq) { if (less(max, e)) { max = e; idx = i; } i++; } pq.remove(idx); return max; } } class OrderedLinkedMaxPQ\u0026lt;Key extends Comparable\u0026lt;Key\u0026gt;\u0026gt; extends LinkedListPQ\u0026lt;Key\u0026gt; { public OrderedLinkedMaxPQ() { super(); } @Override public void insert(Key x) { int i = 0; Iterator it = pq.iterator(); while (it.hasNext()) { if (less(x, (Key) it.next())) break; i++; } pq.add(i, x); System.out.println(i + \u0026#34; eee \u0026#34;); } @Override public Key delMax() { return pq.removeLast(); } } the worst-case bounds     insert() delMax()     无序数组 1 N   有序数组 N 1   无序链表 1 N   有序链表 N 1    2.4.5 Give the heap that results when the keys E A S Y Q U E S T I O N are inserted in that order into an initially empty max-oriented heap.\n2.4.7 The largest item in a heap must appear in position 1, and the second largest must be in position 2 or position 3. Give the list of positions in a heap of size 31 where the kth largest (i) can appear, and (ii) cannot appear, for k=2, 3, 4 (assuming the values to be distinct).\n k = 2：可能出现在2，3；不可能出现在1, 4~31 k = 3：可能出现在2，3，4，5，6，7；不可能出现在1,8~31 k = 4：可能出现在2，3，4，5，6，7，8，9，10，11，12，13，14，15，不可能出现在1，16~31  第k大元素只可能出现在深度不大于k的位置($ position \\le 2^k-1 ,k \\ge 2$)\n2.4.9 Draw all of the different heaps that can be made from the five keys A B C D E, then draw all of the different heaps that can be made from the five keys A A A B B.\nA B C D E  最大堆  最小堆   A A A B B 2.4.11 Suppose that your application will have a huge number of insert operations, but only a few remove the maximum operations. Which priority-queue implementation do you think would be most effective: heap, unordered array, or ordered array?\n因为有大量的insert操作和很少的delMax操作，而heap, unordered array, ordered array实现的Priority Queue insert操作的花费时间的数量级分别为lgN, 1, N, 所以unordered array是最有效的。\n2.4.12 Suppose that your application will have a huge number of find the maximum operations, but a relatively small number of insert and remove the maximum operations. Which priority-queue implementation do you think would be most effective: heap, unordered array, or ordered array?\n大量的查找最大元素，heap和ordered array查找最大元素都是常量时间，但heap插入和删除最大元素都是lgN，而ordered array插入和删除分别是N和常量时间，综合下来，heap是最有效的。\nUNDIRECTED GRAPHS depth-first-search public class DepthFirstPaths { private boolean[] marked; private int[] edgeTo; private int s; public DepthFirstPaths(Graph G,int s) { marked = new boolean[G.V()]; edgeTo = new int[G.V()]; Arrays.fill(marked, false); this.s = s; dfs(G, s); } private void dfs(Graph G, int v) { marked[v] = true; for (int w : G.adj(v)) { if (!marked[w]) { dfs(G, w); edgeTo[w] = v; } } } public boolean hasPathTo(int v) { return marked[v]; } public Iterable\u0026lt;Integer\u0026gt; pathTo(int v) { if (!hasPathTo(v)) return null; Stack\u0026lt;Integer\u0026gt; path = new Stack\u0026lt;\u0026gt;(); for (int x = v; x != s; x = edgeTo[x]) path.push(x); path.push(s); return path; } public static void main(String[] args) { int V = StdIn.readInt(); Graph g = new Graph(V); int E = StdIn.readInt(); for (int i = 0; i \u0026lt; E; i++) { g.addEdge(StdIn.readInt(), StdIn.readInt()); } DepthFirstPaths dfp = new DepthFirstPaths(g, 0); for (var i : dfp.pathTo(3)) { System.out.println(i); } } } breadth-first-search public class BreadthFirstPaths { private boolean[] marked; private int[] edgeTo; private int s; public BreadthFirstPaths(Graph G, int s) { marked = new boolean[G.V()]; edgeTo = new int[G.V()]; this.s = s; bfs(G, s); } private void bfs(Graph G, int s) { Queue\u0026lt;Integer\u0026gt; Q = new Queue\u0026lt;\u0026gt;(); Q.enqueue(s); marked[s] = true; while (!Q.isEmpty()) { int v = Q.dequeue(); for (int w : G.adj(v)) { if (!marked[w]) { Q.enqueue(w); marked[w] = true; edgeTo[w] = v; } } } } public boolean hasPathTo(int v) { return marked[v]; } public Iterable\u0026lt;Integer\u0026gt; pathTo(int v) { if (!hasPathTo(v)) return null; Stack\u0026lt;Integer\u0026gt; path = new Stack\u0026lt;\u0026gt;(); for (int i = v; i != s; i = edgeTo[i]) path.push(i); path.push(s); return path; } public static void main(String[] args) { int V = StdIn.readInt(); Graph g = new Graph(V); int E = StdIn.readInt(); for (int i = 0; i \u0026lt; E; i++) { g.addEdge(StdIn.readInt(), StdIn.readInt()); } BreadthFirstPaths bfp = new BreadthFirstPaths(g, 0); for (var i : bfp.pathTo(3)) { System.out.println(i); } } } connected components public class CC { private boolean[] marked; private int[] id; private int count; public CC(Graph G) { marked = new boolean[G.V()]; id = new int[G.V()]; for (int v = 0; v \u0026lt; G.V(); v++) { if (!marked[v]) { dfs(G, v); count++; } } } public int count() { return count; } public int id(int v) { return id[v]; } private void dfs(Graph G, int v) { marked[v] = true; id[v] = count; for (int w : G.adj(v)) { if (!marked[w]) dfs(G, w); } } public static void main(String[] args) { Graph G = new Graph(StdIn.readInt()); int E = StdIn.readInt(); for (int i = 0; i \u0026lt; E; i++) G.addEdge(StdIn.readInt(), StdIn.readInt()); CC cc = new CC(G); System.out.println(cc.count); } } Minimum Spanning Trees Greedy algorithm Cut property   Def: A cut in a graph is a partition of its vertices into two(nonempty) sets.\n  Def: A Crossing edge connects a vertex in one set with a vertex in the other.\n  Cut property. Give any cut, the crossing edge of min weight is in the MST\n Pf. Suppose the min-weight crossing edge e is not in the MST  Adding e to the MST creates a cycle Some other edge f in cycle must be a crossing edge Removing f and adding e is also a spanning tree Since weight of e is less than the weight of f,that spanning tree is lower weight Contradiction      Kruskal\u0026rsquo;s algorithm Consider edges in ascending order of weight.\n Add next edge to tree T unless so doing would create a cycle.  public class KruskalMST { private Queue\u0026lt;Edge\u0026gt; mst = new Queue\u0026lt;\u0026gt;(); private double weight; public KruskalMST(EdgeWeightedGraph G) { weight = 0; MinPQ\u0026lt;Edge\u0026gt; pq = new MinPQ\u0026lt;\u0026gt;(); for (var e : G.edges()) { pq.insert(e); } UF uf = new UF(G.V()); while (!pq.isEmpty() \u0026amp;\u0026amp; mst.size() \u0026lt; G.V() - 1) { Edge e = pq.delMin(); int v = e.either(), w = e.other(v); if (!uf.connected(v, w)) { uf.union(v, w); mst.enqueue(e); weight += e.weight(); } } } public Iterable\u0026lt;Edge\u0026gt; edges() { return mst; } public double weight() { return weight; } } Prim\u0026rsquo;s algorithm  Start with vertex 0 and greedy grow tree T Add to T the min weight with exactly one endpoint in T Repeat until V-1 edges  LazyPrim Implementation public class LazyPrimMST { private boolean[] marked; private Queue\u0026lt;Edge\u0026gt; mst; private MinPQ\u0026lt;Edge\u0026gt; pq; public LazyPrimMST(EdgeWeightedGraph G) { pq = new MinPQ\u0026lt;\u0026gt;(); mst = new Queue\u0026lt;\u0026gt;(); marked = new boolean[G.V()]; visit(G, 0); while (!pq.isEmpty() \u0026amp;\u0026amp; mst.size() \u0026lt; G.V() - 1) { Edge e = pq.delMin(); int v = e.either(), w = e.other(v); if (marked[v] \u0026amp;\u0026amp; marked[w]) continue; mst.enqueue(e); if (!marked[v]) visit(G, v); if (!marked[w]) visit(G, w); } } private void visit(EdgeWeightedGraph G, int v) { marked[v] = true; for (Edge e : G.adj(v)) { if (!marked[e.other(v)]) { pq.insert(e); } } } public Iterable\u0026lt;Edge\u0026gt; mst() { return mst; } } Indexed priority queue implementation  Start as same code as MinPQ Maintain parallel arrays keys[], pq[], and qp[] so that:  keys[i] is the priority of i pq[i] is the index of the key in heap position i qp[i] is the heap position of the key with index i   Use swim(qp[i]) implement decreaseKey(i, key).   EagerPrim Implementation import edu.princeton.cs.algs4.*; public class PrimMST { private Edge[] edgeTo; private double[] distTo; private boolean[] marked; private IndexMinPQ\u0026lt;Double\u0026gt; pq; public PrimMST(EdgeWeightedGraph G) { edgeTo = new Edge[G.V()]; distTo = new double[G.V()]; marked = new boolean[G.V()]; for (int v = 0; v \u0026lt; G.V(); v++) distTo[v] = Double.POSITIVE_INFINITY; pq = new IndexMinPQ\u0026lt;\u0026gt;(G.V()); distTo[0] = 0.0; pq.insert(0, 0.0); while (!pq.isEmpty()) visit(G, pq.delMin()); } private void visit(EdgeWeightedGraph G, int v) { marked[v] = true; for (Edge e : G.adj(v)) { int w = e.other(v); if (marked[w]) continue; if (e.weight() \u0026lt; distTo[w]) { edgeTo[w] = e; distTo[w] = e.weight(); if (pq.contains(w)) pq.change(w, distTo[w]); else pq.insert(w, distTo[w]); } } } public Iterable\u0026lt;Edge\u0026gt; edges() { Queue\u0026lt;Edge\u0026gt; mst = new Queue\u0026lt;\u0026gt;(); for (int v = 0; v \u0026lt; edgeTo.length; v++) { Edge e = edgeTo[v]; if (e != null) { mst.enqueue(e); } } return mst; } public double weight() { double weight = 0.0; for (Edge e : edges()) { weight += e.weight(); } return weight; } } 4.3.2 Draw all of the MSTs of graph depicted at right (all edge weights are equal).\n4.3.3 Show that if a graph’s edges all have distinct weights, the MST is unique\n 假设无向图G有两棵不同的最小生成树T1和T2 e是在T1或T2中（但不是同时在两棵树中）最小权值的边，不妨假设e在T1中 将e添加到T2中会创建一个环C 在C中至少存在一条边f（但不在T1中，否则会产生环） 因为e是在T1或T2中（但不是同时在两棵树中）最小权值的边，并且每条边权值都不同 所以有e.weight \u0026lt; f.weight 用e代替f，将会产生比原来T2权值更小的生成树，产生了矛盾  4.3.13 Give a counterexample that shows why the following strategy does not necessarily find the MST: ‘Start with any vertex as a single-vertex MST, then add V-1 edges to it, always taking next a min-weight edge incident to the vertex most recently added to the MST.’\nShortest Paths shortest-paths properties Data structures for single-source shortest paths  Goal. Find the shortest-paths from s to every other vertex. Observation. A shortest-paths tree (SPT) solution exists. Why? Consequence. Can represent the SPT with two vertex-indexed arrays:  distTo[v] is length of shortest path from s to v edgeTo[v] is last edge on shortest path from s to v    Edge relaxation  Relax edge e = v-\u0026gt;w  distTo[v] is length of shortest known path from s to v distTo[w] is length of shortest known path from s to w edgeTo[w] is last edge on shortest known path from s to w if e = v-\u0026gt;w gives shorter path to w through v, update both distTo[w] and edgeTo[w]     Shortest-paths optimality conditions  Proposition. Let G be an edge-weighted digraph. Then distTo[] are the shortest path distances from s iff:  distTo[s] = 0 For each vertex v, distTo[v] is the length of some path from s to v For each edge e = v-\u0026gt;w, distTo[w] \u0026lt;= distTo[v] + e.weight().   Pf.  suppose that distTo[w] \u0026gt; distTo[v] + e.weight() for some edge e = v-\u0026gt;w. Then, e gives a path from s to w (through v) of length less than distTo[w].  distTo[v1] \u0026lt;= distTo[v0] + e1.weight() distTo[v2] \u0026lt;= distTo[v1] + e2.weight() \u0026hellip; distTo[vk] \u0026lt;= distTo[v(k-1)] + ek.weight()   Add inequalities; simplify; and substitude distTo[v0] = distTo[s] = 0: distTo[w] = distTo[vk] \u0026lt;= e1.weight() + e2.weight() + \u0026hellip; + ek.weight() Thus, distTo[w] is the weight of shortest path to w    Genertic shortest-paths algorithm  Proposition. Genertic algorithm computes SPT(if it exists) from s. Pf sketch  Throughout algorithm, distTo[v] is the length of a simple path from s to v (and edgeTo[v] is last edge on path) Each successful relaxation decreases distTo[v] from some v The entry distTo[v] can decrease at most a finite number of times   Efficient implementataions How to choose which edge to relax?  Ex 1. Dijkstra\u0026rsquo;s algorithm (nonnegative weights) Ex 2. Topological sort algorithm (no directed cycles) Ex 3. Bellman-Ford algorithm (no negative cycles)    Dijkstra\u0026rsquo;s algorithm Dijkstra\u0026rsquo;s algorithm Demo correctness proof   Proposition. Dijkstra\u0026rsquo;s algorithm computes a SPT in any edge-weighted diagraph with nonnegative weights.\n  Pf.\n Each edge e = v-\u0026gt;w is relaxed exactly once (when v is relaxed), leaving distTo[w] \u0026lt;= distTo[v] + e.weight() Inequality hold until algorithm terminates because:  distTo[w] cannot increase \u0026lt;- distTo[] values are monotone decreasing distTo[v] will not change \u0026lt;- we choose lowest distTo[] value at each step (and edge weights are nonnegative)   Thus, opun termination, shortest-paths optimality conditions hold    Java implementation public class DijkstraSP { private DirectedEdge[] edgeTo; private double[] distTo; private IndexMinPQ\u0026lt;Double\u0026gt; pq; public DijkstraSP(EdgeWeightedDigraph G, int s) { edgeTo = new DirectedEdge[G.V()]; distTo = new double[G.V()]; pq = new IndexMinPQ\u0026lt;Double\u0026gt;(G.V()); for (int v = 0; v \u0026lt; G.V(); v++) distTo[v] = Double.POSITIVE_INFINITY; distTo[s] = 0.0; pq.insert(s, 0.0); while (!pq.isEmpty()) { int v = pq.delMin(); for (DirectedEdge e : G.adj(v)) relax(e); } } private void relax(DirectedEdge e) { int v = e.from(), w = e.to(); if (distTo[w] \u0026gt; distTo[v] + e.weight()) { distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; if (pq.contains(w)) pq.decreaseKey(w, distTo[w]); else pq.insert(w, distTo[w]); } } public double distTo(int v) { return distTo[v]; } public Iterable\u0026lt;DirectedEdge\u0026gt; pathTo(int v) { Stack\u0026lt;DirectedEdge\u0026gt; path = new Stack\u0026lt;\u0026gt;(); for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) path.push(e); return path; } } edge-weighted DAGs Acyclic shortest paths demo Shortest paths in edge-weighted DAGs  Proposition. Topological sort algorithm computes SPT in any (edge weights can be negative!) edge-weighted DAG in time proportional to E + V Pf.  Each edge e = v-\u0026gt;w is relaxed exactly once (when v is relaxed), leaving distTo[w] \u0026lt;= distTo[v] + e.weight() Inequality holds until algorithm terminates because:  distTo[w] cannot increase \u0026lt;- distTo[] values are monotone decreasing distTo[v] will not change \u0026lt;- because of topological order, no edge pointing to v will be relaxed after v is relaxed   Thus, upon termination, shortest-paths optimality conditions hold    Java Implementation public class AcyclicSP { private DirectedEdge[] edgeTo; private double[] distTo; public AcyclicSP(EdgeWeightedDigraph G, int s) { edgeTo = new DirectedEdge[G.V()]; distTo = new double[G.V()]; for (int v = 0; v \u0026lt; G.V(); v++) distTo[v] = Double.POSITIVE_INFINITY; distTo[s] = 0.0; Topological topological = new Topological(G); for (int v : topological.order()) for (DirectedEdge e : G.adj(v)) relax(e); } private void relax(DirectedEdge e) { int v = e.from(), w = e.to(); if (distTo[w] \u0026gt; distTo[v] + e.weight()) { distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; } } public Iterable\u0026lt;DirectedEdge\u0026gt; pathTo(int v) { Stack\u0026lt;DirectedEdge\u0026gt; path = new Stack\u0026lt;\u0026gt;(); for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) path.push(e); return path; } } negative weights  Def. A negative cycle is a directed cycle whose sum of edge weights is negative. Proposition. A SPT exists iff no negative cycles.  Bellman-Ford algorithm: analysis   Initialize distTo[s] = 0 and distTo[v] = $ \\infty $ for all other vertices.\n  Repeat V times:\n Relax each edge.    Proposition. Dynamic programming algorithm computes SPT in any edge-weighted digraph with no negative cycles in time proportional to $E\\times V$\n  Pf idea. After pass i, found shortest path containing at most i edges.\n  Bellman-Ford algorithm: practical improvement   Observation. If distTo[v] does not change during pass i, no need to relax any edge pointing from v in pass i+1.\n  FIFO implementation. Maintain queue of vertices whose distTo[] changed.\n  Overall effect.\n The running time is still proportional to $E \\times V $ in worst case. But much faster than that in practice.    Bellman-Ford Java implementation public class BellmanFordSP { private double[] distTo; private DirectedEdge[] edgeTo; private Queue\u0026lt;Integer\u0026gt; queue; private boolean[] onQueue; public BellmanFordSP(EdgeWeightedDigraph G, int s) { distTo = new double[G.V()]; onQueue = new boolean[G.V()]; edgeTo = new DirectedEdge[G.V()]; for (int v = 0; v \u0026lt; G.V(); v++) distTo[v] = Double.POSITIVE_INFINITY; distTo[s] = 0.0; queue = new Queue\u0026lt;\u0026gt;(); queue.enqueue(s); onQueue[s] = true; while (!queue.isEmpty()) { int v = queue.dequeue(); onQueue[v] = false; relax(G, v); } } private void relax(EdgeWeightedDigraph G, int v) { for (DirectedEdge e : G.adj(v)) { int w = e.to(); if (distTo[w] \u0026gt; distTo[v] + e.weight()) { distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; if (!onQueue[w]) { queue.enqueue(w); onQueue[w] = true; } } } } public Iterable\u0026lt;DirectedEdge\u0026gt; pathTo(int v) { Stack\u0026lt;DirectedEdge\u0026gt; path = new Stack\u0026lt;\u0026gt;(); for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) path.push(e); return path; } } Single source shortest-path implementation: cost summary    algorithm restriction typical case worst case extra case     topological sort no directed cycles E + V E + V V   Dijkstra (binary heap) no negative weights ElogV ElogV V   Bellman-Ford no negative cycles EV EV V   Bellman-Ford(queue-based) no negative cycles E + V EV V    4.4.1 True or false. Adding a constant to every edge weight does not change the solution to the single-source shortest-paths problem.\nFalse. 假设一条最短路径的长度是15, 且一共有五条边，而另外一条简单路径的长度为20，由两条边组成，当每条边的权值都增加5之后，原来长度15的路径长度变为40，原来长度为20的路径长度变为30，可以看到最短路径改变了。\n4.4.5 Change the direction of edge 0-\u0026gt;2 in tinyEWD.txt (see page 644). Draw two different SPTs that are rooted at 2 for this modified edge-weighted digraph. 4.5.9 The table below, from an old published road map, purports to give the length of the shortest routes connecting the cities. It contains an error. Correct the table. Also, add a table that shows how to achieve the shortest routes.\n    Providence Westerly New London Norwich     Providence  53 54 48   Westerly 53  18 30   New London 54 18  12   Norwich 48 30 12     给Providence、Westerly、New London、Norwich 分别编号为0、1、2、3\n最短路径：\n    Providence Westerly New London Norwich     Providence  0-1 0-2 0-3   Westerly 1-0  1-2 1-2、2-3   New London 2-0 2-1  2-3   Norwich 3-0 3-2、2-1 3-2     String sorts key-indexed counting   Proposition. Key-indexed counting uses $ ~ 11N+4R $ array accesses to sort a N items whose keys are integers between 0 and R-1.\n  Proposition. Key-indexed counting uses extra space proportional to N + R\n  Stable.\n  public class CountingSort { public static void sort(int[] a, int R) { int N = a.length; int[] count = new int[R+1]; int[] aux = new int[N]; for (int i = 0; i \u0026lt; N; i++) count[a[i]+1]++; // count[a[i]+1] = count[a[i+1]] + 1  for (int r = 0; r \u0026lt; R; r++) count[r+1] += count[r]; // 第一个位置  for (int i = 0; i \u0026lt; N; i++) aux[count[a[i]]++] = a[i]; // aux[count[a[i]] = count[a[i]]+1] = a[i]  for (int i = 0; i \u0026lt; N; i++) a[i] = aux[i]; } public static void main(String[] args) { String s = \u0026#34;dacffbdbfbea\u0026#34;; int[] a = new int[s.length()]; for (int i = 0; i \u0026lt; a.length; i++) a[i] = s.charAt(i)-\u0026#39;a\u0026#39;; sort(a, 26); for (var e : a) { System.out.printf(\u0026#34;%c \u0026#34;, e+\u0026#39;a\u0026#39;); } } } LSD radix sort Least-significant-digit-first string sort  Consider characters from right to left. Stably sort using dth character as the key (using key-indexed counting).  public class LSD { public static void sort(String[] a, int W) { int R = 256; int N = a.length; String[] aux = new String[N]; for (int d = W-1; d \u0026gt;= 0; d--) { int[] count = new int[R+1]; for (int i = 0; i \u0026lt; N; i++) count[a[i].charAt(d)+1]++; for (int r = 0; r \u0026lt; R; r++) count[r+1] += count[r]; for (int i = 0; i \u0026lt; N; i++) aux[count[a[i].charAt(d)]++] = a[i]; for (int i = 0; i \u0026lt; N; i++) a[i] = aux[i]; } } public static void main(String[] args) { In in = new In(\u0026#34;D:\\\\Java_test\\\\test1\\\\src\\\\StringSort\\\\strings.txt\u0026#34;); String[] a = in.readAllStrings(); int N = a.length; int w = a[0].length(); for (int i = 1; i \u0026lt; N; i++) assert a[i].length() == w : \u0026#34;String must have fixed length\u0026#34;; sort(a, w); for (var e : a) System.out.println(e); } } Summary of the performence of sorting algorithms MSD radix sort Most-significant-digit-first srting sort  Partition array into R pieces according to first character (using key-indexed counting). Recursively sort all strings that start with each character (key-indexed counts delineate subarrays to sort).  Implementation public class MSD { final static int R = 256; public static void sort(String[] a) { String[] aux = new String[a.length]; sort(a, aux, 0, a.length-1, 0); } private static void sort(String[] a, String[] aux, int lo, int hi, int d) { if (hi \u0026lt;= lo) return; int[] count = new int[R+2]; for (int i = lo; i \u0026lt;= hi; i++) count[charAt(a[i], d)+2]++; for (int r = 0; r \u0026lt; R + 1; r++) count[r+1] += count[r]; for (int i = lo; i \u0026lt;= hi; i++) aux[count[charAt(a[i], d)+1]++] = a[i]; for (int i = lo; i \u0026lt;= hi; i++) a[i] = aux[i - lo]; for (int r = 0; r \u0026lt; R; r++) sort(a, aux, lo+count[r], lo+count[r+1]-1, d+1); } private static int charAt(String s, int d) { if (s.length() \u0026gt; d) return s.charAt(d); else return -1; } public static void main(String[] args) { In in = new In(\u0026#34;D:\\\\Java_test\\\\test1\\\\src\\\\StringSort\\\\strings.txt\u0026#34;); String[] a = in.readAllStrings(); sort(a); for (var e : a) System.out.println(e); } } suffix arrays Longest repeated substring: Java implementation public class LRS { public static String lrs(String s) { int N = s.length(); String[] suffixes = new String[N]; for (int i = 0; i \u0026lt; N; i++) suffixes[i] = s.substring(i, N); Arrays.sort(suffixes); String lrs = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; N - 1; i++) { int len = lcp(suffixes[i], suffixes[i+1]); if (len \u0026gt; lrs.length()) lrs = suffixes[i].substring(0, len); } return lrs; } private static int lcp(String s, String t) { int n = Math.min(s.length(), t.length()); for (int i = 0; i \u0026lt; n; i++) if (s.charAt(i) != t.charAt(i)) return i; return n; } public static void main(String[] args) { String s = \u0026#34;aacaagtttacaagc\u0026#34;; System.out.println(lrs(s)); } } ","permalink":"https://fffzlfk.github.io/posts/algorithm4th/","summary":"The solution of algs4\u0026rsquo;s exercise","title":"算法（第四版）"},{"content":"C++基础 C++对C的扩充 名字空间 namespace ns1{ int inflag; } namespace ns2{ int inflag; } ns1::inflag=2; ns2::inflag=-3; // using ns1::inflag; inflag=2; // ns2::inflag=-3; 用const定义常量  用const定义标识符常量时，一定要对其初始化，这是唯一方法。  引用   对变量起另外一个名字，这个名字称为该变量的引用。\n  其中原变量名必须是一个已定义过的变量。\n  引用并没有重新在内存中开辟存储单元，只是引用原变量的单元。\n  对引用的初始化，可以用一个变量名，也可以用另一个引用。\nint a=3; int \u0026amp;b=a; int \u0026amp;c=b;   引用同变量一样有地址，可以对其地址进行操作，即将其地址赋给一指针。\n  对const常量的引用使用如下方式：\nint i = 5; const int \u0026amp;ri = i; // ri = 10; 错误  i = 10; //正确  cout \u0026lt;\u0026lt; ri;   以下的声明是非法的\n 企图建立void类型的引用 void \u0026amp;a 企图建立引用的数组 int \u0026amp;a[6] 企图建立指向引用的指针 int \u0026amp;*p    指针和引用的区别：\n 指针是通过地址间接访问某个变量，而引用是通过别名直接访问某个变量。 引用必须初始化，而一旦初始化后不再作为其他变量的别名。指针若不进行初始化，编译器不会报错。    引用与函数  函数的返回值为引用类型   内联函数  调用内联函数时，编译器首先检查调用是否正确（类型安全检查或者自动进行类型转换）。如果正确，则将内联函数的代码直接替换函数调用，并用实参换型参，于是省去了函数调用的开销。因此，内联机制增加了空间开销而节约了时间开销。  第一次上级题目  求2个或3个正整数中的最大数，用带有默认参数的函数实现。 输入三个整数，将它们按由小到大的顺序输出，要求使用变量的引用。 编写一个程序，用同一个函数名对几个数据进行从小到大排序，数据类型可以是整型、浮点型。用重载函数实现。 对第3题改用函数模板实现，并与第3题程序进行对比分析。 设计一个日期Date类，它能实现年月日的输入和输出，要求分别将成员函数定义在类体内和类体外。 声明一个Circle类，有数据成员Radius（半径）、成员函数GetArea（）计算圆的面积，构造一个Circle的对象进行测试。 编写一个基于对象的程序，求出3个长方柱的体积。数据成员包括length(长)、width(宽)、height(高)。要求用成员函数实现以下功能：\n(1) 由键盘分别输入3个长方柱的长、宽、高；\n(2) 计算长方柱的体积；\n(3) 输出3个长方柱的体积。  源码下载 1\n2\n3\n4\n5\n6\n7\n类和对象 复制构造函数调用时机  程序中需要新建立一个对象，并用另一个同类的对象对它初始化  Box box1(1,2,3); Box box2 = box1; // Box box2(box1); 当函数的参数为类对象时，在调用函数时需要将实参对象完整的传递给形参  void func(Box b) { // do something... } int main() { Box box1(1, 2, 3); fun(box1); } 当函数的返回值是类的对象，在函数调用完毕将返回值带回函数调用处时  Box f1() { Box box1(1, 2, 3); return box1; } int main() { Box box2; box2 = f(); return 0; } 指向非静态成员函数的指针 /* Author: fffzlfk */ #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; class Node { public: Node(int xx, int yy) : x(xx), y(yy){} int get_x() { return x; } int get_y() { return y; } private: int x, y; }; int main() { Node node(1, 2); int (Node::*p_x)() = \u0026amp;Node::get_x; // 需要加类名和作用域运算符  int (Node::*p_y)() = \u0026amp;Node::get_y; cout \u0026lt;\u0026lt; (node.*p_x)() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; (node.*p_y)() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 指向静态成员函数的指针 /* Author: fffzlfk */ #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; class A { public: static int get() { return 666; } }; int main() { int (*p)() = \u0026amp;A::get; cout \u0026lt;\u0026lt; p() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; (*p)(); // 加不加*都可  return 0; } 对象引用的作用 .notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Tip\n 避免通过值来传递对象，而是通过引用来传递 参数传递的是引用，没有构造函数或析构函数被调用，节约了系统资源，提高了运行效率  /* Author: fffzlfk */ #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; class Student { public: Student(); Student returnS(Student s) { return s; } Student(const Student \u0026amp;e) { cout \u0026lt;\u0026lt; \u0026#34;Copy Constructor\\n\u0026#34;; } ~Student() { cout \u0026lt;\u0026lt; \u0026#34;Destructor\\n\u0026#34;; } }; Student::Student() {} int main() { Student stu1; stu1.returnS(stu1); return 0; } 输出为：\nCopy Constructor\nCopy Constructor\nDestructor\nDestructor\nDestructor\n修改为\nStudent\u0026amp; returnS(Student \u0026amp;s) { return s; } 之后，输出：\nDestructor\n关于数据成员初始化    数据成员 成员初始化列表 构造函数体内 类外     普通数据成员 $\\checkmark $ $\\checkmark $    常数据成员 $\\checkmark $     静态数据成员   $\\checkmark $   静态常数据成员   $\\checkmark $    常对象 Tip\n  常对象的所有数据成员都是常量，不能改变。因此，常对象必须初始化。\n  不能通过常对象调用普通的成员函数，可以调用常成员函数。\n  如果要修改常对象中某个数据成员的值，可以将数据成员声明为mutable，这样就可以用声明为const的成员函数来修改它的值。\n  /* Author: fffzlfk */ #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; class A { private: mutable int i; // 可以用常成员函数来修改 public: A() {} //常对象必须初始化 \tvoid f_const() const { i++; cout \u0026lt;\u0026lt; \u0026#34;i = \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;f_const()\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void f() { cout \u0026lt;\u0026lt; \u0026#34;f()\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; int main() { const A a; //常对象必须初始化 \ta.f_const(); //常对象只能调用常成员函数 \treturn 0; } 常成员   常数据成员\nTip\n  在任何函数中都不能对常数据成员赋值\n  只能通过构造函数的参数初始化表对常数据成员进行初始化\n  const int Hour; Time::Time(int h) : Hour(h) {} 类的所有对象中的常数据成员的值均不能改变，但不同对象中的该数据成员可以不同（在定义对象时给出）   示例程序：  /* Author: fffzlfk */ #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; class A { public: A(int i) : a(i) {} // 非静态常数据成员只能通过初始化表来获得初值  void print() { cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } private: const int a; static const int b; }; const int A::b = 10; // 静态常数据成员只能在类外初始化 int main() { A a1(100), a2(0); a1.print(); a2.print(); return 0; }   常成员函数\nTip\n 通过常成员函数来引用本类中的数据成员，但不能修改他们 const 是函数类型的一部分，在声明函数时都要有const，在调用时不必加const 常成员函数不能更新对象的数据成员，也不能调用该类中的非const成员函数 通过常对象只能调用它的常成员函数，而不能调用其他成员函数 常对象中的成员函数不是常成员函数，除非成员函数有const修饰 const关键字可以用于对重载函数的区分  /* Author: fffzlfk */ #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; class R { public: R(int r1, int r2) { R1 = r1; R2 = r2; } void print() { cout \u0026lt;\u0026lt; R1 \u0026lt;\u0026lt; \u0026#39;-\u0026#39; \u0026lt;\u0026lt; R2 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void print() const { cout \u0026lt;\u0026lt; R1 \u0026lt;\u0026lt; \u0026#34;+\u0026#34; \u0026lt;\u0026lt; R2 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } private: int R1, R2; }; int main() { R a(5, 4); a.print(); // 普通对象a调用普通成员函数  const R b(20, 5); b.print(); // 常对象b调用常成员函数  return 0; }   const成员和非const成员之间的调用关系\n   数据成员 非const成员函数 const成员函数     非const数据成员 可以引用，也可以改变值 可以引用，但不可以改变值   const数据成员 可以引用，但不能改变值 可以引用，但不可以改变值   const对象的数据成员 不允许引用和改变值 可以引用，不可以改变值      const与指针   指向对象的常指针指针本身的值不能改变，即其指向不能改变。\n类名 *const 指针变量名 = 对象地址\nTime t1(10, 12, 15), t2; Time *const ptr1 = \u0026amp;t1; ptr1 = \u0026amp;t2; //错误，ptr1不能改变指向  Tip\n常指针始终指向同一个对象，但是可以改变其所指对象中数据成员的值。\n   指向常对象的指针const 类名 *指针变量名 = 对象地址\n  如果存在一个常对象，只能用指向常对象的指针去指向它，而不能用非const型的指针去指向它。\n  指向常对象的指针还可以指向非const型的对象，此时不能通过指针改变该对象的值，但是通过该对象本身来改变。指针本身的值也可以改变。\n  Time t1(10, 12, 15), t2; const Time *p = \u0026amp;t1; // p是指向常对象的指针，并指向t1对象 (*p).hour = 18; // 错误，不能通过指针改变t1的值 t1.hour = 18; // 正确，t1不是常对象 p = \u0026amp;t2; // 正确，p改为指向t2 Note\n指向常对象的指针可以指向const和非const型的对象，而指向非const型对象的指针只能指向非const的对象。\n   对象数组 /* Author: fffzlfk */ #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; class Box { public: Box(int h = 10, int w = 12, int len = 15) : height(h), width(w), length(len) {} int volume(); private: int height, width, length; }; int Box::volume() { return height * width * length; } int main() { Box a[2]{Box(10, 12, 15), Box(15, 18, 20)}; // Box a[2] = {Box(10, 12, 15), Box(15, 18,  // 20)}; 加不加等号都可  cout \u0026lt;\u0026lt; a[0].volume() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; a[1].volume() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 类模板 类模板是对一批仅有成员数据类型不同的类的抽象 关于函数模板\n 类模板中的成员函数的定义   可以放在类模板的定义定义体中（此时与类中的成员函数定义方法一致）\n  也可以放在类模板的外部，此时成员函数的定义格式如下：\n  template\u0026lt;class 类型参数\u0026gt; \u0026lt;返回值类型\u0026gt; \u0026lt;类模板名\u0026gt;\u0026lt;类型参数\u0026gt;::\u0026lt;函数名\u0026gt; (\u0026lt;参数表\u0026gt;) { \u0026lt;函数体\u0026gt; } \n在类模板外定义成员函数时，每一个函数前均加上：\ntemplate \u0026lt;class 类型参数\u0026gt;\n 第二次上机题目  编写设计一个People（人）类。该类的数据成员有年龄（age）、身高（height）、体重（weight）和人数（num），其中人数为静态数据成员，成员函数有构造函数（People）、进食（Eating）、运动（Sporting）、睡眠（Sleeping）、显示（Show）和显示人数（ShowNum）。其中构造函数由已知参数年龄(a)、身高(h)和体重(w)构造对象，进食函数使体重加1，运动函数使身高加1，睡眠函数使年龄、身高、体重各加1，显示函数用于显示人的年龄、身高、体重，显示人数函数为静态成员函数，用于显示人的个数。假设年龄的单位为岁，身高的单位为厘米，体重的单位为市斤，要求所有数据成员为protected访问权限，所有成员函数为public访问权限，在主函数中通过对象直接访问类的所有成员函数。 定义一个描述学生（Student）基本情况的类，数据成员包括姓名(name)、学号(num)、数学成绩(mathScore)、英语成绩(englishScore)、人数(count)、数学总成绩(mathTotalScore)和英语总成绩(englishTotalScore)。其中姓名定义为长度为18的字符数组，其他数据成员类型为整型，数学总成绩、英语总成绩和人数为静态数据成员，函数成员包括构造函数、显示基本数据函数（ShowBase）和显示静态数据函数(showStatic)，其中构造函数由已知参数姓名(nm)、学号(nu)、数学成绩(math)和英语成绩(english)构造对象，显示基本数据函数用于显示学生的姓名、学号、数学成绩、英语成绩，显示静态数据函数为静态成员函数，用于显示人数、数学总成绩、英语总成绩；要求所有数据成员为private访问权限，所有成员函数为public访问权限，在主函数中定义若干个学生对象，分别显示学生基本信息，以及显示学生人数，数学总成绩与英语总成绩。 定义一个Dog，包含name、age、sex和weight等属性以及对这些属性操作的方法。要求用字符指针描述name，并且用对象指针来测试这个类。 管理个人活期账户：个人储蓄活期账户包括账号、户名、密码、余额、活期年利率等信息。要求能够对个人账户进行存钱、取钱、计算年利息、打印账户相关信息等操作。编写主函数测试账户相关功能。 5．建立一个对象数组，内放5个学生的数据（学号、成绩），（1）用指针指向数组首元素，输出第1，3，5个学生的数据；（2）设立一个函数max，用指向对象的指针作函数参数，在max函数中找出5个学生中成绩最高者，并输出其学号。  源码下载 1\n2\n3\n4\n5\n运算符重载 不能重载的运算符    不能重载的运算符 说明     :: 作用域运算符   . 成员访问运算符   .* 成员指针   ?: 条件运算符   sizeof 长度运算符    重载为类的成员函数  \u0026lt;函数类型\u0026gt; operator \u0026lt;运算符\u0026gt;(\u0026lt;参数表\u0026gt;) {函数体}\n  C++中不允许重载有三个操作数的运算符 运算符作为成员函数时最多有一个形参：参数可以是对象，对象的引用，或其它类型的参数 运算符重载的实质就是函数重载 运算符重载的函数参数就是该运算符涉及的操作数  单目运算符的重载++、\u0026ndash;  ++为前置运算符时：operator++() {\u0026hellip;} ++为后置运算符时：operator++(int) {\u0026hellip;}  友元函数 有时候需要某些函数访问对象的私有成员，可以通过声明该函数为类的友元函数\nTip\n 友元函数是可以直接访问类的私有成员的非成员函数。 它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明，声明时只需在友元的名称前加上关键字friend，其格式如下：\nfriend 类型 函数名(形式参数);  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; class A { int i; public: friend void foo(A); }; void foo(A a) { cout \u0026lt;\u0026lt; a.i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { A a; foo(a); }   大多数情况下友元函数是某个类的成员函数，即A类中的某个成员函数是B类中的友元函数，这个成员函数可以直接访问B类中的私有数据。这实现了类与类之间的沟通。\nclass A { class B { void fun(B \u0026amp;); friend void A::fun(B \u0026amp;b); }; };   友元类\nclass A { class B { ... ... // B类是A类的友元 // B类可以自由使用A类中的成员  friend class B; }； };   重载为类的友元函数 friend \u0026lt;函数值类型\u0026gt; operator\u0026lt;运算符\u0026gt;(\u0026lt;参数表\u0026gt;) {函数体}\n 运算符重载为类的友元函数****最多只能有两个参数** 如果重载双目运算符，则第一个参数代表左操作数，第二个参数代表右操作数  单目运算符重载  ++为前置运算符时，它的运算符重载函数的一般格式为：A operator ++(A \u0026amp;a) ++为后置运算符时，它的运算符重载函数的一般格式为：A operator ++(A \u0026amp;a, int)(使用哑元区分)  重载输入输出运算符   输入运算符：friend istream \u0026amp; operater \u0026raquo;(istream \u0026amp;is, ClassName \u0026amp;f){…}\n  输出运算符：friend ostream \u0026amp; operater \u0026laquo;(ostream \u0026amp;, ClassName \u0026amp;){\u0026hellip;}\n  函数对象 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; class Test { public: int operator()(int a, int b) { cout \u0026lt;\u0026lt; \u0026#34;operator() called. \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; return a + b; } }; int main() { Test sum; int s = sum(3, 4); // sum看上去像是一个函数，故也称“函数对象”  cout \u0026lt;\u0026lt; \u0026#34;a + b = \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } 类型转换运算符重载 基本类型到类类型的转换  如果直接将数据赋值给对象，所赋入的数据要强制类型转换，这种转换需要调用构造函数。也就是利用构造函数能完成基本类型到类类型的转换 使用构造函数进行类型转换必须有一个前提，那就是在这个类中定义一个只有一个参数的构造函数（或者其他参数有默认值）——转换构造函数  类类型到基本类型的转换   C++引入一种特殊的成员函数——类型转换函数。类型转换函数实际上就是一个类型转换运算符重载函数\n  类型转换函数专门用来将类类型转换为基本数据类型，它只能被重载为成员函数\n  重载类型转换运算符函数格式：\noperator〈返回基本类型名〉（） { …… return 〈基本类型值〉 }\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; class A { int i; public: A(int a = 0) : i(a) {} void show(void) { cout \u0026lt;\u0026lt; \u0026#34;i = \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } operator int() { return i; } }; int main() { A a1(10), a2(20); cout \u0026lt;\u0026lt; a1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; a2 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; }   示例代码 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; class Complex { double real, imag; public: Complex(double r = 0.0, double i = 0.0) : real(r), imag(i) {} double getReal() const { return real; } double getImag() const { return imag; } Complex operator++(); Complex operator++(int); Complex operator+(Complex \u0026amp;); Complex operator+(double d); friend istream \u0026amp;operator\u0026gt;\u0026gt;(istream \u0026amp;, Complex \u0026amp;); friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;, const Complex \u0026amp;); }; Complex Complex::operator++() { return Complex(++real, imag); } Complex Complex::operator++(int a) { return Complex(real++, imag); } Complex Complex::operator+(Complex \u0026amp;c) { return Complex(real + c.real, imag + c.imag); } Complex Complex::operator+(double d) { return Complex(real + d, imag); } istream \u0026amp;operator\u0026gt;\u0026gt;(istream \u0026amp;in, Complex \u0026amp;c) { in \u0026gt;\u0026gt; c.real \u0026gt;\u0026gt; c.imag; return in; } ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;out, const Complex \u0026amp;c) { out \u0026lt;\u0026lt; to_string(c.real) + \u0026#34;+\u0026#34; + to_string(c.imag) + \u0026#34;i\u0026#34;; return out; } int main() { Complex a(1, 2); cout \u0026lt;\u0026lt; a + a \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; a++ \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; ++a \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; a = 10; // 相当于a = Complex(10); 产生临时对象，调用构造函数和析构函数  cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 继承与派生 派生类定义 三种继承方式派生类中基类成员的访问控制权限     公有继承 私有继承 保护继承     公有成员 公有 私有 保护   私有成员 派生类不可访问 派生类不可访问 派生类不可访问   保护成员 保护 私有 保护    派生类的构造函数和析构函数 派生类构造函数   不能在派生类构造函数体中显式调用基类构造函数\n  在成员初始化表中可以显式调用基类构造函数\nRectangle(float x,float y,float w,float h) : Point(x,y) { W=w; H=h; } 或: Rectangle(float x,float y,float w,float h) : Point(x,y),W(w),H(h) {}   构造函数和析构函数的调用顺序   构造函数调用顺序：基类的构造函数-\u0026gt;对象成员构造函数-\u0026gt;派生类构造函数\n  析构函数调用顺序刚好相反\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; class O { public: O() { cout \u0026lt;\u0026lt; \u0026#34;O()\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ~O() { cout \u0026lt;\u0026lt; \u0026#34;~O()\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; class A { public: A() { cout \u0026lt;\u0026lt; \u0026#34;A()\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ~A() { cout \u0026lt;\u0026lt; \u0026#34;~A()\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; class B : public A { O o; public: B() { cout \u0026lt;\u0026lt; \u0026#34;B()\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ~B() { cout \u0026lt;\u0026lt; \u0026#34;~B()\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; int main() { B b; return 0; } A()\rO()\rB()\r~B()\r~O()\r~A()\r  :warning:注意\n 当基类中没有显式定义构造函数，或定义了无参数构造函数时，派生类构造函数的初始化表可以省略对基类构造函数的调用，而采用隐含调用 当基类的构造函数使用一个或多个参数时候，派生类必须定义构造函数，提供将参数传递给基类的构造函数的途径。这时，派生类构造函数体可能为空，仅起到参数传递作用 无论是哪种继承方式，基类的私有成员在派生类中都是不可被访问的。只能通过基类的成员函数访问基类的私有数据成员。 如果在一个派生类中要访问基类中的私有成员，可以将这个派生类声明为基类的友元。 class Base { class Derive : public Base { friend class Derive; // 直接使用Base中的私有成员 } }  友元关系是不能继承的：B类是A类的友元，C类是B类的派生类，则C类和A类之间没有任何友元关系，除非C类声明A类是友元。    多继承与虚基类 多继承派生类的定义 class \u0026lt;派生类名\u0026gt;：\u0026lt;继承方式\u0026gt; \u0026lt;基类名1\u0026gt;，…，\u0026lt;继承方式\u0026gt; \u0026lt;基类名n\u0026gt; { \u0026lt;派生类新定义成员\u0026gt; }； 多继承派生类的构造函数 \u0026lt;派生类名\u0026gt;(\u0026lt;总参数表\u0026gt;):\u0026lt;基类名1\u0026gt;(\u0026lt;参数表1\u0026gt;)，…，\u0026lt; 基类名n\u0026gt; (\u0026lt;参数表n\u0026gt;) { \u0026lt;派生类数据成员的初始化\u0026gt; };   构造函数的调用顺序是：先调用所有基类的构造函数，再调用对象成员构造函数，最后调用派生类的构造函数\n  处于同一层次的各基类构造函数的调用顺序取决于定义派生类时所指定的基类顺序，与派生类构造函数中所定义的成员初始化列表无关\n  如果有多个成员类对象，则构造函数额调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化列表的顺序\n  析构函数的调用顺序与构造函数的调用顺序相反\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; class M1 { int i; public: M1(int _i) : i(_i) { cout \u0026lt;\u0026lt; \u0026#34;M1(\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; class M2 { int i; public: M2(int _i) : i(_i) { cout \u0026lt;\u0026lt; \u0026#34;M2(\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; class Base1 { public: Base1() { cout \u0026lt;\u0026lt; \u0026#34;Base1()\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; class Base2 { public: Base2() { cout \u0026lt;\u0026lt; \u0026#34;Base2()\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; class Derive : public Base1, public Base2 { M2 m2; M1 m1; public: Derive(int a, int b) : m1(a), m2(b), Base2() , Base1() {} }; int main() { Derive d(8, 9); return 0; } Base1()\rBase2()\rM2(9)\rM1(8)\r  多继承引起的二义性问题 两个基类有同名成员  implementation #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class A { public: void display() { cout \u0026lt;\u0026lt; \u0026#34;display() in A\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; class B { public: void display() { cout \u0026lt;\u0026lt; \u0026#34;display() in B\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; class C : public A, public B { }; int main() { C c; c.display(); return 0; }  编译错误   两个基类和派生类三者都有同名成员  基类的同名成员在派生类中被屏蔽，或者说，派生类新增加的同名成员隐藏了基类中的同名成员 implementation #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; class A { public: void display() { cout \u0026lt;\u0026lt; \u0026#34;display() in A\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; class B { public: void display() { cout \u0026lt;\u0026lt; \u0026#34;display() in B\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; class C : public A, public B { public: void display() { cout \u0026lt;\u0026lt; \u0026#34;display() in C\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; int main() { C c; c.display(); return 0; }  访问的是派生类C中的成员 display() in C\r  虚基类 虚基类概念  为了避免对基类成员访问的二义性问题，可以将直接基类（如A、B）的共同基类如N设置为虚基类，这样共同基类N在内存中只有一个副本存在 引进虚基类后，派生类对象中只存在一个虚基类成员的副本 为了保证虚基类在派生类中只继承一次，应当在该基类的所有直接派生类中声明为虚基类，否则仍然会出现对基类的多次继承。  构造函数的调用顺序  先调用虚基类的构造函数，再调用非虚基类的构造函数 若同一层次包含多个虚基类，其调用顺序为定义时的顺序 若虚基类构造函数由非虚基类派生而来，则仍先按先调用基类构造函数，再调用派生类构造函数的顺序 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; class Base1 { public: Base1() { cout \u0026lt;\u0026lt; \u0026#34;class Base1\u0026#34; \u0026lt;\u0026lt; endl; } }; class Base2 { public: Base2() { cout \u0026lt;\u0026lt; \u0026#34;class Base2\u0026#34; \u0026lt;\u0026lt; endl; } }; class Level1 : public Base2, virtual public Base1 { public: Level1() { cout \u0026lt;\u0026lt; \u0026#34;class Level1\u0026#34; \u0026lt;\u0026lt; endl; } }; class Level2 : public Base2, virtual public Base1 { public: Level2() { cout \u0026lt;\u0026lt; \u0026#34;class Level2\u0026#34; \u0026lt;\u0026lt; endl; } }; class TopLevel : public Level1, virtual public Level2 { public: TopLevel() { cout \u0026lt;\u0026lt; \u0026#34;class TopLevel\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { TopLevel obj; return 0; } 输出 class Base1\rclass Base2\rclass Level2\rclass Base2\rclass Level1\rclass TopLevel\r  虚基类的初始化 如果在虚基类中只定义了带参数的构造函数，则要在其所有派生类（包括直接派生类或间接派生类）中，通过构造函数的初始化表对虚基类进行初始化。\nclass A { A(int i){} … }; class B:virtual public A { B(int n):A(n){}… }; class C:virtual public A { C(int n):A(n){}… }; class D:public B, public C { D(int n):A(n),B(n),C(n){}… };  :warning:注意  如果多继承不牵扯到对同一基类的派生，就没有必要定义虚基类 使用多继承要十分小心，经常会出现二义性问题 能用单一继承的问题就不要用多继承    多态性与虚函数 类型兼容规则  派生类的对象可以赋值给基类对象 派生类的对象可以初始化基类的引用 派生类的对象的地址可以赋给基类的指针变量  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; class Base { public: void who() { cout \u0026lt;\u0026lt; \u0026#34;Base class\u0026#34; \u0026lt;\u0026lt; endl; } }; class Derive1 : public Base { public: void who() { cout \u0026lt;\u0026lt; \u0026#34;Derive1 class\u0026#34; \u0026lt;\u0026lt; endl; } }; class Derive2 : public Base { public: void who() { cout \u0026lt;\u0026lt; \u0026#34;Derive2 class\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Base obj1, *p; //定义基类对象obj1和基类对象指针p  Derive1 obj2; Derive2 obj3; p = \u0026amp;obj1; // p指向obj1  p-\u0026gt;who(); //通过指针p调用obj1的公有成员函数//who()  p = \u0026amp;obj2; // p指向obj2  p-\u0026gt;who(); // p只能访问从基类继承下来的who()  p = \u0026amp;obj3; // p指向obj2  p-\u0026gt;who(); // p只能访问从基类继承下来的who()  obj2.who(); obj3.who(); return 0; } 输出\nBase class\rBase class\rBase class\rDerive1 class\rDerive2 class\r#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; class Student { int num; public: Student(int n) : num(n) {} void display() { cout \u0026lt;\u0026lt; \u0026#34;num = \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; } }; class Graduate : public Student { string name; public: Graduate(int n, string _name) : Student(n), name(_name) {} void display() { Student::display(); cout \u0026lt;\u0026lt; \u0026#34;name = \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; int main() { Student stu(1001); Graduate grad(2001, \u0026#34;Jack\u0026#34;); Student *pt = \u0026amp;stu; pt-\u0026gt;display(); pt = \u0026amp;grad; pt-\u0026gt;display(); return 0; } 输出\nnum = 1001\rnum = 2001\r多态（Polymorphism） 相似功能的不同函数使用一个名称来实现，从而可以使用相同的调用方式来调用这些具有不同功能的同名函数\n多态的分类  静态多态性（编译时的多态性）：通过函数重载实现 动态多态性（运行时的多态性）：通过虚函数实现  虚函数 虚函数就是在基类中被关键字virtual说明、并在一个或多个派生类中被重新定义的成员函数\nvirtual \u0026lt;函数值类型\u0026gt; \u0026lt;函数名\u0026gt;(\u0026lt;参数表\u0026gt;);\n  程序运行时，不同类的对象调用各自的虚函数，这就是动态多态\n  实现动态的多态性时，必须使用基类类型的指针变量或对象引用，并使其指向不同的派生对象，并通过调用指针或引用所指向的虚函数才能实现动态的多态性\n  声明虚函数要注意\n 静态成员函数和友元函数不能声明为虚函数 内联成员函数不能声明为虚函数 构造函数不能是虚函数 析构函数可以是虚函数 #include \u0026lt;iostream\u0026gt;using namespace std; class Base { public: Base() = default; virtual ~Base() { cout \u0026lt;\u0026lt; \u0026#34;Base destructor\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; class Derived : public Base { public: Derived() = default; ~Derived() { cout \u0026lt;\u0026lt; \u0026#34;Derived destructor\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; int main() { Base *b = new Derived; delete b; return 0; }     联编  联编的分类   静态联编：在编译阶段完成的联编\n#include \u0026lt;iostream\u0026gt;using namespace std; class Student { public: void print() { cout \u0026lt;\u0026lt; \u0026#34;A student\u0026#34; \u0026lt;\u0026lt; endl; } }; class GStudent : public Student { public: void print() { cout \u0026lt;\u0026lt; \u0026#34;A graduate student\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Student s1, *ps; GStudent s2; s1.print(); s2.print(); s2.Student::print(); ps = \u0026amp;s1; ps-\u0026gt;print(); //基类指针和基类成员函数发生关联  ps = \u0026amp;s2; ps-\u0026gt;print(); //希望调用对象s2的输出函数，但调用的却是对象s1的输出函数  return 0; } 输出\nA student\rA graduate student\rA student\rA student\rA student\r  动态联编：根据具体的执行情况来动态的确定，在运行阶段完成\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; class Student { public: // virtual可省略  virtual void print() { cout \u0026lt;\u0026lt; \u0026#34;a Student\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; class GStudent : public Student { public: virtual void print() { cout \u0026lt;\u0026lt; \u0026#34;A graduate student\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; int main() { Student s1, *ps; GStudent s2; s1.print(); s2.print(); s2.Student::print(); ps = \u0026amp;s1; ps-\u0026gt;print(); ps = \u0026amp;s2; // 对象指针调用虚函数，采用动态联编方式  ps-\u0026gt;print(); return 0; } 输出\na Student\rA graduate student\ra Student\ra Student\rA graduate student\r#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; class Student { public: virtual void print() { cout \u0026lt;\u0026lt; \u0026#34;A studnet\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; class GStudent : public Student { public: void print() { cout \u0026lt;\u0026lt; \u0026#34;A graduate studnet\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; void fun(Student \u0026amp;s) { s.print(); } int main() { Student s1; GStudent s2; fun(s1); fun(s2); return 0; } 输出\nA studnet\rA graduate studnet\r :warning:注意  virtual关键字只能用在虚函数声明中，不能用在虚函数的实现中 只有通过对象指针或对象引用来调用虚函数，才能实现动态联编。如果采用对象来调用虚函数，则采用的是静态联编方式 在派生类中重新定义虚函数时，返回值类型、函数名、参数个数、类型和顺序，都必须与基类的原型相同 当在派生类中定义了虚函数的重载函数，但并没有重新定义虚函数时，与虚函数同名的重载函数覆盖了派生类中的虚函数。此时若试图通过派生类对象、指针调用派生类对象的虚函数就会产生错误 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int PI = 3.1415; class Point { int X, Y; public: Point(int X = 0, int Y = 0) { this-\u0026gt;X = X; this-\u0026gt;Y = Y; } virtual double area() { return 0.0; } }; class Circle : public Point { double radius; public: Circle(int X, int Y, double R) : Point(X, Y) { radius = R; } double area(int i) { return PI * radius * radius; } }; int main() { Point P1(10, 10); cout \u0026lt;\u0026lt; \u0026#34;P1.area = \u0026#34; \u0026lt;\u0026lt; P1.area() \u0026lt;\u0026lt; endl; Circle C1(10, 10, 20); cout \u0026lt;\u0026lt; \u0026#34;C1.area = \u0026#34; \u0026lt;\u0026lt; C1.area() \u0026lt;\u0026lt; endl; Point *Pp; Pp = \u0026amp;C1; cout \u0026lt;\u0026lt; \u0026#34;Pp.area = \u0026#34; \u0026lt;\u0026lt; Pp-\u0026gt;area() \u0026lt;\u0026lt; endl; Point \u0026amp;Rp = C1; cout \u0026lt;\u0026lt; \u0026#34;Rp.area = \u0026#34; \u0026lt;\u0026lt; Rp.area() \u0026lt;\u0026lt; endl; return 0; }  如果在派生类中没有重新定义虚函数，则不实现动态联编，派生类的对象将使用基类虚函数的代码 一个类中的虚函数说明只对派生类中重定义的函数有影响，对它的基类中的函数并没有影响 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; class Base { public: int func(int x) { cout \u0026lt;\u0026lt; \u0026#34;This is Base class\u0026#34; \u0026lt;\u0026lt; endl; return x; } }; class SubClass : public Base { public: virtual int func(int x) { cout \u0026lt;\u0026lt; \u0026#34;This is SubClass\u0026#34; \u0026lt;\u0026lt; endl; return x; } }; class SubSubClass : public SubClass { public: int func(int x) { cout \u0026lt;\u0026lt; \u0026#34;This is SubSubClass\u0026#34; \u0026lt;\u0026lt; endl; return x; } }; int main() { SubSubClass ss; Base \u0026amp;b = ss; cout \u0026lt;\u0026lt; b.func(5) \u0026lt;\u0026lt; endl; SubClass \u0026amp;s = ss; cout \u0026lt;\u0026lt; s.func(5) \u0026lt;\u0026lt; endl; return 0; } 输出 This is Base class 5\rThis is Sub2 class 5\r        纯虚函数 纯虚函数用virtual声明，没有任何实现，必须由派生类重新定义该函数提供实现\n  纯虚函数与函数体为空的虚函数\n 区别  前者没有函数体，后者有函数体 前者所在的类是抽象类，不能直接实例化；后者所在的类是可以实例化的（该类中不含有其他纯虚函数）   共同点  可以派生出新的类，然后在新类中给出虚函数的实现，而且这种实现可以具有动态特征    #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; class A { protected: int x; public: A() { x = 1000; } virtual void print() = 0; // 定义纯虚函数 }; class B : public A { int y; public: B() { y = 2000; } void print() { cout \u0026lt;\u0026lt; \u0026#34;y = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } // 重新定义纯虚函数 }; class C : public A { int z; public: C() { z = 3000; } void print() { cout \u0026lt;\u0026lt; \u0026#34;z = \u0026#34; \u0026lt;\u0026lt; z \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } // 重新定义纯虚函数 }; int main() { A *pa; B b; C c; pa = \u0026amp;b; pa-\u0026gt;print(); pa = \u0026amp;c; pa-\u0026gt;print(); // A a; 不能定义抽象类的对象  // pa = \u0026amp;a;  // pa-\u0026gt;pritn();  return 0; } 输出\ny = 2000\rz = 3000\r  抽象类   包含一个或多个纯虚函数的类称为抽象类\n  如果派生类没有实现基类中的所有纯虚函数，派生类也是抽象类\n  抽象类无法实例化\n  抽象类不能用作参数类型、函数值类型或显式转换的类型，但可以声明指向抽象类的的指针或引用，通过指针或引用来指向并访问派生类对象，从而实现动态多态\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const double PI = 3.14159; class Shapes //抽象类 { public: void setvalue(int d, int w = 0) { x = d; y = w; } virtual void area() = 0; //纯虚函数  protected: int x, y; }; class Square : public Shapes { public: void area() //计算矩形面积  { cout \u0026lt;\u0026lt; \u0026#34;area of rectangle:\u0026#34; \u0026lt;\u0026lt; x * y \u0026lt;\u0026lt; endl; } }; class Circle : public Shapes { public: void area() //计算圆面积  { cout \u0026lt;\u0026lt; \u0026#34;area of circle:\u0026#34; \u0026lt;\u0026lt; PI * x * x \u0026lt;\u0026lt; endl; } }; int main() { Shapes *ptr[2]; //声明抽象类指针  Square s1; //声明派生类对象  Circle c1; //声明派生类对象  ptr[0] = \u0026amp;s1; //抽象类指针指向派生类对象  ptr[0]-\u0026gt;setvalue(10, 5); ptr[0]-\u0026gt;area(); //抽象类指针调用派生类成员函数,实现多态  ptr[1] = \u0026amp;c1; //抽象类指针指向派生类对象  ptr[1]-\u0026gt;setvalue(10); ptr[1]-\u0026gt;area(); //抽象类指针调用派生类成员函数,实现多态  return 0; } 输出\narea of rectangle:50\rarea of circle:314.159\r  第三次上机题目  定义一个复数类Complex，重载运算符“+”，“-”，“*”，“/”,使之能用于复数的加、减、乘、除。运算符重载函数作为Complex类的成员函数。编程序，分别求两个复数之和、差、积和商。 对于2行3列矩阵，重载流插入运算符“\u0026laquo;”和流提取运算符“\u0026raquo;”，使之能用于矩阵的输入和输出。 定义Time类和Date类，Time类为Date类的友元类，通过Time类中的display函数引用Date类对象的私有数据，输出年、月、日和时、分、秒。 分别定义Teacher（教师）类和Cadre（干部）类，采用多继承方式由这两个类派生出新类Teacher_Cadre（教师兼干部）。要求：  在两个基类中都包含姓名、年龄、性别、地址、电话等数据成员。 在Teacher类中还包含数据成员titile（职称），在Cadre类中还包含数据成员post（职务），在Teacher_Cadre类中还包含数据成员wages（工资）。 对两个基类中的姓名、年龄、性别、地址、电话等数据成员用相同的名字，在引用这些数据成员时，指定作用域。 在类体中声明成员函数，在类外定义成员函数。 在派生类Teacher_Cadre的成员函数show中调用Teacher类中的display函数，输出姓名、年龄、性别、职称、地址、电话，然后再用cout语句输出职务与工资。   写一个程序，定义抽象基类Shape，由它派生出5个派生类：Circle（圆形）、Square（正方形）、Rectangle（矩形）、Trapezoid（梯形）、Triangle（三角形）。用虚函数分别计算几种图形面积，并求它们的和。要求用基类指针数组，使它的每一个元素指向一个派生类对象。  源码下载 1\n2\n3\n4\n5\n输入输出流 流 数据从一个位置流向另一个位置。流是字节的序列。\nI/O流类库的层次结构  C++编译系统提供的I/O流类库含有两个平行基类：  streambuf ios   ios类有4个直接派生类：  输入流类istream 输出流类ostream 文件流类基类fstreambase 字符串流类基类strstreambase     I/O流类库的头文件  iostream：I/O流类库的最主要的头文件，包含了对输入输出流进行操作的所需的基本信息，还包括cin、cout、cerr、clog共4个流对象 fstream：用于用户管理的文件的I/O操作 strstream：用于字符串流I/O stdiostream：用于混合使用C和C++的I/O操作 iomanip：用于格式化I/O时应包含此头文件  输入输出的格式控制  两种格式化方式  用流对象的有关成员函数进行格式化 用专门的控制符进行格式化输入输出    用流对象的成员函数格式化  设置状态标志 long ios::setf(long flags)  清楚状态标志 long ios::unsetf(long flags)  取状态标志 long ios::flags()  取状态标志并设置状态标志 long ios::flags(long flag)   :warning:以上三组函数必须用流式对象（cin或cout）来调用\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; void showflags(long f) { long i; for (i = 0x8000; i; i \u0026gt;\u0026gt;= 1) { cout \u0026lt;\u0026lt; ((i \u0026amp; f) ? \u0026#34;1\u0026#34; : \u0026#34;0\u0026#34;); } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { long f; f = cout.flags(); showflags(f); cout.setf(ios::showpos | ios::scientific | ios::fixed); // 追加状态标志  f = cout.flags(); showflags(f); cout.unsetf(ios::scientific); // 从状态标志中去掉scientific  f = cout.flags(); showflags(f); f = cout.flags(ios::hex); // 重新设置状态标志  showflags(f); // 重新设置状态标志之前  f = cout.flags(); showflags(f); return 0; }  用流对象的成员函数设置输出宽度  int ios::width(int len) int ios::width()  第一种设置输出宽度并返回原来的输出宽度；第二种返回当前输出宽度，默认输出宽度为0 只对其后的第一个输出项有效 设置填充字符  char ios::fill(char ch) char ios::fill()  设置输出精度  int ios::precision(int p) int ios::precision()  默认输出精度为6 用流成员函数put输出字符  cout.out(\u0026#39;a\u0026#39;) #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int i = cout.width(); cout \u0026lt;\u0026lt; \u0026#34;width: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout.width(8); cout \u0026lt;\u0026lt; cout.width() \u0026lt;\u0026lt; \u0026#34;new width\u0026#34; \u0026lt;\u0026lt; endl; char c = cout.fill(); cout \u0026lt;\u0026lt; \u0026#34;filling word is: \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34;(ASCII code\u0026#34; \u0026lt;\u0026lt; (int)c \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; endl; cout.fill(\u0026#39;*\u0026#39;); cout \u0026lt;\u0026lt; cout.fill() \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; (int)cout.fill() \u0026lt;\u0026lt; \u0026#34;)(new filling word)\u0026#34; \u0026lt;\u0026lt; endl; int j = cout.precision(); cout \u0026lt;\u0026lt; \u0026#34;precision: \u0026#34; \u0026lt;\u0026lt; j \u0026lt;\u0026lt; endl; cout.precision(8); cout \u0026lt;\u0026lt; 123.456789 \u0026lt;\u0026lt; \u0026#34;(example)\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; cout.precision() \u0026lt;\u0026lt; \u0026#34;(new precision)\u0026#34; \u0026lt;\u0026lt; endl; return 0; } width:0\r8(new width)\rfilling word is: (ASCII code32)\r*(42)(new filling word)\rprecision:6\r123.45679(example)\r8(new precision)\r 用于字符输入的流成员函数  不带参数的get函数 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int c; cout \u0026lt;\u0026lt; \u0026#34;enter a sentence:\u0026#34; \u0026lt;\u0026lt; endl; while ((c = cin.get()) != EOF) // 函数的返回值就是读入的字符 \tcout.put(c); return 0; }  有一个参数的get函数 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { char c; cout \u0026lt;\u0026lt; \u0026#34;enter a sentence:\u0026#34; \u0026lt;\u0026lt; endl; while (cin.get( c)) // 读取一个字符赋给c，如果读取成功，返回真，如失败（如遇文件结束符）则返回假  cout.put(c); cout \u0026lt;\u0026lt; \u0026#34;end\u0026#34; \u0026lt;\u0026lt; endl; return 0; }  有三个参数的get函数  cin.get(字符数组/字符指针, 字符个数n, 终止字符) 从输入流中读取n-1个字符，赋给指定的字符数组（或字符指针指向的数组） 如果在读取n-1个字符之前遇到指定的终止字符，则提前读取结束 如果读取成功返回真，失败（遇文件结束符）则返回假  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { char ch[20]; cout \u0026lt;\u0026lt; \u0026#34;enter a sentence:\u0026#34; \u0026lt;\u0026lt; endl; cin.get(ch, 10, \u0026#39;/\u0026#39;); cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; cin.get(ch, 20, \u0026#39;\\n\u0026#39;); // cin.get(ch, 20);  cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; return 0; } enter a sentence:\ryou!/her.\ryou!\r/her.\r 用getline函数读入一行字符  cin.getline(字符数组（或字符指针）, 字符个数n, 终止字符) 从输入流中读取一行字符，其用法与带3个参数的get函数类似 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { char ch[20]; cout \u0026lt;\u0026lt; \u0026#34;enter a sentence:\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; ch; cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; cin.getline(ch, 20, \u0026#39;/\u0026#39;); cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; cin.getline(ch, 20); cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; return 0; } enter a sentence:\rI like C++./I study C++./I am happy.\rI\rlike C++.\rI study C++./I am h\r   eof函数 while(!cin.eof())  peek函数  无参函数，表示“观察”，观测下一字符 返回值是当前指针指向的当前字符，但只是观测，指针仍停留在当前位置，并不后移 如果要访问的字符是文件结束符时，则函数值是EOF  c = cin.peek();  putback函数  将前面用get或getline函数从输入流中读取的字符ch返回到输入流，插入到当前指针位置，供后面读取  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { char c[20]; int ch; cout \u0026lt;\u0026lt; \u0026#34;enter a sentence:\u0026#34; \u0026lt;\u0026lt; endl; cin.getline(c, 15, \u0026#39;/\u0026#39;); cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; ch = cin.peek(); // 观看当前字符 \tcout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; cin.putback(c[0]); // 将\u0026#39;I\u0026#39;插入到指针所指处 \tcin.getline(c, 15, \u0026#39;/\u0026#39;); cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; return 0; } enter a sentence:\rI am a boy./ am a student./\rI am a boy.\r32\rI am a student\r ignore函数  cin.ignore(n, 终止字符) 跳过输入流中n个字符，或在遇到指定的终止字符时提前结束（此时跳过包括终止字符在内的若干字符）  ignore(5, \u0026#39;A\u0026#39;); // 跳过5个字符，遇\u0026#39;A\u0026#39;后不再跳 ignore(); \u0026lt;-\u0026gt; ignore(1, EOF);  示例代码  不加ignore #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { char ch[20]; cin.get(ch, 20, \u0026#39;/\u0026#39;); cout \u0026lt;\u0026lt; \u0026#34;the first part is: \u0026#34; \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; cin.get(ch, 20, \u0026#39;/\u0026#39;); // get不跳过终止字符  cout \u0026lt;\u0026lt; \u0026#34;the second part is: \u0026#34; \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; return 0; } I like C++./I study C++./I am happy.\rThe first part is:I like C++.\rThe second part is:\r 加ignore #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { char ch[20]; cin.get(ch, 20, \u0026#39;/\u0026#39;); cout \u0026lt;\u0026lt; \u0026#34;the first part is: \u0026#34; \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; cin.ignore(); // 跳过输入流中一个字符  cin.get(ch, 20, \u0026#39;/\u0026#39;); // get不跳过终止字符  cout \u0026lt;\u0026lt; \u0026#34;the second part is: \u0026#34; \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; return 0; } I like C++./I study C++./I am happy.\rThe first part is:I like C++.\rThe second part is:I study C++.\r       用控制符格式化  这组控制符不属于任何类成员，定义在inomanip头文件中 将他们用在提取运算符\u0026quot;\u0026raquo;\u0026ldquo;或插入运算符\u0026rdquo;\u0026laquo;\u0026ldquo;后面来设定输入/输出格式，即在读写对象之间插入一个修改状态的操作 设置输入/输出宽度setw(int)  用整型参数来指定输入/输出域的宽度。使用时只对其后一项输入/输出有效 当用于输出时，若实际宽度小于设置宽度时，数据向右对齐，反之则按照数据的实际宽度输出 当用于输入时，若输入的数据宽度超过设置宽度时，超出的数据部分被截断而被作为下一项输入内容  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { char *p = \u0026#34;12345\u0026#34;, *q = \u0026#34;678\u0026#34;; char f[4], g[4]; int i = 10; cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; setw(6) \u0026lt;\u0026lt; q \u0026lt;\u0026lt; setw(4) \u0026lt;\u0026lt; p \u0026lt;\u0026lt; q \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; setw(4) \u0026gt;\u0026gt; f \u0026gt;\u0026gt; g; cout \u0026lt;\u0026lt; f \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; g \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;i : \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; return 0; } 12345 67812345678\r12345\r123\r45\ri:10\r 设置输出填充字符setfill(char) setprecision(int)  在以fixed形式和scientific形式输出时参数为小数位数   setiosflags(ios::fixed)用定点方式表示实数 setiosflags(ios::scientific)用科学记数法方式表示实数 setiosflags(ios::left)左对齐 setiosflags(ios::right)右对齐 setiosflags(ios::uppercase)大写表示 setiosflags(ios::showpos)正号 setiosflags(ios::skipws)忽略前导空格 resetiosflags() 终止已设置的输出格式状态，在括号中应指定内容  #include \u0026lt;iostream\u0026gt;#include \u0026lt;iomanip\u0026gt;using namespace std; int main() { double f=22.0/7; //在用浮点形式表示的输出中，setprecision(n)表示实数的有效位数  cout\u0026lt;\u0026lt;f\u0026lt;\u0026lt;endl; //默认有效位数为6  cout\u0026lt;\u0026lt;setprecision(3)\u0026lt;\u0026lt;f\u0026lt;\u0026lt;endl; //设置有效位数为3 //在用定点形式表示的输出中，setprecision(n)表示实数的小数位数  cout\u0026lt;\u0026lt;setiosflags(ios::fixed); cout\u0026lt;\u0026lt;setprecision(8)\u0026lt;\u0026lt;f\u0026lt;\u0026lt;endl; //小数位数为8  return 0; } 3.14286\r3.14\r3.14285714\r 设置输入/输出整型数数制dec、hex和oct 控制换行的控制符endl 代表输出单字符'\\0\u0026rsquo;的控制符ends    ","permalink":"https://fffzlfk.github.io/posts/oopc++/","summary":"Object-Oriented Programming","title":"OOP(C++)"},{"content":"$$e^x=1+x+\\frac{x^2}{2!}+\u0026hellip;+\\frac{x^n}{n!}+\u0026hellip;=\\sum_{n=0}^{\\infty} \\frac{x^n}{n!}$$\n$$ sinx = x-\\frac{1}{3!}x^3+\u0026hellip;+(-1)^n\\frac{1}{(2n+1)!}x^{2n+1}+\u0026hellip;=\\sum_{n=0}^{\\infty} (-1)^{n}\\frac{x^{2n+1}}{(2n+1)!} $$\n$$ cosx = 1 - \\frac{1}{2!}x^2 +\u0026hellip;+ (-1)^n\\frac{1}{(2n)!}x^{2n}+\u0026hellip;=\\sum_{n=0}^{\\infty} (-1)^{n}\\frac{x^{2n}}{(2n)!} $$\n$$ ln(1+x)=x-\\frac{1}{2}x^2+\u0026hellip;+(-1)^{n-1}\\frac{x^n}{n}+\u0026hellip;=\\sum_{n=0}^{\\infty} (-1)^{n-1}\\frac{x^{n}}{n}, -1 \\lt x \\le 1 $$\n$$ (1+x)^{\\alpha} = 1 + \\alpha x + \\frac{\\alpha(\\alpha-1)}{2} x^2 + o(x^2) (x \\rightarrow 0, a \\ne 0) $$\n$$ tanx = x + \\frac{1}{3}x^3+o(x^3) (x \\rightarrow 0) $$\n$$ arcsinx = x + \\frac{1}{6}x^3+o(x^3) (x \\rightarrow 0) $$\n$$ arctanx = x - \\frac{1}{3}x^3+o(x^3) (x \\rightarrow 0) $$\n","permalink":"https://fffzlfk.github.io/posts/%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F%E6%80%BB%E7%BB%93/","summary":"Taylor formula","title":"泰勒公式总结"}]