[{"content":"åå‘ä¼ æ’­ åå‘ä¼ æ’­ï¼ˆè‹±è¯­ï¼šBackpropagationï¼Œæ„ä¸ºè¯¯å·®åå‘ä¼ æ’­ï¼Œç¼©å†™ä¸ºBPï¼‰æ˜¯å¯¹å¤šå±‚äººå·¥ç¥ç»ç½‘ç»œè¿›è¡Œæ¢¯åº¦ä¸‹é™çš„ç®—æ³•ï¼Œä¹Ÿå°±æ˜¯ç”¨é“¾å¼æ³•åˆ™ä»¥ç½‘ç»œæ¯å±‚çš„æƒé‡ä¸ºå˜æ•°è®¡ç®—æŸå¤±å‡½æ•°çš„æ¢¯åº¦ï¼Œä»¥æ›´æ–°æƒé‡æ¥æœ€å°åŒ–æŸå¤±å‡½æ•°ã€‚\nç®€å•ä¾‹å­è®¡ç®— ç¬¦å· $ w_ij $ æƒé‡ $ z_i $ è¾“å…¥ $ y_i $ è¾“å‡º $ E = \\frac{1}{2}(y_p-y_a)^2$ æŸå¤± $ f(x) = \\frac{1}{1+e^(-x)}$ æ¿€æ´»å‡½æ•° ä¾‹å¦‚æ±‚ $\\Delta w_{53}$ $$ \\begin{cases} E = \\frac{1}{2}(y_5-y_a)^2\\\\ y_5 = f(z_5)\\\\ z_5 = w_{53} * y_3 + w_{54} * y_4 \\end{cases} $$\n$$ \\begin{align} \\Delta w_{53} \u0026amp;= \\frac{\\partial E}{\\partial w_{53}} \\\\ \u0026amp;= \\frac{\\partial E}{\\partial y_{5}} \\frac{\\partial y_5}{\\partial z_5} \\frac{\\partial z_5}{\\partial w_{53}} \\end{align} $$\nä»£ç å®ç° from math import exp, sqrt def f(x): \u0026#34;\u0026#34;\u0026#34;returns sigmoid(x)\u0026#34;\u0026#34;\u0026#34; return 1 / (1 + exp(-x)) def d_f(x): \u0026#34;\u0026#34;\u0026#34;return d(sigmoid(x))/dx\u0026#34;\u0026#34;\u0026#34; return f(x) * (1 - f(x)) def E(yp, ya): \u0026#34;\u0026#34;\u0026#34;return the error in squre\u0026#34;\u0026#34;\u0026#34; return 1/2*(yp-ya)**2 def d_E(yp, ya): \u0026#34;\u0026#34;\u0026#34;return dE/d(yp)\u0026#34;\u0026#34;\u0026#34; return yp - ya ya = 0.5 z = {1: 0.35, 2: 0.9, 3: 0.0, 4: 0.0, 5: 0.0} w = {(1, 3): 0.1, (2, 3): 0.8, (1, 4): 0.4, (2, 4): 0.6, (3, 5): 0.3, (4, 5): 0.9} y = {i: 0.0 for i in range(1, 6)} s = {(1, 3): 0.0, (2, 3): 0.0, (1, 4): 0.0, (2, 4): 0.0, (3, 5): 0.0, (4, 5): 0.0} def forward(): \u0026#34;\u0026#34;\u0026#34;æ­£å‘è®¡ç®—\u0026#34;\u0026#34;\u0026#34; y[1], y[2] = z[1], z[2] z[3], z[4] = w[1, 3] * y[1] + w[2, 3] * \\ y[2], w[1, 4] * y[1] + w[2, 4] * y[2] y[3], y[4] = f(z[3]), f(z[4]) z[5] = w[3, 5] * y[3] + w[4, 5] * y[4] y[5] = f(z[5]) e = E(y[5], ya) print(f\u0026#39;yp = {y[5]}, Error = {e}\u0026#39;) return e def update(n, g): \u0026#34;\u0026#34;\u0026#34;update weights\u0026#34;\u0026#34;\u0026#34; w[n] -= g def back(): \u0026#34;\u0026#34;\u0026#34;back propagation\u0026#34;\u0026#34;\u0026#34; g = d_E(y[5], ya) * d_f(z[5]) * y[3] update((3, 5), g) g = d_E(y[5], ya) * d_f(z[5]) * y[4] update((4, 5), g) g = d_E(y[5], ya) * d_f(z[5]) * w[3, 5] * d_f(z[3]) * y[1] update((1, 3), g) g = d_E(y[5], ya) * d_f(z[5]) * w[3, 5] * d_f(z[3]) * y[2] update((2, 3), g) g = d_E(y[5], ya) * d_f(z[5]) * w[4, 5] * d_f(z[4]) * y[1] update((1, 4), g) g = d_E(y[5], ya) * d_f(z[5]) * w[4, 5] * d_f(z[4]) * y[2] update((2, 4), g) if __name__ == \u0026#39;__main__\u0026#39;: step = 1 while True: print(f\u0026#39;step = {step}:\u0026#39;, end=\u0026#39; \u0026#39;) if forward() \u0026lt; 0.0000001: break step += 1 back() è¿è¡Œä»£ç ï¼Œå‘ç°è¿­ä»£111æ¬¡åï¼ŒæŸå¤±æ‰è¾¾åˆ°é¢„æœŸã€‚\nâœ python3 main.py step = 1: yp = 0.6902834929076443, Error = 0.01810390383656677 step = 2: yp = 0.6820312027460466, Error = 0.016567679386586154 step = 3: yp = 0.6739592936119999, Error = 0.015130917916992996 step = 4: yp = 0.6660860653430867, Error = 0.013792290550574028 ... ... ... step = 110: yp = 0.500455314229855, Error = 1.036555239542297e-07 step = 111: yp = 0.5004302844701667, Error = 9.2572362633313e-08 åŠ¨é‡æ³•ä¼˜åŒ– def update(n, g): \u0026#34;\u0026#34;\u0026#34;update weights\u0026#34;\u0026#34;\u0026#34; lr = 0.1 beta = 0.999 epsilon = 0.01 s[n] = beta * s[n] + (1 - beta) * g**2 w[n] -= lr / (sqrt(s[n]) + epsilon) * g ä»£ç å¦‚ä¸Šï¼Œä½¿ç”¨åŠ¨é‡æ³•ä¼˜åŒ–åï¼Œä»…è¿­ä»£11æ­¥æŸå¤±å°±è¾¾åˆ°äº†é¢„æœŸã€‚\nâœ python3 main.py step = 1: yp = 0.6902834929076443, Error = 0.01810390383656677 step = 2: yp = 0.6118790538896405, Error = 0.006258461349620539 step = 3: yp = 0.5593494607066376, Error = 0.0017611792430843605 step = 4: yp = 0.5301730589054645, Error = 0.00045520674185631563 step = 5: yp = 0.5151484953395415, Error = 0.00011473845552605596 step = 6: yp = 0.5075810359788381, Error = 2.873605325621872e-05 step = 7: yp = 0.5037909668833773, Error = 7.185714955431785e-06 step = 8: yp = 0.5018953359787233, Error = 1.7961492361214424e-06 step = 9: yp = 0.5009475298860605, Error = 4.48906442488917e-07 step = 10: yp = 0.5004736747645289, Error = 1.1218389127573745e-07 step = 11: yp = 0.5002367820786155, Error = 2.803287637675012e-08 References https://zh.m.wikipedia.org/zh-cn/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95\n","permalink":"https://fffzlfk.github.io/posts/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/","summary":"åå‘ä¼ æ’­ åå‘ä¼ æ’­ï¼ˆè‹±è¯­ï¼šBackpropagationï¼Œæ„ä¸ºè¯¯å·®åå‘ä¼ æ’­ï¼Œç¼©å†™ä¸ºBPï¼‰æ˜¯å¯¹å¤šå±‚äººå·¥ç¥ç»ç½‘ç»œè¿›è¡Œæ¢¯åº¦ä¸‹é™çš„ç®—æ³•ï¼Œä¹Ÿå°±æ˜¯ç”¨é“¾å¼æ³•åˆ™ä»¥ç½‘ç»œæ¯å±‚çš„æƒé‡ä¸ºå˜æ•°è®¡ç®—æŸå¤±å‡½æ•°çš„æ¢¯åº¦ï¼Œä»¥æ›´æ–°æƒé‡æ¥æœ€å°åŒ–æŸå¤±å‡½æ•°ã€‚\nç®€å•ä¾‹å­è®¡ç®— ç¬¦å· $ w_ij $ æƒé‡ $ z_i $ è¾“å…¥ $ y_i $ è¾“å‡º $ E = \\frac{1}{2}(y_p-y_a)^2$ æŸå¤± $ f(x) = \\frac{1}{1+e^(-x)}$ æ¿€æ´»å‡½æ•° ä¾‹å¦‚æ±‚ $\\Delta w_{53}$ $$ \\begin{cases} E = \\frac{1}{2}(y_5-y_a)^2\\\\ y_5 = f(z_5)\\\\ z_5 = w_{53} * y_3 + w_{54} * y_4 \\end{cases} $$\n$$ \\begin{align} \\Delta w_{53} \u0026amp;= \\frac{\\partial E}{\\partial w_{53}} \\\\ \u0026amp;= \\frac{\\partial E}{\\partial y_{5}} \\frac{\\partial y_5}{\\partial z_5} \\frac{\\partial z_5}{\\partial w_{53}} \\end{align} $$\nä»£ç å®ç° from math import exp, sqrt def f(x): \u0026#34;\u0026#34;\u0026#34;returns sigmoid(x)\u0026#34;\u0026#34;\u0026#34; return 1 / (1 + exp(-x)) def d_f(x): \u0026#34;\u0026#34;\u0026#34;return d(sigmoid(x))/dx\u0026#34;\u0026#34;\u0026#34; return f(x) * (1 - f(x)) def E(yp, ya): \u0026#34;\u0026#34;\u0026#34;return the error in squre\u0026#34;\u0026#34;\u0026#34; return 1/2*(yp-ya)**2 def d_E(yp, ya): \u0026#34;\u0026#34;\u0026#34;return dE/d(yp)\u0026#34;\u0026#34;\u0026#34; return yp - ya ya = 0.","title":"åå‘ä¼ æ’­"},{"content":"ç¬¬ä¸€ç«  ç»„åˆæ•°å­¦åŸºç¡€ æ’åˆ— ç›¸å¼‚å…ƒç´ ä¸å…è®¸é‡å¤çš„æ’åˆ— $P(n, r)$\nçƒç›’æ¨¡å‹ï¼šå°†$r$ ä¸ªæœ‰åŒºåˆ«çš„çƒæ”¾å…¥ $n$ ä¸ªä¸åŒçš„ç›’å­é‡Œï¼Œæ¯ç›’ä¸è¶…è¿‡ä¸€ä¸ªã€‚ è®¡ç®—å…¬å¼ï¼š$$ P(n, r)=\\frac{n!}{(n-r)!} $$ é›†åˆæè¿°ï¼š$$ S=\\{1 \\cdot e_1, 1 \\cdot e_2,\u0026hellip;,1 \\cdot e_n\\} $$ ç›¸å¼‚å…ƒç´ å…è®¸é‡å¤çš„æ’åˆ— $RP(\\infty, r)$\nçƒç›’æ¨¡å‹ï¼šå°†$r$ ä¸ªæœ‰åŒºåˆ«çš„çƒæ”¾å…¥ $n$ ä¸ªä¸åŒçš„ç›’å­é‡Œï¼Œæ¯ä¸ªç›’å­çš„çƒæ•°ä¸åŠ é™åˆ¶è€Œä¸”åŒç›’çš„çƒä¸åˆ†æ¬¡åºã€‚\nè®¡ç®—å…¬å¼ï¼š$$ RP(\\infty, r) = n^r $$\né›†åˆæè¿°ï¼š$$ S=\\{\\infty \\cdot e_1, \\infty \\cdot e_2,\u0026hellip;,\\infty \\cdot e_n\\} $$\nä¸å°½ç›¸å¼‚å…ƒç´ çš„å…¨æ’åˆ—\nçƒç›’æ¨¡å‹ï¼šå°†$r$ä¸ªæœ‰åŒºåˆ«çš„çƒæ”¾å…¥$t$ä¸ªä¸åŒçš„ç›’å­ï¼Œæ¯ä¸ªç›’å­çš„å®¹é‡æ˜¯æœ‰é™çš„ï¼Œå…¶ä¸­ç¬¬$i$ä¸ªç›’å­æœ€å¤šåªèƒ½æ”¾å…¥$n_i$ä¸ªçƒï¼ŒåŒç›’çš„çƒä¸åˆ†æ¬¡åºã€‚ é›†åˆæè¿°ï¼š$$ S=\\{ n_1 \\cdot e_1, n_2 \\cdot e_2,\u0026hellip;,n_t \\cdot e_t \\}, n_1+n_2+\u0026hellip;+n_t=n $$ ç‰¹ä¾‹ $r=1$ $$ RP(n, 1) = t $$ $r=n$ $$ RP(n, n) = \\frac{n!}{n_1!n_2!\u0026hellip;n_t!} $$ ç›¸å¼‚å…ƒç´ ä¸å…è®¸é‡å¤çš„åœ†æ’åˆ— $CP(n, r)$ $$ CP(n, r) = \\frac{P(n, r)}{r} = \\frac{n!}{r(n-r)!} $$\né¡¹é“¾æ’åˆ— $$ \\frac{P(n, r)}{2r} = \\frac{n!}{2r(n-r)!} $$\nç»„åˆ ç›¸å¼‚å…ƒç´ ä¸å…è®¸é‡å¤çš„ç»„åˆ $C(n, r)$\nçƒç›’æ¨¡å‹ï¼šå°†$r$ ä¸ªæ— åŒºåˆ«çš„çƒæ”¾å…¥ $n$ ä¸ªä¸åŒçš„ç›’å­é‡Œï¼Œæ¯ç›’ä¸è¶…è¿‡ä¸€ä¸ªã€‚ è®¡ç®—å…¬å¼ï¼š$$ P(n, r)=\\frac{n!}{(n-r)!r!} $$ ç›¸å¼‚å…ƒç´ å…è®¸é‡å¤çš„ç»„åˆ $RC(\\infty, r)$\nçƒç›’æ¨¡å‹ï¼šå°†$r$ ä¸ªæ— åŒºåˆ«çš„çƒæ”¾å…¥ $n$ ä¸ªä¸åŒçš„ç›’å­é‡Œï¼Œæ¯ä¸ªç›’å­çš„çƒæ•°ä¸åŠ é™åˆ¶ã€‚ è®¡ç®—å…¬å¼ï¼š$$ RC(\\infty, r)=C(n+r-1, r)=\\frac{(n+r-1)!}{r!(n-1)!} $$ ä¸å°½ç›¸å¼‚å…ƒç´ ä»»å–$r$ä¸ªç»„åˆé—®é¢˜ $RC(n, r)$\nçƒç›’æ¨¡å‹ï¼šå°†$r$ä¸ªæ— åŒºåˆ«çš„çƒæ”¾å…¥$t$ä¸ªä¸åŒçš„ç›’å­ï¼Œæ¯ä¸ªç›’å­çš„å®¹é‡æ˜¯æœ‰é™çš„ï¼Œå…¶ä¸­ç¬¬$i$ä¸ªç›’å­æœ€å¤šåªèƒ½æ”¾å…¥$n_i$ä¸ªçƒï¼ŒåŒç›’çš„çƒä¸åˆ†æ¬¡åºã€‚ é›†åˆæè¿°ï¼š$$ S=\\{ n_1 \\cdot e_1, n_2 \\cdot e_2,\u0026hellip;,n_t \\cdot e_t \\}, n_1+n_2+\u0026hellip;+n_t=n $$ å¤šé¡¹å¼$$ \\prod_{i=1}^{t}{\\sum_{j=0}^{n_i}{x^j}}=\\prod_{i=1}^{t}{(1+x+x^2+\u0026hellip;+x^{n_i})}=\\sum_{r=0}^{n}{a_rx^r} $$ åˆ™$RC(n, r)$å°±æ˜¯å¤šé¡¹å¼ä¸­$x^r$çš„ç³»æ•°ï¼Œå³$RC(n, r)=a_r$ã€‚ å¤šé¡¹å¼ç³»æ•° é—®é¢˜ï¼šå°†$n$ä¸ªç›¸å¼‚çš„çƒæ”¾å…¥$t$ä¸ªç›’å­ï¼Œè¦æ±‚ç¬¬$i$ä¸ªç›’å­é‡Œæ”¾å…¥$n_i$ä¸ªï¼Œä¸”ç›’ä¸­çš„çƒæ— æ¬¡åºã€‚ è®¡ç®—å…¬å¼ï¼š$$ RP(n, n)=\\frac{n!}{n_1!n_2!\u0026hellip;n_t!} $$ä»¿ç…§äºŒé¡¹å¼ç³»æ•°$\\begin{pmatrix}n \\\\ r \\end{pmatrix}$ï¼Œå°†å…¶è®°ä¸º$\\begin{pmatrix}n \\\\ n_1n_2\u0026hellip;n_t \\end{pmatrix}$ å¤šé¡¹å¼å±•å¼€çš„é¡¹æ•° $(x_1+x_2+\u0026hellip;+x_t)^n$å±•å¼€çš„é¡¹æ•°ç­‰äº$C(n+t-1, n)$ ç³»æ•°ä¹‹å’Œä¸º$t_n$ ","permalink":"https://fffzlfk.github.io/posts/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0/","summary":"ç¬¬ä¸€ç«  ç»„åˆæ•°å­¦åŸºç¡€ æ’åˆ— ç›¸å¼‚å…ƒç´ ä¸å…è®¸é‡å¤çš„æ’åˆ— $P(n, r)$\nçƒç›’æ¨¡å‹ï¼šå°†$r$ ä¸ªæœ‰åŒºåˆ«çš„çƒæ”¾å…¥ $n$ ä¸ªä¸åŒçš„ç›’å­é‡Œï¼Œæ¯ç›’ä¸è¶…è¿‡ä¸€ä¸ªã€‚ è®¡ç®—å…¬å¼ï¼š$$ P(n, r)=\\frac{n!}{(n-r)!} $$ é›†åˆæè¿°ï¼š$$ S=\\{1 \\cdot e_1, 1 \\cdot e_2,\u0026hellip;,1 \\cdot e_n\\} $$ ç›¸å¼‚å…ƒç´ å…è®¸é‡å¤çš„æ’åˆ— $RP(\\infty, r)$\nçƒç›’æ¨¡å‹ï¼šå°†$r$ ä¸ªæœ‰åŒºåˆ«çš„çƒæ”¾å…¥ $n$ ä¸ªä¸åŒçš„ç›’å­é‡Œï¼Œæ¯ä¸ªç›’å­çš„çƒæ•°ä¸åŠ é™åˆ¶è€Œä¸”åŒç›’çš„çƒä¸åˆ†æ¬¡åºã€‚\nè®¡ç®—å…¬å¼ï¼š$$ RP(\\infty, r) = n^r $$\né›†åˆæè¿°ï¼š$$ S=\\{\\infty \\cdot e_1, \\infty \\cdot e_2,\u0026hellip;,\\infty \\cdot e_n\\} $$\nä¸å°½ç›¸å¼‚å…ƒç´ çš„å…¨æ’åˆ—\nçƒç›’æ¨¡å‹ï¼šå°†$r$ä¸ªæœ‰åŒºåˆ«çš„çƒæ”¾å…¥$t$ä¸ªä¸åŒçš„ç›’å­ï¼Œæ¯ä¸ªç›’å­çš„å®¹é‡æ˜¯æœ‰é™çš„ï¼Œå…¶ä¸­ç¬¬$i$ä¸ªç›’å­æœ€å¤šåªèƒ½æ”¾å…¥$n_i$ä¸ªçƒï¼ŒåŒç›’çš„çƒä¸åˆ†æ¬¡åºã€‚ é›†åˆæè¿°ï¼š$$ S=\\{ n_1 \\cdot e_1, n_2 \\cdot e_2,\u0026hellip;,n_t \\cdot e_t \\}, n_1+n_2+\u0026hellip;+n_t=n $$ ç‰¹ä¾‹ $r=1$ $$ RP(n, 1) = t $$ $r=n$ $$ RP(n, n) = \\frac{n!","title":"ç»„åˆæ•°å­¦ç¬”è®°"},{"content":"å¼•å…¥ æœ€è¿‘bç«™ä¸Šå¾ˆå¤šå°ä¼™ä¼´å¯¹ä½•åŒå­¦çš„é”™è¯¯ä»£ç è¿›è¡Œäº†ä¸€äº›å¾ˆæœ‰æ„æ€çš„äºŒåˆ›ï¼Œä¸€åº¦ç™»ä¸Šäº†Github Trendingï¼š\nå…¶ä¸­çœ‹åˆ°æœ‰äººä½¿ç”¨C++ä¸­çš„å®å®ç°äº†ä½•åŒå­¦çš„â€œæˆ–è¿ç®—â€ï¼Œäºæ˜¯å—åˆ°å¯å‘ï¼Œä½¿ç”¨Rustä¸­çš„å®å®ç°äº†ä¸€ä¸‹ã€‚\nSource Code fn parse_to_vec(nums: \u0026amp;str) -\u0026gt; Vec\u0026lt;usize\u0026gt; { let nums = nums.replace(\u0026#39; \u0026#39;, \u0026#34;\u0026#34;); nums.split(\u0026#39;|\u0026#39;).map(|x| x.parse().unwrap()).collect() } fn power_con(powers: \u0026amp;mut [u8], nums: \u0026amp;[usize], power: u8) { for \u0026amp;num in nums { powers[num] = power; } } #[macro_export] macro_rules! powerCon { ($powers: expr, $nums: expr, $force: expr) =\u0026gt; { power_con($powers, \u0026amp;parse_to_vec(stringify!($nums)), $force) }; } fn main() { let mut powers = [0_u8; 68]; powerCon!(\u0026amp;mut powers, 0, 100); powerCon!(\u0026amp;mut powers, 1 | 2 | 6 | 7 | 11 | 52 | 57 | 58 | 65, 10); println!(\u0026#34;{:?}\u0026#34;, powers) } References https://github.com/kifuan/helang/blob/master/helang.cpp\nhttps://www.bilibili.com/video/BV1zW4y1h7YH?share_source=copy_web\u0026amp;vd_source=083fa967106cc2114fabad75979818b9\n","permalink":"https://fffzlfk.github.io/posts/%E4%BD%BF%E7%94%A8rust%E5%AE%9E%E7%8E%B0helangdoge/","summary":"å¼•å…¥ æœ€è¿‘bç«™ä¸Šå¾ˆå¤šå°ä¼™ä¼´å¯¹ä½•åŒå­¦çš„é”™è¯¯ä»£ç è¿›è¡Œäº†ä¸€äº›å¾ˆæœ‰æ„æ€çš„äºŒåˆ›ï¼Œä¸€åº¦ç™»ä¸Šäº†Github Trendingï¼š\nå…¶ä¸­çœ‹åˆ°æœ‰äººä½¿ç”¨C++ä¸­çš„å®å®ç°äº†ä½•åŒå­¦çš„â€œæˆ–è¿ç®—â€ï¼Œäºæ˜¯å—åˆ°å¯å‘ï¼Œä½¿ç”¨Rustä¸­çš„å®å®ç°äº†ä¸€ä¸‹ã€‚\nSource Code fn parse_to_vec(nums: \u0026amp;str) -\u0026gt; Vec\u0026lt;usize\u0026gt; { let nums = nums.replace(\u0026#39; \u0026#39;, \u0026#34;\u0026#34;); nums.split(\u0026#39;|\u0026#39;).map(|x| x.parse().unwrap()).collect() } fn power_con(powers: \u0026amp;mut [u8], nums: \u0026amp;[usize], power: u8) { for \u0026amp;num in nums { powers[num] = power; } } #[macro_export] macro_rules! powerCon { ($powers: expr, $nums: expr, $force: expr) =\u0026gt; { power_con($powers, \u0026amp;parse_to_vec(stringify!($nums)), $force) }; } fn main() { let mut powers = [0_u8; 68]; powerCon!(\u0026amp;mut powers, 0, 100); powerCon!","title":"ä½¿ç”¨Rustå®ç°HelangğŸ˜…"},{"content":"æ“¦æ‹­æ³• ç¼–è¯‘å™¨æŠŠç±»å‹\u0026lt;T\u0026gt;è§†ä¸ºObject public class Pair\u0026lt;T\u0026gt; { private final T first; private final T last; public Pair(T first, T last) { this.first = first; this.last = last; } public T getFirst() { return first; } public T getLast() { return last; } } Javaä¸­æ³›å‹æ˜¯åœ¨ç¼–è¯‘é˜¶æ®µçš„ï¼Œç¼–è¯‘å™¨å°†ä¸Šè¿°ä»£ç ç»è¿‡æ“¦é™¤æ³•ï¼ŒJVMå®é™…çœ‹åˆ°çš„ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š\npublic class Pair { private final Object first; private final Object last; public Pair(Object first, Object last) { this.first = first; this.last = last; } public Object getFirst() { return first; } public Object getLast() { return last; } } ç¼–è¯‘å™¨æ ¹æ®\u0026lt;T\u0026gt;å®ç°å®‰å…¨çš„å¼ºåˆ¶è½¬å‹ Pair\u0026lt;String\u0026gt; p = new Pair\u0026lt;\u0026gt;(\u0026#34;Hello\u0026#34;, \u0026#34;world\u0026#34;); String first = p.getFirst(); String last = p.getLast(); ç¼–è¯‘å™¨æ ¹æ®Tçš„ç±»å‹å®‰å…¨å¼ºè½¬ï¼š\nPair p = new Pair(\u0026#34;Hello\u0026#34;, \u0026#34;world\u0026#34;); String first = (String) p.getFirst(); String last = (String) p.getLast(); æ“¦æ‹­æ³•çš„å±€é™æ€§ \u0026lt;T\u0026gt;ä¸èƒ½æ˜¯åŸºæœ¬ç±»å‹ï¼Œå› ä¸ºæ“¦é™¤æ³•è¦å°†å…¶æ›¿æ¢ä¸ºObject æ— æ³•è·å–æºå¸¦æ³›å‹çš„Classï¼Œå› ä¸ºæ³›å‹æ˜¯åœ¨ç¼–è¯‘æœŸï¼Œæ‰€ä»¥è·å–åˆ°çš„éƒ½ä¸ºPair\u0026lt;Object\u0026gt; ä¾‹å¦‚ï¼š @Test void testGetClass() { Pair\u0026lt;String\u0026gt; p1 = new Pair\u0026lt;\u0026gt;(\u0026#34;Hello\u0026#34;, \u0026#34;World\u0026#34;); Pair\u0026lt;Integer\u0026gt; p2 = new Pair\u0026lt;\u0026gt;(114, 514); Class c1 = p1.getClass(); Class c2 = p2.getClass(); assertEquals(c1, c2); assertEquals(c1, Pair.class); } ä¸æ°å½“çš„è¦†å†™æ–¹æ³• class Pair\u0026lt;T\u0026gt; { public boolean equals(T t) {} } è¿™æ˜¯å› ä¸ºï¼Œå®šä¹‰çš„equals(T t)æ–¹æ³•å®é™…ä¸Šä¼šè¢«æ“¦æ‹­æˆequals(Object t)ï¼Œè€Œè¿™ä¸ªæ–¹æ³•æ˜¯ç»§æ‰¿è‡ªObjectçš„ï¼Œç¼–è¯‘å™¨ä¼šé˜»æ­¢ä¸€ä¸ªå®é™…ä¸Šä¼šå˜æˆè¦†å†™çš„æ³›å‹æ–¹æ³•å®šä¹‰ã€‚\næ³›å‹ç»§æ‰¿ ç±»å¯ä»¥ç»§æ‰¿ä¸€ä¸ªæ³›å‹ç±»ã€‚åœ¨ç»§æ‰¿äº†æ³›å‹ç±»å‹çš„æƒ…å†µä¸‹ï¼Œå­ç±»å¯ä»¥è·å–çˆ¶ç±»çš„æ³›å‹ç±»å‹ã€‚ä¾‹å¦‚ï¼šIntPairå¯ä»¥è·å–åˆ°çˆ¶ç±»çš„æ³›å‹ç±»å‹Integerã€‚\npublic class IntPair extends Pair\u0026lt;Integer\u0026gt; { public IntPair(Integer first, Integer last) { super(first, last); } } class IntPairTest { @Test void getSuperParameterizedType() { Class\u0026lt;IntPair\u0026gt; clazz = IntPair.class; Type t = clazz.getGenericSuperclass(); if (t instanceof ParameterizedType) { ParameterizedType pt = (ParameterizedType) t; Type[] types = pt.getActualTypeArguments(); // may have many types Type firstType = types[0]; Class\u0026lt;?\u0026gt; typeClass = (Class\u0026lt;?\u0026gt;) firstType; assertEquals(typeClass, Integer.class); } } } extendsé€šé…ç¬¦ public class PairHelper { static int add(Pair\u0026lt;Number\u0026gt; p) { Number first = p.getFirst(); Number last = p.getLast(); return first.intValue() + last.intValue(); } } å¦‚ä¸Šï¼Œaddå‡½æ•°æ¥æ”¶çš„å‚æ•°ç±»å‹ä¸ºPair\u0026lt;Number\u0026gt;ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¼ å…¥Pair\u0026lt;Number\u0026gt;æ˜¯æ²¡æœ‰é—®é¢˜çš„ï¼›ä½†ä¼ å…¥Pair\u0026lt;Integer\u0026gt;æ—¶ï¼Œä¼šå¾—åˆ°ä¸€ä¸ªç¼–è¯‘é”™è¯¯ï¼Œè¿™æ˜¯å› ä¸ºè™½ç„¶Integeræ˜¯Numberçš„å­ç±»ï¼Œä½†æ˜¯Pair\u0026lt;Integer\u0026gt;å´ä¸æ˜¯Pair\u0026lt;Number\u0026gt;çš„å­ç±»ã€‚\nä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå¯ä»¥ä½¿ç”¨Pair\u0026lt;? extends Number\u0026gt;ï¼Œè¿™æ ·å°±å¯ä»¥æ¥æ”¶æ³›å‹ç±»å‹ä¸ºNumberå­ç±»çš„Pairç±»å‹äº†ï¼š\nstatic int add(Pair\u0026lt;? extends Number\u0026gt; p) { Number first = p.getFirst(); Number last = p.getLast(); return first.intValue() + last.intValue(); } @Test void addNumberBased() { assertEquals(579, add(new Pair\u0026lt;Integer\u0026gt;(123, 456))); } è¯»å– èƒ½å¤Ÿä»List\u0026lt;? extends Number\u0026gt;ä¸­è·å–åˆ°Numberç±»å‹ï¼Œå› ä¸ºå…¶åŒ…å«çš„å…ƒç´ æ˜¯Numberç±»å‹æˆ–è€…Numberçš„è‡ªç±»å‹ã€‚ ä¸èƒ½ä»List\u0026lt;? extends Number\u0026gt;ä¸­è·å–åˆ°Integerç±»å‹ï¼Œå› ä¸ºå…¶ä¿å­˜çš„å…ƒç´ å¯èƒ½æ˜¯Doubleã€‚ ä¸èƒ½ä»List\u0026lt;? extends Number\u0026gt;ä¸­è·å–åˆ°Doubleç±»å‹ï¼Œå› ä¸ºå…¶ä¿å­˜çš„å…ƒç´ å¯èƒ½æ˜¯Integerã€‚ å†™å…¥ ä¸èƒ½æ·»åŠ Numberåˆ°List\u0026lt;? extends Number\u0026gt;ä¸­ï¼Œå› ä¸ºå…¶ä¿å­˜çš„å…ƒç´ å¯èƒ½æ˜¯Integeræˆ–Doubleã€‚ ä¸èƒ½æ·»åŠ Integeråˆ°List\u0026lt;? extends Number\u0026gt;ä¸­ï¼Œå› ä¸ºå…¶ä¿å­˜çš„å…ƒç´ å¯èƒ½æ˜¯Doubleã€‚ ä¸èƒ½æ·»åŠ Numberåˆ°List\u0026lt;? extends Number\u0026gt;ä¸­ï¼Œå› ä¸ºå…¶ä¿å­˜çš„å…ƒç´ å¯èƒ½æ˜¯Integerã€‚ public class ExtendsTest { List\u0026lt;? extends Number\u0026gt; nums1 = new ArrayList\u0026lt;Number\u0026gt;(); List\u0026lt;? extends Number\u0026gt; nums2 = new ArrayList\u0026lt;Integer\u0026gt;(); List\u0026lt;? extends Number\u0026gt; nums3 = new ArrayList\u0026lt;Double\u0026gt;(); void get() { Number x = nums1.get(0); // Integer y = nums2.get(0); // compile error // Double z = nums3.get(0); // compile error } void set() { /* nums1.add(new Number() { @Override public int intValue() { return 0; } @Override public long longValue() { return 0; } @Override public float floatValue() { return 0; } @Override public double doubleValue() { return 0; } }); */ // compile error // nums2.add(new Integer(1)); // compile error // nums3.add(new Double(1.2)); // compile error } } superé€šé…ç¬¦ \u0026lt;? super T\u0026gt; æè¿°äº†é€šé…ç¬¦ä¸‹ç•Œ, å³å…·ä½“çš„æ³›å‹å‚æ•°éœ€è¦æ»¡è¶³æ¡ä»¶: æ³›å‹å‚æ•°å¿…é¡»æ˜¯ T ç±»å‹æˆ–å®ƒçš„çˆ¶ç±»ã€‚\nè¯»å– æˆ‘ä»¬ä¸èƒ½ä¿è¯å¯ä»¥ä»List\u0026lt;? super Integer\u0026gt;ç±»å‹å¯¹è±¡ä¸­è¯»å–åˆ° Integer ç±»å‹çš„æ•°æ®, å› ä¸ºå…¶å¯èƒ½æ˜¯ List\u0026lt;Number\u0026gt; ç±»å‹çš„ã€‚ æˆ‘ä»¬ä¸èƒ½ä¿è¯å¯ä»¥ä»List\u0026lt;? super Integer\u0026gt;ç±»å‹å¯¹è±¡ä¸­è¯»å–åˆ° Number ç±»å‹çš„æ•°æ®, å› ä¸ºå…¶å¯èƒ½æ˜¯ List\u0026lt;Object\u0026gt; ç±»å‹çš„ã€‚ å”¯ä¸€èƒ½å¤Ÿä¿è¯çš„æ˜¯, æˆ‘ä»¬å¯ä»¥ä»List\u0026lt;? super Integer\u0026gt;ç±»å‹å¯¹è±¡ä¸­è·å–åˆ°ä¸€ä¸ª Object å¯¹è±¡çš„å®ä¾‹ã€‚ å†™å…¥ å¯¹äºä¸Šé¢çš„ä¾‹å­ä¸­çš„ List\u0026lt;? super Integer\u0026gt; array å¯¹è±¡ï¼š\næˆ‘ä»¬å¯ä»¥æ·»åŠ  Integer å¯¹è±¡åˆ° array ä¸­, ä¹Ÿå¯ä»¥æ·»åŠ  Integer çš„å­ç±»å¯¹è±¡åˆ° array ä¸­ï¼Œå› ä¸ºIntegeråŠå…¶çˆ¶ç±»éƒ½å¯ä»¥æ¥å—Integerçš„å­ç±»å¯¹è±¡ã€‚ æˆ‘ä»¬ä¸èƒ½æ·»åŠ  Double/Number/Object ç­‰ä¸æ˜¯ Integer çš„å­ç±»çš„å¯¹è±¡åˆ° array ä¸­ã€‚ extends vs super å¯¹äºList\u0026lt;? super Integer\u0026gt; l1ï¼š æ­£ç¡®çš„ç†è§£ï¼š? super Integer é™å®šçš„æ˜¯æ³›å‹å‚æ•°ã€‚ä»¤ l1 çš„æ³›å‹å‚æ•°æ˜¯ T, åˆ™ T æ˜¯ Integer æˆ– Integer çš„çˆ¶ç±», å› æ­¤ Integer æˆ– Integer çš„å­ç±»çš„å¯¹è±¡å°±å¯ä»¥æ·»åŠ åˆ° l1 ä¸­. é”™è¯¯çš„ç†è§£ï¼š? super Integeré™å®šçš„æ˜¯æ’å…¥çš„å…ƒç´ çš„ç±»å‹, å› æ­¤åªè¦æ˜¯ Integer æˆ– Integer çš„çˆ¶ç±»çš„å¯¹è±¡éƒ½å¯ä»¥æ’å…¥ l1 ä¸­ã€‚ å¯¹äºList\u0026lt;? extends Integer\u0026gt; l2: æ­£ç¡®çš„ç†è§£ï¼š? extends Integer é™å®šçš„æ˜¯æ³›å‹å‚æ•°. ä»¤ l2 çš„æ³›å‹å‚æ•°æ˜¯ T, åˆ™ T æ˜¯ Integer æˆ– Integer çš„å­ç±», è¿›è€Œæˆ‘ä»¬å°±ä¸èƒ½æ‰¾åˆ°ä¸€ä¸ªç±» X, ä½¿å¾— X æ˜¯æ³›å‹å‚æ•° T çš„å­ç±», å› æ­¤æˆ‘ä»¬å°±ä¸å¯ä»¥å‘ l2 ä¸­æ·»åŠ å…ƒç´ . ä¸è¿‡ç”±äºæˆ‘ä»¬çŸ¥é“äº†æ³›å‹å‚æ•° T æ˜¯ Integer æˆ– Integer çš„å­ç±»è¿™ä¸€ç‚¹, å› æ­¤æˆ‘ä»¬å°±å¯ä»¥ä» l2 ä¸­è¯»å–åˆ°å…ƒç´ (å–åˆ°çš„å…ƒç´ ç±»å‹æ˜¯ Integer æˆ– Integer çš„å­ç±»), å¹¶å¯ä»¥å­˜æ”¾åˆ° Integer ä¸­ã€‚ é”™è¯¯çš„ç†è§£ï¼š? extends Integer é™å®šçš„æ˜¯æ’å…¥å…ƒç´ çš„ç±»å‹, å› æ­¤åªè¦æ˜¯ Integer æˆ– Integer çš„å­ç±»çš„å¯¹è±¡éƒ½å¯ä»¥æ’å…¥ l2 ä¸­ åº”ç”¨ï¼šPECS PECS åŸåˆ™: Producer Extends, Consumer Super\nProducer extends: å¦‚æœæˆ‘ä»¬éœ€è¦ä¸€ä¸ª List æä¾›ç±»å‹ä¸º T çš„æ•°æ®(å³å¸Œæœ›ä» List ä¸­è¯»å– T ç±»å‹çš„æ•°æ®), é‚£ä¹ˆæˆ‘ä»¬éœ€è¦ä½¿ç”¨ ? extends T, ä¾‹å¦‚ List\u0026lt;? extends Integer\u0026gt;ã€‚ ä½†æ˜¯æˆ‘ä»¬ä¸èƒ½å‘è¿™ä¸ª List æ·»åŠ æ•°æ®ã€‚ Consumer Super: å¦‚æœæˆ‘ä»¬éœ€è¦ä¸€ä¸ª List æ¥æ¶ˆè´¹ T ç±»å‹çš„æ•°æ®(å³å¸Œæœ›å°† T ç±»å‹çš„æ•°æ®å†™å…¥ List ä¸­), é‚£ä¹ˆæˆ‘ä»¬éœ€è¦ä½¿ç”¨ ? super T, ä¾‹å¦‚ List\u0026lt;? super Integer\u0026gt;ã€‚ä½†æ˜¯è¿™ä¸ª List ä¸èƒ½ä¿è¯ä»å®ƒè¯»å–çš„æ•°æ®çš„ç±»å‹ã€‚ å¦‚æœæˆ‘ä»¬æ—¢å¸Œæœ›è¯»å–, ä¹Ÿå¸Œæœ›å†™å…¥, é‚£ä¹ˆæˆ‘ä»¬å°±å¿…é¡»æ˜ç¡®åœ°å£°æ˜æ³›å‹å‚æ•°çš„ç±»å‹, ä¾‹å¦‚ Listã€‚ public class Collections { public static \u0026lt;T\u0026gt; void copy(List\u0026lt;? super T\u0026gt; dest, List\u0026lt;? extends T\u0026gt; src) { for (int i = 0; i \u0026lt; src.size(); i++) { dest.set(i, src.get(i)); } } } Source code https://github.com/fffzlfk/generics_tour References https://www.liaoxuefeng.com/wiki/1252599548343744/1255945193293888 https://segmentfault.com/a/1190000008423240 ","permalink":"https://fffzlfk.github.io/posts/java%E6%B3%9B%E5%9E%8B/","summary":"æ“¦æ‹­æ³• ç¼–è¯‘å™¨æŠŠç±»å‹\u0026lt;T\u0026gt;è§†ä¸ºObject public class Pair\u0026lt;T\u0026gt; { private final T first; private final T last; public Pair(T first, T last) { this.first = first; this.last = last; } public T getFirst() { return first; } public T getLast() { return last; } } Javaä¸­æ³›å‹æ˜¯åœ¨ç¼–è¯‘é˜¶æ®µçš„ï¼Œç¼–è¯‘å™¨å°†ä¸Šè¿°ä»£ç ç»è¿‡æ“¦é™¤æ³•ï¼ŒJVMå®é™…çœ‹åˆ°çš„ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š\npublic class Pair { private final Object first; private final Object last; public Pair(Object first, Object last) { this.first = first; this.last = last; } public Object getFirst() { return first; } public Object getLast() { return last; } } ç¼–è¯‘å™¨æ ¹æ®\u0026lt;T\u0026gt;å®ç°å®‰å…¨çš„å¼ºåˆ¶è½¬å‹ Pair\u0026lt;String\u0026gt; p = new Pair\u0026lt;\u0026gt;(\u0026#34;Hello\u0026#34;, \u0026#34;world\u0026#34;); String first = p.","title":"Javaæ³›å‹"},{"content":"å¼•å…¥ ä»Šå¤©ï¼ˆ2022å¹´6æœˆ21æ—¥ï¼‰ï¼ŒCloudflareå‘ç”Ÿæ•…éšœï¼Œå½±å“äº†æˆ‘ä»¬19ä¸ªæ•°æ®ä¸­å¿ƒçš„æµé‡ã€‚ä¸å¹¸çš„æ˜¯ï¼Œè¿™19ä¸ªåœ°ç‚¹è´Ÿè´£å¤„ç†æˆ‘ä»¬å…¨çƒæµé‡çš„å¾ˆå¤§ä¸€éƒ¨åˆ†ã€‚è¿™æ¬¡æ•…éšœæ˜¯ç”±ä¸€ä¸ªå˜åŒ–å¼•èµ·çš„ï¼Œè¿™ä¸ªå˜åŒ–æ˜¯ä¸€ä¸ªé•¿æœŸé¡¹ç›®çš„ä¸€éƒ¨åˆ†ï¼Œè¯¥é¡¹ç›®æ˜¯ä¸ºäº†æå‡æˆ‘ä»¬æœ€ç¹å¿™æ•°æ®ä¸­å¿ƒçš„å¯æ¢å¤èƒ½åŠ›ã€‚å¯¹è¿™äº›æ•°æ®ä¸­å¿ƒç½‘ç»œé…ç½®çš„æ”¹å˜é€ æˆäº†ä»06:27(UTC)å¼€å§‹çš„å®•æœºã€‚åœ¨06:58(UTC)ï¼Œç¬¬ä¸€ä¸ªæ•°æ®ä¸­å¿ƒé‡æ–°ä¸Šçº¿ï¼Œåˆ°07:42(UTC)ï¼Œæ‰€æœ‰çš„æ•°æ®ä¸­å¿ƒéƒ½ä¸Šçº¿å¹¶æ¢å¤äº†æ­£å¸¸å·¥ä½œã€‚\næ ¹æ®ä½ æ‰€åœ¨çš„ä½ç½®ï¼Œä½ å¯èƒ½å·²ç»åˆé¥­è®¿é—®ä¾èµ–Cloudflareçš„ç½‘ç«™å’ŒæœåŠ¡ã€‚åœ¨å…¶ä»–åœ°æ–¹ï¼ŒCloudflareç»§ç»­æ­£å¸¸è¿è¡Œã€‚\næˆ‘ä»¬å¯¹è¿™æ¬¡äº‹æ•…æ„Ÿåˆ°éå¸¸æŠ±æ­‰ã€‚è¿™æ˜¯æˆ‘ä»¬è‡ªå·±çš„é”™è¯¯ï¼Œå¹¶ä¸æ˜¯è¢«æ”»å‡»æˆ–æ¶æ„è¡Œä¸ºçš„ç»“æœã€‚\nèƒŒæ™¯ åœ¨è¿‡å»çš„18ä¸ªæœˆé‡Œï¼ŒCloudflareä¸€ç›´åœ¨åŠªåŠ›å°†æˆ‘ä»¬æ‰€æœ‰æœ€ç¹å¿™çš„åœ°ç‚¹è½¬æ¢ä¸ºæ›´çµæ´»ã€æ›´å…·å¼¹æ€§çš„æ¶æ„ã€‚åœ¨è¿™æ®µæ—¶é—´é‡Œï¼Œæˆ‘ä»¬å·²ç»å°†19ä¸ªæ•°æ®ä¸­å¿ƒè½¬ä¸ºè¿™ç§æ¶æ„ï¼Œåœ¨å†…éƒ¨ç§°ä¸ºMulti-Colo PoPï¼ˆMCPï¼‰ï¼šé˜¿å§†æ–¯ç‰¹ä¸¹ã€äºšç‰¹å…°å¤§ã€é˜¿ä»€æœ¬ã€èŠåŠ å“¥ã€æ³•å…°å…‹ç¦ã€ä¼¦æ•¦ã€æ´›æ‰çŸ¶ã€é©¬å¾·é‡Œã€æ›¼å½»æ–¯ç‰¹ã€è¿ˆé˜¿å¯†ã€ç±³å…°ã€å­Ÿä¹°ã€çº½ç“¦å…‹ã€å¤§é˜ªã€åœ£ä¿ç½—ã€åœ£ä½•å¡ã€æ–°åŠ å¡ã€æ‚‰å°¼ã€ä¸œäº¬ã€‚\nè¿™ä¸ªæ–°æ¶æ„çš„ä¸€ä¸ªå…³é”®éƒ¨åˆ†æ˜¯ä¸€ä¸ªé™„åŠ çš„è·¯ç”±å±‚ï¼Œå®ƒè¢«è®¾è®¡ä¸ºä¸€ä¸ªClose Networkï¼Œå½¢æˆäº†ä¸€ä¸ªç½‘çŠ¶çš„è¿æ¥ã€‚è¿™ä¸ªç½‘çŠ¶ç»“æ„ä½¿æˆ‘ä»¬èƒ½å¤Ÿå¾ˆå®¹æ˜“åœ°ç¦ç”¨æˆ–å¯ç”¨æ•°æ®ä¸­å¿ƒåœ°éƒ¨åˆ†å†…éƒ¨ç½‘ç»œï¼Œä»¥ä¾¿è¿›è¡Œç»´æŠ¤æˆ–å¤„ç†é—®é¢˜ã€‚è¿™ä¸€å±‚å¦‚ä¸‹å›¾ä¸­çš„spinesè¡¨ç¤ºã€‚ è¿™ç§æ–°çš„æ¶æ„ä¸ºæˆ‘ä»¬æä¾›äº†æ˜¾è‘—çš„å¯é æ€§æ”¹è¿›ï¼Œå¹¶ä¸”ä½¿æˆ‘ä»¬èƒ½å¤Ÿåœ¨è¿™äº›åœ°æ–¹è¿›è¡Œç»´æŠ¤è€Œä¸ä¸­æ–­å®¢æˆ·æµé‡ã€‚ç”±äºè¿™äº›åœ°æ–¹åŒæ ·æ‰¿æ‹…ç€Cloudflareæµé‡çš„å¾ˆå¤§ä¸€éƒ¨åˆ†ï¼Œè¿™é‡Œçš„ä»»ä½•é—®é¢˜éƒ½ä¼šäº§ç”Ÿéå¸¸å¹¿æ³›çš„å½±å“ã€‚ä¸å¹¸çš„æ˜¯ï¼Œè¿™å°±æ˜¯ä»Šå¤©å‘ç”Ÿçš„äº‹æƒ…ã€‚\näº‹ä»¶çš„æ—¶é—´çº¿å’Œå½±å“ ä¸ºäº†åœ¨äº’è”ç½‘ä¸Šèƒ½è¢«è®¿é—®åˆ°ï¼ŒåƒCloudflareè¿™æ ·çš„ç½‘ç»œåˆ©ç”¨äº†ä¸€ä¸ªè¢«å«åšBGPçš„åè®®ã€‚ä½œä¸ºè¯¥åè®®çš„ä¸€éƒ¨åˆ†ï¼Œè¿è¥å•†åˆ¶å®šç­–ç•¥ï¼Œå†³å®šå“ªäº›å‰ç¼€ï¼ˆç›¸é‚»IPåœ°å€çš„é›†åˆï¼‰è¢«å…¬å¸ƒç»™peersï¼ˆå®ƒä»¬è¿æ¥çš„å…¶ä»–ç½‘ç»œï¼‰ï¼Œæˆ–ä»peersæ¥å—ã€‚\nè¿™äº›ç­–ç•¥æœ‰å•ç‹¬çš„ç»„æˆéƒ¨åˆ†ï¼Œå®ƒä»¬è¢«æŒ‰é¡ºåºè¿›è¡Œè¯„ä¼°ã€‚æœ€ç»ˆç»“æœæ˜¯ï¼Œä»»ä½•ç»™å®šçš„å‰ç¼€è¦ä¹ˆè¢«å…¬å¸ƒï¼Œè¦ä¹ˆä¸è¢«å…¬å¸ƒã€‚ç­–ç•¥çš„å˜åŒ–å¯èƒ½æ„å‘³ç€ä»¥å‰å…¬å¸ƒçš„å‰ç¼€ä¸å†è¢«å…¬å¸ƒï¼Œå³æ‰€è°“çš„â€œæ’¤é”€â€ã€‚è¿™äº›IPåœ°å€å°†ä¸èƒ½åœ¨äº’è”ç½‘ä¸Šåˆ°è¾¾ã€‚\nåœ¨å¯¹æˆ‘ä»¬çš„å‰ç¼€å…¬å¸ƒç­–ç•¥è¿›è¡Œä¿®æ”¹æ—¶ï¼Œæ¡æ¬¾çš„é‡æ–°æ’åºä½¿å¾—æˆ‘ä»¬æ’¤é”€äº†ä¸€ä¸ªå…³é”®çš„å‰ç¼€å­é›†ã€‚\nç”±äºè¿™ä¸ªæ’¤é”€ï¼ŒCloudflareçš„å·¥ç¨‹å¸ˆåœ¨è”ç³»å—å½±å“çš„åœ°ç‚¹ä»¥æ¢å¤æœ‰é—®é¢˜çš„å˜æ›´æ–¹é¢é‡åˆ°äº†æ›´å¤šå›°éš¾ã€‚æˆ‘ä»¬æœ‰å¤„ç†æ­¤ç±»äº‹ä»¶çš„å¤‡ä»½ç¨‹åºï¼Œå¹¶åˆ©ç”¨å®ƒä»¬æ¥æ§åˆ¶å—å½±å“çš„åœ°ç‚¹ã€‚\næ—¶é—´ äº‹ä»¶ 03:56(UTC) æˆ‘ä»¬åœ¨ç¬¬ä¸€ä¸ªåœ°ç‚¹éƒ¨ç½²äº†è¿™ä¸ªå˜åŒ–ã€‚æˆ‘ä»¬çš„æ‰€æœ‰åœ°ç‚¹éƒ½æ²¡æœ‰å—åˆ°è¯¥å˜åŒ–çš„å½±å“ï¼Œå› ä¸ºè¿™äº›åœ°ç‚¹ä½¿ç”¨çš„æ˜¯æˆ‘ä»¬çš„æ—§æ¶æ„ã€‚ 06:17 å˜æ›´è¢«éƒ¨ç½²åˆ°æˆ‘ä»¬æœ€ç¹å¿™çš„åœ°ç‚¹ï¼Œä½†ä¸æ˜¯å…·æœ‰MCPæ¶æ„çš„åœ°ç‚¹ã€‚ 06:27 æ¨å¹¿å·¥ä½œåˆ°è¾¾äº†æ”¯æŒMCPçš„åœ°ç‚¹ï¼Œå˜åŒ–è¢«éƒ¨ç½²åˆ°äº†æˆ‘ä»¬çš„spinesã€‚è¿™æ—¶ï¼Œäº‹ä»¶å¼€å§‹äº†ï¼Œå› ä¸ºè¿™è¿…é€Ÿåœ°ä½¿è¿™19ä¸ªåœ°ç‚¹å®•æœºã€‚ 06:32 Cloudflareå†…éƒ¨å®£å¸ƒäº‹æ•…å‘ç”Ÿã€‚ 06:51 åœ¨è·¯ç”±å™¨ä¸Šè¿›è¡Œäº†ç¬¬ä¸€æ¬¡æ›´æ”¹ï¼Œä»¥éªŒè¯æ ¹æœ¬åŸå› ã€‚ 06:58 æ‰¾åˆ°å¹¶ç†è§£äº†æ ¹æœ¬åŸå› ã€‚å¼€å§‹æ¢å¤æœ‰é—®é¢˜çš„æ›´æ”¹ã€‚ 07:42 æœ€åä¸€é¡¹æ¢å¤å·¥ä½œå·²ç»å®Œæˆã€‚ç”±äºç½‘ç»œå·¥ç¨‹å¸ˆä»¬äº’ç›¸èµ°è¿‡å¯¹æ–¹çš„ä¿®æ”¹ï¼Œæ¢å¤äº†ä¹‹å‰çš„æ¢å¤ï¼Œå¯¼è‡´é—®é¢˜é›¶æ˜Ÿåœ°é‡æ–°å‡ºç°ï¼Œæ‰€ä»¥è¿™è¢«å»¶è¿Ÿäº†ã€‚ 09:00 äº‹ä»¶ç»“æŸã€‚ ä»æˆ‘ä»¬åœ¨å…¨çƒèŒƒå›´å†…å¤„ç†çš„æˆåŠŸçš„HTTPè¯·æ±‚é‡ä¸­å¯ä»¥æ¸…æ¥šåœ°çœ‹åˆ°è¿™äº›æ•°æ®ä¸­å¿ƒçš„é‡è¦æ€§ã€‚\nå°½ç®¡è¿™äº›åœ°æ–¹åªå æˆ‘ä»¬æ•´ä¸ªç½‘ç»œçš„4%ï¼Œä½†ä¸­æ–­å½±å“äº†50%çš„æ€»è¯·æ±‚ã€‚åœ¨æˆ‘ä»¬çš„å‡ºå£å¸¦å®½ä¸­ä¹Ÿå¯ä»¥çœ‹åˆ°åŒæ ·çš„æƒ…å†µã€‚\nå¯¹é”™è¯¯çš„æŠ€æœ¯æè¿°ä»¥åŠå®ƒæ˜¯å¦‚ä½•å‘ç”Ÿçš„ ä½œä¸ºæˆ‘ä»¬ç»§ç»­åŠªåŠ›ä½¿æˆ‘ä»¬çš„åŸºç¡€è®¾æ–½é…ç½®æ ‡å‡†åŒ–çš„ä¸€éƒ¨åˆ†ï¼Œæˆ‘ä»¬æ­£åœ¨æ¨å‡ºä¸€é¡¹å˜åŒ–ï¼Œä»¥ä½¿æˆ‘ä»¬å…¬å¸ƒçš„å‰ç¼€çš„ä¸€ä¸ªå­é›†æ‰€é™„åŠ çš„BGPç¤¾åŒºæ ‡å‡†åŒ–ã€‚å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬æ­£åœ¨ä¸ºæˆ‘ä»¬çš„ç«™ç‚¹-æœ¬åœ°å‰ç¼€æ·»åŠ ä¿¡æ¯ç¤¾åŒºã€‚\nè¿™äº›å‰ç¼€ä½¿æˆ‘ä»¬çš„é‡‘å±èƒ½å¤Ÿç›¸äº’æ²Ÿé€šï¼Œå¹¶è¿æ¥åˆ°å®¢æˆ·çš„æºå¤´ã€‚ä½œä¸ºCloudflareå˜æ›´ç¨‹åºçš„ä¸€éƒ¨åˆ†ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªå˜æ›´è¯·æ±‚å•ï¼Œå…¶ä¸­åŒ…æ‹¬å˜æ›´çš„æ¨¡æ‹Ÿè¿è¡Œï¼Œä»¥åŠä¸€ä¸ªé€æ­¥æ¨å‡ºçš„ç¨‹åºã€‚åœ¨å®ƒè¢«å…è®¸å‡ºå»ä¹‹å‰ï¼Œå®ƒè¿˜è¢«å¤šä¸ªå·¥ç¨‹å¸ˆè¿›è¡Œäº†åŒè¡Œè¯„å®¡ã€‚ä¸å¹¸çš„æ˜¯ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¿™äº›æ­¥éª¤ä¸å¤Ÿå°ï¼Œæ— æ³•åœ¨æˆ‘ä»¬æ‰€æœ‰çš„äººéƒ½å—åˆ°å½±å“ä¹‹å‰æŠ“ä½è¿™ä¸ªé”™è¯¯ã€‚\nå…¶ä¸­ä¸€ä¸ªè·¯ç”±å™¨ä¸Šçš„å˜åŒ–çœ‹èµ·æ¥æ˜¯è¿™æ ·çš„ï¼š\n[edit policy-options policy-statement 4-COGENT-TRANSIT-OUT term ADV-SITELOCAL then] + community add STATIC-ROUTE; + community add SITE-LOCAL-ROUTE; + community add TLL01; + community add EUROPE; [edit policy-options policy-statement 4-PUBLIC-PEER-ANYCAST-OUT term ADV-SITELOCAL then] + community add STATIC-ROUTE; + community add SITE-LOCAL-ROUTE; + community add TLL01; + community add EUROPE; [edit policy-options policy-statement 6-COGENT-TRANSIT-OUT term ADV-SITELOCAL then] + community add STATIC-ROUTE; + community add SITE-LOCAL-ROUTE; + community add TLL01; + community add EUROPE; [edit policy-options policy-statement 6-PUBLIC-PEER-ANYCAST-OUT term ADV-SITELOCAL then] + community add STATIC-ROUTE; + community add SITE-LOCAL-ROUTE; + community add TLL01; + community add EUROPE; è¿™æ˜¯æ— å®³çš„ï¼Œåªæ˜¯ç»™è¿™äº›å‰ç¼€å¹¿å‘Šå¢åŠ äº†ä¸€äº›é¢å¤–çš„ä¿¡æ¯ã€‚spinesä¸Šçš„å˜åŒ–å¦‚ä¸‹ã€‚\n[edit policy-options policy-statement AGGREGATES-OUT] term 6-DISABLED_PREFIXES { ... } ! term 6-ADV-TRAFFIC-PREDICTOR { ... } ! term 4-ADV-TRAFFIC-PREDICTOR { ... } ! term ADV-FREE { ... } ! term ADV-PRO { ... } ! term ADV-BIZ { ... } ! term ADV-ENT { ... } ! term ADV-DNS { ... } ! term REJECT-THE-REST { ... } ! term 4-ADV-SITE-LOCALS { ... } ! term 6-ADV-SITE-LOCALS { ... } [edit policy-options policy-statement AGGREGATES-OUT term 4-ADV-SITE-LOCALS then] community delete NO-EXPORT { ... } + community add STATIC-ROUTE; + community add SITE-LOCAL-ROUTE; + community add AMS07; + community add EUROPE; [edit policy-options policy-statement AGGREGATES-OUT term 6-ADV-SITE-LOCALS then] community delete NO-EXPORT { ... } + community add STATIC-ROUTE; + community add SITE-LOCAL-ROUTE; + community add AMS07; + community add EUROPE; åˆæ­¥çœ‹ä¸€ä¸‹è¿™ä¸ªå·®å¼‚ï¼Œå¯èƒ½ä¼šè®©äººè§‰å¾—è¿™ä¸ªå˜åŒ–æ˜¯ç›¸åŒçš„ï¼Œä½†ä¸å¹¸çš„æ˜¯ï¼Œæƒ…å†µå¹¶éå¦‚æ­¤ã€‚å¦‚æœæˆ‘ä»¬æŠŠæ³¨æ„åŠ›é›†ä¸­åœ¨å·®å¼‚çš„ä¸€ä¸ªéƒ¨åˆ†ï¼Œå¯èƒ½å°±ä¼šæ˜ç™½åŸå› ã€‚\n! term REJECT-THE-REST { ... } ! term 4-ADV-SITE-LOCALS { ... } ! term 6-ADV-SITE-LOCALS { ... } åœ¨è¿™ç§diffæ ¼å¼ä¸­ï¼Œæœ¯è¯­å‰é¢çš„æƒŠå¹å·è¡¨ç¤ºæœ¯è¯­çš„é‡æ–°æ’åºã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¤šä¸ªæœ¯è¯­è¢«ç§»åˆ°ä¸Šé¢ï¼Œä¸¤ä¸ªæœ¯è¯­è¢«åŠ åˆ°ä¸‹é¢ã€‚å…·ä½“æ¥è¯´ï¼Œ4-ADV-SITE-LOCALSå’Œ6-ADV-SITE-LOCALSæœ¯è¯­ä»é¡¶éƒ¨ç§»åˆ°åº•éƒ¨ã€‚è¿™äº›æœ¯è¯­ç°åœ¨åœ¨REJECT-THE-RESTæœ¯è¯­çš„åé¢ï¼Œä»åå­—ä¸Šå¯ä»¥çœ‹å‡ºï¼Œè¿™ä¸ªæœ¯è¯­æ˜¯ä¸€ä¸ªæ˜ç¡®çš„æ‹’ç»ï¼š\nterm REJECT-THE-REST { then reject; } ç”±äºè¿™ä¸ªæœ¯è¯­ç°åœ¨åœ¨ç«™ç‚¹-æœ¬åœ°æœ¯è¯­ä¹‹å‰ï¼Œæˆ‘ä»¬ç«‹å³åœæ­¢å®£ä¼ æˆ‘ä»¬çš„ç«™ç‚¹-æœ¬åœ°å‰ç¼€ï¼Œå–æ¶ˆäº†æˆ‘ä»¬å¯¹æ‰€æœ‰å—å½±å“åœ°ç‚¹çš„ç›´æ¥è®¿é—®ï¼ŒåŒæ—¶ä¹Ÿå–æ¶ˆäº†æˆ‘ä»¬çš„æœåŠ¡å™¨åˆ°è¾¾åŸç‚¹æœåŠ¡å™¨çš„èƒ½åŠ›ã€‚\né™¤äº†æ— æ³•è”ç³»åŸç‚¹ä¹‹å¤–ï¼Œåˆ é™¤è¿™äº›ç«™ç‚¹æœ¬åœ°å‰ç¼€è¿˜å¯¼è‡´æˆ‘ä»¬çš„å†…éƒ¨è´Ÿè½½å¹³è¡¡ç³»ç»ŸMultimogï¼ˆæˆ‘ä»¬çš„Unimogè´Ÿè½½å¹³è¡¡å™¨çš„ä¸€ä¸ªå˜ç§ï¼‰åœæ­¢å·¥ä½œï¼Œå› ä¸ºå®ƒä¸èƒ½å†åœ¨æˆ‘ä»¬MCPçš„æœåŠ¡å™¨ä¹‹é—´è½¬å‘è¯·æ±‚ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬åœ¨MCPä¸­è¾ƒå°çš„è®¡ç®—é›†ç¾¤æ”¶åˆ°ä¸æˆ‘ä»¬æœ€å¤§çš„é›†ç¾¤ç›¸åŒçš„æµé‡ï¼Œå¯¼è‡´è¾ƒå°çš„é›†ç¾¤è¿‡è½½ã€‚\nè¡¥æ•‘å’Œåç»­æ­¥éª¤ è¿™ä¸€äº‹ä»¶äº§ç”Ÿäº†å¹¿æ³›çš„å½±å“ï¼Œæˆ‘ä»¬éå¸¸é‡è§†å¯ç”¨æ€§ã€‚æˆ‘ä»¬å·²ç»ç¡®å®šäº†å‡ ä¸ªéœ€è¦æ”¹è¿›çš„é¢†åŸŸï¼Œå¹¶å°†ç»§ç»­åŠªåŠ›å‘ç°å¯èƒ½å¯¼è‡´å†æ¬¡å‘ç”Ÿçš„ä»»ä½•å…¶ä»–å·®è·ã€‚\nä»¥ä¸‹æ˜¯æˆ‘ä»¬æ­£åœ¨ç«‹å³å¼€å±•å·¥ä½œçš„å†…å®¹:\nå¤„ç†ç¨‹åºã€‚è™½ç„¶MCPè®¡åˆ’æ˜¯ä¸ºäº†æé«˜å¯ç”¨æ€§ï¼Œä½†æˆ‘ä»¬åœ¨æ›´æ–°è¿™äº›æ•°æ®ä¸­å¿ƒçš„è¿‡ç¨‹ä¸­å­˜åœ¨ç¨‹åºä¸Šçš„æ¼æ´ï¼Œæœ€ç»ˆå¯¼è‡´MCPåœ°ç‚¹å—åˆ°äº†æ›´å¹¿æ³›çš„å½±å“ã€‚è™½ç„¶æˆ‘ä»¬ç¡®å®ä½¿ç”¨äº†ä¸€ä¸ªäº¤é”™ç¨‹åºæ¥è¿›è¡Œè¿™ä¸€å˜æ›´ï¼Œä½†äº¤é”™æ”¿ç­–ç›´åˆ°æœ€åä¸€æ­¥æ‰åŒ…æ‹¬MCPæ•°æ®ä¸­å¿ƒã€‚æ›´æ”¹ç¨‹åºå’Œè‡ªåŠ¨åŒ–éœ€è¦åŒ…æ‹¬é’ˆå¯¹MCPçš„æµ‹è¯•å’Œéƒ¨ç½²ç¨‹åºï¼Œä»¥ç¡®ä¿æ²¡æœ‰æ„å¤–çš„åæœã€‚\næ¶æ„ã€‚ä¸æ­£ç¡®çš„è·¯ç”±å™¨é…ç½®ä½¿é€‚å½“çš„è·¯ç”±æ— æ³•è¢«å…¬å¸ƒï¼Œä½¿æµé‡æ— æ³•æ­£å¸¸æµå‘æˆ‘ä»¬çš„åŸºç¡€è®¾æ–½ã€‚æœ€ç»ˆï¼Œå¯¼è‡´ä¸æ­£ç¡®çš„è·¯ç”±å¹¿å‘Šçš„æ”¿ç­–å£°æ˜å°†è¢«é‡æ–°è®¾è®¡ï¼Œä»¥é˜²æ­¢æ— æ„ä¸­çš„é”™è¯¯æ’åºã€‚\nè‡ªåŠ¨åŒ–ã€‚åœ¨æˆ‘ä»¬çš„è‡ªåŠ¨åŒ–å¥—ä»¶ä¸­ï¼Œæœ‰å‡ ä¸ªæœºä¼šå¯ä»¥å‡è½»è¿™ä¸€äº‹ä»¶æ‰€å¸¦æ¥çš„éƒ¨åˆ†æˆ–å…¨éƒ¨å½±å“ã€‚ä¸»è¦æ˜¯ï¼Œæˆ‘ä»¬å°†ä¸“æ³¨äºè‡ªåŠ¨åŒ–æ”¹è¿›ï¼Œä¸ºç½‘ç»œé…ç½®çš„æ¨å‡ºæ‰§è¡Œæ”¹è¿›çš„é”™å¼€æ”¿ç­–ï¼Œå¹¶æä¾›è‡ªåŠ¨ \u0026ldquo;æäº¤-ç¡®è®¤ \u0026ldquo;å›æ»šã€‚å‰è€…å°†å¤§å¤§å‡å°‘æ•´ä½“å½±å“ï¼Œåè€…å°†å¤§å¤§å‡å°‘äº‹ä»¶ä¸­çš„è§£å†³æ—¶é—´ã€‚\nç»“è®º å°½ç®¡Cloudflareå¯¹æˆ‘ä»¬çš„MCPè®¾è®¡è¿›è¡Œäº†å¤§é‡æŠ•èµ„ï¼Œä»¥æé«˜æœåŠ¡çš„å¯ç”¨æ€§ï¼Œä½†è¿™æ¬¡éå¸¸ç—›è‹¦çš„äº‹ä»¶ï¼Œæˆ‘ä»¬æ˜¾ç„¶æ²¡æœ‰è¾¾åˆ°å®¢æˆ·çš„æœŸæœ›ã€‚æˆ‘ä»¬å¯¹æˆ‘ä»¬çš„å®¢æˆ·å’Œæ‰€æœ‰åœ¨æ•…éšœæœŸé—´æ— æ³•è®¿é—®äº’è”ç½‘å±æ€§çš„ç”¨æˆ·æ‰€å—åˆ°çš„å¹²æ‰°æ·±è¡¨é—æ†¾ã€‚æˆ‘ä»¬å·²ç»å¼€å§‹ç€æ‰‹è¿›è¡Œä¸Šè¿°æ”¹é©ï¼Œå¹¶å°†ç»§ç»­åŠªåŠ›ç¡®ä¿è¿™ç§æƒ…å†µä¸ä¼šå†æ¬¡å‘ç”Ÿã€‚\nReferences https://blog.cloudflare.com/cloudflare-outage-on-june-21-2022\n","permalink":"https://fffzlfk.github.io/posts/cloudflare_outage_on_june_21_2022chinese/","summary":"Cloudflare outage on June 21, 2022 (Chinese translation)","title":"Cloudflareäº‹æ•…æŠ¥å‘Š(ä¸­æ–‡ç¿»è¯‘)"},{"content":"å¼•å…¥ åœ¨C++ä¸­ç»å¸¸æ‰“å°å˜é‡æ¥è°ƒè¯•ä»£ç ï¼Œä½†æ— è®ºæ˜¯printfè¿˜æ˜¯coutæ€»æ˜¯å¾ˆéº»çƒ¦ï¼š\nprintf\nint a = 1; float b = 2.0; char c = \u0026#39;c\u0026#39;; printf(\u0026#34;a = %d, b = %f, c = %c\u0026#34;, a, b, c); cout\nint a = 1; float b = 2.0; char c = \u0026#39;c\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34;, c = \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; å¯å˜å‚æ•°å® å¯å˜å‚æ•°å®æ˜¯C99å¼•å…¥çš„ä¸€ä¸ªç‰¹æ€§ï¼ŒC++11å¼€å§‹æ”¯æŒã€‚\n#define def_name(...) def_body(__VA_ARGS__) å¯å˜å‚æ•°æ¨¡æ¿ C++11å…è®¸æ¨¡æ¿å®šä¹‰æœ‰ä»»æ„ç±»å‹ä»»æ„æ•°é‡çš„æ¨¡æ¿å‚æ•°ï¼ˆåŒ…æ‹¬ $0$ ä¸ªæ¨¡æ¿å‚æ•°ï¼‰ã€‚\ntemplate\u0026lt;typename... Values\u0026gt; class tuple; å¦‚æœä¸å¸Œæœ›æœ‰ $0$ ä¸ªæ¨¡æ¿å®å‚ï¼Œå¯ä»¥å¦‚ä¸‹å£°æ˜ï¼š\ntemplate\u0026lt;typename First, typename... Rest\u0026gt; class tuple; å¯å˜å‚æ•°æ¨¡æ¿é€‚ç”¨äºå‡½æ•°æ¨¡æ¿ï¼Œä¾‹å¦‚printfå‡½æ•°çš„å®ç°ï¼š\ntemplate\u0026lt;typename... Args\u0026gt; void printf(const std::string \u0026amp;str_format, Args... args); å‚æ•°åŒ…çš„å±•å¼€ å¯¹äºæ¨¡æ¿å‡½æ•° é€’å½’å±•å¼€ // é€’å½’ç»ˆæ­¢å‡½æ•° void print() {} template\u0026lt;typename T, typename... Args\u0026gt; void print(T head, Args... args) { std::cout \u0026lt;\u0026lt; head \u0026lt;\u0026lt; (sizeof...(args) \u0026gt; 0 ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;); print(args...); } é€—å·è¡¨è¾¾å¼å±•å¼€ï¼šè¿™ç§æ–¹å¼æœ‰ç‚¹ç¹çï¼Œä¸å¤ªå¥½ç†è§£ï¼Œä¸æ¨è å¯¹äºæ¨¡æ¿ç±» é€’å½’å±•å¼€ ç»§æ‰¿å±•å¼€ å®è¿ç®—ç¬¦ #ï¼šå°†å®å‚æ•°è½¬æ¢ä¸ºå­—ç¬¦ä¸²\n#include \u0026lt;stdio.h\u0026gt; #define stringer( x ) printf( #x \u0026#34;\\n\u0026#34; ) int main() { stringer( In quotes in the printf function call ); stringer( \u0026#34;In quotes when printed to the screen\u0026#34; ); stringer( \u0026#34;This: \\\u0026#34; prints an escaped double quote\u0026#34; ); } ä½¿ç”¨gcc -Eé¢„å¤„ç†ä¹‹åï¼Œå¾—åˆ°å¦‚ä¸‹ç»“æœ\nint main() { printf(\u0026#34;In quotes in the printf function call\u0026#34; \u0026#34;\\n\u0026#34;); printf(\u0026#34;\\\u0026#34;In quotes when printed to the screen\\\u0026#34;\u0026#34; \u0026#34;\\n\u0026#34;); printf(\u0026#34;\\\u0026#34;This: \\\\\\\u0026#34; prints an escaped double quote\\\u0026#34;\u0026#34; \u0026#34;\\n\u0026#34;); } #@ï¼šå°†å‚æ•°ç”¨å•å¼•å·æ‹¬èµ·æ¥ï¼Œä½œä¸ºä¸€ä¸ªå­—ç¬¦å¤„ç†\n#define makechar(x) #@x c = makechar(b); é¢„å¤„ç†ä¹‹åå¾—åˆ°ï¼š\nc = \u0026#39;b\u0026#39;; ##ï¼šå°†ä¸¤ä¸ªç‹¬ç«‹çš„tokenè¿æ¥åœ¨ä¸€èµ·\n#define paster(n) printf(\u0026#34;token\u0026#34; #n \u0026#34; = %d\u0026#34;, token##n) int token9 = 9; paster(9); é¢„å¤„ç†ä¹‹åå¾—åˆ°ï¼š\nprintf(\u0026#34;token9 = %d\u0026#34;, token9); å®ç°DBGå® æŒæ¡äº†ä»¥ä¸ŠæŠ€èƒ½ï¼Œæˆ‘ä»¬å°±å¯ä»¥å®ç°ä¸€ä¸ªç®€å•çš„è°ƒè¯•å®ï¼š\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; template \u0026lt;typename T\u0026gt; void _DBG(const char *s, T t) { std::cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;=\u0026#34; \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } template \u0026lt;typename T, typename... Args\u0026gt; void _DBG(const char *s, T t, Args... args) { while (*s != \u0026#39;,\u0026#39;) std::cout \u0026lt;\u0026lt; *s++; std::cout \u0026lt;\u0026lt; \u0026#34;=\u0026#34; \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; _DBG(s + 1, args...); } #define DBG(...) _DBG(#__VA_ARGS__, __VA_ARGS__) int main() { int a = 1; float b = 2.0; char c = \u0026#39;c\u0026#39;; std::string d = \u0026#34;def\u0026#34;; DBG(a, b, c, d); return 0; } ä¸Šé¢çš„ä»£ç è¾“å‡ºï¼š\na=1, b=2, c=c, d=def References https://oi-wiki.org/lang/new/#_9 https://zh.wikipedia.org/wiki/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF https://docs.microsoft.com/en-us/cpp/preprocessor/stringizing-operator-hash?view=msvc-170 ","permalink":"https://fffzlfk.github.io/posts/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%BA%94%E7%94%A8/","summary":"å¼•å…¥ åœ¨C++ä¸­ç»å¸¸æ‰“å°å˜é‡æ¥è°ƒè¯•ä»£ç ï¼Œä½†æ— è®ºæ˜¯printfè¿˜æ˜¯coutæ€»æ˜¯å¾ˆéº»çƒ¦ï¼š\nprintf\nint a = 1; float b = 2.0; char c = \u0026#39;c\u0026#39;; printf(\u0026#34;a = %d, b = %f, c = %c\u0026#34;, a, b, c); cout\nint a = 1; float b = 2.0; char c = \u0026#39;c\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34;, c = \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; å¯å˜å‚æ•°å® å¯å˜å‚æ•°å®æ˜¯C99å¼•å…¥çš„ä¸€ä¸ªç‰¹æ€§ï¼ŒC++11å¼€å§‹æ”¯æŒã€‚\n#define def_name(...) def_body(__VA_ARGS__) å¯å˜å‚æ•°æ¨¡æ¿ C++11å…è®¸æ¨¡æ¿å®šä¹‰æœ‰ä»»æ„ç±»å‹ä»»æ„æ•°é‡çš„æ¨¡æ¿å‚æ•°ï¼ˆåŒ…æ‹¬ $0$ ä¸ªæ¨¡æ¿å‚æ•°ï¼‰ã€‚","title":"å¯å˜å‚æ•°æ¨¡æ¿çš„åº”ç”¨"},{"content":"ç®€å•ç‰ˆGeneric Map func Map[T any](data []T, f func(T) T) []T { res := make([]T, len(data)) for i, v := range data { res[i] = f(v) } return res } æˆ‘ä»¬å¯ä»¥ä¸‹é¢çš„ä»£ç æµ‹è¯•è¿™ä¸ªç®€æ˜“çš„Mapå‡½æ•°\nfunc TestMap(t *testing.T) { square := func(x int) int { return x * x } nums := []int{1, 2, 3, 4, 5} squareArr := Map(nums, square) for i, num := range nums { if squareArr[i] != num*num { t.Errorf(\u0026#34;Expected %d, got %d\u0026#34;, num*num, squareArr[i]) } } upCase := func(s string) string { return strings.ToUpper(s) } strs := []string{\u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;, \u0026#34;ghi\u0026#34;} upperStrs := Map(strs, upCase) for i, str := range strs { if upperStrs[i] != strings.ToUpper(str) { t.Errorf(\u0026#34;Expected %s, got %s\u0026#34;, strings.ToUpper(str), upperStrs[i]) } } } ç®€å•ç‰ˆ Generic Reduce func Reduce[T any](data []T, f func(T, T) T) T { res := data[0] for i := 1; i \u0026lt; len(data); i++ { res = f(res, data[i]) } return res } æˆ‘ä»¬å¯ä»¥ä¸‹é¢çš„ä»£ç æµ‹è¯•è¿™ä¸ªç®€æ˜“çš„Reduceå‡½æ•°\nfunc TestReduce(t *testing.T) { sum := func(x, y int) int { return x + y } nums := []int{1, 2, 3, 4, 5} sumArr := Reduce(nums, sum) if sumArr != 15 { t.Errorf(\u0026#34;Expected 15, got %d\u0026#34;, sumArr) } strs := []string{\u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;, \u0026#34;ghi\u0026#34;} concat := func(x, y string) string { return x + y } concatArr := Reduce(strs, concat) if concatArr != \u0026#34;abcdefghi\u0026#34; { t.Errorf(\u0026#34;Expected abcdefghi, got %s\u0026#34;, concatArr) } } ","permalink":"https://fffzlfk.github.io/posts/mapreduce_in_go/","summary":"ç®€å•ç‰ˆGeneric Map func Map[T any](data []T, f func(T) T) []T { res := make([]T, len(data)) for i, v := range data { res[i] = f(v) } return res } æˆ‘ä»¬å¯ä»¥ä¸‹é¢çš„ä»£ç æµ‹è¯•è¿™ä¸ªç®€æ˜“çš„Mapå‡½æ•°\nfunc TestMap(t *testing.T) { square := func(x int) int { return x * x } nums := []int{1, 2, 3, 4, 5} squareArr := Map(nums, square) for i, num := range nums { if squareArr[i] != num*num { t.Errorf(\u0026#34;Expected %d, got %d\u0026#34;, num*num, squareArr[i]) } } upCase := func(s string) string { return strings.","title":"MapReduce in Go"},{"content":"ç¡¬ä»¶é™åˆ¶ è¿™æ˜¯å®¹æ˜“é‡åŒ–çš„æ–¹é¢ã€‚ç›®å‰CUDAç¼–ç¨‹æŒ‡å—çš„é™„å½•Fåˆ—å‡ºäº†ä¸€äº›ç¡¬ä»¶é™åˆ¶ï¼Œè¿™äº›é™åˆ¶é™åˆ¶äº†å†…æ ¸å¯åŠ¨æ—¶æ¯å—å¯ä»¥æœ‰å¤šå°‘ä¸ªçº¿ç¨‹ã€‚å¦‚æœä½ è¶…è¿‡äº†è¿™äº›é™åˆ¶ï¼Œä½ çš„å†…æ ¸å°†æ— æ³•è¿è¡Œã€‚è¿™äº›é™åˆ¶å¯ä»¥ç²—ç•¥åœ°æ¦‚æ‹¬ä¸ºï¼š\næ¯ä¸ªåŒºå—ä¸èƒ½è¶…è¿‡ $512$ / $1024$ ä¸ªçº¿ç¨‹ï¼ˆåˆ†åˆ«æ˜¯è®¡ç®—èƒ½åŠ›1.xæˆ–2.xåŠä»¥åçš„è®¡ç®—èƒ½åŠ› æ¯ä¸ªå—çš„æœ€å¤§å°ºå¯¸é™åˆ¶åœ¨ $[512, 512, 64]$ / $[1024, 1024, 64]$ï¼ˆè®¡ç®—èƒ½åŠ›1.x/2.xåŠä»¥åçš„è®¡ç®—èƒ½åŠ› æ¯ä¸ªå—æ¶ˆè€—çš„å¯„å­˜å™¨æ€»æ•°ä¸èƒ½è¶…è¿‡ $8k/16k/32k/64k/32k/64k/32k/64k$ ï¼ˆè®¡ç®—èƒ½åŠ› $1.0,1.1/1.2,1.3/2.x-3.0/3.2/3.5-5.2/5.3/6-6.1/6.2/7.0$ æ¯ä¸ªå—ä¸èƒ½æ¶ˆè€—è¶…è¿‡ $16kb/48kb/96kb$ çš„å…±äº«å†…å­˜ï¼ˆè®¡ç®—èƒ½åŠ› $1.x/2.x-6.2/7.0$ å¦‚æœä½ ä¿æŒåœ¨è¿™äº›é™åˆ¶ä¹‹å†…ï¼Œä»»ä½•ä½ èƒ½æˆåŠŸç¼–è¯‘çš„å†…æ ¸éƒ½ä¼šæ— é”™è¯¯åœ°å¯åŠ¨ã€‚\næ€§èƒ½è°ƒæ•™ è¿™æ˜¯éœ€è¦ç»éªŒçš„ä¸€éƒ¨åˆ†ã€‚åœ¨ä¸Šè¿°çš„ç¡¬ä»¶çº¦æŸæ¡ä»¶ä¸‹ï¼Œä½ é€‰æ‹©çš„æ¯å—çº¿ç¨‹æ•°å¯ä»¥è€Œä¸”ç¡®å®å½±å“åˆ°ç¡¬ä»¶ä¸Šè¿è¡Œçš„ä»£ç æ€§èƒ½ã€‚æ¯ä¸ªä»£ç çš„è¡¨ç°éƒ½æ˜¯ä¸åŒçš„ï¼Œå”¯ä¸€çœŸæ­£çš„æ–¹æ³•æ˜¯é€šè¿‡ä»”ç»†çš„åŸºå‡†æµ‹è¯•å’Œå‰–ææ¥é‡åŒ–å®ƒã€‚ä½†è¿˜æ˜¯é‚£å¥è¯ï¼Œéå¸¸ç²—ç•¥åœ°æ€»ç»“ä¸€ä¸‹ï¼š\næ¯ä¸ªåŒºå—çš„çº¿ç¨‹æ•°åº”è¯¥æ˜¯wrapå¤§å°çš„æ•´æ•°å€ï¼Œåœ¨ç›®å‰æ‰€æœ‰çš„ç¡¬ä»¶ä¸Šéƒ½æ˜¯ $32$ GPUä¸Šçš„æ¯ä¸ªæµå¼å¤šå¤„ç†å™¨å¿…é¡»æœ‰è¶³å¤Ÿçš„active wrapsæ¥å……åˆ†éšè—æ¶æ„çš„çš„æ‰€æœ‰ä¸åŒå†…å­˜å’ŒæŒ‡ä»¤æµæ°´çº¿å»¶è¿Ÿï¼Œä»¥å®ç°æœ€å¤§ååé‡ã€‚è¿™é‡Œçš„æ­£ç¡®åšæ³•æ˜¯å°è¯•å®ç°æœ€ä½³çš„ç¡¬ä»¶å ç”¨ç‡ CUDAå†…ç½®å‡½æ•° ä¸Šè¿°æŒ‡å‡ºäº†å—çš„å¤§å°æ˜¯å¦‚ä½•å½±å“æ€§èƒ½çš„ï¼Œå¹¶æå‡ºäº†ä¸€ç§åŸºäºå ç”¨ç‡æœ€å¤§åŒ–çš„é€šç”¨å¯å‘å¼é€‰æ‹©æ–¹æ³•ã€‚åœ¨ä¸æƒ³æä¾›é€‰æ‹©å—å¤§å°çš„æ ‡å‡†çš„æƒ…å†µä¸‹ï¼Œå€¼å¾—ä¸€æçš„æ˜¯ï¼ŒCUDA 6.5+åŒ…æ‹¬å‡ ä¸ªæ–°çš„è¿è¡Œæ—¶å‡½æ•°æ¥å¸®åŠ©å ç”¨ç‡çš„è®¡ç®—å’Œå¯åŠ¨é…ç½®1ã€‚\nå…¶ä¸­ä¸€ä¸ªæœ‰ç”¨çš„å‡½æ•°æ˜¯cudaOccupancyMaxPotentialBlockSizeï¼Œå®ƒå¯å‘å¼åœ°è®¡ç®—äº†ä¸€ä¸ªèƒ½è¾¾åˆ°æœ€ä½³å ç”¨ç‡çš„å—å¤§å°ã€‚è¯¥å‡½æ•°æä¾›çš„å€¼å¯ä»¥ä½œä¸ºæ‰‹åŠ¨ä¼˜åŒ–å‚æ•°çš„èµ·ç‚¹ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š\n/************************/ /* TEST KERNEL FUNCTION */ /************************/ __global__ void MyKernel(int *a, int *b, int *c, int N) { int idx = threadIdx.x + blockIdx.x * blockDim.x; if (idx \u0026lt; N) { c[idx] = a[idx] + b[idx]; } } /********/ /* MAIN */ /********/ void main() { const int N = 1000000; int blockSize; // The launch configurator returned block size int minGridSize; // The minimum grid size needed to achieve the maximum occupancy for a full device launch int gridSize; // The actual grid size needed, based on input size int* h_vec1 = (int*) malloc(N*sizeof(int)); int* h_vec2 = (int*) malloc(N*sizeof(int)); int* h_vec3 = (int*) malloc(N*sizeof(int)); int* h_vec4 = (int*) malloc(N*sizeof(int)); int* d_vec1; cudaMalloc((void**)\u0026amp;d_vec1, N*sizeof(int)); int* d_vec2; cudaMalloc((void**)\u0026amp;d_vec2, N*sizeof(int)); int* d_vec3; cudaMalloc((void**)\u0026amp;d_vec3, N*sizeof(int)); for (int i=0; i\u0026lt;N; i++) { h_vec1[i] = 10; h_vec2[i] = 20; h_vec4[i] = h_vec1[i] + h_vec2[i]; } cudaMemcpy(d_vec1, h_vec1, N*sizeof(int), cudaMemcpyHostToDevice); cudaMemcpy(d_vec2, h_vec2, N*sizeof(int), cudaMemcpyHostToDevice); float time; cudaEvent_t start, stop; cudaEventCreate(\u0026amp;start); cudaEventCreate(\u0026amp;stop); cudaEventRecord(start, 0); cudaOccupancyMaxPotentialBlockSize(\u0026amp;minGridSize, \u0026amp;blockSize, MyKernel, 0, N); // Round up according to array size gridSize = (N + blockSize - 1) / blockSize; cudaEventRecord(stop, 0); cudaEventSynchronize(stop); cudaEventElapsedTime(\u0026amp;time, start, stop); printf(\u0026#34;Occupancy calculator elapsed time: %3.3f ms \\n\u0026#34;, time); cudaEventRecord(start, 0); MyKernel\u0026lt;\u0026lt;\u0026lt;gridSize, blockSize\u0026gt;\u0026gt;\u0026gt;(d_vec1, d_vec2, d_vec3, N); cudaEventRecord(stop, 0); cudaEventSynchronize(stop); cudaEventElapsedTime(\u0026amp;time, start, stop); printf(\u0026#34;Kernel elapsed time: %3.3f ms \\n\u0026#34;, time); printf(\u0026#34;Blocksize %i\\n\u0026#34;, blockSize); cudaMemcpy(h_vec3, d_vec3, N*sizeof(int), cudaMemcpyDeviceToHost); for (int i=0; i\u0026lt;N; i++) { if (h_vec3[i] != h_vec4[i]) { printf(\u0026#34;Error at i = %i! Host = %i; Device = %i\\n\u0026#34;, i, h_vec4[i], h_vec3[i]); return; }; } printf(\u0026#34;Test passed\\n\u0026#34;); } cudaOccupancyMaxPotentialBlockSizeå®šä¹‰åœ¨cuda_runtime.hæ–‡ä»¶ä¸­ï¼š\ntemplate\u0026lt;class T\u0026gt; __inline__ __host__ CUDART_DEVICE cudaError_t cudaOccupancyMaxPotentialBlockSize( int *minGridSize, int *blockSize, T func, size_t dynamicSMemSize = 0, int blockSizeLimit = 0) { return cudaOccupancyMaxPotentialBlockSizeVariableSMem(minGridSize, blockSize, func, __cudaOccupancyB2DHelper(dynamicSMemSize), blockSizeLimit); } è¿™äº›å‚æ•°çš„å«ä¹‰å¦‚ä¸‹ï¼š\nminGridSizeï¼šè¿”å›å®ç°æœ€ä½³æ½œåœ¨å ç”¨ç‡æ‰€éœ€çš„æœ€å°ç½‘æ ¼å¤§å° blockSizeï¼šå»ºè®®çš„å—å¤§å°ï¼Œä»¥å®ç°æœ€å¤§çš„å ç”¨ç‡ funcï¼šå†…æ ¸å‡½æ•° dynamicSMemSizeï¼šæ¯å—åŠ¨æ€å…±äº«å†…å­˜çš„é¢„å®šä½¿ç”¨é‡ï¼Œä»¥å­—èŠ‚ä¸ºå•ä½ blockSizeLimitï¼šæœ€å¤§åŒºå—å¤§å°ï¼Œ0æ„å‘³ç€æ²¡æœ‰é™åˆ¶ã€‚ References https://stackoverflow.com/questions/9985912/how-do-i-choose-grid-and-block-dimensions-for-cuda-kernels\nhttps://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1gee5334618ed4bb0871e4559a77643fc1\nhttps://developer.nvidia.com/blog/cuda-pro-tip-occupancy-api-simplifies-launch-configuration/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://fffzlfk.github.io/posts/cuda%E4%B8%AD%E6%80%8E%E6%A0%B7%E9%80%89%E6%8B%A9grid%E5%92%8Cblock%E7%BB%B4%E5%BA%A6/","summary":"ç¡¬ä»¶é™åˆ¶ è¿™æ˜¯å®¹æ˜“é‡åŒ–çš„æ–¹é¢ã€‚ç›®å‰CUDAç¼–ç¨‹æŒ‡å—çš„é™„å½•Fåˆ—å‡ºäº†ä¸€äº›ç¡¬ä»¶é™åˆ¶ï¼Œè¿™äº›é™åˆ¶é™åˆ¶äº†å†…æ ¸å¯åŠ¨æ—¶æ¯å—å¯ä»¥æœ‰å¤šå°‘ä¸ªçº¿ç¨‹ã€‚å¦‚æœä½ è¶…è¿‡äº†è¿™äº›é™åˆ¶ï¼Œä½ çš„å†…æ ¸å°†æ— æ³•è¿è¡Œã€‚è¿™äº›é™åˆ¶å¯ä»¥ç²—ç•¥åœ°æ¦‚æ‹¬ä¸ºï¼š\næ¯ä¸ªåŒºå—ä¸èƒ½è¶…è¿‡ $512$ / $1024$ ä¸ªçº¿ç¨‹ï¼ˆåˆ†åˆ«æ˜¯è®¡ç®—èƒ½åŠ›1.xæˆ–2.xåŠä»¥åçš„è®¡ç®—èƒ½åŠ› æ¯ä¸ªå—çš„æœ€å¤§å°ºå¯¸é™åˆ¶åœ¨ $[512, 512, 64]$ / $[1024, 1024, 64]$ï¼ˆè®¡ç®—èƒ½åŠ›1.x/2.xåŠä»¥åçš„è®¡ç®—èƒ½åŠ› æ¯ä¸ªå—æ¶ˆè€—çš„å¯„å­˜å™¨æ€»æ•°ä¸èƒ½è¶…è¿‡ $8k/16k/32k/64k/32k/64k/32k/64k$ ï¼ˆè®¡ç®—èƒ½åŠ› $1.0,1.1/1.2,1.3/2.x-3.0/3.2/3.5-5.2/5.3/6-6.1/6.2/7.0$ æ¯ä¸ªå—ä¸èƒ½æ¶ˆè€—è¶…è¿‡ $16kb/48kb/96kb$ çš„å…±äº«å†…å­˜ï¼ˆè®¡ç®—èƒ½åŠ› $1.x/2.x-6.2/7.0$ å¦‚æœä½ ä¿æŒåœ¨è¿™äº›é™åˆ¶ä¹‹å†…ï¼Œä»»ä½•ä½ èƒ½æˆåŠŸç¼–è¯‘çš„å†…æ ¸éƒ½ä¼šæ— é”™è¯¯åœ°å¯åŠ¨ã€‚\næ€§èƒ½è°ƒæ•™ è¿™æ˜¯éœ€è¦ç»éªŒçš„ä¸€éƒ¨åˆ†ã€‚åœ¨ä¸Šè¿°çš„ç¡¬ä»¶çº¦æŸæ¡ä»¶ä¸‹ï¼Œä½ é€‰æ‹©çš„æ¯å—çº¿ç¨‹æ•°å¯ä»¥è€Œä¸”ç¡®å®å½±å“åˆ°ç¡¬ä»¶ä¸Šè¿è¡Œçš„ä»£ç æ€§èƒ½ã€‚æ¯ä¸ªä»£ç çš„è¡¨ç°éƒ½æ˜¯ä¸åŒçš„ï¼Œå”¯ä¸€çœŸæ­£çš„æ–¹æ³•æ˜¯é€šè¿‡ä»”ç»†çš„åŸºå‡†æµ‹è¯•å’Œå‰–ææ¥é‡åŒ–å®ƒã€‚ä½†è¿˜æ˜¯é‚£å¥è¯ï¼Œéå¸¸ç²—ç•¥åœ°æ€»ç»“ä¸€ä¸‹ï¼š\næ¯ä¸ªåŒºå—çš„çº¿ç¨‹æ•°åº”è¯¥æ˜¯wrapå¤§å°çš„æ•´æ•°å€ï¼Œåœ¨ç›®å‰æ‰€æœ‰çš„ç¡¬ä»¶ä¸Šéƒ½æ˜¯ $32$ GPUä¸Šçš„æ¯ä¸ªæµå¼å¤šå¤„ç†å™¨å¿…é¡»æœ‰è¶³å¤Ÿçš„active wrapsæ¥å……åˆ†éšè—æ¶æ„çš„çš„æ‰€æœ‰ä¸åŒå†…å­˜å’ŒæŒ‡ä»¤æµæ°´çº¿å»¶è¿Ÿï¼Œä»¥å®ç°æœ€å¤§ååé‡ã€‚è¿™é‡Œçš„æ­£ç¡®åšæ³•æ˜¯å°è¯•å®ç°æœ€ä½³çš„ç¡¬ä»¶å ç”¨ç‡ CUDAå†…ç½®å‡½æ•° ä¸Šè¿°æŒ‡å‡ºäº†å—çš„å¤§å°æ˜¯å¦‚ä½•å½±å“æ€§èƒ½çš„ï¼Œå¹¶æå‡ºäº†ä¸€ç§åŸºäºå ç”¨ç‡æœ€å¤§åŒ–çš„é€šç”¨å¯å‘å¼é€‰æ‹©æ–¹æ³•ã€‚åœ¨ä¸æƒ³æä¾›é€‰æ‹©å—å¤§å°çš„æ ‡å‡†çš„æƒ…å†µä¸‹ï¼Œå€¼å¾—ä¸€æçš„æ˜¯ï¼ŒCUDA 6.5+åŒ…æ‹¬å‡ ä¸ªæ–°çš„è¿è¡Œæ—¶å‡½æ•°æ¥å¸®åŠ©å ç”¨ç‡çš„è®¡ç®—å’Œå¯åŠ¨é…ç½®1ã€‚\nå…¶ä¸­ä¸€ä¸ªæœ‰ç”¨çš„å‡½æ•°æ˜¯cudaOccupancyMaxPotentialBlockSizeï¼Œå®ƒå¯å‘å¼åœ°è®¡ç®—äº†ä¸€ä¸ªèƒ½è¾¾åˆ°æœ€ä½³å ç”¨ç‡çš„å—å¤§å°ã€‚è¯¥å‡½æ•°æä¾›çš„å€¼å¯ä»¥ä½œä¸ºæ‰‹åŠ¨ä¼˜åŒ–å‚æ•°çš„èµ·ç‚¹ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š\n/************************/ /* TEST KERNEL FUNCTION */ /************************/ __global__ void MyKernel(int *a, int *b, int *c, int N) { int idx = threadIdx.x + blockIdx.x * blockDim.x; if (idx \u0026lt; N) { c[idx] = a[idx] + b[idx]; } } /********/ /* MAIN */ /********/ void main() { const int N = 1000000; int blockSize; // The launch configurator returned block size int minGridSize; // The minimum grid size needed to achieve the maximum occupancy for a full device launch int gridSize; // The actual grid size needed, based on input size int* h_vec1 = (int*) malloc(N*sizeof(int)); int* h_vec2 = (int*) malloc(N*sizeof(int)); int* h_vec3 = (int*) malloc(N*sizeof(int)); int* h_vec4 = (int*) malloc(N*sizeof(int)); int* d_vec1; cudaMalloc((void**)\u0026amp;d_vec1, N*sizeof(int)); int* d_vec2; cudaMalloc((void**)\u0026amp;d_vec2, N*sizeof(int)); int* d_vec3; cudaMalloc((void**)\u0026amp;d_vec3, N*sizeof(int)); for (int i=0; i\u0026lt;N; i++) { h_vec1[i] = 10; h_vec2[i] = 20; h_vec4[i] = h_vec1[i] + h_vec2[i]; } cudaMemcpy(d_vec1, h_vec1, N*sizeof(int), cudaMemcpyHostToDevice); cudaMemcpy(d_vec2, h_vec2, N*sizeof(int), cudaMemcpyHostToDevice); float time; cudaEvent_t start, stop; cudaEventCreate(\u0026amp;start); cudaEventCreate(\u0026amp;stop); cudaEventRecord(start, 0); cudaOccupancyMaxPotentialBlockSize(\u0026amp;minGridSize, \u0026amp;blockSize, MyKernel, 0, N); // Round up according to array size gridSize = (N + blockSize - 1) / blockSize; cudaEventRecord(stop, 0); cudaEventSynchronize(stop); cudaEventElapsedTime(\u0026amp;time, start, stop); printf(\u0026#34;Occupancy calculator elapsed time: %3.","title":"CUDAä¸­æ€æ ·é€‰æ‹©GRIDå’ŒBLOCKç»´åº¦"},{"content":"ä½¿ç”¨å¤šçº¿ç¨‹æé«˜å¹¶è¡Œæ€§ åŒæ­¥çš„ä»£ä»· æˆ‘ä»¬ç ”ç©¶å¯¹ä¸€åˆ—æ•´æ•° $0, \u0026hellip;, n - 1$ æ±‚å’Œï¼Œæˆ‘ä»¬å°†åºåˆ—åˆ’åˆ†æˆ $t$ ä¸ªä¸ç›¸äº¤çš„çš„åŒºåŸŸï¼Œç»™ $t$ ä¸ªçº¿ç¨‹æ¯ä¸ªåˆ†é…ä¸€ä¸ªåŒºåŸŸã€‚å°†çº¿ç¨‹çš„å’Œæ”¾å…¥ä¸€ä¸ªå˜é‡ä¸­ï¼Œå¹¶ä¸”æˆ‘ä»¬ä½¿ç”¨äº’æ–¥é”æ¥ä¿æŠ¤è¿™ä¸ªå˜é‡ã€‚\nuse std::{ sync::{Arc, Mutex}, thread, time::Instant, }; fn main() { let args = std::env::args().collect::\u0026lt;Vec\u0026lt;String\u0026gt;\u0026gt;(); if args.len() != 3 { panic!(\u0026#34;Usage: {} \u0026lt;nthreads\u0026gt; \u0026lt;log_nelems\u0026gt;\u0026#34;, args[0]); } let nthreads: usize = args[1].parse().unwrap(); let log_nelems: usize = args[2].parse().unwrap(); let nelems = 1_usize \u0026lt;\u0026lt; log_nelems; let nelems_per_thread = nelems / nthreads; let gsum = Arc::new(Mutex::new(0)); let now = Instant::now(); let mut handlers = vec![]; for i in 0..nthreads { let gsum = Arc::clone(\u0026amp;gsum); let handler = thread::spawn(move || { let start = i * nelems_per_thread; let end = start + nelems_per_thread; for j in start..end { let mut sum = gsum.lock().unwrap(); *sum += j; } }); handlers.push(handler); } for handle in handlers { handle.join().unwrap(); } assert_eq!(nelems * (nelems - 1) / 2, *gsum.lock().unwrap()); println!(\u0026#34;Running took {} s.\u0026#34;, now.elapsed().as_secs()) } æˆ‘ä»¬åœ¨ä¸€ä¸ªå››æ ¸ç³»ç»Ÿä¸Šï¼Œå¯¹ä¸€ä¸ªå¤§å°ä¸º $n=2^{20}$ çš„åºåˆ—è¿›è¡Œæµ‹è¯•ï¼Œè¿ç®—æ—¶é—´ä»¥æ¯«ç§’ä¸ºå•ä½ï¼Œç»“æœå¦‚ä¸‹ï¼š\nçº¿ç¨‹æ•° 1 2 4 8 16 32 æ—¶é—´ 14932 72823 76478 118155 108878 101532 ç»“æœä»¤äººéš¾ä»¥ç†è§£ï¼Œä½¿ç”¨çš„CPUæ ¸æ•°è¶Šå¤šï¼Œæ€§èƒ½è¶Šå·®ã€‚é€ æˆæ€§èƒ½å·®çš„åŸå› æ˜¯ç›¸å¯¹äºå†…å­˜æ›´æ–°æ“ä½œçš„å¼€é”€ï¼ŒåŒæ­¥æ“ä½œä»£ä»·å¤ªå¤§ï¼ˆPå’ŒVï¼‰ã€‚è¿™çªæ˜¾äº†å¹¶è¡Œç¼–ç¨‹çš„ä¸€ä¸ªé‡è¦æ•™è®­ï¼šåŒæ­¥å¼€é”€å·¨å¤§ï¼Œè¦å°½å¯èƒ½é¿å…ã€‚å¦‚æœæ— æ³•é¿å…ï¼Œå¿…é¡»è¦ç”¨å°½å¯èƒ½å¤šçš„æœ‰ç”¨è®¡ç®—å¼¥è¡¥è¿™ä¸ªå¼€é”€ã€‚\nç”¨å±€éƒ¨å˜é‡ä¼˜åŒ–ï¼Œæ¶ˆé™¤åŒæ­¥ å› æ­¤ï¼Œæˆ‘ä»¬ä½¿ç”¨å±€éƒ¨å˜é‡æ¥æ¶ˆé™¤ä¸å¿…è¦çš„å†…å­˜å¼•ç”¨ï¼Œå°†æ¯ä¸ªå¯¹ç­‰çº¿ç¨‹æŠŠå®ƒçš„éƒ¨åˆ†å’Œç´¯ç§¯åœ¨ä¸€ä¸ªå±€éƒ¨å˜é‡è€Œä¸æ˜¯å…¨å±€å˜é‡ä¸­ã€‚\nuse std::{thread, time::Instant}; fn main() { let args = std::env::args().collect::\u0026lt;Vec\u0026lt;String\u0026gt;\u0026gt;(); if args.len() != 3 { panic!(\u0026#34;Usage: {} \u0026lt;nthreads\u0026gt; \u0026lt;log_nelems\u0026gt;\u0026#34;, args[0]); } let nthreads: usize = args[1].parse().unwrap(); let log_nelems: usize = args[2].parse().unwrap(); let nelems = 1_usize \u0026lt;\u0026lt; log_nelems; let nelems_per_thread = nelems / nthreads; let now = Instant::now(); let mut handlers = vec![]; for i in 0..nthreads { let handler = thread::spawn(move || { let mut sum = 0; let start = i * nelems_per_thread; let end = start + nelems_per_thread; for j in start..end { sum += j; } sum }); handlers.push(handler); } let mut gsum = 0; for handle in handlers { gsum += handle.join().unwrap(); } assert_eq!(nelems * (nelems - 1) / 2, gsum); println!(\u0026#34;Running took {} s.\u0026#34;, now.elapsed().as_micros() as f64 / 1e6) } æˆ‘ä»¬åœ¨ä¸€ä¸ªå››æ ¸ç³»ç»Ÿä¸Šï¼Œå¯¹ä¸€ä¸ªå¤§å°ä¸º $n=2^{31}$ çš„åºåˆ—è¿›è¡Œæµ‹è¯•ï¼Œè¿ç®—æ—¶é—´ä»¥ç§’ä¸ºå•ä½ï¼Œç»“æœå¦‚ä¸‹ï¼š\nçº¿ç¨‹æ•° 1 2 4 8 16 32 æ—¶é—´ 22.413 11.430 6.087 7.414 7.428 7.411 ç»“æœåŸºæœ¬ç¬¦åˆé¢„æœŸï¼Œå¾—åˆ°ä¸€ç»„é€’å‡çš„è¿è¡Œæ—¶é—´ã€‚\nåˆ»ç”»å¹¶è¡Œç¨‹åºçš„æ€§èƒ½ å¦‚å›¾ï¼Œæˆ‘ä»¬çœ‹åˆ°ï¼Œéšç€çº¿ç¨‹æ•°çš„å¢åŠ ï¼Œè¿è¡Œæ—¶é—´ä¸‹é™ï¼Œç›´åˆ°å¢åŠ åˆ°å››ä¸ªçº¿ç¨‹ï¼Œæ­¤æ—¶ï¼Œè¿è¡Œæ—¶é—´è¶‹äºå¹³ç¨³ï¼Œç”šè‡³å¼€å§‹æœ‰ç‚¹å¢åŠ ã€‚åœ¨ç†æƒ³çš„æƒ…å†µä¸­ï¼Œæˆ‘ä»¬ä¼šæœŸæœ›è¿è¡Œæ—¶é—´éšç€æ ¸æ•°çš„å¢åŠ çº¿æ€§ä¸‹é™ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬ä¼šæœŸæœ›çº¿ç¨‹æ•°æ¯å¢åŠ ä¸€å€ï¼Œè¿è¡Œæ—¶é—´å°±ä¸‹é™ä¸€åŠã€‚ç¡®å®æ˜¯è¿™æ ·ï¼Œç›´åˆ°åˆ°è¾¾ $t \u0026gt; 4$ çš„æ—¶å€™ï¼Œæ­¤æ—¶å››ä¸ªæ ¸ä¸­çš„æ¯ä¸€ä¸ªéƒ½å¿™äºè¿è¡Œè‡³å°‘ä¸€ä¸ªçº¿ç¨‹ã€‚éšç€çº¿ç¨‹æ•°é‡çš„å¢åŠ ï¼Œè¿è¡Œæ—¶é—´å®é™…ä¸Šå¢åŠ äº†ä¸€ç‚¹å„¿ï¼Œè¿™æ˜¯ç”±äºåœ¨ä¸€ä¸ªæ ¸ä¸Šå¤šä¸ªçº¿ç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢çš„å¼€é”€ã€‚ç”±äºè¿™ä¸ªåŸå› ï¼Œå¹¶è¡Œç¨‹åºå¸¸å¸¸è¢«å†™ä¸ºæ¯ä¸ªæ ¸ä¸Šåªè¿è¡Œä¸€ä¸ªçº¿ç¨‹ã€‚\nè™½ç„¶ç»å¯¹è¿è¡Œæ—¶é—´æ˜¯è¡¡é‡ç¨‹åºæ€§èƒ½çš„ç»ˆææ ‡å‡†ï¼Œä½†æ˜¯è¿˜æ˜¯æœ‰ä¸€äº›æœ‰ç”¨çš„ç›¸å¯¹è¡¡é‡æ ‡å‡†èƒ½å¤Ÿè¯´æ˜å¹¶è¡Œç¨‹åºæœ‰å¤šå¥½çš„åˆ©ç”¨äº†æ½œåœ¨çš„å¹¶è¡Œæ€§ã€‚å¹¶è¡Œç¨‹åºçš„åŠ é€Ÿæ¯”é€šå¸¸å®šä¹‰ä¸ºï¼š $$ S_p = \\frac{T_1}{T_p} $$ $p$ æ˜¯å¤„ç†å™¨æ ¸çš„æ•°é‡ï¼Œ $T_k$ æ˜¯åœ¨ $k$ ä¸ªæ ¸ä¸Šçš„è¿è¡Œæ—¶é—´ã€‚è¿™ä¸ªå…¬å¼æœ‰æ—¶è¢«ç§°ä¸ºå¼ºæ‰©å±•ï¼ˆstrong scalingï¼‰ã€‚å½“ $T_1$ æ˜¯ç¨‹åºé¡ºåºæ‰§è¡Œç‰ˆæœ¬çš„æ‰§è¡Œæ—¶é—´æ—¶ï¼Œ $S_p$ ç§°ä¸ºç»å¯¹åŠ é€Ÿæ¯”ï¼ˆabsolute speedupï¼‰ã€‚ç»å¯¹åŠ é€Ÿæ¯”æ¯”ç›¸å¯¹åŠ é€Ÿæ¯”èƒ½æ›´çœŸå®åœ°è¡¡é‡å¹¶è¡Œçš„å¥½å¤„ã€‚å³ä½¿æ˜¯å½“å¹¶è¡Œç¨‹åºåœ¨ä¸€ä¸ªå¤„ç†å™¨ä¸Šè¿è¡Œæ—¶ï¼Œä¹Ÿå¸¸å¸¸ä¼šå—åˆ°åŒæ­¥å¼€é”€çš„å½±å“ï¼Œè€Œè¿™äº›å¼€é”€ä¼šäººä¸ºåœ°å¢åŠ ç›¸å¯¹åŠ é€Ÿæ¯”çš„æ•°å€¼ï¼Œå› ä¸ºå®ƒä»¬å¢åŠ äº†åˆ†å­çš„å¤§å°ã€‚å¦ä¸€æ–¹é¢ï¼Œç»å¯¹åŠ é€Ÿæ¯”æ¯”ç›¸å¯¹åŠ é€Ÿæ¯”æ›´éš¾ä»¥æµ‹é‡ï¼Œå› ä¸ºæµ‹é‡ç»å¯¹åŠ é€Ÿæ¯”éœ€è¦ç¨‹åºçš„ä¸¤ç§ä¸åŒçš„ç‰ˆæœ¬ã€‚å¯¹äºå¤æ‚çš„å¹¶è¡Œä»£ç ï¼Œåˆ›å»ºä¸€ä¸ªç‹¬ç«‹çš„é¡ºåºç‰ˆæœ¬å¯èƒ½ä¸å¤ªå®é™…ï¼Œæˆ–è€…å› ä¸ºä»£ç å¤ªå¤æ‚ï¼Œæˆ–è€…å› ä¸ºæºä»£ç ä¸å¯å¾—ã€‚\nä¸€ç§ç›¸å…³çš„æµ‹é‡é‡ç§°ä¸ºæ•ˆç‡ï¼ˆefficiencyï¼‰ï¼Œå®šä¹‰ä¸º: $$ E_p = \\frac{S_p}{p} = \\frac{T_1}{pT_p} $$é€šå¸¸è¡¨ç¤ºä¸ºèŒƒå›´åœ¨ $(0, 100]$ ä¹‹é—´çš„ç™¾åˆ†æ¯”ã€‚æ•ˆç‡æ˜¯å¯¹ç”±äºå¹¶è¡ŒåŒ–é€ æˆçš„å¼€é”€çš„è¡¡é‡ã€‚å…·æœ‰é«˜æ•ˆç‡çš„ç¨‹åºæ¯”æ•ˆç‡ä½çš„ç¨‹åºåœ¨æœ‰ç”¨çš„å·¥ä½œä¸ŠèŠ±è´¹æ›´å¤šçš„æ—¶é—´ï¼Œåœ¨åŒæ­¥å’Œé€šä¿¡ä¸ŠèŠ±è´¹æ›´å°‘çš„æ—¶é—´ã€‚\nä¸‹è¡¨ç»™å‡ºäº†æˆ‘ä»¬å¹¶è¡Œæ±‚å’Œç¤ºä¾‹ç¨‹åºçš„å„ä¸ªåŠ é€Ÿæ¯”å’Œæ•ˆç‡æµ‹é‡å€¼ã€‚åƒè¿™æ ·è¶…è¿‡ $90%$ çš„æ•ˆç‡æ˜¯éå¸¸å¥½çš„ï¼Œä½†æ˜¯ä¸è¦è¢«æ¬ºéª—äº†ã€‚èƒ½å–å¾—è¿™ä¹ˆé«˜çš„æ•ˆç‡æ˜¯å› ä¸ºæˆ‘ä»¬çš„é—®é¢˜éå¸¸å®¹æ˜“å¹¶è¡ŒåŒ–ã€‚åœ¨å®é™…ä¸­ï¼Œå¾ˆå°‘ä¼šè¿™æ ·ã€‚æ•°åå¹´æ¥ï¼Œå¹¶è¡Œç¼–ç¨‹ä¸€ç›´æ˜¯ä¸€ä¸ªå¾ˆæ´»è·ƒçš„ç ”ç©¶é¢†åŸŸã€‚éšç€å•†ç”¨å¤šæ ¸æœºå™¨çš„å‡ºç°ï¼Œè¿™äº›æœºå™¨çš„æ ¸æ•°æ¯å‡ å¹´å°±ç¿»ä¸€ç•ªï¼Œå¹¶è¡Œç¼–ç¨‹ä¼šç»§ç»­æ˜¯ä¸€ä¸ªæ·±å…¥ã€å›°éš¾è€Œæ´»è·ƒçš„ç ”ç©¶é¢†åŸŸã€‚\nçº¿ç¨‹ï¼ˆ$t$ï¼‰ $1$ $2$ $4$ $8$ $16$ $32$ æ ¸ï¼ˆ$p$ï¼‰ $1$ $2$ $4$ $8$ $16$ $32$ è¿è¡Œæ—¶é—´ï¼ˆ $T_p$ ï¼‰ $22.413$ $11.430$ $6.087$ $7.414$ $7.428$ $7.411$ åŠ é€Ÿæ¯”ï¼ˆ $S_p$ ï¼‰ $1$ $1.96$ $3.68$ $3.023$ $3.017$ $3.024$ æ•ˆç‡ï¼ˆ $E_p$ ï¼‰ $100\\%$ $98\\%$ $92\\%$ $76\\%$ $75\\%$ $76\\%$ References https://hansimov.gitbook.io/csapp/part3/ch12-concurrent-programming/12.6-using-threads-for-parallelism\n","permalink":"https://fffzlfk.github.io/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%8A%E5%85%B6%E6%80%A7%E8%83%BD%E5%88%BB%E7%94%BB/","summary":"ä½¿ç”¨å¤šçº¿ç¨‹æé«˜å¹¶è¡Œæ€§ åŒæ­¥çš„ä»£ä»· æˆ‘ä»¬ç ”ç©¶å¯¹ä¸€åˆ—æ•´æ•° $0, \u0026hellip;, n - 1$ æ±‚å’Œï¼Œæˆ‘ä»¬å°†åºåˆ—åˆ’åˆ†æˆ $t$ ä¸ªä¸ç›¸äº¤çš„çš„åŒºåŸŸï¼Œç»™ $t$ ä¸ªçº¿ç¨‹æ¯ä¸ªåˆ†é…ä¸€ä¸ªåŒºåŸŸã€‚å°†çº¿ç¨‹çš„å’Œæ”¾å…¥ä¸€ä¸ªå˜é‡ä¸­ï¼Œå¹¶ä¸”æˆ‘ä»¬ä½¿ç”¨äº’æ–¥é”æ¥ä¿æŠ¤è¿™ä¸ªå˜é‡ã€‚\nuse std::{ sync::{Arc, Mutex}, thread, time::Instant, }; fn main() { let args = std::env::args().collect::\u0026lt;Vec\u0026lt;String\u0026gt;\u0026gt;(); if args.len() != 3 { panic!(\u0026#34;Usage: {} \u0026lt;nthreads\u0026gt; \u0026lt;log_nelems\u0026gt;\u0026#34;, args[0]); } let nthreads: usize = args[1].parse().unwrap(); let log_nelems: usize = args[2].parse().unwrap(); let nelems = 1_usize \u0026lt;\u0026lt; log_nelems; let nelems_per_thread = nelems / nthreads; let gsum = Arc::new(Mutex::new(0)); let now = Instant::now(); let mut handlers = vec!","title":"å¤šçº¿ç¨‹åŠå…¶æ€§èƒ½åˆ»ç”»"},{"content":"ä¸æ­£ç¡®åœ°ä½¿ç”¨newå’Œdelete æ— è®ºæˆ‘ä»¬å¦‚ä½•åŠªåŠ›ï¼Œè¦é‡Šæ”¾æ‰€æœ‰åŠ¨æ€åˆ†é…çš„å†…å­˜æ˜¯éå¸¸å›°éš¾çš„ã€‚å³ä½¿æˆ‘ä»¬èƒ½åšåˆ°è¿™ä¸€ç‚¹ï¼Œä¹Ÿå¾€å¾€ä¸èƒ½å®‰å…¨åœ°é¿å…å‡ºç°å¼‚å¸¸ã€‚è®©æˆ‘ä»¬çœ‹ä¸€ä¸ªç®€å•çš„ä¾‹å­ã€‚\nvoid SomeMethod() { ClassA *a = new ClassA; SomeOtherMethod(); // it can throws an execption delete a; } å¦‚æœSomeOtherMethodæŠ›å‡ºäº†å¼‚å¸¸ï¼Œé‚£ä¹ˆaå¯¹è±¡æ°¸è¿œä¸ä¼šè¢«åˆ é™¤ã€‚ä¸‹é¢çš„ä¾‹å­å±•ç¤ºäº†ä¸€ä¸ªæ›´åŠ å®‰å…¨åŒæ—¶åˆæ›´ç®€æ´çš„å®ç°ï¼Œä½¿ç”¨äº†åœ¨C++11æå‡ºçš„std::unique_ptrã€‚\nvoid SomeMethod() { std::unique_ptr\u0026lt;ClassA\u0026gt; a(new ClassA); SomeOtherMethod(); } æ— è®ºå‘ç”Ÿä»€ä¹ˆï¼Œå½“aé€€å‡ºä½œç”¨åŸŸçš„æ—¶å€™ï¼Œå®ƒä¼šè¢«é‡Šæ”¾ã€‚\nç„¶è€Œï¼Œè¿™ä»…ä»…æ˜¯C++ä¸­è¿™ç§é”™è¯¯æœ€ç®€å•çš„ä¾‹å­ï¼Œè¿˜æœ‰å¾ˆå¤šä¾‹å­è¡¨æ˜deleteåº”è¯¥åœ¨å…¶ä»–åœ°æ–¹è°ƒç”¨ï¼Œä¹Ÿè®¸æ˜¯åœ¨å¤–å±‚å‡½æ•°æˆ–è€…å¦ä¸€ä¸ªçº¿ç¨‹ä¸­ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆåº”è¯¥é¿å…ä½¿ç”¨newå’Œdeleteï¼Œè€Œåº”è¯¥ä½¿ç”¨é€‚å½“çš„æ™ºèƒ½æŒ‡é’ˆã€‚\nè¢«å¿˜è®°çš„è™šææ„å‡½æ•° è¿™æ˜¯æœ€å¸¸è§çš„é”™è¯¯ä¹‹ä¸€ï¼Œå¦‚æœæ´¾ç”Ÿç±»ä¸­æœ‰åŠ¨æ€å†…å­˜åˆ†é…ï¼Œå°†ä¼šå¯¼è‡´æ´¾ç”Ÿç±»çš„å†…å­˜æ³„æ¼ã€‚è¿™é‡Œæœ‰ä¸€äº›ä¾‹å­ï¼Œå½“ä¸€ä¸ªç±»ä¸æ‰“ç®—ç”¨äºç»§æ‰¿ï¼Œå¹¶ä¸”å®ƒçš„å¤§å°å’Œæ€§èƒ½æ˜¯è‡³å…³é‡è¦çš„ã€‚è™šææ„å‡½æ•°æˆ–ä»»ä½•å…¶ä»–è™šå‡½æ•°åœ¨ç±»åœ¨ç±»ä¸­å¼•å…¥äº†é¢å¤–çš„æ•°æ®ï¼Œå³æŒ‡å‘è™šå‡½æ•°è¡¨çš„æŒ‡é’ˆï¼Œè¿™ä½¿å¾—ç±»çš„ä»»ä½•å®ä¾‹çš„å¤§å°å˜å¤§ã€‚\nç„¶è€Œï¼Œåœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œç±»å¯ä»¥è¢«ç»§æ‰¿ï¼Œå³ä½¿å®ƒçš„åˆè¡·å¹¶éå¦‚æ­¤ã€‚å› æ­¤ï¼Œåœ¨å£°æ˜ä¸€ä¸ªç±»çš„æ—¶å€™ï¼Œæ·»åŠ ä¸€ä¸ªè™šææ„å‡½æ•°æ˜¯ä¸€ä¸ªéå¸¸å¥½çš„åšæ³•ã€‚å¦åˆ™ï¼Œå¦‚æœä¸€ä¸ªç±»ç”±äºæ€§èƒ½çš„åŸå› å¿…é¡»ä¸åŒ…å«è™šå‡½æ•°ï¼Œé‚£ä¹ˆåœ¨ç±»çš„å£°æ˜æ–‡ä»¶é‡Œé¢åŠ ä¸Šä¸€ä¸ªæ³¨é‡Šï¼Œè¯´æ˜è¿™ä¸ªç±»ä¸åº”è¯¥è¢«ç»§æ‰¿ï¼Œæ˜¯ä¸€ä¸ªå¾ˆå¥½çš„åšæ³•ã€‚é¿å…è¿™ä¸ªé—®é¢˜çš„æœ€ä½³é€‰æ‹©ä¹‹ä¸€æ˜¯ä½¿ç”¨ä¸€ä¸ªæ”¯æŒåœ¨åˆ›å»ºç±»æ—¶åˆ›å»ºè™šææ„å‡½æ•°çš„IDEã€‚\nå…³äºè¿™ä¸ªé—®é¢˜ï¼Œè¿˜æœ‰ä¸€ç‚¹æ˜¯æ¥è‡ªæ ‡å‡†åº“çš„ç±»æˆ–æ¨¡æ¿ã€‚å®ƒä»¬ä¸æ˜¯ç”¨æ¥ç»§æ‰¿çš„ï¼Œä¹Ÿæ²¡æœ‰ä¸€ä¸ªè™šææ„å‡½æ•°ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªå…¬å¼€ç»§æ‰¿è‡ªstd::stringçš„æ–°çš„å¢å¼ºå­—ç¬¦ä¸²ç±»ï¼Œå°±å¯èƒ½æœ‰äººé”™è¯¯åœ°ä½¿ç”¨å®ƒä¸std::stringçš„æŒ‡é’ˆæˆ–å¼•ç”¨ï¼Œä»è€Œå¯¼è‡´å†…å­˜æ³„æ¼ã€‚\nclass MyString : public std::string { ~MyString() {} }; int main() { std::string *s = new MyString(); delete s; // May not invoke the destructor defined in MyString } ä¸ºäº†é¿å…è¿™æ ·çš„é—®é¢˜ï¼Œé‡ç”¨æ ‡å‡†åº“ä¸­çš„ç±»æˆ–æ¨¡æ¿çš„ä¸€ä¸ªæ›´å®‰å…¨çš„æ–¹æ³•æ˜¯ä½¿ç”¨ç§æœ‰ç»§æ‰¿1æˆ–ç»„åˆã€‚\nç”¨deleteæˆ–æ™ºèƒ½æŒ‡é’ˆåˆ é™¤ä¸€ä¸ªæ•°ç»„ åˆ›å»ºåŠ¨æ€å¤§å°çš„ä¸´æ—¶æ•°ç»„å¾€å¾€æ˜¯å¿…è¦çš„ã€‚å½“å®ƒä»¬ä¸å†éœ€è¦æ—¶ï¼Œé‡Šæ”¾åˆ†é…çš„å†…å­˜æ˜¯å¾ˆé‡è¦çš„ã€‚è¿™é‡Œçš„é—®é¢˜æ˜¯ï¼ŒC++éœ€è¦å¸¦æœ‰[]æ‹¬å·çš„ç‰¹æ®Šåˆ é™¤æ“ä½œç¬¦ï¼Œè¿™ä¸€ç‚¹å¾ˆå®¹æ˜“è¢«é—å¿˜ã€‚delete[]æ“ä½œç¬¦ä¸ä»…ä¼šåˆ é™¤åˆ†é…ç»™æ•°ç»„çš„å†…å­˜ï¼Œè€Œä¸”ä¼šé¦–å…ˆè°ƒç”¨æ•°ç»„ä¸­æ‰€æœ‰å¯¹è±¡çš„ææ„å‡½æ•°ã€‚å¯¹åŸå§‹ç±»å‹ä½¿ç”¨ä¸å¸¦[]æ‹¬å·çš„åˆ é™¤æ“ä½œç¬¦ä¹Ÿæ˜¯ä¸æ­£ç¡®çš„ï¼Œå°½ç®¡è¿™äº›ç±»å‹æ²¡æœ‰ææ„å‡½æ•°ï¼Œæ¯ä¸ªç¼–è¯‘å™¨éƒ½ä¸èƒ½ä¿è¯ä¸€ä¸ªæ•°ç»„çš„æŒ‡é’ˆä¼šæŒ‡å‘æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œæ‰€ä»¥ä½¿ç”¨ä¸å¸¦[]æ‹¬å·çš„deleteä¹Ÿä¼šå¯¼è‡´æœªå®šä¹‰çš„è¡Œä¸ºã€‚\nåœ¨æ•°ç»„ä¸­ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆï¼Œå¦‚unique_ptr\u0026lt;T\u0026gt;, shared_ptrï¼Œä¹Ÿæ˜¯ä¸æ­£ç¡®çš„ã€‚å½“è¿™æ ·çš„æ™ºèƒ½æŒ‡é’ˆä»ä½œç”¨åŸŸä¸­é€€å‡ºæ—¶ï¼Œå®ƒå°†è°ƒç”¨ä¸å¸¦[]æ‹¬å·çš„åˆ é™¤æ“ä½œç¬¦ï¼Œè¿™å°†å¯¼è‡´ä¸Šé¢æè¿°çš„åŒæ ·é—®é¢˜ã€‚å¦‚æœéœ€è¦å¯¹æ•°ç»„ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆï¼Œå¯ä»¥ä½¿ç”¨unique_ptr\u0026lt;T[]\u0026gt;çš„ç‰¹æ®ŠåŒ–ã€‚\nå¦‚æœä¸éœ€è¦å¼•ç”¨è®¡æ•°çš„åŠŸèƒ½ï¼Œä¸»è¦æ˜¯æ•°ç»„çš„æƒ…å†µï¼Œæœ€ä¼˜é›…çš„æ–¹æ³•æ˜¯ä½¿ç”¨STLå‘é‡æ¥ä»£æ›¿ã€‚å®ƒä»¬ä¸åªæ˜¯è´Ÿè´£é‡Šæ”¾å†…å­˜ï¼Œè€Œä¸”è¿˜æä¾›é¢å¤–çš„åŠŸèƒ½ã€‚\nè¿”å›ä¸€ä¸ªå±€éƒ¨å¯¹è±¡çš„å¼•ç”¨ è¿™ä¸»è¦æ˜¯ä¸€ä¸ªåˆå­¦è€…çš„é”™è¯¯ï¼Œä½†å®ƒå€¼å¾—ä¸€æï¼Œå› ä¸ºæœ‰å¾ˆå¤šé—ç•™çš„ä»£ç éƒ½å­˜åœ¨è¿™ä¸ªé—®é¢˜ã€‚è®©æˆ‘ä»¬çœ‹çœ‹ä¸‹é¢çš„ä»£ç ï¼Œä¸€ä¸ªç¨‹åºå‘˜æƒ³é€šè¿‡é¿å…ä¸å¿…è¦çš„å¤åˆ¶æ¥è¿›è¡ŒæŸç§ä¼˜åŒ–ã€‚\nComplex\u0026amp; SumComplex(const Complex\u0026amp; a, const Complex\u0026amp; b) { Complex result; â€¦.. return result; } Complex\u0026amp; sum = SumComplex(a, b); å¯¹è±¡ sumç°åœ¨å°†æŒ‡å‘å±€éƒ¨å¯¹è±¡resultã€‚ä½†æ˜¯ï¼Œåœ¨æ‰§è¡ŒSumComplexå‡½æ•°åï¼Œå¯¹è±¡resultä½äºå“ªé‡Œå‘¢ï¼Ÿä¸çŸ¥é“ã€‚å®ƒä½äºå †æ ˆä¸­ï¼Œä½†åœ¨å‡½æ•°è¿”å›åï¼Œå †æ ˆè¢«æ”¶ç¼©ï¼Œå‡½æ•°ä¸­çš„æ‰€æœ‰æœ¬åœ°å¯¹è±¡éƒ½è¢«ææ„äº†ã€‚è¿™æœ€ç»ˆä¼šå¯¼è‡´ä¸€ä¸ªæœªå®šä¹‰çš„è¡Œä¸ºï¼Œå³ä½¿æ˜¯åŸå§‹ç±»å‹ã€‚ä¸ºäº†é¿å…æ€§èƒ½é—®é¢˜ï¼Œæœ‰æ—¶å¯ä»¥ä½¿ç”¨è¿”å›å€¼ä¼˜åŒ–ã€‚\nComplex SumComplex(const Complex\u0026amp; a, const Complex\u0026amp; b) { return Complex(a.real + b.real, a.imaginar + b.imaginar); } Complex sum = SumComplex(a, b); å¯¹äºä»Šå¤©çš„å¤§å¤šæ•°ç¼–è¯‘å™¨æ¥è¯´ï¼Œå¦‚æœä¸€ä¸ªè¿”å›è¡ŒåŒ…å«ä¸€ä¸ªå¯¹è±¡çš„æ„é€ å‡½æ•°ï¼Œä»£ç å°†è¢«ä¼˜åŒ–ä»¥é¿å…æ‰€æœ‰ä¸å¿…è¦çš„å¤åˆ¶\u0026ndash;æ„é€ å‡½æ•°å°†ç›´æ¥åœ¨sumå¯¹è±¡ä¸Šæ‰§è¡Œã€‚\nä½¿ç”¨å¯¹å·²åˆ é™¤èµ„æºçš„å¼•ç”¨ è¿™äº›C++é—®é¢˜æ¯”ä½ æƒ³è±¡çš„è¦ç»å¸¸å‘ç”Ÿï¼Œè€Œä¸”é€šå¸¸å‡ºç°åœ¨å¤šçº¿ç¨‹çš„åº”ç”¨ç¨‹åºä¸­ã€‚è®©æˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹ä¸‹é¢çš„ä»£ç ã€‚\nThread 1: Connection\u0026amp; connection = connections.GetConnection(connectionId); // ... Thread 2: connections.DeleteConnection(connectionId); // â€¦ Thread 1: connection.send(data); åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå¦‚æœä¸¤ä¸ªçº¿ç¨‹ä½¿ç”¨ç›¸åŒçš„è¿æ¥IDï¼Œè¿™å°†å¯¼è‡´æœªå®šä¹‰çš„è¡Œä¸ºã€‚è¿åè®¿é—®æƒé™çš„é”™è¯¯å¾€å¾€æ˜¯å¾ˆéš¾å‘ç°çš„ã€‚\nåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå½“ä¸€ä¸ªä»¥ä¸Šçš„çº¿ç¨‹è®¿é—®åŒä¸€èµ„æºæ—¶ï¼Œä¿ç•™èµ„æºçš„æŒ‡é’ˆæˆ–å¼•ç”¨æ˜¯éå¸¸å±é™©çš„ï¼Œå› ä¸ºå…¶ä»–çº¿ç¨‹å¯ä»¥åˆ é™¤å®ƒã€‚ä½¿ç”¨å¸¦æœ‰å¼•ç”¨è®¡æ•°çš„æ™ºèƒ½æŒ‡é’ˆè¦å®‰å…¨å¾—å¤šï¼Œä¾‹å¦‚std::shared_ptrã€‚å®ƒä½¿ç”¨åŸå­æ“ä½œæ¥å¢åŠ /å‡å°‘ä¸€ä¸ªå¼•ç”¨è®¡æ•°å™¨ï¼Œæ‰€ä»¥å®ƒæ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚\nå…è®¸å¼‚å¸¸ç¦»å¼€ææ„å‡½æ•° å¹¶ä¸ç»å¸¸éœ€è¦ä»ä¸€ä¸ªææ„å‡½æ•°ä¸­æŠ›å‡ºä¸€ä¸ªå¼‚å¸¸ã€‚å³ä½¿å¦‚æ­¤ï¼Œä¹Ÿæœ‰æ›´å¥½çš„æ–¹æ³•æ¥åšåˆ°è¿™ä¸€ç‚¹ã€‚ç„¶è€Œï¼Œå¼‚å¸¸å¤§å¤šä¸æ˜¯æ˜ç¡®åœ°ä»ææ„å™¨ä¸­æŠ›å‡ºçš„ã€‚å¯èƒ½å‘ç”Ÿçš„æƒ…å†µæ˜¯ï¼Œä¸€ä¸ªç®€å•çš„è®°å½•å¯¹è±¡é”€æ¯çš„å‘½ä»¤å°±ä¼šå¯¼è‡´å¼‚å¸¸çš„æŠ›å‡ºã€‚è®©æˆ‘ä»¬è€ƒè™‘ä»¥ä¸‹ä»£ç ã€‚\nclass A { public: A() {} ~A() { writeToLog(); // could cause an exception to be thrown } }; // â€¦ try { A a1;\tA a2;\t} catch (std::exception\u0026amp; e) { std::cout \u0026lt;\u0026lt; \u0026#34;exception caught\u0026#34;; } åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œå¦‚æœå¼‚å¸¸å‘ç”Ÿäº†ä¸¤æ¬¡ï¼Œæ¯”å¦‚åœ¨é”€æ¯ä¸¤ä¸ªå¯¹è±¡çš„è¿‡ç¨‹ä¸­ï¼Œcatchè¯­å¥å°±ä¸ä¼šè¢«æ‰§è¡Œã€‚å› ä¸ºæœ‰ä¸¤ä¸ªå¹¶è¡Œçš„å¼‚å¸¸ï¼Œæ— è®ºå®ƒä»¬æ˜¯åŒä¸€ç±»å‹è¿˜æ˜¯ä¸åŒç±»å‹ï¼ŒC++è¿è¡Œç¯å¢ƒéƒ½ä¸çŸ¥é“å¦‚ä½•å¤„ç†ï¼Œå¹¶è°ƒç”¨ä¸€ä¸ªç»ˆæ­¢å‡½æ•°ï¼Œå¯¼è‡´ç¨‹åºæ‰§è¡Œçš„ç»ˆæ­¢ã€‚ä¸ºäº†é¿å…è¿™ä¸€ç‚¹C++11å¼€å§‹ï¼Œdestructoré»˜è®¤æ˜¯noexceptã€‚\nä½¿ç”¨æ— æ•ˆçš„è¿­ä»£å™¨å’Œå¼•ç”¨ å…³äºè¿™ä¸ªé—®é¢˜ï¼Œå¯ä»¥å†™ä¸€æ•´æœ¬ä¹¦ã€‚æ¯ä¸ªSTLå®¹å™¨éƒ½æœ‰ä¸€äº›ç‰¹å®šçš„æ¡ä»¶ï¼Œåœ¨è¿™äº›æ¡ä»¶ä¸‹å®ƒä¼šä½¿è¿­ä»£å™¨å’Œå¼•ç”¨å¤±æ•ˆã€‚åœ¨ä½¿ç”¨ä»»ä½•æ“ä½œæ—¶ï¼Œéƒ½è¦æ³¨æ„è¿™äº›ç»†èŠ‚ã€‚å°±åƒä¹‹å‰çš„C++é—®é¢˜ä¸€æ ·ï¼Œè¿™ä¸ªé—®é¢˜åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸­ä¹Ÿä¼šç»å¸¸å‘ç”Ÿï¼Œæ‰€ä»¥éœ€è¦ä½¿ç”¨åŒæ­¥æœºåˆ¶æ¥é¿å…å®ƒã€‚è®©æˆ‘ä»¬çœ‹çœ‹ä¸‹é¢çš„é¡ºåºä»£ç ä½œä¸ºä¸€ä¸ªä¾‹å­ã€‚\nvector\u0026lt;string\u0026gt; v; v.push_back(â€œstring1â€); string\u0026amp; s1 = v[0]; // assign a reference to the 1st element vector\u0026lt;string\u0026gt;::iterator iter = v.begin(); // assign an iterator to the 1st element v.push_back(â€œstring2â€); cout \u0026lt;\u0026lt; s1; // access to a reference of the 1st element cout \u0026lt;\u0026lt; *iter; // access to an iterator of the 1st element ä»é€»è¾‘çš„è§’åº¦æ¥çœ‹ï¼Œè¿™æ®µä»£ç ä¼¼ä¹å®Œå…¨æ²¡æœ‰é—®é¢˜ã€‚ç„¶è€Œï¼Œåœ¨å‘é‡ä¸­æ·»åŠ ç¬¬äºŒä¸ªå…ƒç´ å¯èƒ½ä¼šå¯¼è‡´å‘é‡å†…å­˜çš„é‡æ–°åˆ†é…ï¼Œè¿™å°†ä½¿è¿­ä»£å™¨å’Œå¼•ç”¨éƒ½æ— æ•ˆï¼Œå¹¶å¯¼è‡´åœ¨æœ€åä¸¤è¡Œè¯•å›¾è®¿é—®å®ƒä»¬æ—¶å‡ºç°è®¿é—®è¿è§„é”™è¯¯ã€‚\né€šè¿‡å€¼ä¼ é€’å¯¹è±¡ ä½ å¯èƒ½çŸ¥é“ï¼Œç”±äºå¯¹æ€§èƒ½çš„å½±å“ï¼ŒæŒ‰å€¼ä¼ é€’å¯¹è±¡æ˜¯ä¸ªåä¸»æ„ã€‚è®¸å¤šäººä¸ºäº†é¿å…è¾“å…¥é¢å¤–çš„å­—ç¬¦è€Œè®©å®ƒä¿æŒè¿™æ ·çš„çŠ¶æ€ï¼Œæˆ–è€…å¯èƒ½æƒ³åˆ°ä»¥åå†è¿”å›å»åšä¼˜åŒ–ã€‚è¿™é€šå¸¸æ˜¯ä¸å¯èƒ½çš„ï¼Œç»“æœæ˜¯å¯¼è‡´äº†æ€§èƒ½è¾ƒå·®çš„ä»£ç å’Œå®¹æ˜“å‡ºç°æ„å¤–è¡Œä¸ºçš„ä»£ç ã€‚\nclass A { public: virtual std::string GetName() const { return \u0026#34;A\u0026#34;; } ... }; class B : public A { public: virtual std::string GetName() const { return \u0026#34;B\u0026#34;; } ... }; void func1(A a) { std::string name = a.GetName(); ... } B b; func1(b); è¿™æ®µä»£ç è°ƒç”¨func1å‡½æ•°å°†åˆ›å»ºä¸€ä¸ªå¯¹è±¡bçš„éƒ¨åˆ†å‰¯æœ¬ï¼Œå³å®ƒå°†åªå¤åˆ¶ç±»Açš„éƒ¨åˆ†å¯¹è±¡båˆ°å¯¹è±¡aï¼ˆ\u0026ldquo;åˆ‡ç‰‡é—®é¢˜\u0026rdquo;ï¼‰ã€‚æ‰€ä»¥åœ¨å‡½æ•°ä¸­ï¼Œå®ƒä¹Ÿä¼šè°ƒç”¨ç±»Açš„æ–¹æ³•ï¼Œè€Œä¸æ˜¯ç±»Bçš„æ–¹æ³•ï¼Œè¿™å¾ˆå¯èƒ½ä¸æ˜¯è°ƒç”¨è¯¥å‡½æ•°çš„äººæ‰€æœŸæœ›çš„ã€‚\nç±»ä¼¼çš„é—®é¢˜ä¹Ÿå‘ç”Ÿåœ¨è¯•å›¾æ•è·å¼‚å¸¸çš„æ—¶å€™ï¼Œæ¯”å¦‚è¯´ï¼š\nclass ExceptionA : public std::exception; class ExceptionB : public ExceptionA; try { func2(); // can throw an ExceptionB exception } catch (ExceptionA ex) { writeToLog(ex.GetDescription()); throw; } å½“ä¸€ä¸ªExceptionBç±»å‹çš„å¼‚å¸¸ä»å‡½æ•°func2æŠ›å‡ºæ—¶ï¼Œå®ƒå°†è¢«catchå—æ•è·ï¼Œä½†ç”±äºåˆ‡ç‰‡é—®é¢˜ï¼Œåªæœ‰ExceptionAç±»çš„ä¸€éƒ¨åˆ†ä¼šè¢«å¤åˆ¶ï¼Œä¸æ­£ç¡®çš„æ–¹æ³•ä¼šè¢«è°ƒç”¨ï¼Œè€Œä¸”é‡æ–°æŠ›å‡ºä¹Ÿä¼šå‘å¤–éƒ¨çš„try-catchå—æŠ›å‡ºä¸€ä¸ªä¸æ­£ç¡®çš„å¼‚å¸¸ã€‚\næ€»è€Œè¨€ä¹‹ï¼Œæ€»æ˜¯é€šè¿‡å¼•ç”¨æ¥ä¼ é€’å¯¹è±¡ï¼Œè€Œä¸æ˜¯é€šè¿‡å€¼ã€‚\nç±»æ„é€ å‡½æ•°éšå¼è°ƒç”¨ è™½ç„¶æœ‰æ—¶å€™å®šä¹‰çš„è½¬æ¢ä¹Ÿéå¸¸æœ‰ç”¨ï¼Œä½†å®ƒä»¬ä¼šå¯¼è‡´éš¾ä»¥é¢„æµ‹çš„è½¬æ¢ï¼Œè€Œä¸”å¾ˆéš¾å®šä½ã€‚æ¯”æ–¹è¯´ï¼Œæœ‰äººåˆ›å»ºäº†ä¸€ä¸ªæœ‰å­—ç¬¦ä¸²ç±»çš„åº“ï¼š\nclass String { public: String(int n); String(const char *s); ... } ç¬¬ä¸€ä¸ªæ–¹æ³•çš„ç›®çš„æ˜¯åˆ›å»ºä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„å­—ç¬¦ä¸²ï¼Œç¬¬äºŒä¸ªæ–¹æ³•çš„ç›®çš„æ˜¯åˆ›å»ºä¸€ä¸ªåŒ…å«ç»™å®šå­—ç¬¦çš„å­—ç¬¦ä¸²ã€‚ä½†æ˜¯å½“ä½ æœ‰è¿™æ ·çš„ä¸œè¥¿æ—¶ï¼Œé—®é¢˜å°±å‡ºç°äº†ã€‚\nString s1 = 123; String s2 = \u0026#39;abc\u0026#39;; åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œs1å°†æˆä¸ºä¸€ä¸ªå¤§å°ä¸º123çš„å­—ç¬¦ä¸²ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªåŒ…å«\u0026quot;123\u0026quot;å­—ç¬¦çš„å­—ç¬¦ä¸²ã€‚ç¬¬äºŒä¸ªä¾‹å­åŒ…å«å•å¼•å·è€Œä¸æ˜¯åŒå¼•å·ï¼ˆè¿™å¯èƒ½æ˜¯æ„å¤–å‘ç”Ÿçš„ï¼‰ï¼Œè¿™ä¹Ÿä¼šå¯¼è‡´è°ƒç”¨ç¬¬ä¸€ä¸ªæ„é€ å‡½æ•°å¹¶åˆ›å»ºä¸€ä¸ªå°ºå¯¸éå¸¸å¤§çš„å­—ç¬¦ä¸²ã€‚è¿™äº›éƒ½æ˜¯éå¸¸ç®€å•çš„ä¾‹å­ï¼Œè¿˜æœ‰å¾ˆå¤šæ›´å¤æ‚çš„æƒ…å†µä¼šå¯¼è‡´æ··ä¹±å’Œéš¾ä»¥é¢„æ–™çš„è½¬æ¢ï¼Œå¾ˆéš¾å‘ç°ã€‚å¯¹äºå¦‚ä½•é¿å…è¿™ç±»é—®é¢˜ï¼ŒC++11å¼€å§‹æœ‰äº†explicitå…³é”®å­—ï¼Œå¯ä»¥æŒ‡å®šæ„é€ å‡½æ•°æˆ–è½¬æ¢å‡½æ•°ä¸ºæ˜¾å¼, å³å®ƒä¸èƒ½ç”¨äºéšå¼è½¬æ¢å’Œå¤åˆ¶åˆå§‹åŒ–ã€‚\nç”¨ã€ŠEffective C++ã€‹ä¸­çš„è¯è¯´å°±æ˜¯privateç»§æ‰¿æ˜¯å®ç°ç»§æ‰¿ã€‚å°±æ˜¯class Derivative æƒ³è¦ç”¨class Baseçš„å‡½æ•°æ¥å£ï¼Œä½†æ˜¯åˆä¸æƒ³è®©åˆ«äººé€šè¿‡ä½¿ç”¨Derivativeçš„å¯¹è±¡æ¥ä½¿ç”¨Baseçš„å‡½æ•°æ¥å£ã€‚è¿™æ—¶å¯ä»¥ç”¨privateç»§æ‰¿ã€‚æˆ–è€…Baseå’ŒDerivativeæ ¹æœ¬æ²¡æœ‰ä»»ä½•é€»è¾‘ä¸Šçš„è”ç³»ï¼Œå•çº¯çš„Dæƒ³è¦å¤ç”¨ä¸€ä¸‹Bçš„ä»£ç ï¼Œè¿™æ—¶å°±ç”¨private ç»§æ‰¿ã€‚\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://fffzlfk.github.io/posts/c++%E4%B8%AD%E5%AE%B9%E6%98%93%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/","summary":"ä¸æ­£ç¡®åœ°ä½¿ç”¨newå’Œdelete æ— è®ºæˆ‘ä»¬å¦‚ä½•åŠªåŠ›ï¼Œè¦é‡Šæ”¾æ‰€æœ‰åŠ¨æ€åˆ†é…çš„å†…å­˜æ˜¯éå¸¸å›°éš¾çš„ã€‚å³ä½¿æˆ‘ä»¬èƒ½åšåˆ°è¿™ä¸€ç‚¹ï¼Œä¹Ÿå¾€å¾€ä¸èƒ½å®‰å…¨åœ°é¿å…å‡ºç°å¼‚å¸¸ã€‚è®©æˆ‘ä»¬çœ‹ä¸€ä¸ªç®€å•çš„ä¾‹å­ã€‚\nvoid SomeMethod() { ClassA *a = new ClassA; SomeOtherMethod(); // it can throws an execption delete a; } å¦‚æœSomeOtherMethodæŠ›å‡ºäº†å¼‚å¸¸ï¼Œé‚£ä¹ˆaå¯¹è±¡æ°¸è¿œä¸ä¼šè¢«åˆ é™¤ã€‚ä¸‹é¢çš„ä¾‹å­å±•ç¤ºäº†ä¸€ä¸ªæ›´åŠ å®‰å…¨åŒæ—¶åˆæ›´ç®€æ´çš„å®ç°ï¼Œä½¿ç”¨äº†åœ¨C++11æå‡ºçš„std::unique_ptrã€‚\nvoid SomeMethod() { std::unique_ptr\u0026lt;ClassA\u0026gt; a(new ClassA); SomeOtherMethod(); } æ— è®ºå‘ç”Ÿä»€ä¹ˆï¼Œå½“aé€€å‡ºä½œç”¨åŸŸçš„æ—¶å€™ï¼Œå®ƒä¼šè¢«é‡Šæ”¾ã€‚\nç„¶è€Œï¼Œè¿™ä»…ä»…æ˜¯C++ä¸­è¿™ç§é”™è¯¯æœ€ç®€å•çš„ä¾‹å­ï¼Œè¿˜æœ‰å¾ˆå¤šä¾‹å­è¡¨æ˜deleteåº”è¯¥åœ¨å…¶ä»–åœ°æ–¹è°ƒç”¨ï¼Œä¹Ÿè®¸æ˜¯åœ¨å¤–å±‚å‡½æ•°æˆ–è€…å¦ä¸€ä¸ªçº¿ç¨‹ä¸­ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆåº”è¯¥é¿å…ä½¿ç”¨newå’Œdeleteï¼Œè€Œåº”è¯¥ä½¿ç”¨é€‚å½“çš„æ™ºèƒ½æŒ‡é’ˆã€‚\nè¢«å¿˜è®°çš„è™šææ„å‡½æ•° è¿™æ˜¯æœ€å¸¸è§çš„é”™è¯¯ä¹‹ä¸€ï¼Œå¦‚æœæ´¾ç”Ÿç±»ä¸­æœ‰åŠ¨æ€å†…å­˜åˆ†é…ï¼Œå°†ä¼šå¯¼è‡´æ´¾ç”Ÿç±»çš„å†…å­˜æ³„æ¼ã€‚è¿™é‡Œæœ‰ä¸€äº›ä¾‹å­ï¼Œå½“ä¸€ä¸ªç±»ä¸æ‰“ç®—ç”¨äºç»§æ‰¿ï¼Œå¹¶ä¸”å®ƒçš„å¤§å°å’Œæ€§èƒ½æ˜¯è‡³å…³é‡è¦çš„ã€‚è™šææ„å‡½æ•°æˆ–ä»»ä½•å…¶ä»–è™šå‡½æ•°åœ¨ç±»åœ¨ç±»ä¸­å¼•å…¥äº†é¢å¤–çš„æ•°æ®ï¼Œå³æŒ‡å‘è™šå‡½æ•°è¡¨çš„æŒ‡é’ˆï¼Œè¿™ä½¿å¾—ç±»çš„ä»»ä½•å®ä¾‹çš„å¤§å°å˜å¤§ã€‚\nç„¶è€Œï¼Œåœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œç±»å¯ä»¥è¢«ç»§æ‰¿ï¼Œå³ä½¿å®ƒçš„åˆè¡·å¹¶éå¦‚æ­¤ã€‚å› æ­¤ï¼Œåœ¨å£°æ˜ä¸€ä¸ªç±»çš„æ—¶å€™ï¼Œæ·»åŠ ä¸€ä¸ªè™šææ„å‡½æ•°æ˜¯ä¸€ä¸ªéå¸¸å¥½çš„åšæ³•ã€‚å¦åˆ™ï¼Œå¦‚æœä¸€ä¸ªç±»ç”±äºæ€§èƒ½çš„åŸå› å¿…é¡»ä¸åŒ…å«è™šå‡½æ•°ï¼Œé‚£ä¹ˆåœ¨ç±»çš„å£°æ˜æ–‡ä»¶é‡Œé¢åŠ ä¸Šä¸€ä¸ªæ³¨é‡Šï¼Œè¯´æ˜è¿™ä¸ªç±»ä¸åº”è¯¥è¢«ç»§æ‰¿ï¼Œæ˜¯ä¸€ä¸ªå¾ˆå¥½çš„åšæ³•ã€‚é¿å…è¿™ä¸ªé—®é¢˜çš„æœ€ä½³é€‰æ‹©ä¹‹ä¸€æ˜¯ä½¿ç”¨ä¸€ä¸ªæ”¯æŒåœ¨åˆ›å»ºç±»æ—¶åˆ›å»ºè™šææ„å‡½æ•°çš„IDEã€‚\nå…³äºè¿™ä¸ªé—®é¢˜ï¼Œè¿˜æœ‰ä¸€ç‚¹æ˜¯æ¥è‡ªæ ‡å‡†åº“çš„ç±»æˆ–æ¨¡æ¿ã€‚å®ƒä»¬ä¸æ˜¯ç”¨æ¥ç»§æ‰¿çš„ï¼Œä¹Ÿæ²¡æœ‰ä¸€ä¸ªè™šææ„å‡½æ•°ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªå…¬å¼€ç»§æ‰¿è‡ªstd::stringçš„æ–°çš„å¢å¼ºå­—ç¬¦ä¸²ç±»ï¼Œå°±å¯èƒ½æœ‰äººé”™è¯¯åœ°ä½¿ç”¨å®ƒä¸std::stringçš„æŒ‡é’ˆæˆ–å¼•ç”¨ï¼Œä»è€Œå¯¼è‡´å†…å­˜æ³„æ¼ã€‚\nclass MyString : public std::string { ~MyString() {} }; int main() { std::string *s = new MyString(); delete s; // May not invoke the destructor defined in MyString } ä¸ºäº†é¿å…è¿™æ ·çš„é—®é¢˜ï¼Œé‡ç”¨æ ‡å‡†åº“ä¸­çš„ç±»æˆ–æ¨¡æ¿çš„ä¸€ä¸ªæ›´å®‰å…¨çš„æ–¹æ³•æ˜¯ä½¿ç”¨ç§æœ‰ç»§æ‰¿1æˆ–ç»„åˆã€‚\nç”¨deleteæˆ–æ™ºèƒ½æŒ‡é’ˆåˆ é™¤ä¸€ä¸ªæ•°ç»„ åˆ›å»ºåŠ¨æ€å¤§å°çš„ä¸´æ—¶æ•°ç»„å¾€å¾€æ˜¯å¿…è¦çš„ã€‚å½“å®ƒä»¬ä¸å†éœ€è¦æ—¶ï¼Œé‡Šæ”¾åˆ†é…çš„å†…å­˜æ˜¯å¾ˆé‡è¦çš„ã€‚è¿™é‡Œçš„é—®é¢˜æ˜¯ï¼ŒC++éœ€è¦å¸¦æœ‰[]æ‹¬å·çš„ç‰¹æ®Šåˆ é™¤æ“ä½œç¬¦ï¼Œè¿™ä¸€ç‚¹å¾ˆå®¹æ˜“è¢«é—å¿˜ã€‚delete[]æ“ä½œç¬¦ä¸ä»…ä¼šåˆ é™¤åˆ†é…ç»™æ•°ç»„çš„å†…å­˜ï¼Œè€Œä¸”ä¼šé¦–å…ˆè°ƒç”¨æ•°ç»„ä¸­æ‰€æœ‰å¯¹è±¡çš„ææ„å‡½æ•°ã€‚å¯¹åŸå§‹ç±»å‹ä½¿ç”¨ä¸å¸¦[]æ‹¬å·çš„åˆ é™¤æ“ä½œç¬¦ä¹Ÿæ˜¯ä¸æ­£ç¡®çš„ï¼Œå°½ç®¡è¿™äº›ç±»å‹æ²¡æœ‰ææ„å‡½æ•°ï¼Œæ¯ä¸ªç¼–è¯‘å™¨éƒ½ä¸èƒ½ä¿è¯ä¸€ä¸ªæ•°ç»„çš„æŒ‡é’ˆä¼šæŒ‡å‘æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œæ‰€ä»¥ä½¿ç”¨ä¸å¸¦[]æ‹¬å·çš„deleteä¹Ÿä¼šå¯¼è‡´æœªå®šä¹‰çš„è¡Œä¸ºã€‚\nåœ¨æ•°ç»„ä¸­ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆï¼Œå¦‚unique_ptr\u0026lt;T\u0026gt;, shared_ptrï¼Œä¹Ÿæ˜¯ä¸æ­£ç¡®çš„ã€‚å½“è¿™æ ·çš„æ™ºèƒ½æŒ‡é’ˆä»ä½œç”¨åŸŸä¸­é€€å‡ºæ—¶ï¼Œå®ƒå°†è°ƒç”¨ä¸å¸¦[]æ‹¬å·çš„åˆ é™¤æ“ä½œç¬¦ï¼Œè¿™å°†å¯¼è‡´ä¸Šé¢æè¿°çš„åŒæ ·é—®é¢˜ã€‚å¦‚æœéœ€è¦å¯¹æ•°ç»„ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆï¼Œå¯ä»¥ä½¿ç”¨unique_ptr\u0026lt;T[]\u0026gt;çš„ç‰¹æ®ŠåŒ–ã€‚\nå¦‚æœä¸éœ€è¦å¼•ç”¨è®¡æ•°çš„åŠŸèƒ½ï¼Œä¸»è¦æ˜¯æ•°ç»„çš„æƒ…å†µï¼Œæœ€ä¼˜é›…çš„æ–¹æ³•æ˜¯ä½¿ç”¨STLå‘é‡æ¥ä»£æ›¿ã€‚å®ƒä»¬ä¸åªæ˜¯è´Ÿè´£é‡Šæ”¾å†…å­˜ï¼Œè€Œä¸”è¿˜æä¾›é¢å¤–çš„åŠŸèƒ½ã€‚","title":"C++ä¸­å®¹æ˜“çŠ¯çš„é”™è¯¯"},{"content":"ä¸ºä»€ä¹ˆè¦æœ‰å®Œç¾è½¬å‘ ä¸‹é¢æ˜¯ä¸€ä¸ªç±»å·¥å‚å‡½æ•°ï¼š\ntemplate \u0026lt;typename T, typename Arg\u0026gt; std::shared_ptr\u0026lt;T\u0026gt; factory(Arg arg) { return std::shared_ptr\u0026lt;T\u0026gt;( new T(arg)); } å‚æ•°å¯¹è±¡argåœ¨ä¸Šé¢çš„ä¾‹å­ä¸­æ˜¯ä¼ å€¼æ–¹å¼ä¼ é€’ï¼Œè¿™å¸¦æ¥äº†ç”Ÿæˆé¢å¤–ä¸´æ—¶å¯¹è±¡1çš„ä»£ä»·ï¼Œæ‰€ä»¥æˆ‘ä»¬æ”¹æˆå¼•ç”¨ä¼ é€’ï¼š\ntemplate \u0026lt;typename T, typename Arg\u0026gt; std::shared_ptr\u0026lt;T\u0026gt; factory(Arg \u0026amp;arg) { return std::shared_ptr\u0026lt;T\u0026gt;( new T(arg)); } ä½†è¿™ç§å®ç°çš„é—®é¢˜æ˜¯ä¸èƒ½ç»‘å®šå³å€¼å®å‚ã€‚å¦‚factory\u0026lt;X\u0026gt;(42)å°†ç¼–è¯‘æŠ¥é”™ï¼Œè¿›ä¸€æ­¥çš„ï¼Œæˆ‘ä»¬æŒ‰å¸¸é‡å¼•ç”¨æ¥ä¼ é€’ï¼š\ntemplate \u0026lt;typename T, typename Arg\u0026gt; std::shared_ptr\u0026lt;T\u0026gt; factory(const Arg \u0026amp;arg) { return std::shared_ptr\u0026lt;T\u0026gt;( new T(arg)); } è¿™ç§å®ç°çš„é—®é¢˜æ˜¯ä¸èƒ½æ”¯æŒç§»åŠ¨è¯­ä¹‰ï¼Œå½¢å‚ä½¿ç”¨å³å€¼å¼•ç”¨å¯ä»¥è§£å†³å®Œç¾è½¬å‘é—®é¢˜ã€‚\nå¼•ç”¨æŠ˜å  åœ¨C++11ä¹‹å‰ï¼Œæˆ‘ä»¬ä¸èƒ½å¯¹ä¸€ä¸ªå¼•ç”¨ç±»å‹ç»§ç»­å¼•ç”¨ï¼Œä½†C++ç”±äºå³å€¼å¼•ç”¨çš„å‡ºç°è€Œæ”¾å®½2äº†è¿™ä¸€åšæ³•ï¼Œä»è€Œäº§ç”Ÿäº†å¼•ç”¨æŠ˜å è§„åˆ™ï¼Œå…è®¸æˆ‘ä»¬å¯¹å¼•ç”¨è¿›è¡Œå¼•ç”¨ï¼Œæ—¢èƒ½å·¦å¼•ç”¨ï¼Œåˆèƒ½å³å¼•ç”¨ã€‚ä½†æ˜¯å´éµå¾ªå¦‚ä¸‹è§„åˆ™ï¼š\nå‡½æ•°å½¢å‚ç±»å‹ å®å‚ç±»å‹ æ¨å¯¼åå‡½æ•°å½¢å‚ç±»å‹ T\u0026amp; å·¦å¼•ç”¨ T\u0026amp; T\u0026amp; å³å¼•ç”¨ T\u0026amp; T\u0026amp;\u0026amp; å·¦å¼•ç”¨ T\u0026amp; T\u0026amp;\u0026amp; å³å¼•ç”¨ T\u0026amp;\u0026amp; æ¨¡æ¿å‚æ•°ç±»å‹æ¨å¯¼ å¯¹å‡½æ•°æ¨¡æ¿template\u0026lt;typename T\u0026gt;void foo(T\u0026amp;\u0026amp;);ï¼Œåº”ç”¨ä¸Šè¿°å¼•ç”¨æŠ˜å è§„åˆ™ï¼Œå¯æ€»ç»“å‡ºä»¥ä¸‹ç»“è®ºï¼š\nå¦‚æœå®å‚æ˜¯ç±»å‹Açš„å·¦å€¼ï¼Œåˆ™æ¨¡æ¿å‚æ•°Tçš„ç±»å‹ä¸ºA\u0026amp;ï¼Œå½¢å‚ç±»å‹ä¸ºA\u0026amp;ï¼› å¦‚æœå®å‚æ˜¯ç±»å‹Açš„å³å€¼ï¼Œåˆ™æ¨¡æ¿å‚æ•°Tçš„ç±»å‹ä¸ºA\u0026amp;\u0026amp;ï¼Œå½¢å‚ç±»å‹ä¸ºA\u0026amp;\u0026amp;ã€‚ è¿™åŒæ ·é€‚ç”¨äºç±»æ¨¡æ¿çš„æˆå‘˜å‡½æ•°æ¨¡æ¿çš„ç±»å‹æ¨å¯¼ï¼š\ntemplate \u0026lt;class T\u0026gt; class vector { public: // Tæ˜¯ç±»æ¨¡æ¿å‚æ•° â‡’ è¯¥æˆå‘˜å‡½æ•°ä¸éœ€è¦ç±»å‹æ¨å¯¼;è¿™é‡Œçš„å‡½æ•°å‚æ•°ç±»å‹å°±æ˜¯Tçš„å³å€¼å¼•ç”¨ void push_back(T \u0026amp;\u0026amp;x); // è¯¥æˆå‘˜å‡½æ•°æ˜¯ä¸ªå‡½æ•°æ¨¡æ¿ï¼Œæœ‰è‡ªå·±çš„æ¨¡æ¿å‚æ•°ï¼Œéœ€è¦ç±»å‹æ¨å¯¼ template \u0026lt;typename Args\u0026gt; void emplace_back(Args \u0026amp;\u0026amp;args); } å‡½æ•°æ¨¡æ¿çš„å½¢å‚å¿…é¡»æ˜¯T\u0026amp;\u0026amp;å½¢å¼ï¼Œæ‰éœ€è¦æ¨¡æ¿å‚æ•°ç±»å‹æ¨å¯¼ã€‚å³ä½¿å½¢å‚å£°æ˜ä¸ºconst T\u0026amp;\u0026amp;å½¢å¼ï¼Œå°±åªèƒ½æŒ‰å­—é¢æ„ä¹‰ä½¿ç”¨ï¼Œä¸éœ€è¦æ¨¡æ¿å‚æ•°ç±»å‹æ¨å¯¼ã€‚\nå®Œç¾è½¬å‘ ä¸‹é¢æ˜¯ä¸Šè¿°ä»£ç å®Œç¾è½¬å‘ç‰ˆæœ¬çš„å®ç°ï¼š\ntemplate \u0026lt;typename T, typename Arg\u0026gt; shared_ptr\u0026lt;T\u0026gt; factory(Args\u0026amp;\u0026amp; arg) { return std::shared_ptr\u0026lt;T\u0026gt;( new T(std::forward\u0026lt;Arg\u0026gt;(arg)) ); } å…¶ä¸­std::forwardæ˜¯å®šä¹‰åœ¨æ ‡å‡†åº“\u0026lt;utility\u0026gt;ä¸­çš„æ¨¡æ¿å‡½æ•°ï¼š\ntemplate\u0026lt; class T \u0026gt; T\u0026amp;\u0026amp; forward( typename std::remove_reference\u0026lt;T\u0026gt;::type\u0026amp; t ) { return static_cast\u0026lt;T\u0026amp;\u0026amp;\u0026gt;(t); } template\u0026lt; class T \u0026gt; T\u0026amp;\u0026amp; forward( typename std::remove_reference\u0026lt;T\u0026gt;::type\u0026amp;\u0026amp; t ) { return static_cast\u0026lt;T\u0026amp;\u0026amp;\u0026gt;(t); } std::remove_referenceæ˜¯ä¸ªç±»æ¨¡æ¿ï¼Œå®šä¹‰åœ¨æ ‡å‡†åº“\u0026lt;type_traits\u0026gt;ä¸­ï¼Œç”¨äºç§»é™¤ç±»å‹çš„å¼•ç”¨å…¶ä¸­å®šä¹‰çš„ç±»å‹typeæ˜¯å¼•ç”¨çš„åŸºç±»å‹ã€‚\ntemplate\u0026lt; class T \u0026gt; struct remove_reference {typedef T type;}; template\u0026lt; class T \u0026gt; struct remove_reference\u0026lt;T\u0026amp;\u0026gt; {typedef T type;}; template\u0026lt; class T \u0026gt; struct remove_reference\u0026lt;T\u0026amp;\u0026amp;\u0026gt; {typedef T type;}; å®å‚çš„æ•°æ®ç±»å‹æ˜¯å·¦å€¼å¼•ç”¨ç±»å‹S\u0026amp;æ—¶(T = S\u0026amp;)ï¼Œtçš„ç±»å‹ä¸ºS\u0026amp;ï¼Œstatic_cast\u0026lt;S\u0026amp; \u0026amp;\u0026amp;\u0026gt;(t)æŠ˜å ä¸ºstatic_cast\u0026lt;S\u0026amp;\u0026gt;(t) å®å‚çš„æ•°æ®ç±»å‹æ˜¯å³å€¼å¼•ç”¨ç±»å‹S\u0026amp;\u0026amp;æ—¶(T = S\u0026amp;\u0026amp;)ï¼Œtçš„ç±»å‹ä¸ºS\u0026amp;\u0026amp;ï¼Œstatic_cast\u0026lt;S\u0026amp;\u0026amp; \u0026amp;\u0026amp;\u0026gt;(t)æŠ˜å ä¸ºstatic_cast\u0026lt;S\u0026amp;\u0026amp;\u0026gt;(t) References https://zh.wikipedia.org/zh-cn/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8\nä¸´æ—¶å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸåªæœ‰ä¸€æ¡è¯­å¥çš„æ—¶é—´ã€‚\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nè¿™é‡Œä½¿ç”¨æ”¾å®½ä¸€è¯æ˜¯å› ä¸ºï¼šåªæœ‰åœ¨ç±»å‹åˆ«åå’Œæ¨¡æ¿å‚æ•°æ—¶å¯ä»¥é—´æ¥å®šä¹‰å¼•ç”¨çš„å¼•ç”¨ã€‚\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://fffzlfk.github.io/posts/c++_%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/","summary":"ä¸ºä»€ä¹ˆè¦æœ‰å®Œç¾è½¬å‘ ä¸‹é¢æ˜¯ä¸€ä¸ªç±»å·¥å‚å‡½æ•°ï¼š\ntemplate \u0026lt;typename T, typename Arg\u0026gt; std::shared_ptr\u0026lt;T\u0026gt; factory(Arg arg) { return std::shared_ptr\u0026lt;T\u0026gt;( new T(arg)); } å‚æ•°å¯¹è±¡argåœ¨ä¸Šé¢çš„ä¾‹å­ä¸­æ˜¯ä¼ å€¼æ–¹å¼ä¼ é€’ï¼Œè¿™å¸¦æ¥äº†ç”Ÿæˆé¢å¤–ä¸´æ—¶å¯¹è±¡1çš„ä»£ä»·ï¼Œæ‰€ä»¥æˆ‘ä»¬æ”¹æˆå¼•ç”¨ä¼ é€’ï¼š\ntemplate \u0026lt;typename T, typename Arg\u0026gt; std::shared_ptr\u0026lt;T\u0026gt; factory(Arg \u0026amp;arg) { return std::shared_ptr\u0026lt;T\u0026gt;( new T(arg)); } ä½†è¿™ç§å®ç°çš„é—®é¢˜æ˜¯ä¸èƒ½ç»‘å®šå³å€¼å®å‚ã€‚å¦‚factory\u0026lt;X\u0026gt;(42)å°†ç¼–è¯‘æŠ¥é”™ï¼Œè¿›ä¸€æ­¥çš„ï¼Œæˆ‘ä»¬æŒ‰å¸¸é‡å¼•ç”¨æ¥ä¼ é€’ï¼š\ntemplate \u0026lt;typename T, typename Arg\u0026gt; std::shared_ptr\u0026lt;T\u0026gt; factory(const Arg \u0026amp;arg) { return std::shared_ptr\u0026lt;T\u0026gt;( new T(arg)); } è¿™ç§å®ç°çš„é—®é¢˜æ˜¯ä¸èƒ½æ”¯æŒç§»åŠ¨è¯­ä¹‰ï¼Œå½¢å‚ä½¿ç”¨å³å€¼å¼•ç”¨å¯ä»¥è§£å†³å®Œç¾è½¬å‘é—®é¢˜ã€‚\nå¼•ç”¨æŠ˜å  åœ¨C++11ä¹‹å‰ï¼Œæˆ‘ä»¬ä¸èƒ½å¯¹ä¸€ä¸ªå¼•ç”¨ç±»å‹ç»§ç»­å¼•ç”¨ï¼Œä½†C++ç”±äºå³å€¼å¼•ç”¨çš„å‡ºç°è€Œæ”¾å®½2äº†è¿™ä¸€åšæ³•ï¼Œä»è€Œäº§ç”Ÿäº†å¼•ç”¨æŠ˜å è§„åˆ™ï¼Œå…è®¸æˆ‘ä»¬å¯¹å¼•ç”¨è¿›è¡Œå¼•ç”¨ï¼Œæ—¢èƒ½å·¦å¼•ç”¨ï¼Œåˆèƒ½å³å¼•ç”¨ã€‚ä½†æ˜¯å´éµå¾ªå¦‚ä¸‹è§„åˆ™ï¼š\nå‡½æ•°å½¢å‚ç±»å‹ å®å‚ç±»å‹ æ¨å¯¼åå‡½æ•°å½¢å‚ç±»å‹ T\u0026amp; å·¦å¼•ç”¨ T\u0026amp; T\u0026amp; å³å¼•ç”¨ T\u0026amp; T\u0026amp;\u0026amp; å·¦å¼•ç”¨ T\u0026amp; T\u0026amp;\u0026amp; å³å¼•ç”¨ T\u0026amp;\u0026amp; æ¨¡æ¿å‚æ•°ç±»å‹æ¨å¯¼ å¯¹å‡½æ•°æ¨¡æ¿template\u0026lt;typename T\u0026gt;void foo(T\u0026amp;\u0026amp;);ï¼Œåº”ç”¨ä¸Šè¿°å¼•ç”¨æŠ˜å è§„åˆ™ï¼Œå¯æ€»ç»“å‡ºä»¥ä¸‹ç»“è®ºï¼š\nå¦‚æœå®å‚æ˜¯ç±»å‹Açš„å·¦å€¼ï¼Œåˆ™æ¨¡æ¿å‚æ•°Tçš„ç±»å‹ä¸ºA\u0026amp;ï¼Œå½¢å‚ç±»å‹ä¸ºA\u0026amp;ï¼› å¦‚æœå®å‚æ˜¯ç±»å‹Açš„å³å€¼ï¼Œåˆ™æ¨¡æ¿å‚æ•°Tçš„ç±»å‹ä¸ºA\u0026amp;\u0026amp;ï¼Œå½¢å‚ç±»å‹ä¸ºA\u0026amp;\u0026amp;ã€‚ è¿™åŒæ ·é€‚ç”¨äºç±»æ¨¡æ¿çš„æˆå‘˜å‡½æ•°æ¨¡æ¿çš„ç±»å‹æ¨å¯¼ï¼š","title":"C++ å®Œç¾è½¬å‘"},{"content":"Kernels CUDA C++å¯¹C++è¿›è¡Œäº†æ‰©å±•ï¼Œå…è®¸ç¨‹åºå‘˜å®šä¹‰C++å‡½æ•°ï¼Œç§°ä¸ºå†…æ ¸ï¼Œå½“è¢«è°ƒç”¨æ—¶ï¼Œç”± $N$ ä¸ªä¸åŒçš„CUDAçº¿ç¨‹å¹¶è¡Œæ‰§è¡Œ $N$ æ¬¡ï¼Œè€Œä¸æ˜¯åƒæ™®é€šC++å‡½æ•°é‚£æ ·åªæ‰§è¡Œä¸€æ¬¡ã€‚\nkernelæ˜¯ä½¿ç”¨__global__å£°æ˜å®šä¹‰çš„ï¼Œå¯¹äºç‰¹å®šçš„å†…æ ¸è°ƒç”¨ï¼Œæ‰§è¡Œè¯¥å†…æ ¸çš„CUDAçº¿ç¨‹æ•°é‡æ˜¯ä½¿ç”¨\u0026lt;\u0026lt;\u0026lt;...\u0026gt;\u0026gt;\u0026gt;æ‰§è¡Œé…ç½®è¯­æ³•æŒ‡å®šçš„ï¼ˆC++è¯­è¨€æ‰©å±•ï¼‰ã€‚æ¯ä¸ªæ‰§è¡Œå†…æ ¸çš„çº¿ç¨‹éƒ½æœ‰ä¸€ä¸ªå”¯ä¸€çš„çº¿ç¨‹IDï¼Œå¯ä»¥åœ¨å†…æ ¸å†…é€šè¿‡å†…ç½®å˜é‡è®¿é—®ã€‚\nä½œä¸ºè¯´æ˜ï¼Œä¸‹é¢çš„ç¤ºä¾‹ä»£ç ï¼Œä½¿ç”¨å†…ç½®å˜é‡threadIdxï¼Œå°†ä¸¤ä¸ªå¤§å°ä¸º $N$ çš„å‘é‡ $A$ å’Œ $B$ ç›¸åŠ ï¼Œå¹¶å°†ç»“æœå­˜å…¥å‘é‡ $C$ ã€‚\n// Kernel definition __global__ void VecAdd(float* A, float* B, float* C) { int i = threadIdx.x; C[i] = A[i] + B[i]; } int main() { ... // Kernel invocation with N threads VecAdd\u0026lt;\u0026lt;\u0026lt;1, N\u0026gt;\u0026gt;\u0026gt;(A, B, C); ... } åœ¨è¿™é‡Œï¼Œæ‰§è¡ŒVecAdd()çš„ $N$ ä¸ªçº¿ç¨‹ä¸­çš„æ¯ä¸€ä¸ªéƒ½æ‰§è¡Œäº†ä¸€æ¬¡åŠ æ³•ã€‚\nçº¿ç¨‹ä½“ç³» ä¸ºæ–¹ä¾¿èµ·è§ï¼ŒthreadIdxæ˜¯ä¸€ä¸ª $3$ åˆ†é‡çš„å‘é‡ï¼Œå› æ­¤å¯ä»¥ç”¨ä¸€ç»´ã€äºŒç»´æˆ–ä¸‰ç»´çš„çº¿ç¨‹ç´¢å¼•æ¥è¯†åˆ«çº¿ç¨‹ï¼Œå½¢æˆä¸€ä¸ªä¸€ç»´ã€äºŒç»´æˆ–ä¸‰ç»´çš„çº¿ç¨‹å—ï¼Œç§°ä¸ºçº¿ç¨‹å—ã€‚è¿™æä¾›äº†ä¸€ç§è‡ªç„¶çš„æ–¹å¼æ¥è°ƒç”¨åŸŸä¸­çš„å…ƒç´ è¿›è¡Œè®¡ç®—ï¼Œå¦‚çŸ¢é‡ã€çŸ©é˜µæˆ–ä½“ç§¯ã€‚\nä¸€ä¸ªä¾‹å­ï¼Œä¸‹é¢çš„ä»£ç å°†ä¸¤ä¸ªå¤§å°ä¸º $N\\times N$ çš„çŸ©é˜µ $A$ å’Œ $B$ ç›¸åŠ ï¼Œå¹¶å°†ç»“æœå­˜å…¥çŸ©é˜µ $C$ ã€‚\n// Kernel definition __global__ void MatAdd(float A[N][N], float B[N][N], float C[N][N]) { int i = threadIdx.x; int j = threadIdx.y; C[i][j] = A[i][j] + B[i][j]; } int main() { ... // Kernel invocation with one block of N * N * 1 threads int numBlocks = 1; dim3 threadsPerBlock(N, N); MatAdd\u0026lt;\u0026lt;\u0026lt;numBlocks, threadsPerBlock\u0026gt;\u0026gt;\u0026gt;(A, B, C); ... } æ¯ä¸ªå—çš„çº¿ç¨‹æ•°é‡æ˜¯æœ‰é™åˆ¶çš„ï¼Œå› ä¸ºä¸€ä¸ªå—çš„æ‰€æœ‰çº¿ç¨‹éƒ½è¦é©»ç•™åœ¨åŒä¸€ä¸ªå¤„ç†å™¨æ ¸å¿ƒä¸Šï¼Œå¹¶ä¸”å¿…é¡»åˆ†äº«è¯¥æ ¸å¿ƒçš„æœ‰é™å†…å­˜èµ„æºã€‚åœ¨ç›®å‰çš„GPUä¸Šï¼Œä¸€ä¸ªçº¿ç¨‹å—æœ€å¤šå¯ä»¥åŒ…å« $1024$ ä¸ªçº¿ç¨‹ã€‚\nç„¶è€Œï¼Œä¸€ä¸ªå†…æ ¸å¯ä»¥ç”±å¤šä¸ªå½¢çŠ¶ç›¸åŒçš„çº¿ç¨‹å—æ‰§è¡Œï¼Œå› æ­¤çº¿ç¨‹çš„æ€»æ•°ç­‰äºæ¯ä¸ªå—çš„çº¿ç¨‹æ•°ä¹˜ä»¥å—çš„æ•°é‡ã€‚\nå—è¢«ç»„ç»‡æˆä¸€ä¸ªä¸€ç»´ã€äºŒç»´æˆ–ä¸‰ç»´çš„çº¿ç¨‹å—ç½‘æ ¼ï¼Œå¦‚å›¾æ‰€ç¤ºã€‚ç½‘æ ¼ä¸­çš„çº¿ç¨‹å—çš„æ•°é‡é€šå¸¸ç”±æ­£åœ¨å¤„ç†çš„æ•°æ®çš„å¤§å°å†³å®šï¼Œè¿™é€šå¸¸è¶…è¿‡äº†ç³»ç»Ÿä¸­çš„å¤„ç†å™¨æ•°é‡ã€‚\nåœ¨\u0026lt;\u0026lt;\u0026lt;...\u0026gt;\u0026gt;\u0026gt;ä¸­æŒ‡å®šçš„æ¯ä¸ªå—çš„çº¿ç¨‹æ•°å’Œæ¯ä¸ªç½‘æ ¼çš„å—æ•°å¯ä»¥æ˜¯intæˆ–dim3ç±»å‹ã€‚å¯ä»¥åƒä¸Šé¢çš„ä¾‹å­é‚£æ ·æŒ‡å®šäºŒç»´å—æˆ–ç½‘æ ¼ã€‚\nç½‘æ ¼ä¸­çš„æ¯ä¸ªå—å¯ä»¥é€šè¿‡ä¸€ä¸ªä¸€ç»´ã€äºŒç»´æˆ–ä¸‰ç»´çš„å”¯ä¸€ç´¢å¼•æ¥è¯†åˆ«ï¼Œåœ¨å†…æ ¸ä¸­å¯ä»¥é€šè¿‡å†…ç½®çš„blockIdxå˜é‡è®¿é—®ã€‚çº¿ç¨‹å—çš„å°ºå¯¸å¯ä»¥åœ¨å†…æ ¸ä¸­é€šè¿‡å†…ç½®çš„blockDimå˜é‡è®¿é—®ã€‚\næ‰©å±•ä¹‹å‰çš„MatAdd()ä¾‹å­ä»¥å¤„ç†å¤šä¸ªå—ï¼Œä»£ç å¦‚ä¸‹ï¼š\n// Kernel definition __global__ void MatAdd(float A[N][N], float B[N][N], float C[N][N]) { int i = blockIdx.x * blockDim.x + threadIdx.x; int j = blockIdx.y * blockDim.y + threadIdx.y; if (i \u0026lt; N \u0026amp;\u0026amp; j \u0026lt; N) C[i][j] = A[i][j] + B[i][j]; } int main() { ... // Kernel invocation dim3 threadsPerBlock(16, 16); dim3 numBlocks(N / threadsPerBlock.x, N / threadsPerBlock.y); MatAdd\u0026lt;\u0026lt;\u0026lt;numBlocks, threadsPerBlock\u0026gt;\u0026gt;\u0026gt;(A, B, C); ... } çº¿ç¨‹å—å¤§å°ä¸º $16 \\times 16$ ï¼ˆ $256$ ä¸ªçº¿ç¨‹ï¼‰ï¼Œå°½ç®¡åœ¨è¿™ç§æƒ…å†µä¸‹æ˜¯ä»»æ„çš„ï¼Œä½†å´æ˜¯ä¸€ç§å¸¸è§çš„é€‰æ‹©ã€‚ç½‘æ ¼æ˜¯ç”¨è¶³å¤Ÿçš„å—åˆ›å»ºçš„ï¼Œä»¥ä¾¿åƒä»¥å‰ä¸€æ ·æ¯ä¸ªçŸ©é˜µå…ƒç´ æœ‰ä¸€ä¸ªçº¿ç¨‹ã€‚ä¸ºç®€å•èµ·è§ï¼Œæœ¬ä¾‹å‡è®¾æ¯ä¸ªç»´åº¦çš„æ¯ä¸ªç½‘æ ¼çš„çº¿ç¨‹æ•°è¢«è¯¥ç»´åº¦çš„æ¯ä¸ªå—çš„çº¿ç¨‹æ•°å¹³å‡åˆ†å‰²ï¼Œå°½ç®¡ä¸ä¸€å®šæ˜¯è¿™æ ·çš„ã€‚\nçº¿ç¨‹å—è¢«è¦æ±‚ç‹¬ç«‹æ‰§è¡Œã€‚å¿…é¡»èƒ½å¤Ÿä»¥ä»»ä½•é¡ºåºã€å¹³è¡Œæˆ–ä¸²è”çš„æ–¹å¼æ‰§è¡Œå®ƒä»¬ã€‚å¦‚å›¾æ‰€ç¤ºï¼Œè¿™ç§ç‹¬ç«‹æ€§è¦æ±‚å…è®¸çº¿ç¨‹å—åœ¨ä»»ä½•æ•°é‡çš„å†…æ ¸ä¸Šä»¥ä»»ä½•é¡ºåºè¿›è¡Œè°ƒåº¦ï¼Œä½¿ç¨‹åºå‘˜èƒ½å¤Ÿç¼–å†™éšå†…æ ¸æ•°é‡æ‰©å±•çš„ä»£ç ã€‚\nä¸€ä¸ªå—å†…çš„çº¿ç¨‹å¯ä»¥é€šè¿‡ä¸€äº›å…±äº«å†…å­˜æ¥å…±äº«æ•°æ®ï¼Œå¹¶é€šè¿‡åŒæ­¥å®ƒä»¬çš„æ‰§è¡Œæ¥åè°ƒå†…å­˜è®¿é—®æ¥è¿›è¡Œåˆä½œã€‚æ›´ç¡®åˆ‡åœ°è¯´ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è°ƒç”¨__syncthreads()å‡½æ•°æ¥æŒ‡å®šå†…æ ¸ä¸­çš„åŒæ­¥ç‚¹ï¼›__syncthreads()ä½œä¸ºä¸€ä¸ªéšœç¢ï¼Œå—ä¸­çš„æ‰€æœ‰çº¿ç¨‹å¿…é¡»åœ¨è¿™ä¸ªéšœç¢å¤„ç­‰å¾…ï¼Œç„¶åæ‰å…è®¸ç»§ç»­è¿›è¡Œã€‚å…±äº«å†…å­˜ç»™å‡ºäº†ä¸€ä¸ªä½¿ç”¨å…±äº«å†…å­˜çš„ä¾‹å­ã€‚é™¤äº†__syncthreads()ä¹‹å¤–ï¼Œåˆä½œç»„APIè¿˜æä¾›äº†ä¸€å¥—ä¸°å¯Œçš„çº¿ç¨‹åŒæ­¥åŸè¯­ã€‚\nå…±äº«å†…å­˜åº”è¯¥æ˜¯é è¿‘æ¯ä¸ªå¤„ç†å™¨æ ¸å¿ƒçš„ä½å»¶è¿Ÿå†…å­˜ï¼ˆå¾ˆåƒL1é«˜é€Ÿç¼“å­˜ï¼‰ï¼Œå¹¶ä¸”__syncthreads()åº”è¯¥æ˜¯è½»é‡çº§çš„ã€‚\nå†…å­˜ä½“ç³» å¦‚å›¾æ‰€ç¤ºï¼ŒCUDAçº¿ç¨‹åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­å¯ä»¥ä»å¤šä¸ªå†…å­˜ç©ºé—´è®¿é—®æ•°æ®ã€‚æ¯ä¸ªçº¿ç¨‹éƒ½æœ‰ç§æœ‰çš„æœ¬åœ°å†…å­˜ã€‚æ¯ä¸ªçº¿ç¨‹å—éƒ½æœ‰å…±äº«å†…å­˜ï¼Œå¯¹è¯¥å—çš„æ‰€æœ‰çº¿ç¨‹éƒ½æ˜¯å¯è§çš„ï¼Œå¹¶ä¸”ä¸è¯¥å—å…·æœ‰ç›¸åŒçš„ç”Ÿå‘½å‘¨æœŸã€‚æ‰€æœ‰çº¿ç¨‹éƒ½å¯ä»¥è®¿é—®ç›¸åŒçš„å…¨å±€å†…å­˜ã€‚\nè¿˜æœ‰ä¸¤ä¸ªé¢å¤–çš„åªè¯»å†…å­˜ç©ºé—´å¯ä¾›æ‰€æœ‰çº¿ç¨‹è®¿é—®ï¼šå¸¸é‡å’Œçº¹ç†å†…å­˜ç©ºé—´ã€‚å…¨å±€ã€å¸¸é‡å’Œçº¹ç†å†…å­˜ç©ºé—´é’ˆå¯¹ä¸åŒçš„å†…å­˜ä½¿ç”¨æƒ…å†µè¿›è¡Œäº†ä¼˜åŒ–ï¼ˆè§è®¾å¤‡å†…å­˜è®¿é—®ï¼‰ã€‚çº¹ç†å†…å­˜è¿˜ä¸ºä¸€äº›ç‰¹å®šçš„æ•°æ®æ ¼å¼æä¾›äº†ä¸åŒçš„å¯»å€æ¨¡å¼ï¼Œä»¥åŠæ•°æ®è¿‡æ»¤ï¼ˆè§çº¹ç†å’Œè¡¨é¢å†…å­˜ï¼‰ã€‚\nå…¨å±€ã€å¸¸é‡å’Œçº¹ç†å†…å­˜ç©ºé—´åœ¨åŒä¸€ä¸ªåº”ç”¨ç¨‹åºå¯åŠ¨å†…æ ¸æ—¶æ˜¯æŒä¹…çš„ã€‚\nå¼‚æ„ç¼–ç¨‹ å¦‚å›¾æ‰€ç¤ºï¼ŒCUDAç¼–ç¨‹æ¨¡å‹å‡è®¾CUDAçº¿ç¨‹åœ¨ä¸€ä¸ªç‰©ç†ä¸Šç‹¬ç«‹çš„è®¾å¤‡ä¸Šæ‰§è¡Œï¼Œè¯¥è®¾å¤‡ä½œä¸ºè¿è¡ŒC++ç¨‹åºçš„ä¸»æœºçš„åå¤„ç†å™¨è¿è¡Œã€‚ä¾‹å¦‚ï¼Œå½“å†…æ ¸åœ¨GPUä¸Šæ‰§è¡Œï¼Œè€ŒC++ç¨‹åºçš„å…¶ä½™éƒ¨åˆ†åœ¨CPUä¸Šæ‰§è¡Œæ—¶ï¼Œå°±å±äºè¿™ç§æƒ…å†µã€‚\nCUDAç¼–ç¨‹æ¨¡å‹è¿˜å‡å®šä¸»æœºå’Œè®¾å¤‡éƒ½åœ¨DRAMä¸­ä¿æŒè‡ªå·±ç‹¬ç«‹çš„å†…å­˜ç©ºé—´ï¼Œåˆ†åˆ«ç§°ä¸ºä¸»æœºå†…å­˜å’Œè®¾å¤‡å†…å­˜ã€‚å› æ­¤ï¼Œç¨‹åºé€šè¿‡è°ƒç”¨CUDAè¿è¡Œæ—¶ï¼ˆåœ¨ç¼–ç¨‹æ¥å£ä¸­æè¿°ï¼‰æ¥ç®¡ç†å†…æ ¸å¯è§çš„å…¨å±€ã€å¸¸é‡å’Œçº¹ç†å†…å­˜ç©ºé—´ã€‚è¿™åŒ…æ‹¬è®¾å¤‡å†…å­˜çš„åˆ†é…å’Œæ’¤é”€ï¼Œä»¥åŠä¸»æœºå’Œè®¾å¤‡å†…å­˜ä¹‹é—´çš„æ•°æ®ä¼ è¾“ã€‚\nç»Ÿä¸€å†…å­˜æä¾›äº†ç®¡ç†çš„å†…å­˜æ¥è¿æ¥ä¸»æœºå’Œè®¾å¤‡å†…å­˜ç©ºé—´ã€‚ç®¡ç†çš„å†…å­˜å¯ä»¥ä»ç³»ç»Ÿä¸­çš„æ‰€æœ‰CPUå’ŒGPUè®¿é—®ï¼Œä½œä¸ºä¸€ä¸ªå…·æœ‰å…±åŒåœ°å€ç©ºé—´çš„å•ä¸€ã€è¿è´¯çš„å†…å­˜å›¾åƒã€‚è¿™ç§èƒ½åŠ›ä½¿è®¾å¤‡å†…å­˜çš„è¶…é¢è®¤è´­æˆä¸ºå¯èƒ½ï¼Œå¹¶ä¸”é€šè¿‡æ¶ˆé™¤åœ¨ä¸»æœºå’Œè®¾å¤‡ä¸Šæ˜¾å¼é•œåƒæ•°æ®çš„éœ€è¦ï¼Œå¤§å¤§ç®€åŒ–äº†ç§»æ¤åº”ç”¨ç¨‹åºçš„ä»»åŠ¡ã€‚å…³äºç»Ÿä¸€å†…å­˜çš„ä»‹ç»ï¼Œè¯·å‚è§ç»Ÿä¸€å†…å­˜ç¼–ç¨‹ã€‚\nå¼‚æ­¥çš„SIMTç¼–ç¨‹æ¨¡å‹ åœ¨CUDAç¼–ç¨‹æ¨¡å‹ä¸­ï¼Œçº¿ç¨‹æ˜¯è¿›è¡Œè®¡ç®—æˆ–å†…å­˜æ“ä½œçš„æœ€ä½çº§åˆ«çš„æŠ½è±¡æ¦‚å¿µã€‚ä»åŸºäºNVIDIA Ampere GPUæ¶æ„çš„è®¾å¤‡å¼€å§‹ï¼ŒCUDAç¼–ç¨‹æ¨¡å‹é€šè¿‡å¼‚æ­¥ç¼–ç¨‹æ¨¡å‹ä¸ºå†…å­˜æ“ä½œæä¾›åŠ é€Ÿã€‚å¼‚æ­¥ç¼–ç¨‹æ¨¡å‹å®šä¹‰äº†ä¸CUDAçº¿ç¨‹æœ‰å…³çš„å¼‚æ­¥æ“ä½œçš„è¡Œä¸ºã€‚\nå¼‚æ­¥ç¼–ç¨‹æ¨¡å‹å®šä¹‰äº†ç”¨äºCUDAçº¿ç¨‹ä¹‹é—´åŒæ­¥çš„å¼‚æ­¥éšœç¢çš„è¡Œä¸ºã€‚è¯¥æ¨¡å‹è¿˜è§£é‡Šå¹¶å®šä¹‰äº†cuda::memcpy_asyncå¦‚ä½•åœ¨GPUä¸­è®¡ç®—æ—¶ç”¨äºä»å…¨å±€å†…å­˜å¼‚æ­¥ç§»åŠ¨æ•°æ®ã€‚\nå¼‚æ­¥æ“ä½œ å¼‚æ­¥æ“ä½œè¢«å®šä¹‰ä¸ºç”±ä¸€ä¸ªCUDAçº¿ç¨‹å‘èµ·å¹¶ç”±å¦ä¸€ä¸ªçº¿ç¨‹å¼‚æ­¥æ‰§è¡Œçš„æ“ä½œã€‚åœ¨ä¸€ä¸ªå®Œå–„çš„ç¨‹åºä¸­ï¼Œä¸€ä¸ªæˆ–å¤šä¸ªCUDAçº¿ç¨‹ä¼šä¸å¼‚æ­¥æ“ä½œåŒæ­¥ã€‚å¯åŠ¨å¼‚æ­¥æ“ä½œçš„CUDAçº¿ç¨‹å¹¶ä¸éœ€è¦åœ¨åŒæ­¥çº¿ç¨‹ä¸­ã€‚\nè¿™æ ·çš„å¼‚æ­¥çº¿ç¨‹ï¼ˆas-ifçº¿ç¨‹ï¼‰æ€»æ˜¯ä¸å¯åŠ¨å¼‚æ­¥æ“ä½œçš„CUDAçº¿ç¨‹æœ‰å…³ã€‚ä¸€ä¸ªå¼‚æ­¥æ“ä½œä½¿ç”¨ä¸€ä¸ªåŒæ­¥å¯¹è±¡æ¥åŒæ­¥å®Œæˆæ“ä½œã€‚è¿™æ ·çš„åŒæ­¥å¯¹è±¡å¯ä»¥ç”±ç”¨æˆ·æ˜¾å¼ç®¡ç†ï¼ˆå¦‚cuda::memcpy_asyncï¼‰æˆ–åœ¨åº“å†…éšå¼ç®¡ç†ï¼ˆå¦‚cooperative_groups::memcpy_asyncï¼‰ã€‚\nä¸€ä¸ªåŒæ­¥å¯¹è±¡å¯ä»¥æ˜¯cuda::barrieræˆ–cuda::pipelineã€‚è¿™äº›å¯¹è±¡åœ¨Asynchronous Barrierå’ŒAsynchronous Data Copies using cuda::pipelineä¸­æœ‰è¯¦ç»†è§£é‡Šã€‚è¿™äº›åŒæ­¥å¯¹è±¡å¯ä»¥åœ¨ä¸åŒçš„çº¿ç¨‹èŒƒå›´å†…ä½¿ç”¨ã€‚ä¸€ä¸ªèŒƒå›´å®šä¹‰äº†å¯ä»¥ä½¿ç”¨åŒæ­¥å¯¹è±¡ä¸å¼‚æ­¥æ“ä½œåŒæ­¥çš„çº¿ç¨‹é›†åˆã€‚ä¸‹è¡¨å®šä¹‰äº†CUDA C++ä¸­å¯ç”¨çš„çº¿ç¨‹ä½œç”¨åŸŸä»¥åŠå¯ä»¥ä¸æ¯ä¸ªçº¿ç¨‹åŒæ­¥çš„çº¿ç¨‹ã€‚\nThread ä½œç”¨åŸŸ æè¿° cuda::thread_scope::thread_scope_thread åªæœ‰å‘èµ·å¼‚æ­¥æ“ä½œçš„CUDAçº¿ç¨‹æ‰ä¼šåŒæ­¥ cuda::thread_scope::thread_scope_block ä¸å¯åŠ¨çº¿ç¨‹åœ¨åŒä¸€çº¿ç¨‹å—å†…çš„æ‰€æœ‰æˆ–ä»»ä½•CUDAçº¿ç¨‹éƒ½ä¼šåŒæ­¥ cuda::thread_scope::thread_scope_device ä¸å¯åŠ¨çº¿ç¨‹ç›¸åŒçš„GPUè®¾å¤‡ä¸­çš„æ‰€æœ‰æˆ–ä»»ä½•CUDAçº¿ç¨‹è¿›è¡ŒåŒæ­¥ cuda::thread_scope::thread_scope_system ä¸å¯åŠ¨çº¿ç¨‹åœ¨åŒä¸€ç³»ç»Ÿä¸­çš„æ‰€æœ‰æˆ–ä»»ä½•CUDAæˆ–CPUçº¿ç¨‹è¿›è¡ŒåŒæ­¥ è¿™äº›çº¿ç¨‹ä½œç”¨åŸŸåœ¨CUDA Standard C++åº“ä¸­ä½œä¸ºæ ‡å‡†C++çš„æ‰©å±•æ¥å®ç°ã€‚\nReferences https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#programming-model\n","permalink":"https://fffzlfk.github.io/posts/cuda_%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/","summary":"Kernels CUDA C++å¯¹C++è¿›è¡Œäº†æ‰©å±•ï¼Œå…è®¸ç¨‹åºå‘˜å®šä¹‰C++å‡½æ•°ï¼Œç§°ä¸ºå†…æ ¸ï¼Œå½“è¢«è°ƒç”¨æ—¶ï¼Œç”± $N$ ä¸ªä¸åŒçš„CUDAçº¿ç¨‹å¹¶è¡Œæ‰§è¡Œ $N$ æ¬¡ï¼Œè€Œä¸æ˜¯åƒæ™®é€šC++å‡½æ•°é‚£æ ·åªæ‰§è¡Œä¸€æ¬¡ã€‚\nkernelæ˜¯ä½¿ç”¨__global__å£°æ˜å®šä¹‰çš„ï¼Œå¯¹äºç‰¹å®šçš„å†…æ ¸è°ƒç”¨ï¼Œæ‰§è¡Œè¯¥å†…æ ¸çš„CUDAçº¿ç¨‹æ•°é‡æ˜¯ä½¿ç”¨\u0026lt;\u0026lt;\u0026lt;...\u0026gt;\u0026gt;\u0026gt;æ‰§è¡Œé…ç½®è¯­æ³•æŒ‡å®šçš„ï¼ˆC++è¯­è¨€æ‰©å±•ï¼‰ã€‚æ¯ä¸ªæ‰§è¡Œå†…æ ¸çš„çº¿ç¨‹éƒ½æœ‰ä¸€ä¸ªå”¯ä¸€çš„çº¿ç¨‹IDï¼Œå¯ä»¥åœ¨å†…æ ¸å†…é€šè¿‡å†…ç½®å˜é‡è®¿é—®ã€‚\nä½œä¸ºè¯´æ˜ï¼Œä¸‹é¢çš„ç¤ºä¾‹ä»£ç ï¼Œä½¿ç”¨å†…ç½®å˜é‡threadIdxï¼Œå°†ä¸¤ä¸ªå¤§å°ä¸º $N$ çš„å‘é‡ $A$ å’Œ $B$ ç›¸åŠ ï¼Œå¹¶å°†ç»“æœå­˜å…¥å‘é‡ $C$ ã€‚\n// Kernel definition __global__ void VecAdd(float* A, float* B, float* C) { int i = threadIdx.x; C[i] = A[i] + B[i]; } int main() { ... // Kernel invocation with N threads VecAdd\u0026lt;\u0026lt;\u0026lt;1, N\u0026gt;\u0026gt;\u0026gt;(A, B, C); ... } åœ¨è¿™é‡Œï¼Œæ‰§è¡ŒVecAdd()çš„ $N$ ä¸ªçº¿ç¨‹ä¸­çš„æ¯ä¸€ä¸ªéƒ½æ‰§è¡Œäº†ä¸€æ¬¡åŠ æ³•ã€‚\nçº¿ç¨‹ä½“ç³» ä¸ºæ–¹ä¾¿èµ·è§ï¼ŒthreadIdxæ˜¯ä¸€ä¸ª $3$ åˆ†é‡çš„å‘é‡ï¼Œå› æ­¤å¯ä»¥ç”¨ä¸€ç»´ã€äºŒç»´æˆ–ä¸‰ç»´çš„çº¿ç¨‹ç´¢å¼•æ¥è¯†åˆ«çº¿ç¨‹ï¼Œå½¢æˆä¸€ä¸ªä¸€ç»´ã€äºŒç»´æˆ–ä¸‰ç»´çš„çº¿ç¨‹å—ï¼Œç§°ä¸ºçº¿ç¨‹å—ã€‚è¿™æä¾›äº†ä¸€ç§è‡ªç„¶çš„æ–¹å¼æ¥è°ƒç”¨åŸŸä¸­çš„å…ƒç´ è¿›è¡Œè®¡ç®—ï¼Œå¦‚çŸ¢é‡ã€çŸ©é˜µæˆ–ä½“ç§¯ã€‚\nä¸€ä¸ªä¾‹å­ï¼Œä¸‹é¢çš„ä»£ç å°†ä¸¤ä¸ªå¤§å°ä¸º $N\\times N$ çš„çŸ©é˜µ $A$ å’Œ $B$ ç›¸åŠ ï¼Œå¹¶å°†ç»“æœå­˜å…¥çŸ©é˜µ $C$ ã€‚","title":"Cuda ç¼–ç¨‹æ¨¡å‹"},{"content":"ä¸€ç»„å¸¦æœ‰ on-chip å…±äº«å†…å­˜çš„ SIMD å¤šå¤„ç†å™¨ è®¾å¤‡å¯ä»¥è¢«çœ‹ä½œä¸€ç»„å¤šå¤„ç†å™¨ï¼Œå¦‚å›¾æ‰€ç¤ºã€‚æ¯ä¸ªå¤šå¤„ç†å™¨ä½¿ç”¨å•æŒ‡ä»¤å¤šæ•°æ®(SIMD)æ¶æ„ï¼šåœ¨ä»»ä½•ç»™å®šçš„æ—¶é’Ÿå‘¨æœŸå†…ï¼Œå¤šå¤„ç†å™¨çš„æ¯ä¸ªå¤„ç†å™¨æ‰§è¡ŒåŒä¸€æŒ‡ä»¤ï¼Œä½†æ“ä½œä¸åŒçš„æ•°æ®ã€‚\næ¯ä¸ªå¤šå¤„ç†å™¨ä½¿ç”¨å››ä¸ªä»¥ä¸‹ç±»å‹çš„on-chipå†…å­˜ï¼š\næ¯ä¸ªå¤„ç†å™¨ä¸€ç»„ $32$ ä½å¯„å­˜å™¨ å¹¶è¡Œæ•°æ®ç¼“å­˜æˆ–å…±äº«å†…å­˜ï¼Œè¢«æ‰€æœ‰å¤„ç†å™¨å…±äº«å®ç°å†…å­˜ç©ºé—´å…±äº« é€šè¿‡è®¾å¤‡å†…å­˜çš„ä¸€ä¸ªåªè¯»åŒºåŸŸï¼Œä¸€ä¸ªåªè¯»å¸¸é‡ç¼“å­˜å™¨è¢«æ‰€æœ‰å¤„ç†å™¨å…±äº« é€šè¿‡è®¾å¤‡å†…å­˜çš„ä¸€ä¸ªåªè¯»åŒºåŸŸï¼Œä¸€ä¸ªåªè¯»çº¹ç†ç¼“å­˜å™¨è¢«æ‰€æœ‰å¤„ç†å™¨å…±äº« æœ¬åœ°å’Œå…¨å±€å†…å­˜ç©ºé—´ä½œä¸ºè®¾å¤‡å†…å­˜çš„è¯»å†™åŒºåŸŸï¼Œè€Œä¸è¢«ç¼“å†²ã€‚ æ¯ä¸ªå¤šå¤„ç†å™¨é€šè¿‡çº¹ç†å•å…ƒè®¿é—®çº¹ç†ç¼“å†²å™¨ï¼Œå®ƒæ‰§è¡Œå„ç§å„æ ·çš„å¯»å€æ¨¡å¼å’Œæ•°æ®è¿‡æ»¤ã€‚\næ‰§è¡Œæ¨¡å¼ ä¸€ä¸ªçº¿ç¨‹å—ç½‘æ ¼æ˜¯é€šè¿‡å¤šå¤„ç†å™¨è§„åˆ’æ‰§è¡Œçš„ã€‚æ¯ä¸ªå¤šå¤„ç†å™¨ä¸€ä¸ªæ¥ä¸€ä¸ªçš„å¤„ç†å—æ‰¹å¤„ç†ã€‚ä¸€ä¸ªå—åªè¢«ä¸€ä¸ªå¤šå¤„ç†å™¨å¤„ç†ï¼Œå› æ­¤å¯ä»¥å¯¹é©»ç•™åœ¨on-chipå…±äº«å†…å­˜çš„å…±äº«å†…å­˜ç©ºé—´å½¢æˆéå¸¸å¿«é€Ÿçš„è®¿é—®ã€‚\nä¸€ä¸ªæ‰¹å¤„ç†ä¸­æ¯ä¸ªå¤šå¤„ç†å™¨å¯ä»¥å¤„ç†å¤šå°‘ä¸ªå—ï¼Œå–å†³äºæ¯ä¸ªçº¿ç¨‹ä¸­åˆ†é…äº†å¤šå°‘ä¸ªå¯„å­˜å™¨å’Œå·²çŸ¥å†…æ ¸ä¸­æ¯ä¸ªæ—¶é’Ÿéœ€è¦å¤šå°‘çš„å…±äº«å†…å­˜ï¼Œå› ä¸ºå¤šå¤„ç†å™¨çš„å¯„å­˜å™¨å’Œå†…å­˜åœ¨æ‰€æœ‰çš„çº¿ç¨‹ä¸­æ˜¯åˆ†å¼€çš„ã€‚å¦‚æœåœ¨è‡³å°‘ä¸€ä¸ªå—ä¸­ï¼Œæ¯ä¸ªå¤šå¤„ç†å™¨æ²¡æœ‰è¶³å¤Ÿé«˜çš„å¯„å­˜å™¨æˆ–å…±äº«å†…å­˜ç”¨ï¼Œé‚£ä¹ˆå†…æ ¸å°†æ— æ³•å¯åŠ¨ã€‚\nçº¿ç¨‹å—åœ¨ä¸€ä¸ªæ‰¹å¤„ç†ä¸­è¢«ä¸€ä¸ªå¤šå¤„ç†å™¨æ‰§è¡Œï¼Œè¢«ç§°ä¸ºactiveï¼Œæ¯ä¸ªactiveå—è¢«åˆ’åˆ†æˆSIMDçº¿ç¨‹ç»„ï¼Œè¢«ç§°ä¸ºwarpsï¼›æ¯ä¸€æ¡è¿™æ ·çš„warpåŒ…å«æ•°é‡ç›¸åŒçš„çº¿ç¨‹ï¼Œå«åšwarpå¤§å°ï¼Œå¹¶ä¸”åœ¨SIMDçš„æ–¹å¼ä¸‹é€šè¿‡å¤šå¤„ç†å™¨æ‰§è¡Œï¼Œæ‰§è¡Œè°ƒåº¦ç¨‹åºå‘¨æœŸæ€§åœ°ä»ä¸€æ¡warpåˆ‡æ¢åˆ°å¦ä¸€æ¡warpï¼Œä»¥è¾¾åˆ°å¤šå¤„ç†å™¨è®¡ç®—èµ„æºä½¿ç”¨çš„æœ€å¤§åŒ–ã€‚\nå—è¢«åˆ’åˆ†æˆwarpçš„æ–¹å¼æ€»æ˜¯ç›¸åŒçš„ï¼›æ¯æ¡warpåŒ…å«è¿ç»­çš„çº¿ç¨‹ï¼Œçº¿ç¨‹ç´¢å¼•ä»ç¬¬ä¸€ä¸ªwarpåŒ…å«ç€çš„çº¿ç¨‹ 0 å¼€å§‹é€’å¢ã€‚\nä¸€ä¸ªå¤šå¤„ç†å™¨å¯ä»¥å¹¶å‘åœ°å¤„ç†å‡ ä¸ªå—ï¼Œé€šè¿‡åˆ’åˆ†åœ¨å®ƒä»¬ä¹‹ä¸­çš„å¯„å­˜å™¨å’Œå…±äº«å†…å­˜ã€‚æ›´å‡†ç¡®åœ°è¯´ï¼Œæ¯æ¡çº¿ç¨‹å¯ä½¿ç”¨çš„å¯„å­˜å™¨æ•°é‡ï¼Œç­‰äºæ¯ä¸ªå¤šå¤„ç†å™¨å¯„å­˜å™¨æ€»æ•°é™¤ä»¥å¹¶å‘çš„çº¿ç¨‹æ•°é‡ï¼Œå¹¶å‘çº¿ç¨‹çš„æ•°é‡ç­‰äºå¹¶å‘å—çš„æ•°é‡ä¹˜ä»¥æ¯å—çº¿ç¨‹çš„æ•°é‡ã€‚\nåœ¨ä¸€ä¸ªçº¿ç¨‹å—ç½‘æ ¼å†…çš„å—æ¬¡åºæ˜¯æœªå®šä¹‰çš„ï¼Œå¹¶ä¸”åœ¨å—ä¹‹é—´ä¸å­˜åœ¨åŒæ­¥æœºåˆ¶ï¼Œå› æ­¤æ¥è‡ªåŒä¸€ä¸ªç½‘æ ¼çš„ä¸¤ä¸ªä¸åŒå—çš„çº¿ç¨‹ä¸èƒ½é€šè¿‡å…¨å±€å†…å­˜å½¼æ­¤å®‰å…¨åœ°é€šè®¯ã€‚\nè®¡ç®—å…¼å®¹æ€§ è®¾å¤‡çš„å…¼å®¹æ€§ç”±ä¸¤ä¸ªå‚æ•°å®šä¹‰ï¼Œä¸»è¦ç‰ˆæœ¬å·å’Œæ¬¡è¦ç‰ˆæœ¬å·ã€‚è®¾å¤‡æ‹¥æœ‰çš„ä¸»è¦ç‰ˆæœ¬å·ä»£è¡¨ç›¸åŒçš„æ ¸å¿ƒæ¶æ„ã€‚\næ¬¡è¦ç‰ˆæœ¬å·ä»£è¡¨ä¸€äº›æ”¹è¿›çš„æ ¸å¿ƒæ¶æ„ã€‚æ¯”å¦‚æ–°çš„ç‰¹æ€§ã€‚\nå¤šè®¾å¤‡ ä¸ºä¸€ä¸ªåº”ç”¨ç¨‹åºä½¿ç”¨å¤šGPUä½œä¸ºCUDAè®¾å¤‡ï¼Œå¿…é¡»ä¿è¯è¿™äº›CPUæ˜¯ä¸€æ ·çš„ç±»å‹ã€‚å¦‚æœç³»ç»Ÿå·¥ä½œåœ¨SLI æ¨¡å¼ä¸‹ï¼Œé‚£ä¹ˆåªæœ‰ä¸€ä¸ªGPUå¯ä»¥ä½œä¸ºCUDAè®¾å¤‡ï¼Œç”±äºæ‰€æœ‰çš„GPUåœ¨é©±åŠ¨å †æ ˆä¸­è¢«åº•å±‚çš„èåˆäº†ã€‚SLI æ¨¡å¼éœ€è¦åœ¨æ§åˆ¶é¢æ¿ä¸­å…³é—­,è¿™æ ·æ‰èƒ½ä½¿å¤šä¸ªGPUä½œä¸ºCUDAè®¾å¤‡\n","permalink":"https://fffzlfk.github.io/posts/cuda_%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0/","summary":"ä¸€ç»„å¸¦æœ‰ on-chip å…±äº«å†…å­˜çš„ SIMD å¤šå¤„ç†å™¨ è®¾å¤‡å¯ä»¥è¢«çœ‹ä½œä¸€ç»„å¤šå¤„ç†å™¨ï¼Œå¦‚å›¾æ‰€ç¤ºã€‚æ¯ä¸ªå¤šå¤„ç†å™¨ä½¿ç”¨å•æŒ‡ä»¤å¤šæ•°æ®(SIMD)æ¶æ„ï¼šåœ¨ä»»ä½•ç»™å®šçš„æ—¶é’Ÿå‘¨æœŸå†…ï¼Œå¤šå¤„ç†å™¨çš„æ¯ä¸ªå¤„ç†å™¨æ‰§è¡ŒåŒä¸€æŒ‡ä»¤ï¼Œä½†æ“ä½œä¸åŒçš„æ•°æ®ã€‚\næ¯ä¸ªå¤šå¤„ç†å™¨ä½¿ç”¨å››ä¸ªä»¥ä¸‹ç±»å‹çš„on-chipå†…å­˜ï¼š\næ¯ä¸ªå¤„ç†å™¨ä¸€ç»„ $32$ ä½å¯„å­˜å™¨ å¹¶è¡Œæ•°æ®ç¼“å­˜æˆ–å…±äº«å†…å­˜ï¼Œè¢«æ‰€æœ‰å¤„ç†å™¨å…±äº«å®ç°å†…å­˜ç©ºé—´å…±äº« é€šè¿‡è®¾å¤‡å†…å­˜çš„ä¸€ä¸ªåªè¯»åŒºåŸŸï¼Œä¸€ä¸ªåªè¯»å¸¸é‡ç¼“å­˜å™¨è¢«æ‰€æœ‰å¤„ç†å™¨å…±äº« é€šè¿‡è®¾å¤‡å†…å­˜çš„ä¸€ä¸ªåªè¯»åŒºåŸŸï¼Œä¸€ä¸ªåªè¯»çº¹ç†ç¼“å­˜å™¨è¢«æ‰€æœ‰å¤„ç†å™¨å…±äº« æœ¬åœ°å’Œå…¨å±€å†…å­˜ç©ºé—´ä½œä¸ºè®¾å¤‡å†…å­˜çš„è¯»å†™åŒºåŸŸï¼Œè€Œä¸è¢«ç¼“å†²ã€‚ æ¯ä¸ªå¤šå¤„ç†å™¨é€šè¿‡çº¹ç†å•å…ƒè®¿é—®çº¹ç†ç¼“å†²å™¨ï¼Œå®ƒæ‰§è¡Œå„ç§å„æ ·çš„å¯»å€æ¨¡å¼å’Œæ•°æ®è¿‡æ»¤ã€‚\næ‰§è¡Œæ¨¡å¼ ä¸€ä¸ªçº¿ç¨‹å—ç½‘æ ¼æ˜¯é€šè¿‡å¤šå¤„ç†å™¨è§„åˆ’æ‰§è¡Œçš„ã€‚æ¯ä¸ªå¤šå¤„ç†å™¨ä¸€ä¸ªæ¥ä¸€ä¸ªçš„å¤„ç†å—æ‰¹å¤„ç†ã€‚ä¸€ä¸ªå—åªè¢«ä¸€ä¸ªå¤šå¤„ç†å™¨å¤„ç†ï¼Œå› æ­¤å¯ä»¥å¯¹é©»ç•™åœ¨on-chipå…±äº«å†…å­˜çš„å…±äº«å†…å­˜ç©ºé—´å½¢æˆéå¸¸å¿«é€Ÿçš„è®¿é—®ã€‚\nä¸€ä¸ªæ‰¹å¤„ç†ä¸­æ¯ä¸ªå¤šå¤„ç†å™¨å¯ä»¥å¤„ç†å¤šå°‘ä¸ªå—ï¼Œå–å†³äºæ¯ä¸ªçº¿ç¨‹ä¸­åˆ†é…äº†å¤šå°‘ä¸ªå¯„å­˜å™¨å’Œå·²çŸ¥å†…æ ¸ä¸­æ¯ä¸ªæ—¶é’Ÿéœ€è¦å¤šå°‘çš„å…±äº«å†…å­˜ï¼Œå› ä¸ºå¤šå¤„ç†å™¨çš„å¯„å­˜å™¨å’Œå†…å­˜åœ¨æ‰€æœ‰çš„çº¿ç¨‹ä¸­æ˜¯åˆ†å¼€çš„ã€‚å¦‚æœåœ¨è‡³å°‘ä¸€ä¸ªå—ä¸­ï¼Œæ¯ä¸ªå¤šå¤„ç†å™¨æ²¡æœ‰è¶³å¤Ÿé«˜çš„å¯„å­˜å™¨æˆ–å…±äº«å†…å­˜ç”¨ï¼Œé‚£ä¹ˆå†…æ ¸å°†æ— æ³•å¯åŠ¨ã€‚\nçº¿ç¨‹å—åœ¨ä¸€ä¸ªæ‰¹å¤„ç†ä¸­è¢«ä¸€ä¸ªå¤šå¤„ç†å™¨æ‰§è¡Œï¼Œè¢«ç§°ä¸ºactiveï¼Œæ¯ä¸ªactiveå—è¢«åˆ’åˆ†æˆSIMDçº¿ç¨‹ç»„ï¼Œè¢«ç§°ä¸ºwarpsï¼›æ¯ä¸€æ¡è¿™æ ·çš„warpåŒ…å«æ•°é‡ç›¸åŒçš„çº¿ç¨‹ï¼Œå«åšwarpå¤§å°ï¼Œå¹¶ä¸”åœ¨SIMDçš„æ–¹å¼ä¸‹é€šè¿‡å¤šå¤„ç†å™¨æ‰§è¡Œï¼Œæ‰§è¡Œè°ƒåº¦ç¨‹åºå‘¨æœŸæ€§åœ°ä»ä¸€æ¡warpåˆ‡æ¢åˆ°å¦ä¸€æ¡warpï¼Œä»¥è¾¾åˆ°å¤šå¤„ç†å™¨è®¡ç®—èµ„æºä½¿ç”¨çš„æœ€å¤§åŒ–ã€‚\nå—è¢«åˆ’åˆ†æˆwarpçš„æ–¹å¼æ€»æ˜¯ç›¸åŒçš„ï¼›æ¯æ¡warpåŒ…å«è¿ç»­çš„çº¿ç¨‹ï¼Œçº¿ç¨‹ç´¢å¼•ä»ç¬¬ä¸€ä¸ªwarpåŒ…å«ç€çš„çº¿ç¨‹ 0 å¼€å§‹é€’å¢ã€‚\nä¸€ä¸ªå¤šå¤„ç†å™¨å¯ä»¥å¹¶å‘åœ°å¤„ç†å‡ ä¸ªå—ï¼Œé€šè¿‡åˆ’åˆ†åœ¨å®ƒä»¬ä¹‹ä¸­çš„å¯„å­˜å™¨å’Œå…±äº«å†…å­˜ã€‚æ›´å‡†ç¡®åœ°è¯´ï¼Œæ¯æ¡çº¿ç¨‹å¯ä½¿ç”¨çš„å¯„å­˜å™¨æ•°é‡ï¼Œç­‰äºæ¯ä¸ªå¤šå¤„ç†å™¨å¯„å­˜å™¨æ€»æ•°é™¤ä»¥å¹¶å‘çš„çº¿ç¨‹æ•°é‡ï¼Œå¹¶å‘çº¿ç¨‹çš„æ•°é‡ç­‰äºå¹¶å‘å—çš„æ•°é‡ä¹˜ä»¥æ¯å—çº¿ç¨‹çš„æ•°é‡ã€‚\nåœ¨ä¸€ä¸ªçº¿ç¨‹å—ç½‘æ ¼å†…çš„å—æ¬¡åºæ˜¯æœªå®šä¹‰çš„ï¼Œå¹¶ä¸”åœ¨å—ä¹‹é—´ä¸å­˜åœ¨åŒæ­¥æœºåˆ¶ï¼Œå› æ­¤æ¥è‡ªåŒä¸€ä¸ªç½‘æ ¼çš„ä¸¤ä¸ªä¸åŒå—çš„çº¿ç¨‹ä¸èƒ½é€šè¿‡å…¨å±€å†…å­˜å½¼æ­¤å®‰å…¨åœ°é€šè®¯ã€‚\nè®¡ç®—å…¼å®¹æ€§ è®¾å¤‡çš„å…¼å®¹æ€§ç”±ä¸¤ä¸ªå‚æ•°å®šä¹‰ï¼Œä¸»è¦ç‰ˆæœ¬å·å’Œæ¬¡è¦ç‰ˆæœ¬å·ã€‚è®¾å¤‡æ‹¥æœ‰çš„ä¸»è¦ç‰ˆæœ¬å·ä»£è¡¨ç›¸åŒçš„æ ¸å¿ƒæ¶æ„ã€‚\næ¬¡è¦ç‰ˆæœ¬å·ä»£è¡¨ä¸€äº›æ”¹è¿›çš„æ ¸å¿ƒæ¶æ„ã€‚æ¯”å¦‚æ–°çš„ç‰¹æ€§ã€‚\nå¤šè®¾å¤‡ ä¸ºä¸€ä¸ªåº”ç”¨ç¨‹åºä½¿ç”¨å¤šGPUä½œä¸ºCUDAè®¾å¤‡ï¼Œå¿…é¡»ä¿è¯è¿™äº›CPUæ˜¯ä¸€æ ·çš„ç±»å‹ã€‚å¦‚æœç³»ç»Ÿå·¥ä½œåœ¨SLI æ¨¡å¼ä¸‹ï¼Œé‚£ä¹ˆåªæœ‰ä¸€ä¸ªGPUå¯ä»¥ä½œä¸ºCUDAè®¾å¤‡ï¼Œç”±äºæ‰€æœ‰çš„GPUåœ¨é©±åŠ¨å †æ ˆä¸­è¢«åº•å±‚çš„èåˆäº†ã€‚SLI æ¨¡å¼éœ€è¦åœ¨æ§åˆ¶é¢æ¿ä¸­å…³é—­,è¿™æ ·æ‰èƒ½ä½¿å¤šä¸ªGPUä½œä¸ºCUDAè®¾å¤‡","title":"Cuda ç¡¬ä»¶å®ç°"},{"content":"ç†è®º Cannyè¾¹ç¼˜æ£€æµ‹æ˜¯ç”±John F. Cannyåœ¨1986å¹´å¼€å‘çš„ã€‚è®¸å¤šäººä¹Ÿå°†å…¶ç§°ä¸ºæœ€ä½³æ£€æµ‹å™¨ï¼ŒCannyç®—æ³•æ—¨åœ¨æ»¡è¶³ä¸‰ä¸ªä¸»è¦æ ‡å‡†ã€‚\nå¥½çš„æ£€æµ‹ï¼šç®—æ³•èƒ½å¤Ÿå°½å¯èƒ½å¤šåœ°æ ‡è¯†å‡ºå›¾åƒä¸­çš„å®é™…è¾¹ç¼˜ã€‚ å¥½çš„å®šä½ï¼šæ ‡è¯†å‡ºçš„è¾¹ç¼˜è¦ä¸å®é™…å›¾åƒä¸­çš„å®é™…è¾¹ç¼˜å°½å¯èƒ½æ¥è¿‘ã€‚ æœ€å°å“åº”ï¼šå›¾åƒä¸­çš„è¾¹ç¼˜åªèƒ½æ ‡è¯†ä¸€æ¬¡ï¼Œå¹¶ä¸”å¯èƒ½å­˜åœ¨çš„å›¾åƒé›œè¨Šä¸åº”æ ‡è¯†ä¸ºè¾¹ç¼˜ã€‚ æ­¥éª¤ é™å™ªï¼šä½¿ç”¨é«˜æ–¯æ»¤æ³¢æ¥è¾¾åˆ°ï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªå¤§å°ä¸º $5$ çš„é«˜æ–¯æ ¸çš„ä¾‹å­ï¼š $$ K = \\frac{1}{159}\\begin{bmatrix} 2 \u0026amp; 4 \u0026amp; 5 \u0026amp; 4 \u0026amp; 2\\\\ 4 \u0026amp; 9 \u0026amp; 12 \u0026amp; 9 \u0026amp; 4\\\\ 5 \u0026amp; 12 \u0026amp; 15 \u0026amp; 12 \u0026amp; 5\\\\ 4 \u0026amp; 9 \u0026amp; 12 \u0026amp; 9 \u0026amp; 4\\\\ 2 \u0026amp; 4 \u0026amp; 5 \u0026amp; 4 \u0026amp; 2 \\end{bmatrix} $$\næ‰¾åˆ°å›¾åƒçš„äº®åº¦æ¢¯åº¦ï¼šä¸ºæ­¤ï¼Œæˆ‘ä»¬éµå¾ªä¸€ä¸ªç±»ä¼¼äºSobelçš„ç¨‹åºï¼š\nåº”ç”¨ä¸€å¯¹å·ç§¯masksï¼ˆåœ¨ $x$ å’Œ $y$ æ–¹å‘ä¸Šï¼‰ï¼š $$ G_x = \\begin{bmatrix} -1 \u0026amp; 0 \u0026amp; +1\\\\ -2 \u0026amp; 0 \u0026amp; +2\\\\ -1 \u0026amp; 0 \u0026amp; +1 \\end{bmatrix}, G_y=\\begin{bmatrix} -1 \u0026amp; -2 \u0026amp; -1\\\\ 0 \u0026amp; 0 \u0026amp; 0\\\\ +1 \u0026amp; +2 \u0026amp; +1 \\end{bmatrix} $$ å¯»æ‰¾æ¢¯åº¦å¼ºåº¦å’Œæ–¹å‘ï¼š $$ G=\\sqrt{G_x^2+G_y^2}\\\\ \\theta = \\arctan(\\frac{G_y}{G_x}) $$ æ–¹å‘è¢«å››èˆäº”å…¥ä¸ºå››ä¸ªå¯èƒ½çš„è§’åº¦ä¹‹ä¸€ï¼ˆå³ $0\\degree$ ã€ $45\\degree$ ã€ $90\\degree$ æˆ– $135\\degree$ ï¼‰ã€‚ è¿‡æ»¤éæœ€å¤§å€¼ï¼šåœ¨é«˜æ–¯æ»¤æ³¢è¿‡ç¨‹ä¸­ï¼Œè¾¹ç¼˜æœ‰å¯èƒ½è¢«æ”¾å¤§äº†ã€‚è¿™ä¸ªæ­¥éª¤ä½¿ç”¨ä¸€ä¸ªè§„åˆ™æ¥è¿‡æ»¤ä¸æ˜¯è¾¹ç¼˜çš„ç‚¹ï¼Œä½¿è¾¹ç¼˜çš„å®½åº¦å°½å¯èƒ½ä¸º1ä¸ªåƒç´ ç‚¹ï¼šå¦‚æœä¸€ä¸ªåƒç´ ç‚¹å±äºè¾¹ç¼˜ï¼Œé‚£ä¹ˆè¿™ä¸ªåƒç´ ç‚¹åœ¨æ¢¯åº¦æ–¹å‘ä¸Šçš„æ¢¯åº¦å€¼æ˜¯æœ€å¤§çš„ã€‚å¦åˆ™ä¸æ˜¯è¾¹ç¼˜ï¼Œå°†ç°åº¦å€¼è®¾ä¸º $0$ ã€‚ $$ M_T(m, n) = \\begin{cases} M(m, n)\u0026amp; \\text{if } M(m, n) \\lt T\\\\ 0 \u0026amp; \\text{otherwise} \\end{cases} $$\næ»åï¼šè¿™æ˜¯æœ€åä¸€æ­¥ï¼ŒCannyç¡®å®ä½¿ç”¨äº†ä¸¤ä¸ªé˜ˆå€¼ï¼ˆä¸Šé™å’Œä¸‹é™ï¼‰ã€‚\nå¦‚æœä¸€ä¸ªåƒç´ çš„æ¢¯åº¦å€¼é«˜äºä¸Šé™é˜ˆå€¼ï¼Œåˆ™è¯¥åƒç´ è¢«æ¥å—ä¸ºè¾¹ç¼˜ã€‚ å¦‚æœä¸€ä¸ªåƒç´ çš„æ¢¯åº¦å€¼ä½äºä¸‹é™é˜ˆå€¼ï¼Œé‚£ä¹ˆå®ƒå°†è¢«æ‹’ç»ã€‚ å¦‚æœåƒç´ æ¢¯åº¦åœ¨ä¸¤ä¸ªé˜ˆå€¼ä¹‹é—´ï¼Œé‚£ä¹ˆåªæœ‰å½“å®ƒä¸é«˜äºä¸Šå±‚é˜ˆå€¼çš„åƒç´ ç›¸è¿æ—¶ï¼Œæ‰ä¼šè¢«æ¥å—ã€‚ Cannyå»ºè®®ä¸Šä¸‹é™çš„æ¯”å€¼åœ¨ $2:1$ å’Œ $3:1$ ä¹‹é—´ã€‚ Code ä»£ç é“¾æ¥\nExplanation å˜é‡å®šä¹‰ Mat src, src_gray; Mat dst, detected_edges; int lowThreshold = 0; const int max_lowThreshold = 100; const int ratio = 3; const int kernel_size = 3; const char* window_name = \u0026#34;Edge Map\u0026#34;; æˆ‘ä»¬å»ºç«‹äº†ä¸€ä¸ª $3:1$ çš„ä¸‹é™:ä¸Šé™é˜ˆå€¼çš„æ¯”å€¼ï¼ˆç”¨å¯å˜æ¯”å€¼ï¼‰ã€‚ æˆ‘ä»¬è®¾å®šå†…æ ¸å¤§å°ä¸º $3$ ï¼ˆç”¨äºCannyå‡½æ•°å†…éƒ¨è¿›è¡Œçš„Sobelè¿ç®—ï¼‰ æˆ‘ä»¬å°†ä¸‹é™é˜ˆå€¼çš„æœ€å¤§å€¼è®¾å®šä¸º $100$ ã€‚ åŠ è½½å›¾åƒ CommandLineParser parser( argc, argv, \u0026#34;{@input | fruits.jpg | input image}\u0026#34; ); src = imread( samples::findFile( parser.get\u0026lt;String\u0026gt;( \u0026#34;@input\u0026#34; ) ), IMREAD_COLOR ); // Load an image if( src.empty() ) { std::cout \u0026lt;\u0026lt; \u0026#34;Could not open or find the image!\\n\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Usage: \u0026#34; \u0026lt;\u0026lt; argv[0] \u0026lt;\u0026lt; \u0026#34; \u0026lt;Input image\u0026gt;\u0026#34; \u0026lt;\u0026lt; std::endl; return -1; } åˆ›å»ºä¸€ä¸ªä¸srcç›¸åŒç±»å‹å’Œå¤§å°çš„çŸ©é˜µï¼ˆdstï¼‰ã€‚ dst.create( src.size(), src.type() ); ç°åº¦åŒ– cvtColor( src, src_gray, COLOR_BGR2GRAY ); åˆ›å»ºä¸€ä¸ªçª—å£æ¥æ˜¾ç¤ºç»“æœ namedWindow( window_name, WINDOW_AUTOSIZE ); åˆ›å»ºä¸€ä¸ªTrackbarï¼Œè®©ç”¨æˆ·ä¸ºæˆ‘ä»¬çš„Cannyæ£€æµ‹å™¨è¾“å…¥ä½é˜ˆå€¼ createTrackbar( \u0026#34;Min Threshold:\u0026#34;, window_name, \u0026amp;lowThreshold, max_lowThreshold, CannyThreshold ); è®©æˆ‘ä»¬ä¸€æ­¥ä¸€æ­¥åœ°è§‚å¯ŸCannyThresholdå‡½æ•° é¦–å…ˆï¼Œæˆ‘ä»¬ç”¨å†…æ ¸å¤§å°ä¸º $3$ çš„æ»¤æ³¢å™¨å¯¹å›¾åƒè¿›è¡Œæ¨¡ç³Šå¤„ç†ã€‚\nblur( src_gray, detected_edges, Size(3,3) ); æ¥ç€ï¼Œæˆ‘ä»¬åº”ç”¨OpenCVå‡½æ•°cv::Canny\nCanny( detected_edges, detected_edges, lowThreshold, lowThreshold*ratio, kernel_size ); detected_edgesï¼šæºå›¾åƒï¼ˆç°åº¦å›¾ï¼‰ detected_edgesï¼šè¾“å‡ºå›¾åƒï¼ˆå¯ä¸è¾“å…¥ç›¸åŒï¼‰ lowThresholdï¼šç”¨æˆ·ç§»åŠ¨Trackbaræ—¶è¾“å…¥çš„å€¼ highThresholdï¼šåœ¨ç¨‹åºä¸­è®¾ç½®ä¸ºlowThresholdçš„ $3$ å€ï¼ˆæŒ‰ç…§Cannyçš„å»ºè®®ï¼‰ kernel_sizeï¼šæˆ‘ä»¬å°†å…¶å®šä¹‰ä¸º $3$ ï¼ˆå†…éƒ¨ä½¿ç”¨çš„Sobelå†…æ ¸çš„å¤§å°ï¼‰ã€‚ æˆ‘ä»¬ç”¨é›¶æ¥å¡«å……dstå›¾åƒï¼ˆæ„å‘³ç€å›¾åƒæ˜¯å®Œå…¨é»‘è‰²çš„ï¼‰ dst = Scalar::all(0); æ˜¾ç¤º æœ€åï¼Œæˆ‘ä»¬å°†ä½¿ç”¨å‡½æ•°cv::Mat::copyToåªæ˜ å°„å›¾åƒä¸­è¢«è¯†åˆ«ä¸ºè¾¹ç¼˜çš„åŒºåŸŸï¼ˆåœ¨é»‘è‰²èƒŒæ™¯ä¸Šï¼‰ã€‚cv::Mat::copyToå°†srcå›¾åƒå¤åˆ¶åˆ°dstä¸Šã€‚æ³¨æ„ï¼Œå®ƒåªä¼šå¤åˆ¶åƒç´ çš„éé›¶å€¼çš„ä½ç½®ã€‚å› ä¸ºCannyæ£€æµ‹å™¨çš„è¾“å‡ºæ˜¯é»‘è‰²èƒŒæ™¯ä¸Šçš„è¾¹ç¼˜è½®å»“ï¼Œæ‰€ä»¥é™¤äº†æ£€æµ‹åˆ°çš„è¾¹ç¼˜ï¼Œç”Ÿæˆçš„dstå°†æ˜¯é»‘è‰²çš„ã€‚\nè‹¥æ²¡æœ‰è¿™ä¸€æ­¥ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¾—åˆ°çš„å›¾åƒæ˜¯è¾¹ç¼˜çš„ç°åº¦å›¾\nç»“æœ References https://docs.opencv.org/4.5.5/da/d5c/tutorial_canny_detector.html\n","permalink":"https://fffzlfk.github.io/posts/opencv_canny_detector/","summary":"ç†è®º Cannyè¾¹ç¼˜æ£€æµ‹æ˜¯ç”±John F. Cannyåœ¨1986å¹´å¼€å‘çš„ã€‚è®¸å¤šäººä¹Ÿå°†å…¶ç§°ä¸ºæœ€ä½³æ£€æµ‹å™¨ï¼ŒCannyç®—æ³•æ—¨åœ¨æ»¡è¶³ä¸‰ä¸ªä¸»è¦æ ‡å‡†ã€‚\nå¥½çš„æ£€æµ‹ï¼šç®—æ³•èƒ½å¤Ÿå°½å¯èƒ½å¤šåœ°æ ‡è¯†å‡ºå›¾åƒä¸­çš„å®é™…è¾¹ç¼˜ã€‚ å¥½çš„å®šä½ï¼šæ ‡è¯†å‡ºçš„è¾¹ç¼˜è¦ä¸å®é™…å›¾åƒä¸­çš„å®é™…è¾¹ç¼˜å°½å¯èƒ½æ¥è¿‘ã€‚ æœ€å°å“åº”ï¼šå›¾åƒä¸­çš„è¾¹ç¼˜åªèƒ½æ ‡è¯†ä¸€æ¬¡ï¼Œå¹¶ä¸”å¯èƒ½å­˜åœ¨çš„å›¾åƒé›œè¨Šä¸åº”æ ‡è¯†ä¸ºè¾¹ç¼˜ã€‚ æ­¥éª¤ é™å™ªï¼šä½¿ç”¨é«˜æ–¯æ»¤æ³¢æ¥è¾¾åˆ°ï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªå¤§å°ä¸º $5$ çš„é«˜æ–¯æ ¸çš„ä¾‹å­ï¼š $$ K = \\frac{1}{159}\\begin{bmatrix} 2 \u0026amp; 4 \u0026amp; 5 \u0026amp; 4 \u0026amp; 2\\\\ 4 \u0026amp; 9 \u0026amp; 12 \u0026amp; 9 \u0026amp; 4\\\\ 5 \u0026amp; 12 \u0026amp; 15 \u0026amp; 12 \u0026amp; 5\\\\ 4 \u0026amp; 9 \u0026amp; 12 \u0026amp; 9 \u0026amp; 4\\\\ 2 \u0026amp; 4 \u0026amp; 5 \u0026amp; 4 \u0026amp; 2 \\end{bmatrix} $$\næ‰¾åˆ°å›¾åƒçš„äº®åº¦æ¢¯åº¦ï¼šä¸ºæ­¤ï¼Œæˆ‘ä»¬éµå¾ªä¸€ä¸ªç±»ä¼¼äºSobelçš„ç¨‹åºï¼š\nåº”ç”¨ä¸€å¯¹å·ç§¯masksï¼ˆåœ¨ $x$ å’Œ $y$ æ–¹å‘ä¸Šï¼‰ï¼š $$ G_x = \\begin{bmatrix} -1 \u0026amp; 0 \u0026amp; +1\\\\ -2 \u0026amp; 0 \u0026amp; +2\\\\ -1 \u0026amp; 0 \u0026amp; +1 \\end{bmatrix}, G_y=\\begin{bmatrix} -1 \u0026amp; -2 \u0026amp; -1\\\\ 0 \u0026amp; 0 \u0026amp; 0\\\\ +1 \u0026amp; +2 \u0026amp; +1 \\end{bmatrix} $$ å¯»æ‰¾æ¢¯åº¦å¼ºåº¦å’Œæ–¹å‘ï¼š $$ G=\\sqrt{G_x^2+G_y^2}\\\\ \\theta = \\arctan(\\frac{G_y}{G_x}) $$ æ–¹å‘è¢«å››èˆäº”å…¥ä¸ºå››ä¸ªå¯èƒ½çš„è§’åº¦ä¹‹ä¸€ï¼ˆå³ $0\\degree$ ã€ $45\\degree$ ã€ $90\\degree$ æˆ– $135\\degree$ ï¼‰ã€‚ è¿‡æ»¤éæœ€å¤§å€¼ï¼šåœ¨é«˜æ–¯æ»¤æ³¢è¿‡ç¨‹ä¸­ï¼Œè¾¹ç¼˜æœ‰å¯èƒ½è¢«æ”¾å¤§äº†ã€‚è¿™ä¸ªæ­¥éª¤ä½¿ç”¨ä¸€ä¸ªè§„åˆ™æ¥è¿‡æ»¤ä¸æ˜¯è¾¹ç¼˜çš„ç‚¹ï¼Œä½¿è¾¹ç¼˜çš„å®½åº¦å°½å¯èƒ½ä¸º1ä¸ªåƒç´ ç‚¹ï¼šå¦‚æœä¸€ä¸ªåƒç´ ç‚¹å±äºè¾¹ç¼˜ï¼Œé‚£ä¹ˆè¿™ä¸ªåƒç´ ç‚¹åœ¨æ¢¯åº¦æ–¹å‘ä¸Šçš„æ¢¯åº¦å€¼æ˜¯æœ€å¤§çš„ã€‚å¦åˆ™ä¸æ˜¯è¾¹ç¼˜ï¼Œå°†ç°åº¦å€¼è®¾ä¸º $0$ ã€‚ $$ M_T(m, n) = \\begin{cases} M(m, n)\u0026amp; \\text{if } M(m, n) \\lt T\\\\ 0 \u0026amp; \\text{otherwise} \\end{cases} $$","title":"OpenCV Canny Detector"},{"content":"ç†è®º åœ¨ä¹‹å‰çš„æ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬å­¦ä¹ äº†å¦‚ä½•ä½¿ç”¨Sobelç®—å­ã€‚å®ƒæ˜¯åŸºäºè¿™æ ·ä¸€ä¸ªäº‹å®ï¼Œå³åœ¨è¾¹ç¼˜åŒºåŸŸï¼Œåƒç´ å¼ºåº¦æ˜¾ç¤ºäº†ä¸€ä¸ª \u0026ldquo;è·³è·ƒ\u0026quot;æˆ–å¼ºåº¦çš„é«˜å˜åŒ–ã€‚å¾—åˆ°å¼ºåº¦çš„ä¸€é˜¶å¯¼æ•°ï¼Œæˆ‘ä»¬è§‚å¯Ÿåˆ°è¾¹ç¼˜çš„ç‰¹å¾æ˜¯ä¸€ä¸ªæœ€å¤§å€¼ï¼Œå¦‚å›¾æ‰€ç¤ºï¼š é‚£ä¹ˆï¼Œå¦‚æœæˆ‘ä»¬å–äºŒé˜¶å¯¼æ•°ä¼šæ€æ ·ï¼Ÿ ä½ å¯ä»¥è§‚å¯Ÿåˆ°ï¼Œè¾¹ç¼˜äºŒé˜¶å¯¼æ•°æ˜¯é›¶! å› æ­¤ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ç”¨è¿™ä¸ªæ ‡å‡†æ¥å°è¯•æ£€æµ‹å›¾åƒçš„è¾¹ç¼˜ã€‚ç„¶è€Œï¼Œè¯·æ³¨æ„ï¼Œé›¶å€¼ä¸ä»…ä¼šå‡ºç°åœ¨è¾¹ç¼˜ï¼ˆå®ƒä»¬å®é™…ä¸Šå¯ä»¥å‡ºç°åœ¨å…¶ä»–æ— æ„ä¹‰çš„ä½ç½®ï¼‰ï¼›è¿™å¯ä»¥é€šè¿‡åœ¨éœ€è¦æ—¶ä½¿ç”¨è¿‡æ»¤æ¥è§£å†³ã€‚\næ‹‰æ™®æ‹‰æ–¯ç®—å­ ä»ä¸Šé¢çš„è§£é‡Šä¸­ï¼Œæˆ‘ä»¬å¯ä»¥æ¨æ–­å‡ºï¼ŒäºŒé˜¶å¯¼æ•°å¯ä»¥ç”¨æ¥æ£€æµ‹è¾¹ç¼˜ã€‚ç”±äºå›¾åƒæ˜¯äºŒç»´çš„ï¼Œæˆ‘ä»¬éœ€è¦åœ¨ä¸¤ä¸ªç»´åº¦ä¸Šå–å¯¼æ•°ã€‚è¿™é‡Œï¼Œæ‹‰æ™®æ‹‰æ–¯ç®—å­å°±æ´¾ä¸Šç”¨åœºäº†ã€‚ æ‹‰æ™®æ‹‰æ–¯ç®—å­çš„å®šä¹‰æ˜¯ï¼š $$ Laplace(f) = \\frac{\\partial^2f}{\\partial x^2}+\\frac{\\partial^2f}{\\partial y^2} $$ æ‹‰æ™®æ‹‰æ–¯ç®—å­åœ¨OpenCVä¸­æ˜¯ç”±å‡½æ•°Laplacian()å®ç°çš„ã€‚äº‹å®ä¸Šï¼Œç”±äºæ‹‰æ™®æ‹‰æ–¯ç®—å­ä½¿ç”¨å›¾åƒçš„æ¢¯åº¦ï¼Œå®ƒåœ¨å†…éƒ¨è°ƒç”¨ç´¢è´å°”ç®—å­æ¥è¿›è¡Œè®¡ç®—çš„ã€‚ Code ä»£ç é“¾æ¥\nExplanation å˜é‡å£°æ˜ // Declare the variables we are going to use Mat src, src_gray, dst; int kernel_size = 3; int scale = 1; int delta = 0; int ddepth = CV_16S; const char* window_name = \u0026#34;Laplace Demo\u0026#34;; åŠ è½½å›¾åƒ const char* imageName = argc \u0026gt;=2 ? argv[1] : \u0026#34;./images/lena.jpg\u0026#34;; src = imread( samples::findFile( imageName ), IMREAD_COLOR ); // Load an image // Check if image is loaded fine if(src.empty()){ printf(\u0026#34; Error opening image\\n\u0026#34;); printf(\u0026#34; Program Arguments: [image_name -- default lena.jpg] \\n\u0026#34;); return -1; } æ¶ˆé™¤å™ªå£° // Reduce noise by blurring with a Gaussian filter ( kernel size = 3 ) GaussianBlur( src, src, Size(3, 3), 0, 0, BORDER_DEFAULT ); ç°åº¦åŒ– cvtColor( src, src_gray, COLOR_BGR2GRAY ); // Convert the image to grayscale æ‹‰æ™®æ‹‰æ–¯ç®—å­ Laplacian( src_gray, dst, ddepth, kernel_size, scale, delta, BORDER_DEFAULT ); å‚æ•°å¦‚ä¸‹ã€‚ src_grayï¼šè¾“å…¥çš„å›¾åƒã€‚ dstï¼šç›®æ ‡å›¾åƒ ddepthã€‚ç›®çš„å›¾åƒçš„æ·±åº¦ã€‚ç”±äºæˆ‘ä»¬çš„è¾“å…¥æ˜¯CV_8Uï¼Œæˆ‘ä»¬å®šä¹‰ddepth = CV_16Sä»¥é¿å…æº¢å‡ºã€‚ kernel_sizeã€‚å†…éƒ¨åº”ç”¨çš„Sobelç®—å­çš„æ ¸å¤§å°ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­æˆ‘ä»¬ä½¿ç”¨3ã€‚ scale, delta å’Œ BORDER_DEFAULTï¼šæˆ‘ä»¬æŠŠå®ƒä»¬ä½œä¸ºé»˜è®¤å€¼ã€‚ å°†è¾“å‡ºè½¬æ¢ä¸ºCV_8Uå›¾åƒ // converting back to CV_8U convertScaleAbs( dst, abs_dst ); ç»“æœ ç¼–è¯‘å®Œä¸Šé¢çš„ä»£ç åï¼Œæˆ‘ä»¬å¯ä»¥è¿è¡Œå®ƒï¼Œå¹¶å°†å›¾åƒçš„è·¯å¾„ä½œä¸ºå‚æ•°ã€‚ä¾‹å¦‚ï¼Œä»¥ä¸‹å›¾è¾“å…¥ä¸ºä¾‹ï¼š æˆ‘ä»¬å¾—åˆ°ä»¥ä¸‹ç»“æœã€‚æ³¨æ„åˆ°æ ‘æœ¨å’Œç‰›çš„è½®å»“æ˜¯å¦‚ä½•è¢«è¿‘ä¼¼åœ°å®šä¹‰çš„ï¼ˆé™¤äº†åœ¨å¼ºåº¦éå¸¸ç›¸ä¼¼çš„åŒºåŸŸï¼Œå³ç‰›å¤´å‘¨å›´ï¼‰ã€‚å¦å¤–ï¼Œè¯·æ³¨æ„ï¼Œæ ‘æœ¨åé¢çš„æˆ¿å­çš„å±‹é¡¶ï¼ˆå³ä¾§ï¼‰æ˜¯ä¸æ˜æ˜¾çš„æ ‡è®°ã€‚è¿™æ˜¯ç”±äºè¯¥åŒºåŸŸçš„å¯¹æ¯”åº¦è¾ƒé«˜ã€‚ References https://docs.opencv.org/4.5.5/d5/db5/tutorial_laplace_operator.html\n","permalink":"https://fffzlfk.github.io/posts/opencv_laplace_operator/","summary":"ç†è®º åœ¨ä¹‹å‰çš„æ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬å­¦ä¹ äº†å¦‚ä½•ä½¿ç”¨Sobelç®—å­ã€‚å®ƒæ˜¯åŸºäºè¿™æ ·ä¸€ä¸ªäº‹å®ï¼Œå³åœ¨è¾¹ç¼˜åŒºåŸŸï¼Œåƒç´ å¼ºåº¦æ˜¾ç¤ºäº†ä¸€ä¸ª \u0026ldquo;è·³è·ƒ\u0026quot;æˆ–å¼ºåº¦çš„é«˜å˜åŒ–ã€‚å¾—åˆ°å¼ºåº¦çš„ä¸€é˜¶å¯¼æ•°ï¼Œæˆ‘ä»¬è§‚å¯Ÿåˆ°è¾¹ç¼˜çš„ç‰¹å¾æ˜¯ä¸€ä¸ªæœ€å¤§å€¼ï¼Œå¦‚å›¾æ‰€ç¤ºï¼š é‚£ä¹ˆï¼Œå¦‚æœæˆ‘ä»¬å–äºŒé˜¶å¯¼æ•°ä¼šæ€æ ·ï¼Ÿ ä½ å¯ä»¥è§‚å¯Ÿåˆ°ï¼Œè¾¹ç¼˜äºŒé˜¶å¯¼æ•°æ˜¯é›¶! å› æ­¤ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ç”¨è¿™ä¸ªæ ‡å‡†æ¥å°è¯•æ£€æµ‹å›¾åƒçš„è¾¹ç¼˜ã€‚ç„¶è€Œï¼Œè¯·æ³¨æ„ï¼Œé›¶å€¼ä¸ä»…ä¼šå‡ºç°åœ¨è¾¹ç¼˜ï¼ˆå®ƒä»¬å®é™…ä¸Šå¯ä»¥å‡ºç°åœ¨å…¶ä»–æ— æ„ä¹‰çš„ä½ç½®ï¼‰ï¼›è¿™å¯ä»¥é€šè¿‡åœ¨éœ€è¦æ—¶ä½¿ç”¨è¿‡æ»¤æ¥è§£å†³ã€‚\næ‹‰æ™®æ‹‰æ–¯ç®—å­ ä»ä¸Šé¢çš„è§£é‡Šä¸­ï¼Œæˆ‘ä»¬å¯ä»¥æ¨æ–­å‡ºï¼ŒäºŒé˜¶å¯¼æ•°å¯ä»¥ç”¨æ¥æ£€æµ‹è¾¹ç¼˜ã€‚ç”±äºå›¾åƒæ˜¯äºŒç»´çš„ï¼Œæˆ‘ä»¬éœ€è¦åœ¨ä¸¤ä¸ªç»´åº¦ä¸Šå–å¯¼æ•°ã€‚è¿™é‡Œï¼Œæ‹‰æ™®æ‹‰æ–¯ç®—å­å°±æ´¾ä¸Šç”¨åœºäº†ã€‚ æ‹‰æ™®æ‹‰æ–¯ç®—å­çš„å®šä¹‰æ˜¯ï¼š $$ Laplace(f) = \\frac{\\partial^2f}{\\partial x^2}+\\frac{\\partial^2f}{\\partial y^2} $$ æ‹‰æ™®æ‹‰æ–¯ç®—å­åœ¨OpenCVä¸­æ˜¯ç”±å‡½æ•°Laplacian()å®ç°çš„ã€‚äº‹å®ä¸Šï¼Œç”±äºæ‹‰æ™®æ‹‰æ–¯ç®—å­ä½¿ç”¨å›¾åƒçš„æ¢¯åº¦ï¼Œå®ƒåœ¨å†…éƒ¨è°ƒç”¨ç´¢è´å°”ç®—å­æ¥è¿›è¡Œè®¡ç®—çš„ã€‚ Code ä»£ç é“¾æ¥\nExplanation å˜é‡å£°æ˜ // Declare the variables we are going to use Mat src, src_gray, dst; int kernel_size = 3; int scale = 1; int delta = 0; int ddepth = CV_16S; const char* window_name = \u0026#34;Laplace Demo\u0026#34;; åŠ è½½å›¾åƒ const char* imageName = argc \u0026gt;=2 ? argv[1] : \u0026#34;./images/lena.jpg\u0026#34;; src = imread( samples::findFile( imageName ), IMREAD_COLOR ); // Load an image // Check if image is loaded fine if(src.","title":"OpenCV Laplace Operator"},{"content":"ç†è®º åœ¨ä¹‹å‰çš„ä¸¤ä¸ªæ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬å·²ç»çœ‹åˆ°äº†å·ç§¯çš„åº”ç”¨å®ä¾‹ã€‚æœ€é‡è¦çš„å·ç§¯ä¹‹ä¸€æ˜¯è®¡ç®—å›¾åƒä¸­çš„å¯¼æ•°ï¼ˆæˆ–å¯¹å®ƒä»¬çš„è¿‘ä¼¼å€¼ï¼‰\nä¸ºä»€ä¹ˆå›¾åƒä¸­çš„å¯¼æ•°è®¡ç®—å¯èƒ½æ˜¯é‡è¦çš„ï¼Ÿè®©æˆ‘ä»¬è®¾æƒ³ä¸€ä¸‹ï¼Œæˆ‘ä»¬è¦æ£€æµ‹å›¾åƒä¸­å­˜åœ¨çš„è¾¹ç¼˜ã€‚æ¯”å¦‚è¯´ï¼š ä½ å¯ä»¥å¾ˆå®¹æ˜“åœ°æ³¨æ„åˆ°ï¼Œåœ¨ä¸€ä¸ªè¾¹ç¼˜ï¼Œåƒç´ å¼ºåº¦çš„å˜åŒ–æ˜¯å¾ˆæ˜æ˜¾çš„ã€‚ä¸€ä¸ªè¡¨è¾¾å˜åŒ–çš„å¥½æ–¹æ³•æ˜¯ä½¿ç”¨å¯¼æ•°ã€‚æ¢¯åº¦çš„é«˜å˜åŒ–è¡¨ç¤ºå›¾åƒä¸­çš„ä¸€ä¸ªé‡å¤§å˜åŒ–ã€‚\nä¸ºäº†æ›´åŠ å½¢è±¡ï¼Œè®©æˆ‘ä»¬å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªä¸€ç»´å›¾åƒã€‚åœ¨ä¸‹é¢çš„å›¾ä¸­ï¼Œä¸€ä¸ªè¾¹ç¼˜ç”±å¼ºåº¦çš„ \u0026ldquo;è·³è·ƒ \u0026ldquo;æ¥è¡¨ç¤ºï¼š å¦‚æœæˆ‘ä»¬å–ç¬¬ä¸€ä¸ªå¯¼æ•°ï¼Œå¯ä»¥æ›´å®¹æ˜“åœ°çœ‹åˆ°è¾¹ç¼˜çš„ \u0026ldquo;è·³è·ƒ\u0026rdquo;ï¼ˆå®é™…ä¸Šï¼Œè¿™é‡Œå‡ºç°çš„æ˜¯ä¸€ä¸ªæœ€å¤§å€¼ï¼‰ï¼š å› æ­¤ï¼Œä»ä¸Šé¢çš„è§£é‡Šä¸­ï¼Œæˆ‘ä»¬å¯ä»¥æ¨æ–­å‡ºï¼Œæ£€æµ‹å›¾åƒä¸­çš„è¾¹ç¼˜çš„æ–¹æ³•å¯ä»¥é€šè¿‡å®šä½æ¢¯åº¦é«˜äºå…¶é‚»å±…çš„åƒç´ ä½ç½®ï¼ˆæˆ–è€…æ¦‚æ‹¬åœ°è¯´ï¼Œé«˜äºä¸€ä¸ªé˜ˆå€¼ï¼‰æ¥è¿›è¡Œã€‚\næ›´è¯¦ç»†çš„è§£é‡Šï¼Œè¯·å‚è€ƒBradskiå’ŒKaehlerçš„ã€ŠLearning OpenCVã€‹ã€‚\nSobel ç®—å­ Sobelç®—å­æ˜¯ä¸€ä¸ªç¦»æ•£çš„å¾®åˆ†ç®—å­ï¼Œå®ƒè®¡ç®—å›¾åƒå¼ºåº¦å‡½æ•°çš„æ¢¯åº¦çš„è¿‘ä¼¼å€¼ã€‚ Sobelç®—å­ç»“åˆäº†Gaussian smoothingå’Œå¾®åˆ†ã€‚ Formulation å‡è®¾è¦æ“ä½œçš„å›¾åƒä¸º $I$:\næˆ‘ä»¬è®¡ç®—ä¸¤ä¸ªå¯¼æ•°ï¼š æ°´å¹³å˜åŒ–ï¼šè¿™æ˜¯é€šè¿‡ç”¨å¥‡æ•°å¤§å°çš„å†…æ ¸ $G_x$ å¯¹ $I$ è¿›è¡Œå·ç§¯è®¡ç®—çš„ã€‚ä¾‹å¦‚ï¼Œå¯¹äºå†…æ ¸å¤§å°ä¸º $3$ ï¼Œ $G_x$ å°†è¢«è®¡ç®—ä¸ºï¼š $$ G_x=\\begin{bmatrix} -1 \u0026amp; 0 \u0026amp; +1\\\\ -2 \u0026amp; 0 \u0026amp; +2\\\\ -1 \u0026amp; 0 \u0026amp; +1 \\end{bmatrix} * I $$ å‚ç›´å˜åŒ–ï¼šè¿™æ˜¯é€šè¿‡ç”¨å¥‡æ•°å¤§å°çš„å†…æ ¸ $G_y$ å¯¹ $I$ è¿›è¡Œå·ç§¯è®¡ç®—çš„ã€‚ä¾‹å¦‚ï¼Œå¯¹äºå†…æ ¸å¤§å°ä¸º $3$ ï¼Œ $G_y$ å°†è¢«è®¡ç®—ä¸ºï¼š $$ G_y = \\begin{bmatrix} -1 \u0026amp; -2 \u0026amp; -1\\\\ 0 \u0026amp; 0 \u0026amp; 0\\\\ +1 \u0026amp; +2 \u0026amp; + 1 \\end{bmatrix} * I $$ åœ¨å›¾åƒçš„æ¯ä¸€ç‚¹ä¸Šï¼Œæˆ‘ä»¬é€šè¿‡ç»“åˆä¸Šè¿°ä¸¤ä¸ªç»“æœè®¡ç®—å‡ºè¯¥ç‚¹çš„æ¢¯åº¦è¿‘ä¼¼å€¼ï¼š $$ G = \\sqrt{G_{x}^{2}+G_{y}^{2}} $$ æœ‰æ—¶ä¼šä½¿ç”¨ä»¥ä¸‹æ›´ç®€å•çš„æ–¹ç¨‹å¼ï¼š $$ G = |G_x|+|G_y| $$ å½“æ ¸çš„å¤§å°ä¸º $3$ æ—¶ï¼Œä¸Šé¢æ˜¾ç¤ºçš„ Sobelæ ¸å¯èƒ½ä¼šäº§ç”Ÿæ˜æ˜¾çš„ä¸å‡†ç¡®ï¼ˆæ¯•ç«Ÿï¼Œ Sobel åªæ˜¯ä¸€ä¸ªå¯¼æ•°çš„è¿‘ä¼¼å€¼ï¼‰ã€‚OpenCVé€šè¿‡ä½¿ç”¨ Scharr() å‡½æ•°æ¥è§£å†³è¿™ç§å¤§å°ä¸º $3$ çš„æ ¸çš„ä¸ç²¾ç¡®æ€§ã€‚è¿™å’Œæ ‡å‡†çš„ Sobel å‡½æ•°ä¸€æ ·å¿«ï¼Œä½†æ¯”å®ƒæ›´å‡†ç¡®ã€‚å®ƒå¯ä»¥å®ç°ä»¥ä¸‹å†…æ ¸ $$ G_x=\\begin{bmatrix} -3 \u0026amp; 0 \u0026amp; +3\\\\ -10 \u0026amp; 0 \u0026amp; +10\\\\ -3 \u0026amp; 0 \u0026amp; +3 \\end{bmatrix}, G_y=\\begin{bmatrix} -3 \u0026amp; -10 \u0026amp; -3\\\\ 0 \u0026amp; 0 \u0026amp; 0\\\\ +3 \u0026amp; +10 \u0026amp; +3 \\end{bmatrix} $$\nCode ä»£ç é“¾æ¥\nExplanation å˜é‡å£°æ˜ // First we declare the variables we are going to use Mat image,src, src_gray; Mat grad; const String window_name = \u0026#34;Sobel Demo - Simple Edge Detector\u0026#34;; int ksize = parser.get\u0026lt;int\u0026gt;(\u0026#34;ksize\u0026#34;); int scale = parser.get\u0026lt;int\u0026gt;(\u0026#34;scale\u0026#34;); int delta = parser.get\u0026lt;int\u0026gt;(\u0026#34;delta\u0026#34;); int ddepth = CV_16S; åŠ è½½å›¾åƒ String imageName = parser.get\u0026lt;String\u0026gt;(\u0026#34;@input\u0026#34;); // As usual we load our source image (src) image = imread( samples::findFile( imageName ), IMREAD_COLOR ); // Load an image // Check if image is loaded fine if( image.empty() ) { printf(\u0026#34;Error opening image: %s\\n\u0026#34;, imageName.c_str()); return EXIT_FAILURE; } æ¶ˆé™¤å™ªå£° // Remove noise by blurring with a Gaussian filter ( kernel size = 3 ) GaussianBlur(image, src, Size(3, 3), 0, 0, BORDER_DEFAULT); ç°åº¦åŒ– // Convert the image to grayscale cvtColor(src, src_gray, COLOR_BGR2GRAY); Sobel ç®—å­ Mat grad_x, grad_y; Mat abs_grad_x, abs_grad_y; Sobel(src_gray, grad_x, ddepth, 1, 0, ksize, scale, delta, BORDER_DEFAULT); Sobel(src_gray, grad_y, ddepth, 0, 1, ksize, scale, delta, BORDER_DEFAULT); æˆ‘ä»¬è®¡ç®— $x$ å’Œ $y$ æ–¹å‘çš„ \u0026ldquo;å¯¼æ•°\u0026rdquo;ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬ä½¿ç”¨å‡½æ•°Sobel()ï¼Œå¦‚ä¸‹æ‰€ç¤ºã€‚è¯¥å‡½æ•°éœ€è¦ä»¥ä¸‹å‚æ•°: src_grayï¼šåœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œè¾“å…¥çš„å›¾åƒã€‚è¿™é‡Œæ˜¯CV_8U grad_x / grad_yï¼šè¾“å‡ºå›¾åƒã€‚ ddepthï¼šè¾“å‡ºå›¾åƒçš„æ·±åº¦ã€‚æˆ‘ä»¬å°†å…¶è®¾ç½®ä¸ºCV_16Sä»¥é¿å…æº¢å‡ºã€‚ x_orderï¼š $X$ æ–¹å‘ä¸Šçš„å¯¼æ•°é¡ºåºã€‚ y_order: $Y$ æ–¹å‘çš„å¯¼æ•°é¡ºåºã€‚ scaleï¼šdeltaå’ŒBORDER_DEFAULTï¼šæˆ‘ä»¬ä½¿ç”¨é»˜è®¤å€¼ã€‚ æ³¨æ„ï¼Œåœ¨è®¡ç®— $x$ æ–¹å‘çš„æ¢¯åº¦æ—¶ï¼Œæˆ‘ä»¬ä½¿ç”¨ï¼šxorder=1ï¼Œyorder=0ï¼Œæˆ‘ä»¬å¯¹ $y$ æ–¹å‘è¿›è¡Œç±»ä¼¼çš„è®¡ç®—ã€‚\nè½¬æ¢ä¸ºCV_8Uå›¾åƒ // converting back to CV_8U convertScaleAbs(grad_x, abs_grad_x); convertScaleAbs(grad_y, abs_grad_y); æ¢¯åº¦ addWeighted(abs_grad_x, 0.5, abs_grad_y, 0.5, 0, grad); æˆ‘ä»¬è¯•å›¾é€šè¿‡å¢åŠ ä¸¤ä¸ªæ–¹å‘çš„æ¢¯åº¦æ¥è¿‘ä¼¼è®¡ç®—æ¢¯åº¦ï¼ˆæ³¨æ„ï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªç²¾ç¡®çš„è®¡ç®—ï¼ä½†å¯¹æˆ‘ä»¬çš„ç›®çš„æ¥è¯´æ˜¯å¥½çš„ï¼‰ã€‚\nç»“æœ References https://docs.opencv.org/4.5.5/d2/d2c/tutorial_sobel_derivatives.html\n","permalink":"https://fffzlfk.github.io/posts/opencv_sobel_derivatives/","summary":"ç†è®º åœ¨ä¹‹å‰çš„ä¸¤ä¸ªæ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬å·²ç»çœ‹åˆ°äº†å·ç§¯çš„åº”ç”¨å®ä¾‹ã€‚æœ€é‡è¦çš„å·ç§¯ä¹‹ä¸€æ˜¯è®¡ç®—å›¾åƒä¸­çš„å¯¼æ•°ï¼ˆæˆ–å¯¹å®ƒä»¬çš„è¿‘ä¼¼å€¼ï¼‰\nä¸ºä»€ä¹ˆå›¾åƒä¸­çš„å¯¼æ•°è®¡ç®—å¯èƒ½æ˜¯é‡è¦çš„ï¼Ÿè®©æˆ‘ä»¬è®¾æƒ³ä¸€ä¸‹ï¼Œæˆ‘ä»¬è¦æ£€æµ‹å›¾åƒä¸­å­˜åœ¨çš„è¾¹ç¼˜ã€‚æ¯”å¦‚è¯´ï¼š ä½ å¯ä»¥å¾ˆå®¹æ˜“åœ°æ³¨æ„åˆ°ï¼Œåœ¨ä¸€ä¸ªè¾¹ç¼˜ï¼Œåƒç´ å¼ºåº¦çš„å˜åŒ–æ˜¯å¾ˆæ˜æ˜¾çš„ã€‚ä¸€ä¸ªè¡¨è¾¾å˜åŒ–çš„å¥½æ–¹æ³•æ˜¯ä½¿ç”¨å¯¼æ•°ã€‚æ¢¯åº¦çš„é«˜å˜åŒ–è¡¨ç¤ºå›¾åƒä¸­çš„ä¸€ä¸ªé‡å¤§å˜åŒ–ã€‚\nä¸ºäº†æ›´åŠ å½¢è±¡ï¼Œè®©æˆ‘ä»¬å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªä¸€ç»´å›¾åƒã€‚åœ¨ä¸‹é¢çš„å›¾ä¸­ï¼Œä¸€ä¸ªè¾¹ç¼˜ç”±å¼ºåº¦çš„ \u0026ldquo;è·³è·ƒ \u0026ldquo;æ¥è¡¨ç¤ºï¼š å¦‚æœæˆ‘ä»¬å–ç¬¬ä¸€ä¸ªå¯¼æ•°ï¼Œå¯ä»¥æ›´å®¹æ˜“åœ°çœ‹åˆ°è¾¹ç¼˜çš„ \u0026ldquo;è·³è·ƒ\u0026rdquo;ï¼ˆå®é™…ä¸Šï¼Œè¿™é‡Œå‡ºç°çš„æ˜¯ä¸€ä¸ªæœ€å¤§å€¼ï¼‰ï¼š å› æ­¤ï¼Œä»ä¸Šé¢çš„è§£é‡Šä¸­ï¼Œæˆ‘ä»¬å¯ä»¥æ¨æ–­å‡ºï¼Œæ£€æµ‹å›¾åƒä¸­çš„è¾¹ç¼˜çš„æ–¹æ³•å¯ä»¥é€šè¿‡å®šä½æ¢¯åº¦é«˜äºå…¶é‚»å±…çš„åƒç´ ä½ç½®ï¼ˆæˆ–è€…æ¦‚æ‹¬åœ°è¯´ï¼Œé«˜äºä¸€ä¸ªé˜ˆå€¼ï¼‰æ¥è¿›è¡Œã€‚\næ›´è¯¦ç»†çš„è§£é‡Šï¼Œè¯·å‚è€ƒBradskiå’ŒKaehlerçš„ã€ŠLearning OpenCVã€‹ã€‚\nSobel ç®—å­ Sobelç®—å­æ˜¯ä¸€ä¸ªç¦»æ•£çš„å¾®åˆ†ç®—å­ï¼Œå®ƒè®¡ç®—å›¾åƒå¼ºåº¦å‡½æ•°çš„æ¢¯åº¦çš„è¿‘ä¼¼å€¼ã€‚ Sobelç®—å­ç»“åˆäº†Gaussian smoothingå’Œå¾®åˆ†ã€‚ Formulation å‡è®¾è¦æ“ä½œçš„å›¾åƒä¸º $I$:\næˆ‘ä»¬è®¡ç®—ä¸¤ä¸ªå¯¼æ•°ï¼š æ°´å¹³å˜åŒ–ï¼šè¿™æ˜¯é€šè¿‡ç”¨å¥‡æ•°å¤§å°çš„å†…æ ¸ $G_x$ å¯¹ $I$ è¿›è¡Œå·ç§¯è®¡ç®—çš„ã€‚ä¾‹å¦‚ï¼Œå¯¹äºå†…æ ¸å¤§å°ä¸º $3$ ï¼Œ $G_x$ å°†è¢«è®¡ç®—ä¸ºï¼š $$ G_x=\\begin{bmatrix} -1 \u0026amp; 0 \u0026amp; +1\\\\ -2 \u0026amp; 0 \u0026amp; +2\\\\ -1 \u0026amp; 0 \u0026amp; +1 \\end{bmatrix} * I $$ å‚ç›´å˜åŒ–ï¼šè¿™æ˜¯é€šè¿‡ç”¨å¥‡æ•°å¤§å°çš„å†…æ ¸ $G_y$ å¯¹ $I$ è¿›è¡Œå·ç§¯è®¡ç®—çš„ã€‚ä¾‹å¦‚ï¼Œå¯¹äºå†…æ ¸å¤§å°ä¸º $3$ ï¼Œ $G_y$ å°†è¢«è®¡ç®—ä¸ºï¼š $$ G_y = \\begin{bmatrix} -1 \u0026amp; -2 \u0026amp; -1\\\\ 0 \u0026amp; 0 \u0026amp; 0\\\\ +1 \u0026amp; +2 \u0026amp; + 1 \\end{bmatrix} * I $$ åœ¨å›¾åƒçš„æ¯ä¸€ç‚¹ä¸Šï¼Œæˆ‘ä»¬é€šè¿‡ç»“åˆä¸Šè¿°ä¸¤ä¸ªç»“æœè®¡ç®—å‡ºè¯¥ç‚¹çš„æ¢¯åº¦è¿‘ä¼¼å€¼ï¼š $$ G = \\sqrt{G_{x}^{2}+G_{y}^{2}} $$ æœ‰æ—¶ä¼šä½¿ç”¨ä»¥ä¸‹æ›´ç®€å•çš„æ–¹ç¨‹å¼ï¼š $$ G = |G_x|+|G_y| $$ å½“æ ¸çš„å¤§å°ä¸º $3$ æ—¶ï¼Œä¸Šé¢æ˜¾ç¤ºçš„ Sobelæ ¸å¯èƒ½ä¼šäº§ç”Ÿæ˜æ˜¾çš„ä¸å‡†ç¡®ï¼ˆæ¯•ç«Ÿï¼Œ Sobel åªæ˜¯ä¸€ä¸ªå¯¼æ•°çš„è¿‘ä¼¼å€¼ï¼‰ã€‚OpenCVé€šè¿‡ä½¿ç”¨ Scharr() å‡½æ•°æ¥è§£å†³è¿™ç§å¤§å°ä¸º $3$ çš„æ ¸çš„ä¸ç²¾ç¡®æ€§ã€‚è¿™å’Œæ ‡å‡†çš„ Sobel å‡½æ•°ä¸€æ ·å¿«ï¼Œä½†æ¯”å®ƒæ›´å‡†ç¡®ã€‚å®ƒå¯ä»¥å®ç°ä»¥ä¸‹å†…æ ¸ $$ G_x=\\begin{bmatrix} -3 \u0026amp; 0 \u0026amp; +3\\\\ -10 \u0026amp; 0 \u0026amp; +10\\\\ -3 \u0026amp; 0 \u0026amp; +3 \\end{bmatrix}, G_y=\\begin{bmatrix} -3 \u0026amp; -10 \u0026amp; -3\\\\ 0 \u0026amp; 0 \u0026amp; 0\\\\ +3 \u0026amp; +10 \u0026amp; +3 \\end{bmatrix} $$","title":"OpenCV Sobel Derivatives"},{"content":"å½¢æ€å­¦æ“ä½œ ç®€è€Œè¨€ä¹‹ï¼šä¸€å¥—åŸºäºå½¢çŠ¶å¤„ç†å›¾åƒçš„æ“ä½œã€‚å½¢æ€å­¦æ“ä½œå°†ä¸€ä¸ªç»“æ„åŒ–å…ƒç´ åº”ç”¨äºè¾“å…¥å›¾åƒï¼Œå¹¶ç”Ÿæˆä¸€ä¸ªè¾“å‡ºå›¾åƒã€‚ æœ€åŸºæœ¬çš„å½¢æ€å­¦æ“ä½œæ˜¯ã€‚è…èš€å’Œè†¨èƒ€ã€‚å®ƒä»¬æœ‰å¹¿æ³›çš„ç”¨é€”ï¼Œå³ å»é™¤å™ªéŸ³ éš”ç¦»å•ä¸ªå…ƒç´ å’Œè¿æ¥å›¾åƒä¸­ä¸åŒçš„å…ƒç´  å¯»æ‰¾å›¾åƒä¸­çš„å¼ºåº¦å‡¹å‡¸ç‚¹æˆ–æ´ æˆ‘ä»¬å°†ä»¥ä¸‹é¢çš„å›¾åƒä¸ºä¾‹ï¼Œç®€è¦åœ°è§£é‡Šè†¨èƒ€å’Œä¾µèš€ã€‚ Dilationï¼ˆè†¨èƒ€ï¼‰ è¿™ç§æ“ä½œåŒ…æ‹¬å°†å›¾åƒAä¸ä¸€äº›kernel Bè¿›è¡Œå·ç§¯ï¼Œå†…æ ¸å¯ä»¥æœ‰ä»»ä½•å½¢çŠ¶æˆ–å¤§å°ï¼Œé€šå¸¸æ˜¯ä¸€ä¸ªæ­£æ–¹å½¢æˆ–åœ†å½¢ã€‚ kernel Bæœ‰ä¸€ä¸ªå®šä¹‰çš„é”šç‚¹(anchor point)ï¼Œé€šå¸¸æ˜¯æ ¸çš„ä¸­å¿ƒã€‚ å½“kernel Båœ¨å›¾åƒä¸Šæ‰«ææ—¶ï¼Œæˆ‘ä»¬è®¡ç®—å‡ºè¢«Bé‡å çš„æœ€å¤§åƒç´ å€¼ï¼Œå¹¶ç”¨è¯¥æœ€å¤§å€¼æ›¿æ¢é”šç‚¹ä½ç½®çš„å›¾åƒåƒç´ ã€‚æ­£å¦‚ä½ å¯ä»¥æ¨æ–­çš„é‚£æ ·ï¼Œè¿™ç§æœ€å¤§åŒ–çš„æ“ä½œä¼šä½¿å›¾åƒä¸­çš„æ˜äº®åŒºåŸŸ \u0026ldquo;å¢é•¿\u0026rdquo;ï¼ˆå› æ­¤è¢«ç§°ä¸ºè†¨èƒ€ï¼‰ã€‚ è†¨èƒ€æ“ä½œï¼š $dst(x, y)=max(x^{\u0026rsquo;}, y^{\u0026rsquo;})_{:element(x^{\u0026rsquo;}, y^{\u0026rsquo;}) \\ne 0} src(x+x^{\u0026rsquo;}, y+y^{\u0026rsquo;})$ ä»¥ä¸Šé¢çš„å›¾åƒä¸ºä¾‹ã€‚åº”ç”¨è†¨èƒ€çš„æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ° è…èš€ å®ƒåœ¨ç»™å®šå†…æ ¸çš„åŒºåŸŸå†…è®¡ç®—å±€éƒ¨æœ€å°å€¼ã€‚å½“å†…æ ¸Båœ¨å›¾åƒä¸Šè¢«æ‰«ææ—¶ï¼Œæˆ‘ä»¬è®¡ç®—å‡ºè¢«Bé‡å çš„æœ€å°åƒç´ å€¼ï¼Œå¹¶ç”¨è¯¥æœ€å°å€¼æ›¿æ¢é”šç‚¹ä¸‹çš„å›¾åƒåƒç´ ã€‚ è…èš€æ“ä½œä¸ºï¼š$dst(x, y)=min(x^{\u0026rsquo;}, y^{\u0026rsquo;})_{:element(x^{\u0026rsquo;}, y^{\u0026rsquo;}) \\ne 0} src(x+x^{\u0026rsquo;}, y+y^{\u0026rsquo;})$ ä¸è†¨èƒ€çš„ä¾‹å­ç±»ä¼¼ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹åŸå§‹å›¾åƒåº”ç”¨è…èš€ç®—å­ï¼ˆå¦‚ä¸Šå›¾ï¼‰ã€‚ä½ å¯ä»¥åœ¨ä¸‹é¢çš„ç»“æœä¸­çœ‹åˆ°ï¼Œå›¾åƒçš„äº®åŒºå˜è–„äº†ï¼Œè€Œæš—åŒºå˜å¤§äº†ã€‚ Code #include \u0026#34;basic/erosion_dilatation.hpp\u0026#34; namespace basic { namespace erosion_dilatation { namespace impl { Mat src, erosion_dst, dilation_dst; int erosion_elem = 0; int erosion_size = 0; int dilation_elem = 0; int dilation_size = 0; int const max_elem = 2; int const max_kernel_size = 21; int work(int argc, char **argv) { CommandLineParser parser(argc, argv, \u0026#34;{@input | ./images/LinuxLogo.jpg | input image}\u0026#34;); src = imread(samples::findFile(parser.get\u0026lt;String\u0026gt;(\u0026#34;@input\u0026#34;)), IMREAD_COLOR); if (src.empty()) { cout \u0026lt;\u0026lt; \u0026#34;Could not open or find the image!\\n\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Usage: \u0026#34; \u0026lt;\u0026lt; argv[0] \u0026lt;\u0026lt; \u0026#34; \u0026lt;Input image\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl; return -1; } namedWindow(\u0026#34;Erosion Demo\u0026#34;, WINDOW_AUTOSIZE); namedWindow(\u0026#34;Dilation Demo\u0026#34;, WINDOW_AUTOSIZE); moveWindow(\u0026#34;Dilation Demo\u0026#34;, src.cols, 0); createTrackbar(\u0026#34;Element:\\n 0: Rect \\n 1: Cross \\n 2: Ellipse\u0026#34;, \u0026#34;Erosion Demo\u0026#34;, \u0026amp;erosion_elem, max_elem, Erosion); createTrackbar(\u0026#34;Kernel size:\\n 2n +1\u0026#34;, \u0026#34;Erosion Demo\u0026#34;, \u0026amp;erosion_size, max_kernel_size, Erosion); createTrackbar(\u0026#34;Element:\\n 0: Rect \\n 1: Cross \\n 2: Ellipse\u0026#34;, \u0026#34;Dilation Demo\u0026#34;, \u0026amp;dilation_elem, max_elem, Dilation); createTrackbar(\u0026#34;Kernel size:\\n 2n +1\u0026#34;, \u0026#34;Dilation Demo\u0026#34;, \u0026amp;dilation_size, max_kernel_size, Dilation); Erosion(0, 0); Dilation(0, 0); waitKey(0); return 0; } void Erosion(int, void *) { int erosion_type = 0; if (erosion_elem == 0) { erosion_type = MORPH_RECT; } else if (erosion_elem == 1) { erosion_type = MORPH_CROSS; } else if (erosion_elem == 2) { erosion_type = MORPH_ELLIPSE; } Mat element = getStructuringElement( erosion_type, Size(2 * erosion_size + 1, 2 * erosion_size + 1), Point(erosion_size, erosion_size)); erode(src, erosion_dst, element); imshow(\u0026#34;Erosion Demo\u0026#34;, erosion_dst); } void Dilation(int, void *) { int dilation_type = 0; if (dilation_elem == 0) { dilation_type = MORPH_RECT; } else if (dilation_elem == 1) { dilation_type = MORPH_CROSS; } else if (dilation_elem == 2) { dilation_type = MORPH_ELLIPSE; } Mat element = getStructuringElement( dilation_type, Size(2 * dilation_size + 1, 2 * dilation_size + 1), Point(dilation_size, dilation_size)); dilate(src, dilation_dst, element); imshow(\u0026#34;Dilation Demo\u0026#34;, dilation_dst); } } // namespace impl } // namespace erosion_dilatation } // namespace basic ç¨‹åºåŠŸèƒ½ åŠ è½½ä¸€ä¸ªå›¾åƒï¼ˆå¯ä»¥æ˜¯BGRæˆ–ç°åº¦ï¼‰ã€‚ åˆ›å»ºä¸¤ä¸ªçª—å£ï¼ˆä¸€ä¸ªç”¨äºè†¨èƒ€è¾“å‡ºï¼Œå¦ä¸€ä¸ªç”¨äºä¾µèš€ï¼‰ ä¸ºæ¯ä¸ªæ“ä½œåˆ›å»ºä¸€ç»„ä¸¤ä¸ªTraceBar erosion_elem æˆ– dilation_elemï¼ˆçŸ©å½¢ã€åå­—ã€æ¤­åœ†ï¼‰ å†…æ ¸å¤§å°kernel size ç»“æœ References https://docs.opencv.org/4.5.5/db/df6/tutorial_erosion_dilatation.html\n","permalink":"https://fffzlfk.github.io/posts/opencv_erosion_dilatation/","summary":"å½¢æ€å­¦æ“ä½œ ç®€è€Œè¨€ä¹‹ï¼šä¸€å¥—åŸºäºå½¢çŠ¶å¤„ç†å›¾åƒçš„æ“ä½œã€‚å½¢æ€å­¦æ“ä½œå°†ä¸€ä¸ªç»“æ„åŒ–å…ƒç´ åº”ç”¨äºè¾“å…¥å›¾åƒï¼Œå¹¶ç”Ÿæˆä¸€ä¸ªè¾“å‡ºå›¾åƒã€‚ æœ€åŸºæœ¬çš„å½¢æ€å­¦æ“ä½œæ˜¯ã€‚è…èš€å’Œè†¨èƒ€ã€‚å®ƒä»¬æœ‰å¹¿æ³›çš„ç”¨é€”ï¼Œå³ å»é™¤å™ªéŸ³ éš”ç¦»å•ä¸ªå…ƒç´ å’Œè¿æ¥å›¾åƒä¸­ä¸åŒçš„å…ƒç´  å¯»æ‰¾å›¾åƒä¸­çš„å¼ºåº¦å‡¹å‡¸ç‚¹æˆ–æ´ æˆ‘ä»¬å°†ä»¥ä¸‹é¢çš„å›¾åƒä¸ºä¾‹ï¼Œç®€è¦åœ°è§£é‡Šè†¨èƒ€å’Œä¾µèš€ã€‚ Dilationï¼ˆè†¨èƒ€ï¼‰ è¿™ç§æ“ä½œåŒ…æ‹¬å°†å›¾åƒAä¸ä¸€äº›kernel Bè¿›è¡Œå·ç§¯ï¼Œå†…æ ¸å¯ä»¥æœ‰ä»»ä½•å½¢çŠ¶æˆ–å¤§å°ï¼Œé€šå¸¸æ˜¯ä¸€ä¸ªæ­£æ–¹å½¢æˆ–åœ†å½¢ã€‚ kernel Bæœ‰ä¸€ä¸ªå®šä¹‰çš„é”šç‚¹(anchor point)ï¼Œé€šå¸¸æ˜¯æ ¸çš„ä¸­å¿ƒã€‚ å½“kernel Båœ¨å›¾åƒä¸Šæ‰«ææ—¶ï¼Œæˆ‘ä»¬è®¡ç®—å‡ºè¢«Bé‡å çš„æœ€å¤§åƒç´ å€¼ï¼Œå¹¶ç”¨è¯¥æœ€å¤§å€¼æ›¿æ¢é”šç‚¹ä½ç½®çš„å›¾åƒåƒç´ ã€‚æ­£å¦‚ä½ å¯ä»¥æ¨æ–­çš„é‚£æ ·ï¼Œè¿™ç§æœ€å¤§åŒ–çš„æ“ä½œä¼šä½¿å›¾åƒä¸­çš„æ˜äº®åŒºåŸŸ \u0026ldquo;å¢é•¿\u0026rdquo;ï¼ˆå› æ­¤è¢«ç§°ä¸ºè†¨èƒ€ï¼‰ã€‚ è†¨èƒ€æ“ä½œï¼š $dst(x, y)=max(x^{\u0026rsquo;}, y^{\u0026rsquo;})_{:element(x^{\u0026rsquo;}, y^{\u0026rsquo;}) \\ne 0} src(x+x^{\u0026rsquo;}, y+y^{\u0026rsquo;})$ ä»¥ä¸Šé¢çš„å›¾åƒä¸ºä¾‹ã€‚åº”ç”¨è†¨èƒ€çš„æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ° è…èš€ å®ƒåœ¨ç»™å®šå†…æ ¸çš„åŒºåŸŸå†…è®¡ç®—å±€éƒ¨æœ€å°å€¼ã€‚å½“å†…æ ¸Båœ¨å›¾åƒä¸Šè¢«æ‰«ææ—¶ï¼Œæˆ‘ä»¬è®¡ç®—å‡ºè¢«Bé‡å çš„æœ€å°åƒç´ å€¼ï¼Œå¹¶ç”¨è¯¥æœ€å°å€¼æ›¿æ¢é”šç‚¹ä¸‹çš„å›¾åƒåƒç´ ã€‚ è…èš€æ“ä½œä¸ºï¼š$dst(x, y)=min(x^{\u0026rsquo;}, y^{\u0026rsquo;})_{:element(x^{\u0026rsquo;}, y^{\u0026rsquo;}) \\ne 0} src(x+x^{\u0026rsquo;}, y+y^{\u0026rsquo;})$ ä¸è†¨èƒ€çš„ä¾‹å­ç±»ä¼¼ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹åŸå§‹å›¾åƒåº”ç”¨è…èš€ç®—å­ï¼ˆå¦‚ä¸Šå›¾ï¼‰ã€‚ä½ å¯ä»¥åœ¨ä¸‹é¢çš„ç»“æœä¸­çœ‹åˆ°ï¼Œå›¾åƒçš„äº®åŒºå˜è–„äº†ï¼Œè€Œæš—åŒºå˜å¤§äº†ã€‚ Code #include \u0026#34;basic/erosion_dilatation.hpp\u0026#34; namespace basic { namespace erosion_dilatation { namespace impl { Mat src, erosion_dst, dilation_dst; int erosion_elem = 0; int erosion_size = 0; int dilation_elem = 0; int dilation_size = 0; int const max_elem = 2; int const max_kernel_size = 21; int work(int argc, char **argv) { CommandLineParser parser(argc, argv, \u0026#34;{@input | .","title":"OpenCV Erosion Dilatation"},{"content":"ç†è®º Smoothingä¹Ÿå«blurringï¼ˆæ¨¡ç³ŠåŒ–ï¼‰ï¼Œæ˜¯ä¸€ä¸ªç®€å•è€Œå¸¸ç”¨çš„å›¾åƒå¤„ç†æ“ä½œã€‚\nSmoothingæœ‰å¾ˆå¤šåŸå› ã€‚åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬å°†é‡ç‚¹è®¨è®ºå¹³æ»‘æ“ä½œï¼Œä»¥å‡å°‘å™ªéŸ³ã€‚\nä¸ºäº†è¿›è¡Œå¹³æ»‘æ“ä½œï¼Œæˆ‘ä»¬å°†å¯¹æˆ‘ä»¬çš„å›¾åƒåº”ç”¨ä¸€ä¸ªfilterã€‚æœ€å¸¸è§çš„filteræ˜¯çº¿æ€§çš„ï¼Œå…¶ä¸­è¾“å‡ºåƒç´ çš„å€¼ï¼ˆå³ $g(i,j)$ ï¼‰ä¸ºè¾“å…¥åƒç´ å€¼çš„åŠ æƒå’Œï¼ˆå³ $f(i+k,j+l)$ ï¼‰ã€‚\n$$ g(i, j) = \\sum_{k, l}{f(i+k, j+l)h(k, l)} $$\n$h(k,l)$ è¢«ç§°ä¸ºkernelï¼Œå®ƒåªä¸è¿‡æ˜¯filterçš„ç³»æ•°ã€‚è¿™æœ‰åŠ©äºæŠŠæ»¤æ³¢å™¨æƒ³è±¡æˆä¸€ä¸ªåœ¨å›¾åƒä¸Šæ»‘åŠ¨çš„ç³»æ•°çª—å£ã€‚\næ»¤æ³¢å™¨æœ‰å¾ˆå¤šç§ç±»ï¼Œè¿™é‡Œæˆ‘ä»¬å°†æåˆ°æœ€å¸¸ç”¨çš„å‡ ç§ã€‚\nNormalized Box Filterï¼ˆå½’ä¸€åŒ–å—æ»¤æ³¢å™¨ï¼‰ è¿™ä¸ªæ»¤æ³¢å™¨æ˜¯æœ€ç®€å•çš„ï¼Œæ¯ä¸ªè¾“å‡ºåƒç´ éƒ½æ˜¯å…¶å†…æ ¸é‚»å±…çš„å¹³å‡å€¼ï¼ˆæ‰€æœ‰çš„åƒç´ éƒ½æœ‰ç›¸åŒçš„æƒé‡ï¼‰ã€‚ $$ K = \\frac{1}{K_{width} \\cdot k_{height}} \\begin{bmatrix} 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \u0026hellip;\u0026amp; 1\\\\ 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \u0026hellip;\u0026amp; 1\\\\ . \u0026amp; . \u0026amp; . \u0026amp; \u0026hellip;\u0026amp; 1\\\\ 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \u0026hellip;\u0026amp; 1 \\end{bmatrix} $$\nGaussian Filterï¼ˆé«˜æ–¯æ»¤æ³¢å™¨ï¼‰ å¯èƒ½æ˜¯æœ€æœ‰ç”¨çš„æ»¤æ³¢å™¨ï¼ˆå°½ç®¡ä¸æ˜¯æœ€å¿«çš„ï¼‰ã€‚é«˜æ–¯æ»¤æ³¢æ˜¯é€šè¿‡ç”¨é«˜æ–¯å†…æ ¸å¯¹è¾“å…¥é˜µåˆ—ä¸­çš„æ¯ä¸ªç‚¹è¿›è¡Œå·ç§¯ï¼Œç„¶åå°†å®ƒä»¬å…¨éƒ¨ç›¸åŠ æ¥äº§ç”Ÿè¾“å‡ºé˜µåˆ—çš„ã€‚\nè®©æˆ‘ä»¬å›é¡¾ä¸€ä¸‹1D Gaussian kernelæ˜¯ä»€ä¹ˆæ ·å­ï¼š å‡è®¾å›¾åƒæ˜¯ä¸€ç»´çš„ï¼Œä½ å¯ä»¥æ³¨æ„åˆ°ï¼Œä½äºä¸­é—´çš„åƒç´ ä¼šæœ‰æœ€å¤§çš„æƒé‡ã€‚å®ƒçš„é‚»å±…çš„æƒé‡éšç€å®ƒä»¬ä¸ä¸­å¿ƒåƒç´ ä¹‹é—´çš„ç©ºé—´è·ç¦»å¢åŠ è€Œå‡å°‘ã€‚\nä¸€ä¸ªäºŒç»´é«˜æ–¯å¯ä»¥è¡¨ç¤ºä¸ºï¼š $$ G_0(x, y)=Ae^{\\frac{-(x-\\mu_x)^2}{2\\sigma_x^2}+\\frac{-(y-\\mu_y)^2}{2\\sigma_y^2}} $$ å…¶ä¸­ $\\mu$ æ˜¯å¹³å‡å€¼ï¼ˆå³°å€¼ï¼‰ï¼Œ $\\sigma^2$ ä»£è¡¨æ–¹å·®ï¼ˆæ¯ä¸€ä¸ªå˜é‡ $x$ å’Œ $y$ ï¼‰ã€‚\nBilateral Filterï¼ˆåŒè¾¹æ»¤æ³¢å™¨ï¼‰ åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»è§£é‡Šäº†ä¸€äº›ä¸»è¦ç›®æ ‡æ˜¯å¹³æ»‘è¾“å…¥å›¾åƒçš„æ»¤æ³¢å™¨ã€‚ç„¶è€Œï¼Œæœ‰æ—¶è¿™äº›æ»¤æ³¢å™¨ä¸ä»…èƒ½æ¶ˆé™¤å™ªå£°ï¼Œè¿˜ä¼šä½¿è¾¹ç¼˜å˜å¾—å¹³æ»‘ã€‚ä¸ºäº†é¿å…è¿™ç§æƒ…å†µï¼ˆè‡³å°‘åœ¨ä¸€å®šç¨‹åº¦ä¸Šï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªåŒè¾¹æ»¤æ³¢å™¨ã€‚\nç±»ä¼¼äºé«˜æ–¯æ»¤æ³¢å™¨çš„æ–¹å¼ï¼ŒåŒè¾¹æ»¤æ³¢å™¨ä¹Ÿè€ƒè™‘äº†ç›¸é‚»çš„åƒç´ ï¼Œå¹¶ä¸ºæ¯ä¸ªåƒç´ åˆ†é…æƒé‡ã€‚è¿™äº›æƒé‡æœ‰ä¸¤ä¸ªç»„æˆéƒ¨åˆ†ï¼Œç¬¬ä¸€ä¸ªç»„æˆéƒ¨åˆ†ä¸é«˜æ–¯æ»¤æ³¢å™¨ä½¿ç”¨çš„æƒé‡ç›¸åŒã€‚ç¬¬äºŒéƒ¨åˆ†è€ƒè™‘åˆ°äº†ç›¸é‚»åƒç´ å’Œè¢«è¯„ä¼°åƒç´ ä¹‹é—´çš„å¼ºåº¦å·®å¼‚ã€‚\nCode è¿™ä¸ªç¨‹åºæ˜¯åšä»€ä¹ˆçš„ï¼Ÿ åŠ è½½ä¸€å¼ å›¾ç‰‡ åº”ç”¨4ç§ä¸åŒçš„è¿‡æ»¤å™¨ï¼ˆåœ¨ç†è®ºä¸­è§£é‡Šè¿‡çš„ï¼‰ï¼Œå¹¶æŒ‰é¡ºåºæ˜¾ç¤ºè¿‡æ»¤åçš„å›¾ç‰‡ ä»£ç é“¾æ¥ å‡½æ•°è§£é‡Š Normalized Block Filter OpenCV æä¾›äº†blurå‡½æ•°æ¥ç”¨è¿™ä¸ªæ»¤æ³¢å™¨è¿›è¡Œå¹³æ»‘å¤„ç†ã€‚ srcï¼šæºå›¾åƒ dst: ç›®çš„å›¾åƒ ksize: Size(w, h): å®šä¹‰è¦ä½¿ç”¨çš„å†…æ ¸çš„å¤§å°ï¼ˆå®½åº¦ä¸º $w$ åƒç´ ï¼Œé«˜åº¦ä¸º $h$ åƒç´ ï¼‰ã€‚ anchor: Point(-1, -1): è¡¨ç¤ºé”šç‚¹ï¼ˆè¢«è¯„ä¼°çš„åƒç´ ï¼‰ç›¸å¯¹äºé‚»åŸŸçš„ä½ç½®ã€‚å¦‚æœæœ‰ä¸€ä¸ªè´Ÿå€¼ï¼Œé‚£ä¹ˆå†…æ ¸çš„ä¸­å¿ƒè¢«è®¤ä¸ºæ˜¯é”šç‚¹ã€‚ Gaussian Filter functionGaussianBlur srcï¼šæºå›¾åƒ dst: ç›®çš„å›¾åƒ ksize: Size(w, h): è¦ä½¿ç”¨çš„æ ¸çš„å¤§å°ï¼ˆè¦è€ƒè™‘çš„é‚»å±…ï¼‰ã€‚ $w$ å’Œ $h$ å¿…é¡»æ˜¯å¥‡æ•°å’Œæ­£æ•°ï¼Œå¦åˆ™å¤§å°å°†ç”¨ $\\sigma_x$ å’Œ $\\sigma_y$ å‚æ•°è®¡ç®— sigmaXï¼šxçš„æ ‡å‡†åå·®ã€‚å†™æˆ $0$ æ„å‘³ç€ç”¨æ ¸å¤§å°è®¡ç®—çš„ã€‚ sigmaYï¼šyçš„æ ‡å‡†å·®ã€‚å†™ $0$ æ„å‘³ç€æ˜¯ç”¨å†…æ ¸å¤§å°è®¡ç®—çš„ã€‚ Median Filterï¼ˆä¸­å€¼æ»¤æ³¢å™¨ï¼‰ functionmedianBlur srcï¼šæºå›¾åƒ dst: ç›®çš„å›¾åƒ ksizeï¼šå†…æ ¸çš„å¤§å°ï¼ˆåªæœ‰ä¸€ä¸ªæ•°ï¼Œå› ä¸ºæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯æ–¹å½¢çª—å£ï¼‰ï¼Œå¿…é¡»æ˜¯å¥‡æ•°ã€‚ Bilateral Filterï¼ˆåŒè¾¹æ»¤æ³¢ï¼‰ functionbilateralFilter srcï¼šæºå›¾åƒ dst: ç›®çš„å›¾åƒ d: æ¯ä¸ªåƒç´ é‚»åŸŸçš„ç›´å¾„ sigmaColorï¼šè‰²å½©ç©ºé—´çš„æ ‡å‡†åå·® sigmaSpaceï¼šåæ ‡ç©ºé—´ä¸­çš„æ ‡å‡†åå·® ç»“æœ åŸå›¾ å½’ä¸€åŒ–å—æ»¤æ³¢ é«˜æ–¯æ»¤æ³¢ ä¸­å€¼æ»¤æ³¢ åŒè¾¹æ»¤æ³¢ References https://docs.opencv.org/4.5.5/d7/da8/tutorial_table_of_content_imgproc.html\n","permalink":"https://fffzlfk.github.io/posts/opencv_blurring/","summary":"ç†è®º Smoothingä¹Ÿå«blurringï¼ˆæ¨¡ç³ŠåŒ–ï¼‰ï¼Œæ˜¯ä¸€ä¸ªç®€å•è€Œå¸¸ç”¨çš„å›¾åƒå¤„ç†æ“ä½œã€‚\nSmoothingæœ‰å¾ˆå¤šåŸå› ã€‚åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬å°†é‡ç‚¹è®¨è®ºå¹³æ»‘æ“ä½œï¼Œä»¥å‡å°‘å™ªéŸ³ã€‚\nä¸ºäº†è¿›è¡Œå¹³æ»‘æ“ä½œï¼Œæˆ‘ä»¬å°†å¯¹æˆ‘ä»¬çš„å›¾åƒåº”ç”¨ä¸€ä¸ªfilterã€‚æœ€å¸¸è§çš„filteræ˜¯çº¿æ€§çš„ï¼Œå…¶ä¸­è¾“å‡ºåƒç´ çš„å€¼ï¼ˆå³ $g(i,j)$ ï¼‰ä¸ºè¾“å…¥åƒç´ å€¼çš„åŠ æƒå’Œï¼ˆå³ $f(i+k,j+l)$ ï¼‰ã€‚\n$$ g(i, j) = \\sum_{k, l}{f(i+k, j+l)h(k, l)} $$\n$h(k,l)$ è¢«ç§°ä¸ºkernelï¼Œå®ƒåªä¸è¿‡æ˜¯filterçš„ç³»æ•°ã€‚è¿™æœ‰åŠ©äºæŠŠæ»¤æ³¢å™¨æƒ³è±¡æˆä¸€ä¸ªåœ¨å›¾åƒä¸Šæ»‘åŠ¨çš„ç³»æ•°çª—å£ã€‚\næ»¤æ³¢å™¨æœ‰å¾ˆå¤šç§ç±»ï¼Œè¿™é‡Œæˆ‘ä»¬å°†æåˆ°æœ€å¸¸ç”¨çš„å‡ ç§ã€‚\nNormalized Box Filterï¼ˆå½’ä¸€åŒ–å—æ»¤æ³¢å™¨ï¼‰ è¿™ä¸ªæ»¤æ³¢å™¨æ˜¯æœ€ç®€å•çš„ï¼Œæ¯ä¸ªè¾“å‡ºåƒç´ éƒ½æ˜¯å…¶å†…æ ¸é‚»å±…çš„å¹³å‡å€¼ï¼ˆæ‰€æœ‰çš„åƒç´ éƒ½æœ‰ç›¸åŒçš„æƒé‡ï¼‰ã€‚ $$ K = \\frac{1}{K_{width} \\cdot k_{height}} \\begin{bmatrix} 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \u0026hellip;\u0026amp; 1\\\\ 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \u0026hellip;\u0026amp; 1\\\\ . \u0026amp; . \u0026amp; . \u0026amp; \u0026hellip;\u0026amp; 1\\\\ 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \u0026hellip;\u0026amp; 1 \\end{bmatrix} $$\nGaussian Filterï¼ˆé«˜æ–¯æ»¤æ³¢å™¨ï¼‰ å¯èƒ½æ˜¯æœ€æœ‰ç”¨çš„æ»¤æ³¢å™¨ï¼ˆå°½ç®¡ä¸æ˜¯æœ€å¿«çš„ï¼‰ã€‚é«˜æ–¯æ»¤æ³¢æ˜¯é€šè¿‡ç”¨é«˜æ–¯å†…æ ¸å¯¹è¾“å…¥é˜µåˆ—ä¸­çš„æ¯ä¸ªç‚¹è¿›è¡Œå·ç§¯ï¼Œç„¶åå°†å®ƒä»¬å…¨éƒ¨ç›¸åŠ æ¥äº§ç”Ÿè¾“å‡ºé˜µåˆ—çš„ã€‚\nè®©æˆ‘ä»¬å›é¡¾ä¸€ä¸‹1D Gaussian kernelæ˜¯ä»€ä¹ˆæ ·å­ï¼š å‡è®¾å›¾åƒæ˜¯ä¸€ç»´çš„ï¼Œä½ å¯ä»¥æ³¨æ„åˆ°ï¼Œä½äºä¸­é—´çš„åƒç´ ä¼šæœ‰æœ€å¤§çš„æƒé‡ã€‚å®ƒçš„é‚»å±…çš„æƒé‡éšç€å®ƒä»¬ä¸ä¸­å¿ƒåƒç´ ä¹‹é—´çš„ç©ºé—´è·ç¦»å¢åŠ è€Œå‡å°‘ã€‚","title":"OpenCV Blurring"},{"content":"ç¡¬ä»¶ SP(Streaming Processor)ï¼šæµå¤„ç†å™¨ï¼Œæ˜¯GPUæœ€åŸºæœ¬çš„å¤„ç†å•å…ƒï¼Œåœ¨fermiæ¶æ„å¼€å§‹è¢«å«åšCUDA coreã€‚\nSM(Streaming MultiProcessor)ï¼šä¸€ä¸ªSMç”±å¤šä¸ªCUDA coreç»„æˆã€‚\næ¯”å¦‚è¯´ï¼Œå¦‚æœä¸€ä¸ªGPUæœ‰ $4$ ä¸ªSMï¼Œå¹¶ä¸”æ¯ä¸ªSMæœ‰ $768$ ä¸ªSP(Aka CUDA core)ï¼›é‚£ä¹ˆåœ¨æŸä¸€æ—¶åˆ»ï¼ŒçœŸæ­£å¹¶è¡Œè¿è¡Œçš„çº¿ç¨‹æ•°ä¸ä¼šè¶…è¿‡ $4 \\times 768$ ä¸ªã€‚\nè½¯ä»¶ threadsè¢«ç»„ç»‡æˆblocksã€‚ä¸€ä¸ªblockçš„çº¿ç¨‹å¯ä»¥ç”¨1Dimension(x), 2Dimensions(x, y)æˆ–è€…3Dim indexs(x, y, z) ç´¢å¼•ï¼Œ\næ˜¾ç„¶ï¼Œå¦‚æœä½ éœ€è¦ $4 \\times 768$ ä¸ªä»¥ä¸Šçš„threadsçš„è¯ä½ éœ€è¦ $4$ ä¸ªä»¥ä¸Šçš„blocksã€‚blocksä¹Ÿå¯ä»¥ä½¿ç”¨1D, 2Dæˆ–3Dç´¢å¼•ï¼Œè¿™äº›blocksè¢«æ”¾åœ¨ç­‰å¾…é˜Ÿåˆ—ä¸Šè¿›å…¥GPUæ‰§è¡Œã€‚\nWrap å½“ä¸€ä¸ªkernelè¢«æ‰§è¡Œæ—¶ï¼Œgridä¸­çš„çº¿ç¨‹å—è¢«åˆ†é…åˆ°SMä¸Šã€‚ä¸€ä¸ªCUDA coreå¯ä»¥æ‰§è¡Œä¸€ä¸ªthreadï¼Œä¸€ä¸ªSMçš„CUDA coreä¼šåˆ†æˆå‡ ä¸ªwrapï¼Œç”±wrap schedulerè´Ÿè´£è°ƒåº¦ã€‚\nä¸€ä¸ªwrapä¸­çš„çº¿ç¨‹åœ¨åŒä¸€ä¸ªblockä¸­ï¼Œå¦‚æœblockæ‰€å«çº¿ç¨‹æ•°ä¸æ˜¯wrapçš„å¤§å°çš„æ•´æ•°å€ï¼Œé‚£ä¹ˆå¤šå‡ºæ¥çš„é‚£äº›threadæ‰€åœ¨çš„wrapä¸­ï¼Œä¼šå‰©ä½™ä¸€äº›inactiveçš„threadã€‚\nä¸€ä¸ªç®€å•çš„case å¤„ç†ä¸€å¼  $512 \\times 512$ çš„å›¾ç‰‡ã€‚\nå‡è®¾æˆ‘ä»¬å¸Œæœ›ä¸€ä¸ªçº¿ç¨‹å¤„ç†ä¸€ä¸ªåƒç´ pixel(i, j)ã€‚\næˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ¯ $64$ ä¸ªçº¿ç¨‹çš„åŒºå—ã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦ $\\frac{512 \\times 512 }{64} = 4096$ ä¸ªåŒºå—ï¼ˆä¸ºäº†æ‹¥æœ‰ $512 \\times 512 $ ä¸ªçº¿ç¨‹ ï¼‰ã€‚\né€šå¸¸æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å°†çº¿ç¨‹ç»„ç»‡åœ¨2DåŒºå—ä¸­ï¼ˆä¸ºäº†æ›´å®¹æ˜“ç´¢å¼•å›¾åƒåƒç´ ï¼‰ã€‚blockDim= $8 * 8$ ï¼Œæˆ‘æ›´å–œæ¬¢å«å®ƒthreadsPerBlockã€‚\ndim3 threadsPerBlock(8, 8); è¿˜æœ‰2Dçš„gridDim= $64 \\times 64$ ï¼ˆéœ€è¦ $4096$ ä¸ªåŒºå—ï¼‰ã€‚æˆ‘æ›´å–œæ¬¢å«å®ƒnumBlocksã€‚\ndim3 numBlocks(imageWidth/threadPerBlock.x, imageHeight/threadPerBlock.y); è¿™ä¸ªkernelæ˜¯è¿™æ ·å¯åŠ¨çš„ï¼š\nmyKernel \u0026lt;\u0026lt;\u0026lt;numBlocks, threadsPerBlock\u0026gt;\u0026gt;\u0026gt;(/* params for the kernel function */) æœ€åï¼Œä¼šæœ‰ä¸€ä¸ªç±»ä¼¼ $4096$ ä¸ªåŒºå—çš„é˜Ÿåˆ—çš„ä¸œè¥¿ï¼Œå…¶ä¸­ä¸€ä¸ªå—æ­£åœ¨ç­‰å¾…è¢«åˆ†é…åˆ°GPUçš„ä¸€ä¸ªå¤šå¤„ç†å•å…ƒä¸­ï¼Œä»¥è·å¾—å…¶ $64$ ä¸ªçº¿ç¨‹çš„æ‰§è¡Œã€‚\nåœ¨kernelä¸­ï¼Œä¸€ä¸ªçº¿ç¨‹è¦å¤„ç†çš„åƒç´ æ˜¯è¿™æ ·è®¡ç®—çš„ï¼š\nuint i = (blockIdx.x + blockDim.x) + threadIdx.x; uint j = (blockIdx.y + blockDim.y) + threadIdx.y; Reference Understanding CUDA grid dimensions, block dimensions and threads organization (simple explanation) [closed]\nCUDAçš„thread,block,gridå’Œwarp\n","permalink":"https://fffzlfk.github.io/posts/cuda%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/","summary":"ç¡¬ä»¶ SP(Streaming Processor)ï¼šæµå¤„ç†å™¨ï¼Œæ˜¯GPUæœ€åŸºæœ¬çš„å¤„ç†å•å…ƒï¼Œåœ¨fermiæ¶æ„å¼€å§‹è¢«å«åšCUDA coreã€‚\nSM(Streaming MultiProcessor)ï¼šä¸€ä¸ªSMç”±å¤šä¸ªCUDA coreç»„æˆã€‚\næ¯”å¦‚è¯´ï¼Œå¦‚æœä¸€ä¸ªGPUæœ‰ $4$ ä¸ªSMï¼Œå¹¶ä¸”æ¯ä¸ªSMæœ‰ $768$ ä¸ªSP(Aka CUDA core)ï¼›é‚£ä¹ˆåœ¨æŸä¸€æ—¶åˆ»ï¼ŒçœŸæ­£å¹¶è¡Œè¿è¡Œçš„çº¿ç¨‹æ•°ä¸ä¼šè¶…è¿‡ $4 \\times 768$ ä¸ªã€‚\nè½¯ä»¶ threadsè¢«ç»„ç»‡æˆblocksã€‚ä¸€ä¸ªblockçš„çº¿ç¨‹å¯ä»¥ç”¨1Dimension(x), 2Dimensions(x, y)æˆ–è€…3Dim indexs(x, y, z) ç´¢å¼•ï¼Œ\næ˜¾ç„¶ï¼Œå¦‚æœä½ éœ€è¦ $4 \\times 768$ ä¸ªä»¥ä¸Šçš„threadsçš„è¯ä½ éœ€è¦ $4$ ä¸ªä»¥ä¸Šçš„blocksã€‚blocksä¹Ÿå¯ä»¥ä½¿ç”¨1D, 2Dæˆ–3Dç´¢å¼•ï¼Œè¿™äº›blocksè¢«æ”¾åœ¨ç­‰å¾…é˜Ÿåˆ—ä¸Šè¿›å…¥GPUæ‰§è¡Œã€‚\nWrap å½“ä¸€ä¸ªkernelè¢«æ‰§è¡Œæ—¶ï¼Œgridä¸­çš„çº¿ç¨‹å—è¢«åˆ†é…åˆ°SMä¸Šã€‚ä¸€ä¸ªCUDA coreå¯ä»¥æ‰§è¡Œä¸€ä¸ªthreadï¼Œä¸€ä¸ªSMçš„CUDA coreä¼šåˆ†æˆå‡ ä¸ªwrapï¼Œç”±wrap schedulerè´Ÿè´£è°ƒåº¦ã€‚\nä¸€ä¸ªwrapä¸­çš„çº¿ç¨‹åœ¨åŒä¸€ä¸ªblockä¸­ï¼Œå¦‚æœblockæ‰€å«çº¿ç¨‹æ•°ä¸æ˜¯wrapçš„å¤§å°çš„æ•´æ•°å€ï¼Œé‚£ä¹ˆå¤šå‡ºæ¥çš„é‚£äº›threadæ‰€åœ¨çš„wrapä¸­ï¼Œä¼šå‰©ä½™ä¸€äº›inactiveçš„threadã€‚\nä¸€ä¸ªç®€å•çš„case å¤„ç†ä¸€å¼  $512 \\times 512$ çš„å›¾ç‰‡ã€‚\nå‡è®¾æˆ‘ä»¬å¸Œæœ›ä¸€ä¸ªçº¿ç¨‹å¤„ç†ä¸€ä¸ªåƒç´ pixel(i, j)ã€‚\næˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ¯ $64$ ä¸ªçº¿ç¨‹çš„åŒºå—ã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦ $\\frac{512 \\times 512 }{64} = 4096$ ä¸ªåŒºå—ï¼ˆä¸ºäº†æ‹¥æœ‰ $512 \\times 512 $ ä¸ªçº¿ç¨‹ ï¼‰ã€‚\né€šå¸¸æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å°†çº¿ç¨‹ç»„ç»‡åœ¨2DåŒºå—ä¸­ï¼ˆä¸ºäº†æ›´å®¹æ˜“ç´¢å¼•å›¾åƒåƒç´ ï¼‰ã€‚blockDim= $8 * 8$ ï¼Œæˆ‘æ›´å–œæ¬¢å«å®ƒthreadsPerBlockã€‚\ndim3 threadsPerBlock(8, 8); è¿˜æœ‰2Dçš„gridDim= $64 \\times 64$ ï¼ˆéœ€è¦ $4096$ ä¸ªåŒºå—ï¼‰ã€‚æˆ‘æ›´å–œæ¬¢å«å®ƒnumBlocksã€‚","title":"Cudaè½¯ä»¶æ¶æ„"},{"content":"A - Square String? æ€è·¯ åˆ¤æ–­$s[0.. \\frac{n}{2}]$ å’Œ $s[\\frac{n}{2}..n]$æ˜¯å¦ç›¸ç­‰\nä»£ç  use std::io::stdin; #[derive(Default)] struct Scanner { buffer: Vec\u0026lt;String\u0026gt;, } impl Scanner { fn next\u0026lt;T: std::str::FromStr\u0026gt;(\u0026amp;mut self) -\u0026gt; T { loop { if let Some(token) = self.buffer.pop() { return token.parse().ok().expect(\u0026#34;Failed parse\u0026#34;); } let mut input = String::new(); stdin().read_line(\u0026amp;mut input).expect(\u0026#34;Failed read\u0026#34;); self.buffer = input.split_whitespace().rev().map(String::from).collect(); } } } fn solve(scan: \u0026amp;mut Scanner) { let t: usize = scan.next(); for _ in 0..t { let s: String = scan.next(); let n = s.len(); if s[..n / 2].to_owned() == s[n / 2..].to_owned() { println!(\u0026#34;YES\u0026#34;); } else { println!(\u0026#34;NO\u0026#34;); } } } fn main() { let mut scan = Scanner::default(); solve(\u0026amp;mut scan); } B - Squares and Cubes æ€è·¯ ä½¿ç”¨HashSetå°±èƒ½è¿‡\nä»£ç  use std::io::stdin; #[derive(Default)] struct Scanner { buffer: Vec\u0026lt;String\u0026gt;, } impl Scanner { fn next\u0026lt;T: std::str::FromStr\u0026gt;(\u0026amp;mut self) -\u0026gt; T { loop { if let Some(token) = self.buffer.pop() { return token.parse().ok().expect(\u0026#34;Failed parse\u0026#34;); } let mut input = String::new(); stdin().read_line(\u0026amp;mut input).expect(\u0026#34;Failed read\u0026#34;); self.buffer = input.split_whitespace().rev().map(String::from).collect(); } } } use std::collections::HashSet; fn solve(scan: \u0026amp;mut Scanner) { let t: usize = scan.next(); for _ in 0..t { let n: usize = scan.next(); let mut st = HashSet::new(); let c = f64::cbrt(n as f64) as usize; let s = f64::sqrt(n as f64) as usize; for i in 1..=c { st.insert(i * i); st.insert(i * i * i); } for i in c..=s { st.insert(i * i); } println!(\u0026#34;{}\u0026#34;, st.len()); } } fn main() { let mut scan = Scanner::default(); solve(\u0026amp;mut scan); } C - Wrong Addition æ€è·¯ æ¨¡æ‹Ÿ\nä»£ç  use std::io::stdin; #[derive(Default)] struct Scanner { buffer: Vec\u0026lt;String\u0026gt;, } impl Scanner { fn next\u0026lt;T: std::str::FromStr\u0026gt;(\u0026amp;mut self) -\u0026gt; T { loop { if let Some(token) = self.buffer.pop() { return token.parse().ok().expect(\u0026#34;Failed parse\u0026#34;); } let mut input = String::new(); stdin().read_line(\u0026amp;mut input).expect(\u0026#34;Failed read\u0026#34;); self.buffer = input.split_whitespace().rev().map(String::from).collect(); } } } fn solve(scan: \u0026amp;mut Scanner) { let t: usize = scan.next(); \u0026#39;outer: for _ in 0..t { let mut a: usize = scan.next(); let mut s: usize = scan.next(); let mut b: Vec\u0026lt;u8\u0026gt; = vec![]; while s != 0 { let mut y = s % 10; let x = a % 10; if y \u0026gt;= x { b.push((y - x) as u8 + b\u0026#39;0\u0026#39;); } else { s /= 10; y += 10 * (s % 10); if y \u0026gt; x \u0026amp;\u0026amp; y \u0026gt;= 10 \u0026amp;\u0026amp; y \u0026lt;= 19 { b.push((y - x) as u8 + b\u0026#39;0\u0026#39;); } else { println!(\u0026#34;-1\u0026#34;); continue \u0026#39;outer; } } a /= 10; s /= 10; } if a != 0 { println!(\u0026#34;-1\u0026#34;); continue; } b.reverse(); let b: usize = String::from_utf8_lossy(\u0026amp;b).parse().unwrap(); println!(\u0026#34;{}\u0026#34;, b); } } fn main() { let mut scan = Scanner::default(); solve(\u0026amp;mut scan); } D - New Year\u0026rsquo;s Problem æ€è·¯ äºŒåˆ†ç­”æ¡ˆï¼Œæ³¨æ„æœ€å¤šåªèƒ½visit $n-1$ ä¸ªè½¬æ¢ä¸ºå­˜åœ¨ä¸€ä¸ªå•†åº—ä¹°ä¸¤ä¸ªäººçš„ç¤¼ç‰©ã€‚\nä»£ç  use std::io::stdin; #[derive(Default)] struct Scanner { buffer: Vec\u0026lt;String\u0026gt;, } impl Scanner { fn next\u0026lt;T: std::str::FromStr\u0026gt;(\u0026amp;mut self) -\u0026gt; T { loop { if let Some(token) = self.buffer.pop() { return token.parse().ok().expect(\u0026#34;Failed parse\u0026#34;); } let mut input = String::new(); stdin().read_line(\u0026amp;mut input).expect(\u0026#34;Failed read\u0026#34;); self.buffer = input.split_whitespace().rev().map(String::from).collect(); } } } fn solve(scan: \u0026amp;mut Scanner) { let n: usize = scan.next(); let m: usize = scan.next(); let mut p: Vec\u0026lt;Vec\u0026lt;u32\u0026gt;\u0026gt; = vec![vec![0; m]; n]; for row in p.iter_mut() { for col in row.iter_mut() { *col = scan.next::\u0026lt;u32\u0026gt;(); } } let (mut l, mut r) = (0, 1e9 as u32); while l \u0026lt; r { let mid = (l + r + 1) \u0026gt;\u0026gt; 1; if check(\u0026amp;p, mid) { l = mid; } else { r = mid-1; } } println!(\u0026#34;{}\u0026#34;, l); } fn check(p: \u0026amp;Vec\u0026lt;Vec\u0026lt;u32\u0026gt;\u0026gt;, mid: u32) -\u0026gt; bool { let mut ok = vec![false; p[0].len()]; let mut has_pair = false; for i in 0..p.len() { let mut ok_cols = 0; for j in 0..p[0].len() { if p[i][j] \u0026gt;= mid { ok[j] = true; ok_cols += 1; } } has_pair = has_pair || ok_cols \u0026gt;= 2; } has_pair \u0026amp;\u0026amp; ok.iter().all(|\u0026amp;x| x) } fn main() { let mut scan = Scanner::default(); let t: usize = scan.next(); for _ in 0..t { solve(\u0026amp;mut scan); } } ","permalink":"https://fffzlfk.github.io/posts/codeforces-762/","summary":"Codeforces Round #762 (Div. 3)","title":"CodeForces 762"},{"content":"æ¨¡æ¿å…ƒç¼–ç¨‹ #include \u0026lt;cstdint\u0026gt; template \u0026lt;uint64_t N\u0026gt; struct Fact { enum { Value = N * Fact\u0026lt;N - 1\u0026gt;::Value }; }; template \u0026lt;\u0026gt; struct Fact\u0026lt;1\u0026gt; { enum { Value = 1 }; }; template \u0026lt;uint64_t N\u0026gt; struct Fib { enum { Value = Fib\u0026lt;N - 1\u0026gt;::Value + Fib\u0026lt;N - 2\u0026gt;::Value }; }; template \u0026lt;\u0026gt; struct Fib\u0026lt;1\u0026gt; { enum { Value = 1 }; }; template \u0026lt;\u0026gt; struct Fib\u0026lt;2\u0026gt; { enum { Value = 2 }; }; template \u0026lt;uint64_t base, uint64_t exp\u0026gt; struct Pow { enum { Value = base * Pow\u0026lt;base, exp - 1\u0026gt;::Value }; }; template \u0026lt;uint64_t base\u0026gt; struct Pow\u0026lt;base, 1\u0026gt; { enum { Value = base }; }; int main() { auto val1 = Fact\u0026lt;10\u0026gt;::Value; auto val2 = Fib\u0026lt;20\u0026gt;::Value; auto val3 = Pow\u0026lt;2, 10\u0026gt;::Value; return 0; } å¦‚ä¸Šä»£ç ç‰‡æ®µæˆ‘ä»¬æ˜¯ç”¨æ¨¡æ¿å®ç°äº†åœ¨ç¼–è¯‘æœŸçš„è®¡ç®—ï¼ˆC++11èµ·æ”¯æŒï¼‰ã€‚\nconstexpr ä»C++14å¼€å§‹ï¼Œæ”¯æŒä½¿ç”¨consrexpræ¥ä¿®é¥°å‡½æ•°ï¼Œè¿™æ ·å¦‚æœæˆ‘ä»¬ç»™è¿™ä¸ªå‡½æ•°ä¼ å…¥å¸¸é‡ï¼Œé‚£ä¹ˆå°†ä¼šåœ¨ç¼–è¯‘å™¨è®¡ç®—ï¼›å¦‚æœä¼ å…¥å˜é‡ï¼Œåªèƒ½åœ¨è¿è¡ŒæœŸè®¡ç®—ã€‚è¿™ä¸€ç‚¹å¯ä»¥ä»ç”Ÿæˆçš„æ±‡ç¼–ä»£ç çœ‹å‡ºã€‚\n#include \u0026lt;cstdint\u0026gt; constexpr auto fact(uint64_t n) { if (n == 1) { return n; } return fact(n-1) * n; } int main() { constexpr auto val = fact(10); return 0; } fact(int): push rbp mov rbp, rsp sub rsp, 16 mov DWORD PTR [rbp-4], edi cmp DWORD PTR [rbp-4], 1 jne .L2 mov eax, DWORD PTR [rbp-4] jmp .L3 .L2: mov eax, DWORD PTR [rbp-4] sub eax, 1 mov edi, eax call fact(int) imul eax, DWORD PTR [rbp-4] .L3: leave ret main: push rbp mov rbp, rsp sub rsp, 32 mov DWORD PTR [rbp-20], edi mov QWORD PTR [rbp-32], rsi mov DWORD PTR [rbp-4], 3628800 mov eax, DWORD PTR [rbp-20] mov edi, eax call fact(int) mov DWORD PTR [rbp-8], eax mov eax, 0 leave ret constexprä¸æ¨¡æ¿å…ƒç¼–ç¨‹çš„æ¯”è¾ƒ #include \u0026lt;cstdint\u0026gt; constexpr auto fib(uint64_t n) { if (n \u0026lt;= 1) { return 1; } return fib(n-1) + fib(n-2); } int main(int argc, char *argv[]) { constexpr auto val = fib(40); return 0; } å¦‚æœæˆ‘ä»¬é‡‡ç”¨constexprè¿™ç§å†™æ³•çš„è¯ï¼Œç¼–è¯‘å™¨ä¼šæŠ¥é”™ï¼Œè¿™æ˜¯å› ä¸ºè¿™ä¸ªå‡½æ•°é‡å¤è®¡ç®—æ¯”è¾ƒå¤šã€‚\nè€Œæˆ‘ä»¬ä½¿ç”¨ä¸‹é¢æ¨¡æ¿å…ƒç¼–ç¨‹è¿™ç§å†™æ³•çš„è¯å°±å¯ä»¥ï¼Œè¿™æ˜¯å› ä¸ºç¼–è¯‘å™¨ä¼šå¯¹å…¶è¿›è¡Œè®°å¿†åŒ–ï¼Œçœå»äº†é‡å¤çš„è®¡ç®—ã€‚\næœªæ¥ç¼–è¯‘å™¨å¯èƒ½ä¼šæ”¯æŒconstexprå‡½æ•°çš„è®°å¿†åŒ–ã€‚\ntemplate\u0026lt;uint64_t N\u0026gt; struct Fib { enum { Value = Fib\u0026lt;N-1\u0026gt;::Value + Fib\u0026lt;N-2\u0026gt;::Value }; }; template\u0026lt;\u0026gt; struct Fib\u0026lt;1\u0026gt; { enum { Value = 1 }; }; template\u0026lt;\u0026gt; struct Fib\u0026lt;0\u0026gt; { enum { Value = 1}; }; int main(int argc, char *argv[]) { auto val = Fib\u0026lt;40\u0026gt;::Value; return 0; } constexpr if C++17å¼€å§‹æ”¯æŒconstexpr ifï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥ç®€åŒ–æ¨¡æ¿å…ƒç¼–ç¨‹çš„å†™æ³•ï¼Œçœå»äº†å®ä¾‹åŒ–åˆå§‹å€¼ã€‚è¿™æ ·çš„è¯å³ä½¿æ¯”è¾ƒå¤æ‚çš„è®¡ç®—ä¹Ÿèƒ½å¤Ÿæ”¯æŒï¼Œå› ä¸ºæ¨¡æ¿å…ƒç¼–ç¨‹æœ‰è®°å¿†åŒ–ã€‚\n#include \u0026lt;cstdint\u0026gt; template\u0026lt;uint64_t N\u0026gt; struct Fib { static constexpr uint64_t Value = []{ if constexpr (N \u0026lt;= 1) { return 1; } else { return Fib\u0026lt;N-1\u0026gt;::Value + Fib\u0026lt;N-2\u0026gt;::Value; } }(); }; int main(int argc, char *argv[]) { constexpr auto val = Fib\u0026lt;40\u0026gt;::Value; return 0; } ","permalink":"https://fffzlfk.github.io/posts/%E4%BB%8E%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%E5%88%B0constexprc++/","summary":"C++å…ƒç¼–ç¨‹","title":"ä»æ¨¡æ¿å…ƒç¼–ç¨‹åˆ°constexpr(C++)"},{"content":"åˆ›å»ºå‹ å•ä¾‹æ¨¡å¼ é¥¿æ±‰å¼ package singleton type Singleton struct{} var singleton *Singleton func init() { singleton = \u0026amp;Singleton{} } // é¥¿æ±‰å¼ func GetInstance() *Singleton { return singleton } æ‡’æ±‰å¼ package singleton import \u0026#34;sync\u0026#34; var ( LazySingleton *Singleton once = \u0026amp;sync.Once{} ) // æ‡’æ±‰å¼ func GetLazyInstance() *Singleton { if LazySingleton == nil { once.Do(func() { LazySingleton = new(Singleton) }) } return singleton } æµ‹è¯•ç»“æœ ~/go_files/temp/scheme/singleton Â» go test -benchmem -bench=\u0026#34;.\u0026#34; -v fffzlfk@DESKTOP-U99TE3D === RUN TestGetInstance --- PASS: TestGetInstance (0.00s) === RUN TestGetLazyInstance --- PASS: TestGetLazyInstance (0.00s) goos: linux goarch: amd64 pkg: scheme/singleton cpu: 11th Gen Intel(R) Core(TM) i5-1135G7 @ 2.40GHz BenchmarkGetInstanceParallel BenchmarkGetInstanceParallel-8 1000000000 0.2773 ns/op 0 B/op 0 allocs/op BenchmarkGetLazyInstanceParallel BenchmarkGetLazyInstanceParallel-8 1000000000 0.8395 ns/op 0 B/op 0 allocs/op PASS ok scheme/singleton 1.244s å¯ä»¥çœ‹åˆ°é¥¿æ±‰å¼æ€§èƒ½å¥½ä¸€ç‚¹\n","permalink":"https://fffzlfk.github.io/posts/go%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","summary":"Go Design Scheme","title":"Goè®¾è®¡æ¨¡å¼"},{"content":"åŸºæœ¬socketå‡½æ•° åˆ›å»ºç½‘ç»œç«¯ç‚¹ åˆ›å»ºsocketæè¿°ç¬¦ int socket (int family, int type, int protocol) Socketåœ°å€ TCP/IPåè®®çš„socketåœ°å€ struct sockaddr_in { short sin_family; /*AF_INET*/ u_short sin_port; /*ç«¯å£å·ï¼Œç½‘ç»œå­—èŠ‚é¡ºåº*/ struct n_addr sin_addr; /*IPåœ°å€ï¼Œç½‘ç»œå­—èŠ‚é¡ºåº*/ char sin_zero[8]; /*å¡«å……å­—èŠ‚ï¼Œå¿…é¡»ä¸ºå…¨é›¶*/ }; struct in_addr { union { struct { u_char s_b1,s_b2,s_b3,s_b4; } S_un_b; struct { u_short s_w1,s_w2; } S_un_w; u_long S_addr; } S_un; }; åœ°å€è½¬æ¢å‡½æ•° å­—ç¬¦ä¸²å½¢å¼åœ°å€è½¬æ¢ä¸ºç½‘ç»œåœ°å€å½¢å¼inet_aton(const char *cp,struct in_addr *inp); ç½‘ç»œåœ°å€è½¬æ¢ä¸ºå­—ç¬¦ä¸²åœ°å€å½¢å¼char* inet_ntoa(struct in_addr in); å­—èŠ‚é¡ºåº ä¸»æœºå­—èŠ‚é¡ºåº little-endianä½å­—èŠ‚åœ¨å‰ big-endiané«˜å­—èŠ‚åœ¨å‰ ç½‘ç»œå­—èŠ‚é¡ºåº é‡‡ç”¨big-endiané¡ºåº\nä¸»æœºå­—èŠ‚é¡ºåºå’Œç½‘ç»œå­—èŠ‚é¡ºåºçš„è½¬æ¢ unsigned short int htons(unsigned short int hostshort) unsigned long int htonl(unsigned long int hotlong) unsigned short int ntohs(unsigned short int netshort) unsigned long int ntohl(unsigned long int netlong) è¿æ¥æœåŠ¡å™¨ int connect(int sockfd,struct sockaddr *servaddr,int addrlen) ç»‘å®šæœåŠ¡å™¨åœ°å€å’Œç«¯å£ int bind(int sockfd,struct sockaddr *myaddr,int addrlen); åœ°å€å¯é‡ç”¨ åœ¨bindä¹‹å‰\nint on = 1; setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, \u0026amp;on, sizeof(on)); ç›‘å¬ç«¯å£ int listen(int sockfd,int backlog) sockfdï¼å·²ç»‘å®šçš„socketæè¿°ç¬¦ backlogï¼ä»¥å®Œæˆè¿æ¥ï¼Œç­‰å¾…æ¥å—çš„é˜Ÿåˆ—é•¿åº¦ æ¥æ”¶å®¢æˆ·ç«¯è¿æ¥ int accept(int sockfd,struct sockaddr *clientaddr,int addrlen); ä»£ç ç¤ºä¾‹ server #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #define MAXDATASIZE 128 #define PORT 3000 #define BACKLOG 5 int main(int argc, char **argv) { int sockfd, new_fd, nbytes, sin_size; char buf[MAXDATASIZE]; struct sockaddr_in srvaddr, clientaddr; // 1.åˆ›å»ºç½‘ç»œç«¯ç‚¹ sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd == -1) { printf(\u0026#34;can;t create socket\\n\u0026#34;); exit(1); } if (argc == 2) { int on = 1; setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, \u0026amp;on, sizeof(on)); printf(\u0026#34;reuse addr\\n\u0026#34;); } //å¡«å……åœ°å€ bzero(\u0026amp;srvaddr, sizeof(srvaddr)); srvaddr.sin_family = AF_INET; srvaddr.sin_port = htons(PORT); srvaddr.sin_addr.s_addr = htonl(INADDR_ANY); /* if(inet_aton(argv[1],\u0026amp;srvaddr.sin_addr)==-1){ printf(\u0026#34;addr convert error\\n\u0026#34;); exit(1); } */ // 2.ç»‘å®šæœåŠ¡å™¨åœ°å€å’Œç«¯å£ if (bind(sockfd, (struct sockaddr *)\u0026amp;srvaddr, sizeof(struct sockaddr)) == -1) { printf(\u0026#34;bind error\\n\u0026#34;); exit(1); } // 3. ç›‘å¬ç«¯å£ if (listen(sockfd, BACKLOG) == -1) { printf(\u0026#34;listen error\\n\u0026#34;); exit(1); } for (;;) { // 4.æ¥å—å®¢æˆ·ç«¯è¿æ¥ sin_size = sizeof(struct sockaddr_in); if ((new_fd = accept(sockfd, (struct sockaddr *)\u0026amp;clientaddr, \u0026amp;sin_size)) == -1) { printf(\u0026#34;accept error\\n\u0026#34;); continue; } printf(\u0026#34;client addr:%s %d\\n\u0026#34;, inet_ntoa(clientaddr.sin_addr), ntohs(clientaddr.sin_port)); // 5.æ¥æ”¶è¯·æ±‚ getchar(); nbytes = read(new_fd, buf, MAXDATASIZE); buf[nbytes] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;client:%s\\n\u0026#34;, buf); // 6.å›é€å“åº” sprintf(buf, \u0026#34;wellcome!\u0026#34;); write(new_fd, buf, strlen(buf)); //å…³é—­socket close(new_fd); } close(sockfd); return 0; } client #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;netdb.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #define MAXDATASIZE 128 #define PORT 3000 int addr_conv(char *address, struct in_addr *inaddr); int main(int argc, char **argv) { int sockfd, nbytes; int port = PORT; char buf[MAXDATASIZE]; struct sockaddr_in srvaddr; if (argc != 2 \u0026amp;\u0026amp; argc != 3) { printf( \u0026#34;usage:./client hostname|ip. Or usage:./client hostname|ip port\\n\u0026#34;); exit(0); } if (argc == 3) port = atoi(argv[2]); // 1.åˆ›å»ºç½‘ç»œç«¯ç‚¹ sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd == -1) { printf(\u0026#34;can;t create socket\\n\u0026#34;); exit(1); } //æŒ‡å®šæœåŠ¡å™¨åœ°å€ï¼ˆæœ¬åœ°socketåœ°å€é‡‡ç”¨é»˜è®¤å€¼ï¼‰ bzero(\u0026amp;srvaddr, sizeof(srvaddr)); srvaddr.sin_family = AF_INET; srvaddr.sin_port = htons(port); /* if(inet_aton(\u0026#34;127.0.0.1\u0026#34;,\u0026amp;srvaddr.sin_addr)==-1){ printf(\u0026#34;addr convert error\\n\u0026#34;); exit(1); } */ if (addr_conv(argv[1], \u0026amp;srvaddr.sin_addr) == -1) { perror(strerror(errno)); } // 2.è¿æ¥æœåŠ¡å™¨ if (connect(sockfd, (struct sockaddr *)\u0026amp;srvaddr, sizeof(struct sockaddr)) == -1) { printf(\u0026#34;connect error\\n\u0026#34;); exit(1); } // 3.å‘é€è¯·æ±‚ sprintf(buf, \u0026#34;hello\u0026#34;); write(sockfd, buf, strlen(buf)); sprintf(buf, \u0026#34;hello2\u0026#34;); write(sockfd, buf, strlen(buf)); sprintf(buf, \u0026#34;hello3\u0026#34;); write(sockfd, buf, strlen(buf)); // 4.æ¥æ”¶å“åº” if ((nbytes = read(sockfd, buf, MAXDATASIZE)) == -1) { printf(\u0026#34;read error\\n\u0026#34;); exit(1); } buf[nbytes] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;srv respons:%s\\n\u0026#34;, buf); //å…³é—­socket close(sockfd); return 0; } int addr_conv(char *address, struct in_addr *inaddr) { struct hostent *he; if (inet_aton(address, inaddr) == 1) { printf(\u0026#34;call inet_aton sucess.\\n\u0026#34;); return 0; } printf(\u0026#34;call inet_aton fail.\\n\u0026#34;); he = gethostbyname(address); if (he != NULL) { printf(\u0026#34;call gethostbyname sucess.\\n\u0026#34;); *inaddr = *((struct in_addr *)(he-\u0026gt;h_addr_list[0])); return 0; } return -1; } é«˜çº§socketå‡½æ•° DHCP åŠ¨æ€ä¸»æœºé…ç½®åè®®ï¼ˆDynamic Host Configuration Protocolï¼‰\nåˆ†é…æ–¹å¼ è‡ªåŠ¨åˆ†é… åŠ¨æ€åˆ†é… äººå·¥åˆ†é… DHCPè¿‡ç¨‹ åŸŸåè®¿é—® åŸŸåç³»ç»Ÿâ€”â€”DNS åŸŸåæŸ¥æ‰¾è¿‡ç¨‹ åŸŸååˆ°IPçš„è½¬æ¢å‡½æ•° struct hostent* gethostbyname(const char *name) struct hostent{ char\th_name;\t/*ä¸»æœºæ­£å¼åç§°*/ char\t**h_aliases;\t/*åˆ«ååˆ—è¡¨ï¼Œä»¥NULLç»“æŸ*/ int h_addrtype;\t/*ä¸»æœºåœ°å€ç±»å‹ï¼šAF_INET*/ int h_length;\t/*ä¸»æœºåœ°å€é•¿åº¦ï¼š4å­—èŠ‚32ä½*/ char **h_addr_list;\t/*ä¸»æœºç½‘ç»œåœ°å€åˆ—è¡¨ï¼Œä»¥NULLç»“æŸ*/ } #define h_addr h_addr_list[0]; //ä¸»æœºçš„ç¬¬ä¸€ä¸ªç½‘ç»œåœ°å€ ç¤ºä¾‹ä»£ç \n#include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;netdb.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main(int argc, char **argv) { if (argc != 2) { printf(\u0026#34;invalid args\\n\u0026#34;); } struct hostent *he; he = gethostbyname(argv[1]); if (he != NULL) { printf(\u0026#34;h_name:%s\\n\u0026#34;, he-\u0026gt;h_name); printf(\u0026#34;h_length:%d\\n\u0026#34;, he-\u0026gt;h_length); printf(\u0026#34;h_addrtype:%d\\n\u0026#34;, he-\u0026gt;h_addrtype); int i; for (i = 0; he-\u0026gt;h_aliases[i] != NULL; i++) printf(\u0026#34;h_aliases[%d]:%s\\n\u0026#34;, i + 1, he-\u0026gt;h_aliases[i]); printf(\u0026#34;first ip:%s\\r\\n\u0026#34;, inet_ntoa(*((struct in_addr *)he-\u0026gt;h_addr))); for (i = 0; he-\u0026gt;h_addr_list[i] != NULL; i++) printf(\u0026#34;ip%d:%s\\n\u0026#34;, i + 1, inet_ntoa(*(struct in_addr *)he-\u0026gt;h_addr_list[i])); } else { printf(\u0026#34;gethostbyname error: %s\\n\u0026#34;, hstrerror(h_errno)); } return 0; } IPåˆ°åŸŸåçš„è½¬æ¢å‡½æ•° æŸ¥è¯¢IPå¯¹åº”çš„åŸŸå struct hostent *gethostbyaddr(const char *addr, size_t len, in family); ç¤ºä¾‹ä»£ç  #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;netdb.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; int main(int argc, char *argv[]) { struct in_addr addr; inet_aton(argv[1], \u0026amp;addr); struct hostent *he; he = gethostbyaddr((char *)\u0026amp;addr, 4, AF_INET); if (he != NULL) { printf(\u0026#34;h_name: %s\\n\u0026#34;, he-\u0026gt;h_name); } else { printf(\u0026#34;gethostbyaddr error: %s\u0026#34;, hstrerror(h_errno)); } return 0; } é«˜çº§Socketå‡½æ•° recvå’Œsend int recv(int sockfd,void* buf,int len, int flags); int send(int sockfd,void* buf,int len,int flags); flags MSG_DONTROUTEä¸è·¯ç”±â€”â€”ä¸»æœºåœ¨æœ¬åœ°ç½‘ï¼Œä¸éœ€è·¯ç”±ã€‚å¤šç½‘å¡æ—¶ï¼Œé€ä¸ªæœç´¢ MSG_OBBå¸¦å¤–æ•°æ®â€”â€”ç´§æ€¥æ•°æ® MSG_PEEKä¸ä»ç¼“å­˜åŒºç§»èµ°æ•°æ®â€”â€”å¤šè¿›ç¨‹å…±äº«æ•°æ®ï¼Œè¿˜å¯ä»¥ç”¨æ¥æŸ¥çœ‹ç¼“å­˜åŒºæ•°æ® MSG_WAITALLç­‰å¾…æ‰€æœ‰æ•°æ®â€”â€”å‘ç°æ–‡ä»¶ç»“æŸç¬¦æ—¶ï¼ˆCrtl+Dï¼‰ï¼Œå‡½æ•°ä¹Ÿç»“æŸ shutdownå…³é—­è¿æ¥ int shutdown(int sockfd,int howto); howto = 0å¯¹åæ¥æ¥æ”¶åˆ°çš„æ•°æ®è¿”å›ç¡®è®¤åä¸¢å¼ƒ howto = 1ç»§ç»­å‘é€å‘é€ç¼“å†²åŒºæœªå‘é€å®Œçš„æ•°æ®ï¼Œç„¶åå‘é€FINå­—æ®µå…³é—­å†™é€šé“ howto = 2å…³é—­è¯»å†™é€šé“ï¼Œä»»ä½•è¿›ç¨‹ä¸èƒ½å†æ“ä½œè¿™ä¸ªsocket ä¸closeçš„åŒºåˆ« shutdownæ“ä½œè¿æ¥é€šé“ï¼Œå…¶ä»–è¿›ç¨‹ä¸èƒ½å†ä½¿ç”¨å·²è¢«å…³é—­çš„é€šé“ï¼›closeæ“ä½œæè¿°ç¬¦ï¼Œå…¶ä»–è¿›ç¨‹ä»ç„¶å¯ä»¥ä½¿ç”¨è¯¥socketæè¿°ç¬¦ closeå…³é—­åº”ç”¨ç¨‹åºä¸socketçš„æ¥å£ï¼Œè°ƒç”¨closeä¹‹åè¿›ç¨‹ä¸èƒ½å†è¯»å†™è¿™ä¸ªsocketï¼›shutdownå¯ä»¥åªå…³é—­ä¸€ä¸ªé€šé“ï¼Œå¦ä¸€ä¸ªé€šé“ä»ç„¶å¯ä»¥æ“ä½œ UDPä¸åŸå§‹Socketç¼–ç¨‹ UDP Socketç¼–ç¨‹ recvfromï¼šæ¥å—UDPæ•°æ®åŒ… int recvfrom(int sockfd, void *buf, int len, unsigned char flags, struct socketaddr *from, socklen_t *addrlen); sendtoï¼šå‘é€UDPæ•°æ®åŒ… int sendto(int sockfd,const void *buf,int len,unsigned char flags, struct socketaddr *to,int tolen); UDPæœåŠ¡å™¨ æœåŠ¡å™¨ä¸æ¥å—å®¢æˆ·ç«¯è¿æ¥ï¼Œåªéœ€ç›‘å¬ç«¯å£ å¾ªç¯æœåŠ¡å™¨ï¼Œå¯ä»¥äº¤æ›¿å¤„ç†å„ä¸ªå®¢æˆ·ç«¯æ•°æ®åŒ… #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;netdb.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;sys/time.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int main(int argc, char **argv) { if (argc != 2) { cout \u0026lt;\u0026lt; \u0026#34;argument invalid\u0026#34; \u0026lt;\u0026lt; endl; return 1; } short port = atoi(argv[1]); int sockfd = socket(AF_INET, SOCK_DGRAM, 0); if (sockfd == -1) { cout \u0026lt;\u0026lt; \u0026#34;create socket error\u0026#34; \u0026lt;\u0026lt; endl; return 1; } sockaddr_in addr; bzero(\u0026amp;addr, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = htonl(INADDR_ANY); //ç»‘å®šæœåŠ¡å™¨åœ°å€ if (bind(sockfd, (struct sockaddr *)\u0026amp;addr, sizeof(addr)) == -1) { cout \u0026lt;\u0026lt; \u0026#34;bind error\u0026#34; \u0026lt;\u0026lt; endl; return 1; } for (;;) { char buf[32]; sockaddr_in client_addr; socklen_t addr_len; //æ¥æ”¶å®¢æˆ·ç«¯æ•°æ®åŒ… int n = recvfrom(sockfd, buf, 16, 0, (struct sockaddr *)\u0026amp;client_addr, \u0026amp;addr_len); if (n \u0026gt;= 0) { buf[n] = 0; cout \u0026lt;\u0026lt; \u0026#34;recv:\u0026#34; \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; struct timeval tv; gettimeofday(\u0026amp;tv, NULL); sprintf(buf, \u0026#34;%d %d\u0026#34;, (int)tv.tv_sec, (int)tv.tv_usec); //åˆ©ç”¨recvfronä¸­å¾—åˆ°çš„åœ°å€å›é€æ•°æ®åŒ… sendto(sockfd, buf, strlen(buf), 0, (struct sockaddr *)\u0026amp;client_addr, sizeof(client_addr)); } } close(sockfd); return 0; } UDPå®¢æˆ·ç«¯ å®¢æˆ·ç«¯ä¸ç”¨å»ºç«‹è¿æ¥ï¼Œç¬¬ä¸€æ¬¡è°ƒç”¨sendtoå‡½æ•°æ—¶ï¼ŒUDPåè®®ä¸ºè¿™ä¸ªUDP socketé€‰æ‹©ä¸€ä¸ªç«¯å£å·ï¼Œä»¥åçš„å‘é€å’Œæ¥å—æ“ä½œå‡ä½¿ç”¨è¿™ä¸ªç«¯å£å·ã€‚ å®¢æˆ·ç«¯å¯ä»¥æ¥æ”¶æ¥è‡ªä»»ä½•ä¸»æœºçš„æ•°æ®æŠ¥ å®¢æˆ·ç«¯å¯èƒ½æ°¸è¿œé˜»å¡ï¼ˆæœåŠ¡å™¨ä¸»æœºå´©æºƒï¼‰ #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;netdb.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int main(int argc, char **argv) { if (argc \u0026lt; 2) { cout \u0026lt;\u0026lt; \u0026#34;argument invalid\u0026#34; \u0026lt;\u0026lt; endl; return 1; } short port = atoi(argv[1]); int sockfd = socket(AF_INET, SOCK_DGRAM, 0); if (sockfd == -1) { cout \u0026lt;\u0026lt; \u0026#34;create socket error\u0026#34; \u0026lt;\u0026lt; endl; return 1; } sockaddr_in addr; bzero(\u0026amp;addr, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = htonl(INADDR_ANY); if (argc == 3 \u0026amp;\u0026amp; strcmp(argv[2], \u0026#34;-c\u0026#34;) == 0) { //è®°å½•æœåŠ¡å™¨åœ°å€ connect(sockfd, (struct sockaddr *)\u0026amp;addr, sizeof(addr)); } for (int i = 0; i \u0026lt; 10; i++) { char buf[16]; sprintf(buf, \u0026#34;%d hello\u0026#34;, getpid()); cout \u0026lt;\u0026lt; \u0026#34;send:\u0026#34; \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; int n; if (argc == 3 \u0026amp;\u0026amp; strcmp(argv[2], \u0026#34;-c\u0026#34;) == 0) { //å‘é€æ—¶ä¸éœ€è¦æœåŠ¡å™¨åœ°å€ n = sendto(sockfd, buf, strlen(buf), 0, NULL, 0); } else { //å‘é€æ—¶éœ€è¦æœåŠ¡å™¨åœ°å€ n = sendto(sockfd, buf, strlen(buf), 0, (struct sockaddr *)\u0026amp;addr, sizeof(addr)); } n = recvfrom(sockfd, buf, 16, 0, NULL, NULL); if (n \u0026gt;= 0) { buf[n] = 0; cout \u0026lt;\u0026lt; \u0026#34;recv:\u0026#34; \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; } sleep(1); } close(sockfd); return 0; } æœ‰è¿æ¥çš„UDP Socket åœ¨UDP Socketä¸Šè°ƒç”¨connectå‡½æ•°ï¼Œä½†ä¸ä¼šäº§ç”Ÿ3æ¬¡æ¡æ‰‹è¿‡ç¨‹ï¼Œåªè®°å½•è¿æ¥å¦ä¸€æ–¹çš„IPå’Œç«¯å£ï¼Œconnectå‡½æ•°é©¬ä¸Šè¿”å› ä½¿ç”¨UDP Socketçš„è¯´æ˜ UDPåè®®ä¸ä¿è¯æ•°æ®åŒ…å¯é åˆ°è¾¾ï¼ˆè¶…æ—¶å’Œé‡å‘æœºåˆ¶ï¼‰ UDPåè®®ä¸ä¿è¯æ•°æ®æŠ¥é¡ºåºåˆ°è¾¾ï¼ˆæ•°æ®æŠ¥åºåˆ—å·åŒºåˆ†ï¼‰ UDPåè®®æ²¡æœ‰æµæ§ UDPå¹¿æ’­ server #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { int sockfd; if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) \u0026lt; 0) { exit(-1); } int on = 1; setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST | SO_REUSEADDR, \u0026amp;on, sizeof(int)); struct sockaddr_in addr; memset(\u0026amp;addr, 0, sizeof(struct sockaddr_in)); addr.sin_family = AF_INET; addr.sin_addr.s_addr = inet_addr(\u0026#34;255.255.255.255\u0026#34;); addr.sin_port = htons(8080); char msg[] = \u0026#34;Broadcast Message: Hello!\u0026#34;; int n; if ((n = sendto(sockfd, msg, strlen(msg), 0, (struct sockaddr *)\u0026amp;addr, sizeof(addr))) \u0026lt; 0) { exit(-1); } printf(\u0026#34;msg=%s, msgLen=%ld, sendBytes=%d\\n\u0026#34;, msg, strlen(msg), n); close(sockfd); return 0; } client #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { int sockfd; if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) \u0026lt; 0) { exit(-1); } int on = 1; setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, \u0026amp;on, sizeof on); struct sockaddr_in addr; memset(\u0026amp;addr, 0, sizeof(sockaddr_in)); addr.sin_family = AF_INET; addr.sin_port = htons(8080); addr.sin_addr.s_addr = INADDR_ANY; if (bind(sockfd, (struct sockaddr *)\u0026amp;addr, sizeof(struct sockaddr)) \u0026lt; 0) { exit(-1); } int n; char buf[256]; socklen_t addr_len = sizeof(struct sockaddr_in); if ((n = recvfrom(sockfd, buf, 256, 0, (struct sockaddr *)\u0026amp;addr, \u0026amp;addr_len)) \u0026lt; 0) { exit(-1); } buf[n] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;Received: %s\\n\u0026#34;, buf); close(sockfd); return 0; } åŸå§‹Socketç¼–ç¨‹ æ¦‚è¿° TCPã€UDP Socketå¯¹TCPåè®®å’ŒUDPåè®®åšäº†å°è£…æ¥ç®€åŒ–ç¼–ç¨‹æ¥å£ï¼Œä½†å¤±å»äº†å¯¹IPæ•°æ®åŒ…æ“ä½œçš„çµæ´»æ€§ åŸå§‹Socketç›´æ¥é’ˆå¯¹IPæ•°æ®åŒ…ç¼–ç¨‹ï¼Œå…·æœ‰æ›´å¼ºçš„çµæ´»æ€§ å¯ä»¥ç¼–å†™åŸºäºIPåè®®çš„é«˜å±‚åè®® å‘é€æ•°æ®åŒ… æ²¡æœ‰è°ƒç”¨connectå‡½æ•°ç»‘å®šå¯¹æ–¹åœ°å€æ—¶å¿…é¡»ç”¨sendtoæˆ–sendmsgå‘é€æ•°æ®åŒ…ï¼›è°ƒç”¨connectç»‘å®šå¯¹æ–¹IPåœ°å€åï¼Œå¯ä»¥ä½¿ç”¨writeå’Œsendå‘é€æ•°æ®åŒ… æ¥æ”¶æ•°æ®åŒ… UDPåŒ…å’ŒTCPåŒ… å¤§å¤šæ•°ICMPåŒ…çš„æ‹·è´å°†ä¼ é€’ç»™åŸå§‹socket å…¶ä»–ç±»å‹çš„æ•°æ®åŒ…çš„æ‹·è´ä¼ é€’ç»™åŒ¹é…çš„socket å†…æ ¸ä¸èƒ½è¯†åˆ«çš„IPæ•°æ®åŒ…å°†ä¼ é€ç»™åŒ¹é…çš„åŸå§‹socket Linuxè¿›ç¨‹ä¸ä¿¡å·æœºåˆ¶ æ¦‚è¿° linuxè¿›ç¨‹æ˜¯ç³»ç»Ÿè¿›è¡Œèµ„æºåˆ†é…å’Œè°ƒåº¦çš„åŸºæœ¬å•ä½ã€‚ è¿›ç¨‹çš„çŠ¶æ€ï¼š æ–°å»º è¿è¡Œ é˜»å¡ å°±ç»ª å®Œæˆ æŒ‰ç»§æ‰¿å…³ç³»åˆ†ç±» çˆ¶ã€å­ã€å­™è¿›ç¨‹ å…„å¼Ÿè¿›ç¨‹ å­¤å„¿è¿›ç¨‹ åˆ›å»ºè¿›ç¨‹ pid_t fork(void); åŠŸèƒ½ï¼šåˆ›å»ºæ–°çš„è¿›ç¨‹ï¼Œè°ƒç”¨è€…æˆä¸ºçˆ¶è¿›ç¨‹ï¼Œäº§ç”Ÿçš„æ–°è¿›ç¨‹æˆä¸ºå­è¿›ç¨‹ è¿”å›å€¼ï¼š \u0026gt; 0, å­è¿›ç¨‹çš„idï¼Œåªåœ¨çˆ¶è¿›ç¨‹ä¸­è¿”å› -1, è°ƒç”¨å¤±è´¥ =0, åªåœ¨å­è¿›ç¨‹ä¸­è¿”å› å¤´æ–‡ä»¶ï¼š#include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; forkçš„åŸç† ä¸¤æ¬¡è¿”å› è°ƒç”¨forkçš„è¿›ç¨‹ï¼ˆçˆ¶è¿›ç¨‹ï¼‰è¿”å›æ­£æ•´æ•°ï¼ˆå­è¿›ç¨‹IDï¼‰ åœ¨æ–°åˆ›å»ºçš„è¿›ç¨‹ï¼ˆå­è¿›ç¨‹ï¼‰ä¸­è¿”å›0ï¼Œè¡¨ç¤ºæ˜¯å­è¿›ç¨‹ åœ¨è°ƒç”¨forkæ—¶å‘ç”Ÿäº†ä»€ä¹ˆ ç³»ç»Ÿåˆ›å»ºæ–°è¿›ç¨‹ï¼Œå¹¶ä¸ºè¯¥è¿›ç¨‹å‡†å¤‡æ•°æ®æ®µã€å †æ ˆæ®µå’Œä»£ç æ®µ ä»£ç æ®µä½¿ç”¨å’Œçˆ¶è¿›ç¨‹ç›¸åŒçš„ä»£ç æ®µ çˆ¶è¿›ç¨‹çš„æ•°æ®æ®µå’Œå †æ ˆæ®µè¢«å¤åˆ¶ï¼ˆcopy on write, å†™å…¥æ—¶å¤åˆ¶ï¼‰ç»™å­è¿›ç¨‹ å­è¿›ç¨‹å’Œçˆ¶è¿›ç¨‹å…±äº«çš„å†…å®¹ ä»£ç æ®µ ç”¨æˆ·æ ‡è¯†ç¬¦ ç¯å¢ƒå˜é‡ æ‰“å¼€çš„æ–‡ä»¶æè¿°ç¬¦(Socketæè¿°ç¬¦) æ ¹ç›®å½• å½“å‰å·¥ä½œç›®å½• åˆ›å»ºæ–‡ä»¶çš„æ¨¡å¼ âš ï¸ æ•°æ®æ®µå’Œå †æ ˆæ®µé€šè¿‡å¤åˆ¶æ–¹å¼å…±äº«ï¼Œå› æ­¤å­è¿›ç¨‹æˆ–çˆ¶è¿›ç¨‹ä¿®æ”¹äº†å˜é‡å€¼åä¸ä¼šå½±å“å¦ä¸€ä¸ªè¿›ç¨‹ï¼Œå³ä½¿æ˜¯å…¨å±€å˜é‡ã€‚ çˆ¶å­è¿›ç¨‹æ‰§è¡Œé¡ºåºéšæœº æ‰§è¡Œå¦ä¸€ä¸ªç¨‹åº int execve(const char *path,char * const argv[],char *envp);åªæœ‰execveæ˜¯çœŸæ­£çš„ç³»ç»Ÿè°ƒç”¨ int execl(const char *path, const char * argv,â€¦); æ³¨æ„ï¼š fork()å’Œexec()è¿™ä¸¤ä¸ªå‡½æ•°ï¼Œå‰è€…ç”¨äºå¹¶è¡Œæ‰§è¡Œï¼Œçˆ¶ã€å­è¿›ç¨‹æ‰§è¡Œç›¸åŒæ­£æ–‡ä¸­çš„ä¸åŒéƒ¨åˆ†ï¼›åè€…ç”¨äºè°ƒç”¨å…¶ä»–è¿›ç¨‹ï¼Œè¿›ç¨‹æ‰§è¡Œæ–°çš„æ­£æ–‡ã€‚ fork()ä»¥åï¼Œçˆ¶ã€å­è¿›ç¨‹å…±äº«ä»£ç æ®µï¼Œå¹¶åªé‡æ–°åˆ›å»ºæ•°æ®æœ‰æ”¹å˜çš„é¡µï¼ˆæ®µé¡µå¼ç®¡ç†ï¼‰ exec()ä»¥åï¼Œå»ºç«‹æ–°çš„ä»£ç æ®µï¼Œç”¨è¢«è°ƒç”¨ç¨‹åºçš„å†…å®¹å¡«å……ã€‚ å‰è€…çš„å­è¿›ç¨‹æ‰§è¡Œåç»­çš„å…¬å…±ä»£ç ï¼Œåè€…çš„å­è¿›ç¨‹ä¸æ‰§è¡Œåç»­çš„å…¬å…±ä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;unistd.h\u0026gt; using namespace std; int main() { pid_t pid; if ((pid = fork()) == 0) { // å­è¿›ç¨‹ cout \u0026lt;\u0026lt; \u0026#34;Son Process\u0026#34; \u0026lt;\u0026lt; endl; exit(0); } else if (pid \u0026gt; 0) { // çˆ¶è¿›ç¨‹ cout \u0026lt;\u0026lt; \u0026#34;Father Process\u0026#34; \u0026lt;\u0026lt; endl; exit(0); } else { cout \u0026lt;\u0026lt; \u0026#34;Error\u0026#34; \u0026lt;\u0026lt; endl; exit(1); } return 0; } åˆ›å»ºå®ˆæŠ¤è¿›ç¨‹ fork()å­è¿›ç¨‹ï¼Œçˆ¶è¿›ç¨‹é€€å‡º å­è¿›ç¨‹å»ºç«‹æ–°ä¼šè¯setsid() æ”¹å˜å½“å‰å·¥ä½œç›®å½•chdir(ä¸æ˜¯å¿…é¡») é‡è®¾æ–‡ä»¶æ©ç (ä¸æ˜¯å¿…é¡») å­è¿›ç¨‹ä¼šç»§æ‰¿çˆ¶è¿›ç¨‹çš„æ©ç  å¢åŠ å­è¿›ç¨‹ç¨‹åºçš„çµæ´»æ€§ umask(0); å…³é”®æ–‡ä»¶æè¿°ç¬¦ï¼ˆä¸æ˜¯å¿…é¡»ï¼‰ close(0), close(1), close(2) é‡Šæ”¾èµ„æº æ‰§è¡Œæ ¸å¿ƒå·¥ä½œ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;sys/param.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; using namespace std; int main(int argc, char const *argv[]) { // 1. è°ƒç”¨forkï¼Œçˆ¶è¿›ç¨‹é€€å‡ºï¼Œå­è¿›ç¨‹ç»§ç»­è¿è¡Œ pid_t pid = fork(); if (pid \u0026lt; 0) { exit(1); } else if (pid \u0026gt; 0) { exit(0); } // 2. è°ƒç”¨setsidå˜æˆä¼šé•¿ // ä¼šé•¿å°±æ˜¯ä¸€ä¸ªå®ˆæŠ¤è¿›ç¨‹ setsid(); // 3. å¿½ç•¥SIGHUPä¿¡å· signal(SIGHUP, SIG_IGN); // å†æ¬¡forkï¼Œçˆ¶è¿›ç¨‹ï¼ˆsessionçš„å¤´è¿›ç¨‹ï¼‰é€€å‡º if ((pid = fork()) \u0026gt; 0) { exit(0); } else if (pid \u0026lt; 0) { exit(1); } // 4. chdir æ”¹å˜å½“å‰å·¥ä½œç›®å½• chdir(\u0026#34;/tmp\u0026#34;); // 5. é‡è®¾æ–‡ä»¶æ©ç  umask(0); // 6. å…³é—­æ‰€æœ‰æ‰“å¼€çš„æ–‡ä»¶æè¿°ç¬¦ for (int i = 0; i \u0026lt; NOFILE; i++) { close(i); } // 7. ä¸ºæ ‡å‡†è¾“å…¥ï¼ˆ0ï¼‰ï¼Œæ ‡å‡†è¾“å‡ºï¼ˆ1ï¼‰ã€æ ‡å‡†é”™è¯¯è¾“å‡ºï¼ˆ2ï¼‰æ‰“å¼€æ–°çš„æ–‡ä»¶æè¿°ç¬¦ int fd_rd = open(\u0026#34;/dev/null\u0026#34;, O_RDONLY); int fd_wr = open(\u0026#34;/root/deamon.log\u0026#34;, O_WRONLY); dup(fd_rd); dup(fd_wr); // 8. å¤„ç†SICHLDï¼Œé¿å…å®ˆæŠ¤è¿›ç¨‹çš„å­è¿›ç¨‹ç§°ä¸ºåƒµå°¸è¿›ç¨‹ signal(SIGCHLD, SIG_IGN); // è®©å­è¿›ç¨‹ä¸€ç›´æ´»ç€ while (true) { } return 0; } ä¿¡å·æœºåˆ¶ ä¿¡å·åˆ†ç±» å¸¸ç”¨ä¿¡å·ï¼š SIGALARMâ€”â€”è®¡æ—¶å™¨åˆ°æ—¶ SIGCHLDâ€”â€”å­è¿›ç¨‹åœæ­¢æ—¶é€šçŸ¥çˆ¶è¿›ç¨‹ SIGKILLâ€”â€”ç»ˆæ­¢è¿›ç¨‹ SIGSTOPâ€”â€”åœæ­¢è¿›ç¨‹ï¼ˆæš‚åœï¼‰ SIGINTâ€”â€”ä¸­æ–­å­—ç¬¦ å¯é ä¿¡å·å’Œéå¯é ä¿¡å· å®æ—¶ä¿¡å·å’Œéå®æ—¶ä¿¡å· å‘é€ä¿¡å· int kill(pid_t pid, int sig) int raise(int sig)å‘è¿›ç¨‹è‡ªèº«å‘é€ä¿¡å· unsigned int alarm(unsigned int seconds) void abort() int sigqueue(pid_t pid, int sig, const union sigval val) ç”¨killå‘é€ä¿¡å· ç”¨ç‰¹å®šçš„é”®ç›˜å­—ç¬¦äº§ç”Ÿä¿¡å· CTRL+Cäº§ç”ŸSIGINT CTRL+BACKSPACEäº§ç”ŸSIGQUIT æ¥æ”¶ä¿¡å· int sigcation(int signum, const struct sigaction *act, struct sigaction *oldact); sigactionç»“æ„ struct sigaction { void (*sa_handler)(int); // å‡½æ•°æŒ‡é’ˆ void (*sa_sigaction)(int, siginfo_t *, void *); //å‡½æ•°æŒ‡é’ˆ sigset_t sa_mask; // å±è”½çš„ä¿¡å·é›† int sa_flags;\t// æ ‡å¿—ï¼ŒSA_SIGINFO void (*sa_restorer)(void); // å·²åºŸå¼ƒ } ç¤ºä¾‹ INTä¿¡å·å¤„ç†\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;csignal\u0026gt; #include \u0026lt;unistd.h\u0026gt; using namespace std; void signalHandler(int signum) { cout \u0026lt;\u0026lt; \u0026#34;Catched signal: \u0026#34; \u0026lt;\u0026lt; signum \u0026lt;\u0026lt; endl; // exit(signum); } int main() { // æ³¨å†Œä¿¡å·SIGNALå’Œä¿¡å·å¤„ç†ç¨‹åº signal(SIGINT, signalHandler); while (true) { cout \u0026lt;\u0026lt; \u0026#34;Going to sleep...\u0026#34; \u0026lt;\u0026lt; endl; sleep(1); } return 0; } è¿›ç¨‹ç»ˆæ­¢ exit()\nå¤„ç†å­è¿›ç¨‹æ­»äº¡ åƒµå°¸è¿›ç¨‹ï¼ˆzombieï¼‰ å­è¿›ç¨‹ç»ˆæ­¢æ—¶å¦‚æœçˆ¶è¿›ç¨‹å­˜åœ¨ä¸”æœªå¤„ç†SIGCHLDä¿¡å·åˆ™å­è¿›ç¨‹å˜ä¸ºåƒµå°¸è¿›ç¨‹ åƒµå°¸è¿›ç¨‹å æ®ç³»ç»Ÿè¿›ç¨‹è¡¨é¡¹ å¯¹æ¯”å­¤å„¿è¿›ç¨‹ å­è¿›ç¨‹ç»ˆæ­¢ï¼Œçˆ¶è¿›ç¨‹å¹¶æ²¡æœ‰è°ƒç”¨ wait/waitpid è·å–å­è¿›ç¨‹çš„ç»ˆæ­¢çŠ¶æ€ï¼Œä¸”çˆ¶è¿›ç¨‹è¿˜æ²¡æœ‰ç»“æŸï¼ˆå­è¿›ç¨‹æ²¡æœ‰è¢« init æ”¶å…»ï¼‰ï¼Œé‚£ä¹ˆå½“å­è¿›ç¨‹ç»“æŸåï¼Œå®ƒçš„è¿›ç¨‹æè¿°ç¬¦ä»ç„¶ä¿å­˜åœ¨ç³»ç»Ÿä¸­ï¼Œè¿™å°±æˆäº†åƒµå°¸è¿›ç¨‹ã€‚ å­è¿›ç¨‹è¿˜æ²¡æœ‰ç»“æŸï¼Œä½†æ˜¯çˆ¶è¿›ç¨‹ç»“æŸäº†ï¼Œè¿™ä¸ªæ—¶å€™å­è¿›ç¨‹å¤±å»å…¶å”¯ä¸€çš„çˆ¶è¿›ç¨‹ï¼Œæˆä¸ºäº†å­¤å„¿è¿›ç¨‹ã€‚ æ¸…ç†åƒµå°¸è¿›ç¨‹çš„æ–¹æ³•1 å¿½ç•¥SIGCHLDä¿¡å·ï¼ˆä½¿ç”¨ä¿¡å·å¤„ç†å‡½æ•°ï¼ˆSIG_IGN) å¿½ç•¥SIGCHLDä¿¡å·æ—¶ï¼Œç³»ç»Ÿå°†æ¸…é™¤å­è¿›ç¨‹çš„è¿›ç¨‹è¡¨é¡¹ï¼Œè¿™ç§æ–¹æ³•ä¾èµ–äºLinuxç‰ˆæœ¬çš„å®ç° ç»ˆç«¯æ“ä½œ topï¼ŒæŸ¥çœ‹åŠ¨æ€è¿›ç¨‹çŠ¶æ€ `ps -A -ostat, ppid, pid, cmd | grep -e \u0026lsquo;^[Zz]\u0026rsquo;ï¼ŒæŸ¥çœ‹åƒµå°¸è¿›ç¨‹ kill -HUP xxxx, æ¸…é™¤åƒµå°¸ æ¸…é™¤åƒµå°¸è¿›ç¨‹çš„æ–¹æ³•2 è°ƒç”¨waitæˆ–waitpidç­‰å¾…å­è¿›ç¨‹ pid_t wait(int *status);ç­‰å¾…ä»»æ„å­è¿›ç¨‹ç»ˆæ­¢ï¼Œæ²¡æœ‰å­è¿›ç¨‹ç»ˆæ­¢æ—¶é˜»å¡ï¼Œå¦‚æœæ²¡æœ‰å­è¿›ç¨‹è¿”å›-1 pid_t waitpid(int pid, int *status, int option) æ­¤æ–¹æ³•æ²¡æœ‰å…¼å®¹æ€§é—®é¢˜ æ¸…é™¤åƒµå°¸è¿›ç¨‹çš„æ–¹æ³•3 æ•è·SIGCHLDä¿¡å· æ¸…é™¤åƒµå°¸è¿›ç¨‹çš„æ–¹æ³•4 è°ƒç”¨fork()ä¸¤æ¬¡ï¼Œä½¿å¾—å­è¿›ç¨‹æˆä¸ºå­¤å„¿è¿›ç¨‹ï¼Œç”±initç®¡ç† è¿™ç§æ–¹æ³•ç¬¬ä¸€æ¬¡è°ƒç”¨forkäº§ç”Ÿçš„å­è¿›ç¨‹å¯èƒ½æˆä¸ºåƒµå°¸è¿›ç¨‹ è¿™ç§æ–¹æ³•ç¬¬äºŒæ¬¡è°ƒç”¨forkäº§ç”Ÿçš„å­è¿›ç¨‹ç”±initå¤„ç†å­è¿›ç¨‹é€€å‡ºï¼Œä¸ä¼šæˆä¸ºåƒµå°¸è¿›ç¨‹ é€šä¿—ç‚¹è®²ï¼Œå°±æ˜¯çˆ·çˆ·ç¬¬ä¸€æ¬¡ fork ç”Ÿä¸€ä¸ªè€çˆ¸ï¼Œè€çˆ¸å‡ºç”Ÿåç«‹åˆ» fork ç”Ÿä¸‹å„¿å­ï¼Œè¿™ä¸ªæ—¶å€™è€çˆ¸çš„ä»»åŠ¡å°±ç»“æŸäº†ï¼Œå¯ä»¥æ­»æ‰äº† (exit)ï¼Œè¿™ä¸ªæ—¶å€™å„¿å­è¢«å¼ºå¤§çš„ init æ”¶å…»ï¼Œçˆ·çˆ·çˆ±å¹²å•¥å¹²å•¥ï¼Œä»è€Œå„¿å­æ°¸è¿œä¸ä¼šæˆä¸ºåƒµå°¸è¿›ç¨‹ã€‚\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; int main() { pid_t pid; if ((pid = fork()) == 0) { pid = fork(); if (pid \u0026gt; 0) { // çˆ¶äº²ç”Ÿä¸‹å„¿å­ç›´æ¥é€€å‡ºï¼Œå„¿å­ä¼šè¢«æ”¶å…» exit(0); } sleep(0.5); printf(\u0026#34;I\u0026#39;m son after second fork.\\n\u0026#34;); printf(\u0026#34;my parent\u0026#39;s pid: %d\\n\u0026#34;, getppid()); exit(0); } // çˆ·çˆ·ç”Ÿä¸‹çˆ¶äº²åç›´æ¥ç­‰å¾…ä¸ºå…¶æ”¶å°¸ waitpid(pid, NULL, 0); // çˆ·çˆ·å°½æƒ…å¿«æ´» return 0; } è¿›ç¨‹åŒæ­¥ å½“forkè°ƒç”¨æˆåŠŸåï¼Œçˆ¶å­è¿›ç¨‹å„åšå„çš„äº‹æƒ…ï¼Œä½†å½“çˆ¶è¿›ç¨‹çš„å·¥ä½œå‘Šä¸€æ®µè½ï¼Œéœ€è¦ç”¨åˆ°å­è¿›ç¨‹çš„ç»“æœæ—¶ï¼Œå®ƒå°±åœä¸‹æ¥è°ƒç”¨waitï¼Œä¸€ç›´ç­‰åˆ°å­è¿›ç¨‹è¿è¡Œç»“æŸï¼Œç„¶ååˆ©ç”¨å­è¿›ç¨‹çš„ç»“æœç»§ç»­æ‰§è¡Œã€‚\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { pid_t pc, pr; int status; pc = fork(); if (pc \u0026lt; 0) printf(\u0026#34;Error occured on forking.\\n\u0026#34;); else if (pc == 0) { /* å­è¿›ç¨‹çš„å·¥ä½œ */ printf(\u0026#34;son\\n\u0026#34;); exit(0); } else { /* çˆ¶è¿›ç¨‹çš„å·¥ä½œ */ printf(\u0026#34;father\\n\u0026#34;); pr = wait(\u0026amp;status); /* åˆ©ç”¨å­è¿›ç¨‹çš„ç»“æœ */ } return 0; } Linuxè¿›ç¨‹é—´é€šä¿¡ï¼ˆIPC) ç®¡é“ å•å‘é€šä¿¡ï¼Œå®ç°åŒå‘é€šä¿¡éœ€åˆ›å»ºä¸¤ä¸ªç®¡é“ åªé€‚ç”¨äºçˆ¶å­é—´è¿›ç¨‹é€šä¿¡ ä½¿ç”¨ç®¡é“ ç”¨pipeåˆ›å»ºä¸¤ä¸ªç®¡é“pipe1å’Œpipe2 pipe[0]è¯»ï¼Œpipe[1]å†™ fork()åˆ›å»ºå­è¿›ç¨‹ çˆ¶è¿›ç¨‹ç”¨pipe1å†™æ•°æ®ï¼ˆå…³é—­pipe1è¯»ç«¯å£ï¼‰ï¼Œpipe2è¯»æ•°æ®ï¼ˆå…³é—­pipe2å†™ç«¯å£ï¼‰ å­è¿›ç¨‹ç”¨pipe1è¯»æ•°æ®ï¼ˆå…³é—­pipe1å†™ç«¯å£ï¼‰ï¼Œpipe2å†™æ•°æ®ï¼ˆå…³é—­pipe2è¯»ç«¯å£ï¼‰ ç¤ºä¾‹ #include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int main(int argc, char **argv) { int pipe1[2], pipe2[2]; char pstr[] = \u0026#34;parent data\u0026#34;; char cstr[] = \u0026#34;child data\u0026#34;; char buf[100]; if (pipe(pipe1) \u0026lt; 0 || pipe(pipe2) \u0026lt; 0) cout \u0026lt;\u0026lt; \u0026#34;pipe error\u0026#34; \u0026lt;\u0026lt; endl; pid_t pid = fork(); if (pid \u0026gt; 0) { // çˆ¶è¿›ç¨‹,ç”¨ç®¡é“1å†™æ•°æ®,ç®¡é“2è¯»æ•°æ® close(pipe1[0]); //å…³é—­pipe1è¯»ç«¯å£ close(pipe2[1]); //å…³é—­pipe2å†™ç«¯å£ write(pipe1[1], pstr, sizeof(pstr)); if (read(pipe2[0], buf, 100) \u0026gt; 0) cout \u0026lt;\u0026lt; \u0026#34;parent received:\u0026#34; \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; } else if (pid == 0) { // å­è¿›ç¨‹ç”¨ç®¡é“1è¯»æ•°æ®,ç®¡é“2å†™æ•°æ® close(pipe1[1]); //å…³é—­pipe1å†™ç«¯å£ close(pipe2[0]); //å…³é—­pipe2è¯»ç«¯å£ if (read(pipe1[0], buf, 100) \u0026gt; 0) cout \u0026lt;\u0026lt; \u0026#34;child received:\u0026#34; \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; write(pipe2[1], cstr, sizeof(cstr)); exit(0); } else cout \u0026lt;\u0026lt; \u0026#34;fork error\u0026#34; \u0026lt;\u0026lt; endl; return 0; } å‘½åç®¡é“ ç‰¹ç‚¹ ä¸ä¸€ä¸ªè·¯å¾„åç›¸å…³è”ï¼Œä»¥æ–‡ä»¶å½¢å¼å­˜åœ¨äºæ–‡ä»¶ç³»ç»Ÿä¸­ è¯¥æ–‡ä»¶åæ‰€å¯¹åº”çš„æ–‡ä»¶æ²¡æœ‰æ•°æ®åªæ˜¯ä¸ºäº†ä¾¿äºå…¶ä»–è¿›ç¨‹å¼•ç”¨ å¯ä»¥åœ¨å…„å¼Ÿè¿›ç¨‹é€šä¿¡ åˆ›å»º int mkfifo(char *pathname, mode_t mode);\nä½¿ç”¨ å†™è¿›ç¨‹mkfifoåˆ›å»ºå‘½åç®¡é“ å†™è¿›ç¨‹openä»¥å†™é˜»å¡æ–¹å¼æ‰“å¼€ç®¡é“ è¯»è¿›ç¨‹openä»¥è¯»é˜»å¡æ–¹å¼æ‰“å¼€ç®¡é“ å†™è¿›ç¨‹è°ƒç”¨writeå†™ï¼Œè¯»è¿›ç¨‹readè¯»å‡ºæ•°æ® ç¤ºä¾‹ fifo_server.cpp\n#include \u0026lt;errno.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/time.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; #define FIFO_NAME \u0026#34;/home/fffzlfk/fifo_test\u0026#34; int main(int argc, char **argv) { char pstr[] = \u0026#34;server data\u0026#34;; if (mkfifo(FIFO_NAME, O_CREAT | O_EXCL) \u0026lt; 0 \u0026amp;\u0026amp; (errno != EEXIST)) cout \u0026lt;\u0026lt; \u0026#34;create fifo error\u0026#34; \u0026lt;\u0026lt; endl; int fd; if (argc == 2 \u0026amp;\u0026amp; strcmp(argv[1], \u0026#34;-b\u0026#34;) == 0) fd = open(FIFO_NAME, O_WRONLY, 0); else fd = open(FIFO_NAME, O_WRONLY | O_NONBLOCK, 0); if (fd != -1) cout \u0026lt;\u0026lt; \u0026#34;open success\u0026#34; \u0026lt;\u0026lt; endl; else { perror(\u0026#34;open fail\u0026#34;); return 0; } int write_num = write(fd, pstr, sizeof(pstr)); if (write_num == -1) { if (errno = EAGAIN) cout \u0026lt;\u0026lt; \u0026#34;write fifo error,try later:\u0026#34; \u0026lt;\u0026lt; endl; } else cout \u0026lt;\u0026lt; \u0026#34;real write num is:\u0026#34; \u0026lt;\u0026lt; write_num \u0026lt;\u0026lt; endl; return 0; } fifo_client.cpp\n#include \u0026lt;errno.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/time.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; #define FIFO_NAME \u0026#34;/home/fffzlfk/fifo_test\u0026#34; int main(int argc, char **argv) { char buf[1024]; int fd; if (argc == 2 \u0026amp;\u0026amp; strcmp(argv[1], \u0026#34;-b\u0026#34;) == 0) fd = open(FIFO_NAME, O_RDONLY, 0); else fd = open(FIFO_NAME, O_RDONLY | O_NONBLOCK, 0); if (fd != -1) cout \u0026lt;\u0026lt; \u0026#34;open success\u0026#34; \u0026lt;\u0026lt; endl; else { perror(\u0026#34;open fail\u0026#34;); return 0; } int read_num = 20; memset(buf, 0, sizeof(buf)); read_num = read(fd, buf, 1024); if (read_num == -1) { if (errno == EAGAIN) cout \u0026lt;\u0026lt; \u0026#34;no data,try later:\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;real read bytes:\u0026#34; \u0026lt;\u0026lt; read_num \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;read data:\u0026#34; \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; } //åˆ é™¤ç®¡é“æ–‡ä»¶ // unlink(FIFO_NAME); return 0; } UnixåŸŸSocket ä¸æ˜¯çœŸæ­£çš„ç½‘ç»œåè®® æä¾›åŒä¸€å°æœºå™¨çš„çš„è¿›ç¨‹é—´é€šä¿¡ æ˜¯åŒå‘é€šé“ åˆ†ä¸ºå‘½åå’Œéå‘½åä¸¤ç§ å‘½åUnixåŸŸSocket ç‰¹ç‚¹ æœåŠ¡å™¨å¯ä»¥æ¥æ”¶å¤šä¸ªå®¢æˆ·ç«¯è¿æ¥è¯·æ±‚ å®¢æˆ·ç«¯è°ƒç”¨å‡½æ•°connectæœåŠ¡å™¨è¿æ¥ connectä½¿ç”¨çš„socketåº”è¯¥æ˜¯å·²æ‰“å¼€çš„UNIXåŸŸsocket å®¢æˆ·ç«¯å¿…é¡»æ‹¥æœ‰æ‰“å¼€socketåœ°å€æ‰€æŒ‡æ–‡ä»¶æƒé™ ç›‘å¬socketçš„è¿æ¥é˜Ÿåˆ—æ»¡æ—¶connectç«‹åˆ»è¿”å›é”™è¯¯ éå‘½åUnixåŸŸSocket ç‰¹ç‚¹ æ— åçš„ å…¨åŒå·¥ ä¸éœ€è¦è¿æ¥ çˆ¶å­è¿›ç¨‹é—´é€šä¿¡ä½¿ç”¨socketpair I/Oæ¨¡å‹ é˜»å¡I/Oæ¨¡å‹ äº§ç”Ÿé˜»å¡çš„åŸå› â€”â€”æ—¶é—´ç‰‡è°ƒåº¦ç®—æ³• å¥½å¤„â€”â€”é˜»å¡è¿›ç¨‹ä¸å ç”¨CPUæ—¶é—´ äº§ç”Ÿé˜»å¡çš„å‡½æ•°â€”â€”è¯»ã€å†™ã€å»ºç«‹è¿æ¥ã€æ¥å—è¿æ¥ è¯»ï¼šreadã€readvã€recvã€recvfromå’Œrecvmsg å†™ï¼šwriteã€writevã€sendã€sendtoå’Œsendmsg å»ºç«‹è¿æ¥ï¼šconnect æ¥å—è¿æ¥ï¼šaccept è¶…æ—¶æ§åˆ¶ è°ƒç”¨alarmå‡½æ•°è®¾ç½®è¶…æ—¶ è®¾ç½®socketé€‰é¡¹â€”â€”è®¾ç½®SO_RCVTIMEOå’ŒSO_SNDTIMEOé€‰é¡¹ éé˜»å¡I/Oæ¨¡å‹ è®¾ç½®Socketä¸ºéé˜»å¡æ–¹å¼ å‡½æ•°fcntl int flags; flag = fcntl(sockfd,F_GETFL,0); fcntl(sockfd,F_SETFL,flag|O_NONBLOCK); å‡½æ•°ioctl int on=1; ioctl(sockfd,FIONBIO,\u0026amp;on); æ£€æŸ¥æ“ä½œæ˜¯å¦å¯ä»¥å®Œæˆçš„æ–¹å¼ï¼ˆè½®è¯¢ï¼‰ è¾“å…¥è¾“å‡ºå¤šè·¯å¤ç”¨I/Oæ¨¡å‹ int select(int maxfd, struct fd_set* rdset, struct fd_set* wrset, struct fd_set* exset, struct timeval* timeout); void FD_SET(int fd,fd_set *fdset) //å°†fdåŠ å…¥åˆ°fdset void FD_CLR(int fd,fd_set *fdset) //å°†fdä»fdseté‡Œé¢æ¸…é™¤ void FD_ZERO(fd_set *fdset) //ä»fdsetä¸­æ¸…é™¤æ‰€æœ‰çš„æ–‡ä»¶æè¿°ç¬¦ int FD_ISSET(int fd,fd_set *fdset) //åˆ¤æ–­fdæ˜¯å¦åœ¨fdseté›†åˆä¸­ select()å¯ä»¥è®¾ç½®è¶…æ—¶ï¼Œä½¿é•¿æœŸæ²¡æœ‰æ–‡ä»¶æè¿°ç¬¦å°±ç»ªæ—¶ï¼Œè¿›ç¨‹å¯ä»¥è·³å‡ºé˜»å¡çŠ¶æ€ã€‚select()çš„ç¬¬ä¸€ä¸ªå‚æ•° maxfd æ˜¯é›†åˆä¸­æœ€å¤§çš„æ–‡ä»¶æè¿°ç¬¦åŠ 1ï¼Œå¦‚ï¼šä¸€ä¸ªåŒ…å«3ä¸ªå¥—æ¥å­—æè¿°ç¬¦çš„é›†åˆ{12ï¼Œ23ï¼Œ30}ï¼Œé‚£ä¹ˆ maxfd å°±åº”è¯¥æ˜¯30+1=31ã€‚\nåœ¨æˆ‘ä»¬è°ƒç”¨select( )æ—¶ï¼Œè¿›ç¨‹ä¼šä¸€ç›´é˜»å¡åˆ°ä»¥ä¸‹çš„ä¸€ç§æƒ…å†µå‘ç”Ÿ:\næœ‰æ–‡ä»¶å¯ä»¥è¯»ï¼ŒåŒ…æ‹¬å‡ºç°é”™è¯¯ï¼› æœ‰æ–‡ä»¶å¯ä»¥å†™ï¼ŒåŒ…æ‹¬å‡ºç°é”™è¯¯ï¼› è¶…æ—¶æ‰€è®¾ç½®çš„æ—¶é—´åˆ°ï¼› è¢«ä¿¡å·ä¸­æ–­ã€‚ ä¿¡å·é©±åŠ¨I/Oæ¨¡å‹ è®¾ç½®SIGIOä¿¡å·å¤„ç†å‡½æ•° è®¾ç½®socketæè¿°ç¬¦æ‰€æœ‰è€… å…è®¸è¿™ä¸ªsocketè¿›è¡Œä¿¡å·é©±åŠ¨I/O void sigio_handler(int signo) { ... } int main() { int sockfd; int on = 1; ... signal(SIGIO, sigio_handler); fcntl(sockfd, F_SETOWN, getpid()); // è®¾ç½®å¥—æ¥å­—æ‰€æœ‰è€…ä¸ºå½“å‰è¿›ç¨‹ ioctl(sockfd, FIOASYNC, \u0026amp;on); // å¯åŠ¨ä¿¡å·é©±åŠ¨æ¨¡å¼ ... } æœåŠ¡å™¨æ¨¡å‹ ç½‘ç»œæœåŠ¡å™¨åˆ†ç±» å¾ªç¯æœåŠ¡å™¨ï¼šåŒä¸€æ—¶åˆ»åªèƒ½å¤„ç†ä¸€ä¸ªå®¢æˆ·ç«¯è¯·æ±‚ å¹¶å‘æœåŠ¡å™¨ï¼šåŒä¸€æ—¶åˆ»å¯ä»¥å¤„ç†å¤šä¸ªå®¢æˆ·ç«¯è¯·æ±‚ UDPå’ŒTCPæœåŠ¡å™¨æ¨¡å‹ UDPæœåŠ¡å™¨é€šå¸¸é‡‡ç”¨å¾ªç¯æœåŠ¡å™¨æ¨¡å‹ TCPæœåŠ¡å™¨é€šå¸¸é‡‡ç”¨å¹¶å‘æœåŠ¡å™¨æ¨¡å‹ å¾ªç¯æœåŠ¡å™¨æ¨¡å‹ UDPå¾ªç¯æœåŠ¡å™¨æ¨¡å‹ TCPå¾ªç¯æœåŠ¡å™¨æ¨¡å‹ å¹¶å‘æœåŠ¡å™¨æ¨¡å‹ UCPå¹¶å‘æœåŠ¡å™¨æ¨¡å‹ TCPå¹¶å‘æœåŠ¡å™¨æ¨¡å‹ ä¸€ä¸ªå­è¿›ç¨‹å¯¹åº”ä¸€ä¸ªå®¢æˆ·ç«¯ åˆ›å»ºå­è¿›ç¨‹å¼€é”€å¤§ï¼Œé€‚åˆé•¿æ—¶é—´å®¢æˆ·è¯·æ±‚ï¼ˆå¦‚FTPï¼‰ å®¢æˆ·ç«¯æ•°é‡å¤§ã€è¯·æ±‚æ—¶é—´çŸ­ä¼šå¤§å¤§é™ä½æ•ˆç‡ï¼ˆå¦‚HTTPï¼‰ å»¶è¿Ÿåˆ›å»ºå­è¿›ç¨‹ å¤„ç†çŸ­è¯·æ±‚ä»¥å¾ªç¯æ–¹å¼å®Œæˆ å¤„ç†æ—¶é—´é•¿çš„è¯·æ±‚ä»¥å¹¶å‘æ–¹å¼å®Œæˆ é¢„åˆ›å»ºå­è¿›ç¨‹ æ•°é‡å›ºå®š æ‰€æœ‰è¿›ç¨‹è°ƒç”¨acceptï¼Œæ— è¿æ¥æ—¶å°†ç¡çœ  æœ‰è¿æ¥åˆ°æ¥æ—¶æ‰€æœ‰è¿›ç¨‹è¢«å”¤é†’ æŸä¸€ä¸ªè¿›ç¨‹æ¥å—è¿æ¥åï¼Œå…¶ä½™è¿æ¥ç»§ç»­ç¡çœ  åŠ¨æ€å­è¿›ç¨‹æ•° çˆ¶è¿›ç¨‹ä¸å­è¿›ç¨‹é€šè¿‡ç®¡é“é€šä¿¡ å­è¿›ç¨‹æ¥æ”¶è¿æ¥æ—¶ç»™çˆ¶è¿›ç¨‹å‘1ï¼Œå…³é—­æ—¶å‘0 çˆ¶è¿›ç¨‹æ”¶åˆ°1æ—¶ï¼Œæ£€æŸ¥ç©ºé—²å­è¿›ç¨‹æ•°æ˜¯å¦å°äºä¸Šé™ï¼Œå°äºåˆ™åˆ›å»ºæ–°çš„å­è¿›ç¨‹ çˆ¶è¿›ç¨‹æ”¶åˆ°0æ—¶ï¼Œæ£€æŸ¥ç©ºé—²å­è¿›ç¨‹æ•°æ˜¯å¦å¤§äºä¸Šé™ï¼Œå¤§äºåˆ™ç»ˆæ­¢ä¸€äº›å­è¿›ç¨‹ å¤šè·¯å¤ç”¨I/O selectå‡½æ•°æ£€æŸ¥ä¾¦å¬socketæ˜¯å¦æœ‰è¿æ¥åˆ°è¾¾ã€å·²è¿æ¥socketæ˜¯å¦æœ‰æ•°æ®åˆ°è¾¾ã€å·²è¿æ¥socketæ˜¯å¦å¯ä»¥å†™æ•°æ® åœ¨æµ‹è¯•æ˜¯å¦å¯è¯»çš„æè¿°ç¬¦é›†åˆrdsetä¸­åŒæ—¶åŒ…å«ä¾¦å¬socketå’Œå·²è¿æ¥socketï¼Œåœ¨æµ‹è¯•æ˜¯å¦å¯å†™æè¿°ç¬¦é›†åˆä¸­åŒ…å«å·²è¿æ¥socketï¼Œå°±å¯ä»¥å®ç°å¤šè·¯å¤ç”¨ Linux epoll ä¸€ç§å¤šè·¯å¤ç”¨æ¨¡å‹ å¯¹æ¯”select select\nint n = select(maxfd+1, \u0026amp;rds, NULL, NULL, 100); if (n \u0026gt; 0) { for(int i = 0; i \u0026lt; fdset_size; i++) { if (FD_ISSET(allFD[i],\u0026amp;rds)) { handleEvent(allFD[i]); } } } epoll\nint n = epoll_wait(epfd, events, 10, 100); for(int i = 0; i \u0026lt; n;i++) { handleEvent(events[n]); } å¸¦å¤–æ•°æ®ï¼ˆOOBï¼‰ å¸¦å¤–æ•°æ®ï¼ˆOut Of Bandï¼‰ï¼šä¼ è¾“å±‚ä½¿ç”¨å¸¦å¤–æ•°æ®å‘é€é‡è¦æ•°æ®\nç´§æ€¥çŠ¶æ€\nå‘é€æ–¹TCPåè®®ä¿è¯ç´§æ€¥çŠ¶æ€èƒ½å¤Ÿç«‹å³å‘é€ æ¥æ”¶æ–¹é€šè¿‡ä¿¡å·SIGURGæˆ–selectå‡½æ•°å¾—çŸ¥ç´§æ€¥çŠ¶æ€ TCPå¸¦å¤–æ•°æ®å‘é€ TCPåªæ”¯æŒ1å­—èŠ‚å¸¦å¤–æ•°æ® TCPä½¿ç”¨URGæ ‡å¿—ä½å’Œç´§æ€¥æŒ‡é’ˆæŒ‡æ˜å¸¦å¤–æ•°æ®ï¼šç´§æ€¥æŒ‡é’ˆ=å¸¦å¤–æ•°æ®ä½ç½®+1 å‘é€TCPå¸¦å¤–æ•°æ®çš„å‡½æ•° sendå‡½æ•°å’Œæ ‡å¿—MSG_OOB\nä¸€ä¸ªè¿›ç¨‹å·²ç»å¾€TCPè¿æ¥çš„å‘é€ç¼“å†²åŒºå†™å…¥äº†Nä¸ªå­—èŠ‚çš„æ™®é€šæ•°æ®ï¼Œç„¶åè¯¥è¿›ç¨‹åˆå‘è¿™ä¸ªè¿æ¥å†™å…¥äº†3å­—èŠ‚çš„å¸¦å¤–æ•°æ®â€œabcâ€ã€‚æ­¤æ—¶ï¼Œå¾…å‘é€çš„TCPæŠ¥æ–‡æ®µå¤´éƒ¨å°†è¢«è®¾ç½®ä¸ºURGæ ‡å¿—ï¼Œå¹¶å°†ç´§æ€¥æŒ‡é’ˆè®¾ç½®ä¸ºæŒ‡å‘å¸¦å¤–æ•°æ®çš„ä¸‹ä¸€å­—èŠ‚ã€‚\nå‘é€å•ä¸ªå­—èŠ‚ï¼Œè¿™ä¸ªå­—èŠ‚è¢«è®¤ä¸ºæ˜¯å¸¦å¤–æ•°æ®send(sockfd, \u0026quot;A\u0026quot;, 1, MSG_OOB); å‘é€å¤šä¸ªå­—èŠ‚ï¼Œåªæœ‰æœ€åä¸€ä¸ªå­—èŠ‚è¢«è®¤ä¸ºæ˜¯å¸¦å¤–æ•°æ®send(sockfd, \u0026quot;ABC\u0026quot;, 3, MSG_OOB);ï¼Œå…¶ä»–æ•°æ®è¢«å½“ä½œæ™®é€šæ•°æ®ã€‚ TCPæ¥æ”¶å¸¦å¤–æ•°æ®çš„è¿‡ç¨‹ TCPæ¥æ”¶ç«¯åœ¨æ”¶åˆ°ç´§æ€¥æŒ‡é’ˆæ ‡å¿—æ—¶æ£€æŸ¥ç´§æ€¥æŒ‡é’ˆï¼Œç„¶åæ ¹æ®ç´§æ€¥æŒ‡é’ˆçš„ä½ç½®ç¡®å®šå¸¦å¤–æ•°æ®çš„ä½ç½®ï¼Œå¹¶å°†å®ƒè¯»å…¥ä¸€ä¸ªç‰¹æ®Šçš„ç¼“å­˜ä¸­ï¼ˆ1å­—èŠ‚ï¼‰ï¼Œç§°ä¹‹ä¸ºå¸¦å¤–ç¼“å­˜ã€‚\næœªè®¾ç½®SO_OOBINLINEé€‰é¡¹æ—¶æ–°åˆ°æ¥çš„å¸¦å¤–æ•°æ®å°†è¦†ç›–æœªå¤„ç†çš„å¸¦å¤–æ•°æ®ã€‚ è®¾ç½®äº†SO_OOBINLINEé€‰é¡¹æ—¶æ–°åˆ°æ¥çš„å¸¦å¤–æ•°æ®ä¸ä¼šè¦†ç›–æœªå¤„ç†çš„å¸¦å¤–æ•°æ®ï¼Œä½†æœªå¤„ç†çš„å¸¦å¤–æ•°æ®å°†ä¼šå˜æˆæ™®é€šæ•°æ®ã€‚ ä»£ç  ./sigurg portï¼Œè¯»æ•°æ®ï¼Œå¸¦å¤–æ•°æ®åœ¨ä¿¡å·å¤„ç†ä¸­ ./oobserver portï¼Œæ¥å—è¿æ¥å¹¶ç»™å®¢æˆ·æœºå‘åŒ…å«å¸¦å¤–æ•°æ®çš„åŒ… ./oobclient port-iï¼Œoob_inline å¤ä¹  ä¸€å°å·¥ä½œäºå†…å¤–ç½‘æ¨¡å¼çš„ä¸»æœºï¼Œå…·æœ‰ä¸€ä¸ªå¤–ç½‘åœ°å€IP_OUTTERå’Œä¸€ä¸ªå†…ç½‘åœ°å€192.168.1ï¼Œå†…ç½‘çš„æ©ç ä¸º192.168.1.125ã€‚è¯¥ä¸»æœºå¯å°†å¤–ç½‘ç”¨æˆ·çš„è¯·æ±‚å¹¿æ’­ç»™å†…ç½‘ç”¨æˆ·ã€‚è¯·è®¾è®¡å’Œå®ç°è¯¥ä¸»æœºç¨‹åºã€‚\né—®é¢˜åˆ†æå’Œæ–¹æ¡ˆè®¾è®¡ TCPåè®®å…·æœ‰ç¨³å®šå¯é çš„ç‰¹æ€§ï¼Œæœ¬é¢˜ä¸­å¤–ç½‘é€šä¿¡å±äºå•æ’­ï¼Œä½¿ç”¨TCPåè®®èƒ½å¤Ÿå…·æœ‰è‰¯å¥½æ€§èƒ½ï¼Œå› æ­¤å¤–ç½‘é€šä¿¡ä½¿ç”¨TCPå¥—æ¥å­—ã€‚ å†…ç½‘æ¶‰åŠåˆ°å¹¿æ’­ï¼Œé€‚åˆä½¿ç”¨UDPåè®®è¿›è¡Œå·¥ä½œï¼Œå› æ­¤å†…ç½‘é‡‡ç”¨UDPå¥—æ¥å­—å·¥ä½œã€‚ ä¸»æœºé‡‡ç”¨å•è¿›ç¨‹ã€é˜»å¡å¼å·¥ä½œã€‚ ç¼–ç¨‹ #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; using namespace std; const int port = 8080; int main() { int sockt, connfd, socku; struct sockaddr_in addr, addrX; char buf[2048]; if ((sockt = socket(AF_INET, SOCK_STREAM, 0)) \u0026lt; 0) { exit(-1); } bzero(\u0026amp;addr, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = htonl(INADDR_ANY); if ((bind(sockt, (sockaddr *)\u0026amp;addr, sizeof(addr))) \u0026lt; 0) { exit(-1); } if (listen(sockt, 5) == -1) { exit(-1); } struct sockaddr_in cli_addr; socklen_t sin_size = sizeof(struct sockaddr_in); for (;;) { connfd = accept(sockt, (sockaddr *)\u0026amp;cli_addr, \u0026amp;sin_size); if (connfd \u0026lt; 0) { exit(-1); } int n = read(connfd, buf, 2048); if (n \u0026lt;= 0) { exit(-1); } if ((socku = socket(AF_INET, SOCK_DGRAM, 0)) \u0026lt; 0) { exit(-1); } bzero(\u0026amp;addrX, sizeof(addr)); addrX.sin_family = AF_INET; addrX.sin_port = htons(port); addrX.sin_addr.s_addr = inet_addr(\u0026#34;192.168.1.1\u0026#34;); n = sendto(socku, buf, n, 0, (sockaddr *)\u0026amp;addrX, sizeof(addrX)); close(socku); close(sockt); } return 0; } æœ‰ä¸€å°æœåŠ¡å™¨ï¼Œå¯ä»¥ä¸ºå¤šä¸ªå®¢æˆ·æœºåŒæ—¶æä¾›ä¸¤ä¸ªæ•´æ•°çš„ä¹˜æ³•å’Œé™¤æ³•è¿ç®—ï¼Œè¯·è®¾è®¡å’Œå®ç°è¯¥æœåŠ¡å™¨ã€‚æç¤ºï¼šéœ€è€ƒè™‘åº”ç”¨å±‚åè®®ã€åƒµå°¸è¿›ç¨‹çš„æ¸…é™¤ç­‰é—®é¢˜ã€‚\né—®é¢˜åˆ†æå’Œæ–¹æ¡ˆè®¾è®¡ æœ¬é¢˜éœ€è¦åŒæ—¶ä¸ºå¤šä¸ªå®¢æˆ·æœºæœåŠ¡ï¼Œåº”é‡‡ç”¨å¹¶å‘æ–¹å¼ï¼› å¯¹äºæ•´æ•°ã€è¦è€ƒè™‘å­—èŠ‚é¡ºåºè½¬æ¢ï¼› é™¤æ³•è¦è€ƒè™‘é™¤0é—®é¢˜ï¼› è®¾è®¡æœåŠ¡å™¨æ¥æ”¶æ•°æ®æ ¼å¼å¦‚ä¸‹ï¼š int mType (è¿ç®—ç±»å‹ï¼š0-ä¹˜ã€1-é™¤) n1(æ•´æ•°1)ï¼Œn2(æ•´æ•°2) æœåŠ¡å™¨å‘é€æ•°æ®æ ¼å¼å¦‚ä¸‹ï¼š int mRet(0-æ­£ç¡®ã€1-é”™è¯¯) nï¼ˆè¿ç®—ç»“æœï¼‰ å·¥ä½œäºTCPæ–¹å¼ã€‚ ç¼–ç¨‹ void sigchild_handler(int sig) { wait(NULL); } main() { int sock, connfd; struct sockaddr_in addr; struct sigaction sigact; short mRet, mType; int n, n1, n2; char buf[1024]; sigact.sa_handler = sigchild_handler; sigact.sa_mask = 0; sigact.sa_flags = 0; sigaction(SIGCHILD, \u0026amp;sigact, NULL); if ((sock = socket(AF_INET, SOCK_STREAM, 0))\u0026lt; 0) { exit(-1); } SET_ADDR_PORT; if (bind() \u0026lt; 0) { exit(-1); } if (listen(sock, 5) \u0026lt; 0) { exit(-1); } for (;;) { connfd = accept(); if (connfd \u0026lt; 0) { exit(-1); } if (fork() == 0) { close(sock); int n = read(conndf, buf, 2048); if (n \u0026lt;= 0) { exit(-1); } mRet = 0; ntoh(CharToInt); if (mType == 0) { n = hton(n1*n2); } else if (mType == 1 \u0026amp;\u0026amp; n2 != 0) { n = hton(n1/n2); } else { mRet = hton(1); n = 0; } IntToChar; write(connfd, buf, 2*sizeof(int)); close(connfd); exit(0); } exit(0); } close(sock); } ","permalink":"https://fffzlfk.github.io/posts/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","summary":"Network Program Design for Application","title":"ç½‘ç»œåº”ç”¨ç¨‹åºè®¾è®¡"},{"content":"æ¦‚è¿° åˆ†å¸ƒå¼ç³»ç»Ÿå®šä¹‰ åˆ†å¸ƒå¼è®¡ç®—ï¼šå¤šä¸ªé€šè¿‡ç½‘ç»œäº’è”çš„è®¡ç®—èŠ‚ç‚¹é€šè¿‡ç›¸äº’åä½œå…±åŒå®Œæˆè®¡ç®—ä»»åŠ¡ã€‚\nç†è§£åˆ†å¸ƒå¼ç³»ç»Ÿå®šä¹‰çš„å‡ ä¸ªè¦ç‚¹ å¤šä¸ªè®¡ç®—èŠ‚ç‚¹ï¼šè®¡ç®—èŠ‚ç‚¹æŠ½è±¡ä¸ºæœ‰é™çŠ¶æ€æœºï¼ˆå›¾çµæœºï¼‰ ç½‘ç»œäº’è” ç‹¬ç«‹è‡ªæ²» ç›¸äº’åä½œå…±åŒå®Œæˆç›®æ ‡ æ¶ˆæ¯ä¼ é€’æ¨¡å‹ ä¸å¹¶è¡Œè®¡ç®—çš„å…³ç³» ä¸åŒå±‚æ¬¡çš„å¹¶è¡Œè®¡ç®—ï¼š\næŒ‡ä»¤çº§å¹¶è¡Œï¼šå¤šæŒ‡ä»¤å¹¶è¡Œï¼›å•æŒ‡å¤šæ•°å¹¶è¡Œï¼ˆå‘é‡æŒ‡ä»¤ï¼‰ CPUå¤šæ ¸å¹¶è¡Œï¼šå¤šçº¿ç¨‹ç¼–ç¨‹ å¤šCPUå¹¶è¡Œï¼ˆä¸€è‡´æ€§å†…å­˜è®¿é—®ï¼‰ï¼šå¤šçº¿ç¨‹ç¼–ç¨‹ å¤šCPUå¹¶è¡Œï¼ˆéä¸€è‡´æ€§å†…å­˜è®¿é—®ï¼‰ï¼šè¶…çº§è®¡ç®—æœº åŸºäºGPUçš„å¹¶è¡Œï¼šå•æŒ‡å¤šæ•°å¹¶è¡Œï¼›CUDAã€OpenCL å¤šæœºå¹¶è¡Œï¼šå°±ä¸šæ¶ˆæ¯ä¼ é€’çš„åˆ†å¸ƒå¼è®¡ç®—ï¼ˆshare nothingï¼‰ æ„å»ºåˆ†å¸ƒå¼ç³»ç»Ÿçš„ç›®çš„ æé«˜è®¡ç®—èƒ½åŠ› æé«˜å­˜å‚¨èƒ½åŠ› æé«˜ç½‘ç»œååèƒ½åŠ›ï¼ˆå¹¶å‘è®¿é—®èƒ½åŠ›ï¼‰ æé«˜å¯é æ€§ï¼ˆè§£å†³å±€éƒ¨å¤±æ•ˆé—®é¢˜ï¼‰ æé«˜å®‰å…¨æ€§ï¼ˆè§£å†³è¢«å±€éƒ¨æ”»å‡»é—®é¢˜ï¼‰ æé«˜å¯æ‰©å±•æ€§ï¼ˆè§£å†³ç“¶é¢ˆé—®é¢˜ï¼‰ å®ç°èµ„æºå…±äº« å®ç°è·¨è¶Šæ—¶ç©ºçš„ååŒæœåŠ¡ï¼ˆå‘æŒ¥ä¸åŒèŠ‚ç‚¹çš„ä¼˜åŠ¿ï¼‰ è¡¡é‡åˆ†å¸ƒå¼ç³»ç»Ÿä¼˜åŠ£çš„ç‰¹æ€§ å¯æ‰©å±•æ€§/å¯ä¼¸ç¼©æ€§ï¼ˆScalabilityï¼‰ å‚ç›´å¯æ‰©å±•æ€§ï¼ˆVertical Scalablilityï¼‰ æ°´å¹³å¯æ‰©å±•æ€§ï¼ˆHorizontal Scalabilityï¼‰ å®¹é”™æ€§ï¼ˆFault Tolerance/Reliabilityï¼‰ å¯ç”¨æ€§ï¼ˆAvailabilityï¼‰ å¯æ¢å¤æ€§ï¼ˆRecoverabilityï¼‰ é€æ˜æ€§ï¼ˆTransparencyï¼‰ å¼€æ”¾æ€§ï¼ˆOpennessï¼‰ å®‰å…¨æ€§ï¼ˆSecurityï¼‰ å¯ç»´æŠ¤æ€§ï¼ˆMaintainabilityï¼‰ è®¾è®¡åˆ†å¸ƒå¼ç³»ç»Ÿçš„æŒ‘æˆ˜ å¼‚æ„æ€§ è‡ªæ²» å±€éƒ¨è§†å›¾ å¼€æ”¾æ€§ å¯æ‰©å±•æ€§ æ•…éšœå¤„ç† å®‰å…¨æ€§ é€æ˜æ€§ æœåŠ¡è´¨é‡ä¿è¯ å…³äºåˆ†å¸ƒå¼ä¸€è‡´æ€§ å‡ ç±»åˆ†å¸ƒå¼ç³»ç»Ÿæ¡†æ¶æ¨¡å¼ å®¢æˆ·ç«¯-æœåŠ¡å™¨ï¼ˆClient-Serverï¼‰æ¨¡å¼ å®¢æˆ·ç«¯å‘å‡ºæœåŠ¡è¯·æ±‚ï¼ŒæœåŠ¡ç«¯æ ¹æ®å®¢æˆ·ç«¯è¯·æ±‚å‚æ•°å®Œæˆå®é™…è¿ç®—ï¼Œå¹¶å°†è¿ç®—ç»“æœè¿”å›ç»™å®¢æˆ·ç«¯ å®¢æˆ·ç«¯è¿ç®—ä»»åŠ¡è½»ã€æœåŠ¡ç«¯è¿ç®—ä»»åŠ¡é‡ å®¢æˆ·ç«¯ç”Ÿå‘½å‘¨æœŸçŸ­ã€æœåŠ¡ç«¯ç”Ÿå‘½å‘¨æœŸé•¿ æœåŠ¡ç«¯ä¸€èˆ¬è¦åº”å¯¹å¹¶å‘é—®é¢˜ å®¢æˆ·ç«¯ä¸€èˆ¬è´Ÿè´£å’Œç”¨æˆ·è¿›è¡Œäº¤äº’ ç˜¦å®¢æˆ·ç«¯/èƒ–æœåŠ¡ç«¯ Clientâ€”Clusteræ¨¡å¼\næ˜¯Client-Serveræ¨¡å¼çš„å˜ç§ æœåŠ¡ç«¯ç”±å¤šä¸ªæœåŠ¡å™¨æ„æˆï¼Œå…±åŒæ‰¿æ‹…è®¡ç®—ä»»åŠ¡ åœ¨å®è§‚é€»è¾‘ä¸Šï¼Œå¤šä¸ªæœåŠ¡å™¨æ„æˆçš„é›†ç¾¤å¯ä»¥è§†ä¸ºå•ä¸€çš„åŠŸèƒ½å¼ºå¤§çš„è®¡ç®—èŠ‚ç‚¹ã€‚å®¢æˆ·ç«¯æ„Ÿè§‰ä¸åˆ°æœåŠ¡ç«¯çš„å®é™…æ„æˆã€‚ ä¸»ä»ï¼ˆMaster-Slaveï¼‰æ¨¡å¼\nä¸»èŠ‚ç‚¹ï¼ˆMasterï¼‰è´Ÿè´£å°†æ€»ä»»åŠ¡åˆ†è§£ä¸ºå¤šä¸ªè‡ªä»»åŠ¡åˆ†å‘ç»™å„ä¸ªä»èŠ‚ç‚¹ï¼ˆSlaveï¼Œä¹Ÿå«WorkerèŠ‚ç‚¹ï¼‰ ä¸»èŠ‚ç‚¹ç›‘è§†å„ä¸ªä»èŠ‚ç‚¹çš„ä»»åŠ¡æ‰§è¡Œæƒ…å†µï¼Œå°†æ‰§è¡Œå¤±è´¥çš„ä»»åŠ¡è°ƒåº¦ç»™å…¶ä»–çš„ä»èŠ‚ç‚¹å®Œæˆ ä¸»èŠ‚ç‚¹åœ¨åˆ†é…ä»»åŠ¡æ—¶ä¼šå‚è€ƒå„ä¸ªèŠ‚ç‚¹çš„å½“å‰è´Ÿè½½æƒ…å†µ æ€»çº¿æ¨¡å¼\nä¸åŒèŠ‚ç‚¹é€šè¿‡è™šæ‹Ÿæ€»çº¿ç›¸è¿ æ¶ˆæ¯å‘é€è€…ä¸å¿…çŸ¥é“æ¥æ”¶è€…æ˜¯è°ï¼Œæ¥æ”¶è€…ä¹Ÿä¸çŸ¥é“å‘é€è€…æ˜¯è° å‘é€è€…å’Œæ¥æ”¶è€…ä¹‹é—´ç”¨å¼‚æ­¥æ–¹å¼é€šä¿¡ ä¸€ç§æ¾è€¦åˆç»“æ„ ä¸åŒèŠ‚ç‚¹å®Œæˆä¸åŒåŠŸèƒ½ï¼Œåˆ†å·¥åä½œ å¯¹ç­‰ï¼ˆPeer-to-Peerï¼‰æ¨¡å¼\nç³»ç»Ÿä¸­æ¯ä¸ªè®¡ç®—èŠ‚ç‚¹åœ¨ä»»åŠ¡åˆ†å·¥ä¸Šæ˜¯å®Œå…¨å¯¹ç­‰çš„ å®Œå…¨ç›¸åŒè½¯ä»¶åœ¨ä¸åŒçš„è®¡ç®—æœºä¸Šè¿è¡Œï¼Œåªæ˜¯åˆå§‹åŒ–å‚æ•°ä¸åŒ ç»“æ„åŒ–P2Pï¼šä¸åŒèŠ‚ç‚¹ä¹‹é—´çš„äº¤äº’æ¨¡å¼éµå¾ªå›ºå®šè§„å¾‹ éç»“æ„åŒ–P2Pï¼šä¸åŒèŠ‚ç‚¹ä¹‹é—´çš„äº¤äº’æ¨¡å¼æ²¡æœ‰å›ºå®šè§„å¾‹ æ··åˆæ¨¡å¼\nå¸¸ç”¨çš„è´Ÿè½½å‡è¡¡ç­–ç•¥ éšæœº è½®è¯¢ å›ºå®šæƒé‡å€¼ IPå“ˆå¸Œï¼ˆåŸºäºä¸€è‡´æ€§éšæœºæ•£åˆ—å‡½æ•°ï¼‰ æœ€å°‘TCPè¿æ¥æ•° æœ€å°å“åº”æ—¶é—´ åŸºäºå„æœåŠ¡å™¨å®é™…è´Ÿè½½çš„åŠ¨æ€è´Ÿè½½å‡è¡¡ç®—æ³• ä¸­é—´ä»¶çš„åŸºæœ¬æ¦‚å¿µ ä¸­é—´ä»¶çš„ä½œç”¨ ä¸ºå¼€å‘è€…æä¾›é«˜å±‚çš„ç¼–ç¨‹æŠ½è±¡ï¼Œå±è”½åˆ†å¸ƒå¼ç³»ç»Ÿçš„åº•å±‚çš„å¼‚æ„å‹å¤æ‚æ€§ æé«˜äº’æ“ä½œæ€§å’Œå¯ç§»æ¤æ€§ æä¾›åˆ†å¸ƒå¼ç³»ç»Ÿçš„åŸºç¡€è®¾æ–½æœåŠ¡ å¸¸ç”¨çš„ä¸­é—´ä»¶ è¿œç¨‹è¿‡ç¨‹è°ƒç”¨ä¸­é—´ä»¶ åˆ†å¸ƒå¼å¯¹è±¡ä¸­é—´ä»¶ åˆ†å¸ƒå¼ç»„ä»¶ä¸­é—´ä»¶ æ¶ˆæ¯é˜Ÿåˆ—ä¸­é—´ä»¶ WebæœåŠ¡ä¸­é—´ä»¶ P2Pä¸­é—´ä»¶ ä¸­é—´ä»¶çš„è¡¨ç°å½¢å¼ ä½œä¸ºç‹¬ç«‹çš„åå°è¿›ç¨‹å­˜åœ¨ ä½œä¸ºè¿è¡Œæ—¶çš„å‡½æ•°åº“/ç±»åº“å­˜åœ¨ï¼ˆLIBé™æ€åº“ã€DLLåŠ¨æ€åº“ã€JaråŒ…ç­‰ï¼‰ ä½œä¸ºæºä»£ç çº§çš„å‡½æ•°åº“/ç±»åº“å­˜åœ¨ ä½œä¸ºé«˜çº§è¯­è¨€è§£é‡Šå™¨çš„ä¸€éƒ¨åˆ†å­˜åœ¨ ä½œä¸ºè¾…åŠ©ç¼–è¯‘å·¥å…·å­˜åœ¨ ä½œä¸ºé«˜çº§è¯­è¨€ç¼–è¯‘å™¨çš„ä¸€éƒ¨åˆ†å­˜åœ¨ æŠ½è±¡ç†è®ºæ¨¡å‹ äº¤äº’æ¨¡å¼ åŒæ­¥æ¨¡å‹ å¼‚æ­¥æ¨¡å‹ ä¿¡æ¯æ•…éšœæ¨¡å¼ èŠ‚ç‚¹æ•…éšœæ¨¡å¼ å¤±æ•ˆåœæ­¢æ¨¡å¼ï¼ˆFailâ€”Stopï¼‰ å¤±æ•ˆåœæ­¢æ¢å¤æ¨¡å¼ æ‹œå åº­æ¨¡å¼ å‘é€è€…éªŒè¯æ‹œå åº­æ¨¡å¼ ç†æ€§æ‹œå åº­æ¨¡å¼ åˆ†å¸ƒå¼èŠ‚ç‚¹ä¹‹é—´çš„é€šä¿¡æŠ€æœ¯ TCP/IPç½‘ç»œä½“ç³»ä»‹ç» TCP/IPå…ˆäºOSIæ¨¡å‹ï¼Œä¸å®Œå…¨ç¬¦åˆOSIæ ‡å‡† TCP/IPå››å±‚æ¨¡å‹ï¼ˆä¹Ÿå¯åˆ†ä¸ºäº”å±‚ï¼Œå°†ç½‘ç»œæ¥å£åˆ†ä¸ºä¸¤å±‚ï¼‰ Socket ä»€ä¹ˆæ˜¯Socket ç½‘ç»œå±‚å’Œä¼ è¾“å±‚æä¾›ç»™åº”ç”¨å±‚çš„æ ‡å‡†åŒ–ç¼–ç¨‹æ¥å£ï¼ˆæˆ–ç§°ä¸ºç¼–ç¨‹æ¥å£ï¼‰ å¥—æ¥å­—åˆ†ç±»-Socketç±»å‹ æµå¼å¥—æ¥å­—\næ•°æ®æŠ¥å¥—æ¥å­—\nåŸå§‹å¥—æ¥å­—\nå¦‚ä½•æ ‡è¯†ä¸€ä¸ªSocket äº”å…ƒç»„ï¼š\u0026lt;SIP, sPort, dIP, dPort, åè®®\u0026gt;\næœ¬åœ°IPåœ°å€ æœ¬åœ°ç«¯å£å·ï¼ˆé€šå¸¸ä¸´æ—¶åˆ†é…ï¼š1024~5000ï¼‰ è¿œç¨‹IPåœ°å€ è¿œç¨‹ç«¯å£å·ï¼ˆé€šå¸¸ä½¿ç”¨ä¿ç•™ç«¯å£å·1~1023ï¼‰ åè®®ç±»å‹ï¼ˆæ³¨æ„TCP 53å’ŒUDP 53æ˜¯ä¸åŒçš„ï¼‰ TCPå¥—æ¥å­—ç¼–ç¨‹å…¸å‹æ¨¡å‹ UDPå¥—æ¥å­—ç¼–ç¨‹å…¸å‹æ¨¡å‹ å¹¶å‘æœåŠ¡æŠ€æœ¯ åŸºäºå¤šçº¿ç¨‹çš„å¹¶å‘æœåŠ¡æŠ€æœ¯ åŸºäºçº¿ç¨‹æ± çš„å¹¶å‘æœåŠ¡æŠ€æœ¯ ç¤ºä¾‹ç¨‹åº åŸºäºTCPåè®®çš„Client-Serveré€šä¿¡ç¨‹åºç¤ºä¾‹ Server Client ç¬¬ä¸€æ¬¡ä½œä¸š å°†åŸºäºUDPåè®®çš„Client-Serveré€šä¿¡ç¨‹åºç¤ºä¾‹çš„æœåŠ¡å™¨ç«¯ç¨‹åºæ”¹é€ æˆå¤šçº¿ç¨‹ç‰ˆã€‚\nå°†åŸºäºTCPåè®®çš„Client-Serveré€šä¿¡ç¨‹åºç¤ºä¾‹çš„æœåŠ¡å™¨ç«¯ç¨‹åºæ”¹é€ æˆçº¿ç¨‹æ± ç‰ˆã€‚\nä»£ç å®ç°\nè¿œç¨‹è°ƒç”¨RPCå’ŒRMI è¿œç¨‹è°ƒç”¨RPC è¿œç¨‹è¿‡ç¨‹è°ƒç”¨ï¼ˆRemote Procedure Callï¼ŒRPCï¼‰ï¼šä½¿åº”ç”¨ç¨‹åºå¯ä»¥åƒè°ƒç”¨æœ¬åœ°èŠ‚ç‚¹ä¸Šçš„è¿‡ç¨‹é‚£æ ·å»è°ƒç”¨ä¸€ä¸ªè¿œç¨‹èŠ‚ç‚¹ä¸Šçš„å­ç¨‹åºã€‚\nè¿œç¨‹æ–¹æ³•è°ƒç”¨RMI è¿œç¨‹æ–¹æ³•è°ƒç”¨ï¼ˆRemote Method Invocationï¼Œ RMIï¼‰ï¼šå°†é¢å‘å¯¹è±¡çš„ç¼–ç¨‹æ¨¡å‹æ‰©å±•åˆ°äº†åˆ†å¸ƒå¼ç¯å¢ƒã€‚\nRPC/RMIä¸­é—´ä»¶çš„ä½œç”¨ å®šä¹‰å¹¶åˆ©ç”¨SocketæœåŠ¡æ¥å£å®ç°äº†ä¸€å¥—è°ƒç”¨è€…å’Œè¢«è°ƒç”¨è€…ä¹‹é—´çš„é€šä¿¡åè®®â€”â€”è¿œç¨‹è°ƒç”¨åè®® å®ç°äº†è¿‡ç¨‹å‚æ•°ä»¥åŠè¿ç®—ç»“æœçš„åºåˆ—åŒ–å’Œååºåˆ—åŒ– é€šä¿¡è¿‡ç¨‹ä¸­çš„é”™è¯¯å¤„ç† è¿‡ç¨‹æœåŠ¡è¿›ç¨‹ï¼ˆæˆ–è¿œç¨‹å¯¹è±¡ï¼‰çš„é›†ä¸­æ³¨å†Œä¸å‘ç°â€”â€”ç›®å½•æœåŠ¡ è¿œç¨‹å¯¹è±¡çš„ç»Ÿä¸€æ ‡è¯†å’Œç”Ÿå‘½å‘¨æœŸç®¡ç† åœ¨æœåŠ¡ç«¯æ”¯æŒå¹¶å‘è®¿é—®ï¼ˆå¤šé‡‡ç”¨å¤šçº¿ç¨‹æŠ€æœ¯ï¼‰ æ³¨å†Œä¸­å¿ƒ ç”¨äºæœåŠ¡ç«¯æ³¨å†Œè¿œç¨‹æœåŠ¡ä»¥åŠå®¢æˆ·ç«¯å‘ç°æœåŠ¡ å¯ä»¥å®ç°è´Ÿè½½å‡è¡¡ RPC/RMIä¸­é—´ä»¶çš„å®ç°åŸç† åœ¨è°ƒç”¨è€…è¿›ç¨‹ä¸­æ³¨å…¥stu/proxyæ¨¡å— åœ¨è¢«è°ƒç”¨è€…è¿›ç¨‹ä¸­æ³¨å…¥skeletonæ¨¡å— stubå’Œskeletonä¹‹é—´åˆ©ç”¨Socketè¿›è¡Œé€šä¿¡ skeletonç›¸å½“äºæœåŠ¡å™¨ç«¯ gRPCä¸­é—´ä»¶ é€šä¿¡åè®®åŸºäºHTTPåè®®æ ‡å‡†ï¼Œå¯¹è±¡åºåˆ—åŒ–åŸºäº**ProtoBuf(Protocol Buffers)**åºåˆ—åŒ–åè®® Protocol Buffers(ç®€ç§°Protobuf) æ˜¯Googleè®¾è®¡çš„åºåˆ—åŒ–æ ‡å‡†åè®®å’Œåºåˆ—åŒ–ä¸­é—´ä»¶ã€‚ ç¨‹åºä¸­åº”ç”¨Protobufçš„æ–¹æ³• åœ¨.protoæ–‡ä»¶ä¸­å®šä¹‰è¦åºåˆ—åŒ–çš„å¯¹è±¡ï¼ˆä½¿ç”¨ç‹¬ç«‹äºå…·ä½“ç¼–ç¨‹è¯­è¨€çš„æ ‡å‡†æ ¼å¼Protocol Buffersï¼‰ åˆ©ç”¨ä»£ç è‡ªåŠ¨ç”Ÿæˆå·¥å…·ï¼ˆegï¼šWindowsä¸‹protoc.exeï¼‰ç”Ÿæˆæ‰€æœ‰è¦åºåˆ—åŒ–å¯¹è±¡çš„å·¥å‚ç±» å°†ç”Ÿæˆçš„å·¥å‚ç±»æºç æ·»åŠ åˆ°åº”ç”¨å·¥ç¨‹ä¸­ éœ€è¦åˆ›å»ºä¸€ä¸ªå¯åºåˆ—åŒ–å¯¹è±¡æ—¶ï¼Œç”¨å·¥å‚å¯¹è±¡åˆ›å»º è°ƒç”¨å¯åºåˆ—åŒ–å¯¹è±¡çš„writeToæ–¹æ³•å°†å¯¹è±¡åºåˆ—åŒ–æˆå­—èŠ‚æµå¹¶å­˜å…¥å¤–éƒ¨å­˜å‚¨ä»‹è´¨ è°ƒç”¨å·¥å‚å¯¹è±¡çš„parseFromæ–¹æ³•å¯ä»¥å®ç°ååºåˆ—åŒ–ï¼Œå¹¶æ ¹æ®ååºåˆ—åŒ–ç»“æœç”Ÿæˆä¸€ä¸ªæ–°çš„å¯¹è±¡ ç¨‹åºä¸­åº”ç”¨gRPCçš„æ–¹æ³• å°†RPCæœåŠ¡æ¥å£å®šä¹‰ä¸ºæ ‡å‡†.protoæ–‡ä»¶ ç”¨Protobufæä¾›çš„ä»£ç è‡ªåŠ¨ç”Ÿæˆå·¥å…·æ ¹æ®.protoæ–‡ä»¶ç”ŸæˆRPCæœåŠ¡ä¸­æ‰€æœ‰è¦åºåˆ—åŒ–å¯¹è±¡çš„å·¥å‚ç±» åˆ©ç”¨gRPCæä¾›çš„ä»£ç è‡ªåŠ¨ç”Ÿæˆå·¥å…·æ ¹æ®.protoæ–‡ä»¶ç”ŸæˆRPCæœåŠ¡çš„stubç±»å’Œskeletonç±» å°†å·¥å…·è‡ªåŠ¨ç”Ÿæˆçš„åºåˆ—åŒ–å¯¹è±¡å·¥å‚ç›¸å…³æºç¨‹åºã€RPCæœåŠ¡çš„stubç±»å’Œskeletonç±»ç›¸å…³æºç¨‹åºåŠ å…¥çš„RPCæœåŠ¡ç«¯å·¥ç¨‹ä¸­ RPCæœåŠ¡ç«¯å·¥ç¨‹åŸºäºskeletonç±»ä¸­ç›¸å…³åŸºç±»å®ç°RPCæœåŠ¡åŠŸèƒ½çš„æ ¸å¿ƒé€»è¾‘å’Œç›‘å¬æœåŠ¡å™¨ å°†å·¥å…·è‡ªåŠ¨ç”Ÿæˆçš„åºåˆ—åŒ–å¯¹è±¡å·¥å‚ç›¸å…³æºç¨‹åºã€RPCæœåŠ¡çš„stubç±»å’Œskeletonç±»ç›¸å…³æºç¨‹åºåŠ å…¥çš„RPCå®¢æˆ·ç«¯å·¥ç¨‹ä¸­ RPCå®¢æˆ·ç«¯å·¥ç¨‹åŸºäºstubç±»å®ç°è°ƒç”¨RPCæœåŠ¡çš„ç›¸å…³é€»è¾‘ ç¬¬äºŒæ¬¡ä½œä¸š åˆ©ç”¨RPCæŠ€æœ¯å®ç°ä¸€ä¸ªä¹¦ç±ä¿¡æ¯ç®¡ç†ç³»ç»Ÿï¼Œå…·ä½“è¦æ±‚ï¼š\nå®¢æˆ·ç«¯å®ç°ç”¨æˆ·äº¤äº’ï¼ŒæœåŠ¡å™¨ç«¯å®ç°ä¹¦ç±ä¿¡æ¯å­˜å‚¨å’Œç®¡ç†ã€‚å®¢æˆ·ç«¯ä¸æœåŠ¡å™¨ç«¯åˆ©ç”¨RPCæœºåˆ¶è¿›è¡Œé€šä¿¡ã€‚å¯ä»¥é€‰æ‹©Java RMIã€gRPCã€Dubboç­‰ä»»æ„RPCä¸­é—´ä»¶ã€‚ æœåŠ¡å™¨ç«¯è‡³å°‘æš´éœ²å¦‚ä¸‹RPCæ¥å£ï¼š bool add(Book b) æ·»åŠ ä¸€ä¸ªä¹¦ç±å¯¹è±¡ã€‚ï¼ˆæ³¨æ„Bookå¯¹è±¡åºåˆ—åŒ–é—®é¢˜ï¼‰ Book queryByID(int bookID) æŸ¥è¯¢æŒ‡å®šIDå·çš„ä¹¦ç±å¯¹è±¡ã€‚ BookList queryByName(String name) æŒ‰ä¹¦åæŸ¥è¯¢ä¹¦ç±å¯¹è±¡åˆ—è¡¨ã€‚ bool delete((int bookID) åˆ é™¤æŒ‡å®šIDå·çš„ä¹¦ç±å¯¹è±¡ã€‚ å®ç°\nå¾®æœåŠ¡ å„ä¸ªæ¨¡å—ç‹¬ç«‹ï¼ˆå¤§å¤šé‡‡ç”¨å®¹å™¨æŠ€æœ¯ï¼ˆå¦‚Dockerï¼‰ï¼‰ï¼Œæ¨¡å—ä¹‹é—´ä½¿ç”¨RPCé€šä¿¡ã€‚\nåŸºäºæ¶ˆæ¯ä¸­é—´ä»¶çš„é€šä¿¡æŠ€æœ¯ ç‚¹åˆ°ç‚¹é€šä¿¡æŠ€æœ¯çš„ç¼ºç‚¹ å…³ç³»å¤æ‚ï¼Œè€¦åˆåº¦é«˜ å¯æ‰©å±•æ€§å·®ï¼šå¢åŠ ç”Ÿäº§è€…æˆ–æ¶ˆè´¹è€…å¯¹å¤šä¸ªèŠ‚ç‚¹äº§ç”Ÿå½±å“ å®¹é”™æ€§å·®ï¼šèŠ‚ç‚¹å¤±æ•ˆæˆ–ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…é€Ÿåº¦ä¸åŒ¹é…ä¼šä¸¢å¤±æ•°æ® è§£å†³æ–¹æ¡ˆâ€”â€”å¢å‡ä¸­ä»‹èŠ‚ç‚¹ é™ä½äº†è€¦åˆæ€§ æé«˜äº†å®¹é”™æ€§ï¼šä¸­ä»‹èŠ‚ç‚¹å…·æœ‰æ•°æ®ç¼“å­˜åŠŸèƒ½ æé«˜äº†å¯æ‰©å±•æ€§ï¼šå¢åŠ ç”Ÿäº§è€…æˆ–æ¶ˆè´¹è€…å¯¹å…¶ä»–èŠ‚ç‚¹æ— å½±å“ é¢å‘æ¶ˆæ¯ä¸­é—´ä»¶ï¼ˆMessage Oriented Middlewareï¼ŒMOMï¼‰ ä½¿åˆ†å¸ƒå¼åº”ç”¨ç¨‹åºå¯ä»¥é€šè¿‡å‘é€å’Œæ¥æ”¶æ¶ˆæ¯æ¥è¿›è¡Œå¼‚æ­¥é€šä¿¡å’Œäº¤æ¢æ•°æ®ã€‚\nMOMä¸¤ç§é€šä¿¡æ¨¡å¼ æ¶ˆæ¯é˜Ÿåˆ—æ¨¡å¼\næ¶ˆæ¯é˜Ÿåˆ—ä¸­çš„æ¶ˆæ¯ä¸€æ—¦è¢«æŸä¸ªæ¶ˆè´¹è€…å–èµ°ï¼Œè¯¥æ¶ˆæ¯å°±ä»é˜Ÿåˆ—ä¸­åˆ é™¤ å¯ä»¥å®ç°è´Ÿè½½å‡è¡¡ ä¸»é¢˜è®¢é˜…æ¨¡å¼ï¼ˆç±»ä¼¼å¾®ä¿¡å…¬ä¼—å·è®¢é˜…ï¼‰\nå¤šä¸ªè®¢é˜…åŒä¸€ä¸»é¢˜çš„æ¶ˆè´¹è€…å¯ä»¥åŒæ—¶æ¥æ”¶å‘å¸ƒåˆ°è¯¥æ¶ˆæ¯ä¸»é¢˜çš„æ¶ˆæ¯ å¯ä»¥å®ç°å¹¿æ’­ ä¸‰ç§æ¥æ”¶æ–¹å¼ é˜»å¡æ¥æ”¶ï¼ˆåŒæ­¥ï¼‰ è½®è¯¢æ¥æ”¶ å›è°ƒæ¥æ”¶ï¼ˆå¼‚æ­¥ï¼‰ ç¬¬ä¸‰æ¬¡ä½œä¸š åˆ©ç”¨MOMæ¶ˆæ¯é˜Ÿåˆ—æŠ€æœ¯å®ç°ä¸€ä¸ªåˆ†å¸ƒå¼éšæœºä¿¡å·åˆ†æç³»ç»Ÿï¼Œå…·ä½“è¦æ±‚ï¼š\néšæœºä¿¡å·äº§ç”Ÿå™¨æ¯éš”10æ¯«ç§’å·¦å³å°±äº§ç”Ÿä¸€ä¸ªæ­£æ€åˆ†å¸ƒçš„éšæœºæ•°å­—ï¼Œå¹¶ä½œä¸ºä¸€ä¸ªæ¶ˆå‘å¸ƒ å¤šä¸ªéšæœºä¿¡å·åˆ†ææ¨¡å—è®¢é˜…å¹¶æ¥æ”¶è¯¥éšæœºæ•°å­—ï¼Œç„¶åå¯¹ä¿¡å·è¿›è¡Œåˆ†æå¹¶å®æ—¶æ˜¾ç¤ºåˆ†ç»“æœã€‚è‡³å°‘åŒ…å«å¦‚ä¸‹åˆ†ææ¨¡å—ï¼š è®¡ç®—éšæœºä¿¡å·çš„å‡å€¼ï¼› è®¡ç®—è¿‡å»Nä¸ªéšæœºä¿¡å·çš„æ–¹å·®ï¼ˆNä¸ºå¸¸é‡ï¼Œå¯è®¾ç½®ï¼‰ å®ç°åŸºäºæ­£æ€åˆ†å¸ƒçš„å¼‚å¸¸ç‚¹æ£€æµ‹ å®æ—¶ç»˜åˆ¶è¿‡å»ä¸€æ®µæ—¶é—´å†…éšæœºä¿¡å·çš„æŠ˜çº¿å›¾ï¼ˆé€‰ä½œï¼‰ åŸºäºNSQçš„Golangå®ç°\nåˆ†å¸ƒå¼å­˜å‚¨ åˆ†å¸ƒå¼å­˜å‚¨è¦è¾¾åˆ°çš„ç›®æ ‡ æé«˜å­˜å‚¨å®¹é‡ï¼šå¤šä¸ªå­˜å‚¨èŠ‚ç‚¹å®¹é‡çš„èšåˆï¼ˆæ°´å¹³å¯æ‰©å±•ï¼‰ æé«˜æ•°æ®ååé‡ æé«˜å¯é æ€§/å¯ç”¨æ€§ï¼šéƒ¨åˆ†å­˜å‚¨èŠ‚ç‚¹å‘ç”Ÿæ•…éšœæ—¶æ•°æ®ä¸ä¸¢å¤±ï¼Œéƒ¨åˆ†èŠ‚ç‚¹å¤±æ•ˆæ—¶ç”¨æˆ·ä¾ç„¶å¯ä»¥è®¿é—®ï¼ˆå®¹é”™æ€§ï¼‰ ä½æ—¶å»¶ï¼šå°±è¿‘çš„æœåŠ¡å™¨ä¸Šï¼ˆCDNï¼‰ åŸºæœ¬æ‰‹æ®µï¼šå¤åˆ¶ï¼ˆreplicaï¼‰ ç”¨é€” å¦‚æœä¸€äº›èŠ‚ç‚¹ä¸å¯ç”¨ï¼Œå‰©ä½™çš„èŠ‚ç‚¹ä»ç„¶å¯ä»¥æä¾›æœåŠ¡ æé«˜ååç‡ å¸¦æ¥çš„é—®é¢˜ ç¡¬ä»¶æˆæœ¬ å¤šæ•°æ®å‰¯æœ¬ä¹‹é—´çš„ä¸€è‡´æ€§é—®é¢˜ åŸºæœ¬æ‰‹æ®µï¼šåˆ†åŒºï¼ˆPartitioning) å°†ä¸€ä¸ªå¤§å‹æ•°æ®åº“æ–‡ä»¶ï¼ˆæˆ–æ•°æ®åº“ï¼‰æ‹†åˆ†æˆè¾ƒå°çš„å­é›†ï¼ˆç§°ä¸ºåˆ†åŒºpartitionæˆ–åˆ‡ç‰‡shardï¼‰æ´¾åˆ†ç»™ä¸åŒçš„èŠ‚ç‚¹\nå¸¦æ¥çš„é—®é¢˜ è·¨åŒºå¤„ç†ï¼ˆåˆ†å¸ƒå¼ç´¢å¼•é—®é¢˜ï¼‰ åˆç†ã€åŠ¨æ€åˆ†åŒºé—®é¢˜ï¼ˆå¤§æ•°æ®å¦‚ä½•æ‹†åˆ†ï¼‰ è´Ÿè½½å‡è¡¡ åˆ†å¸ƒå¼äº‹åŠ¡å¤„ç† åŸºäºé¢†å¯¼è€…çš„å¤åˆ¶ï¼ˆä¸»ä»å¤åˆ¶ï¼‰ å®¢æˆ·ç«¯è¦å‘æ•°æ®å­˜å‚¨ç³»ç»Ÿå†™å…¥æ•°æ®æ—¶ï¼Œå®ƒå¿…é¡»å°†è¯·æ±‚å‘é€ç»™é¢†å¯¼è€…ï¼›é¢†å¯¼è€…å°†æ–°æ•°æ®å†™å…¥æœ¬åœ°å­˜å‚¨ï¼ŒåŒæ—¶ä¹Ÿä¼šå°†æ•°æ®å˜æ›´å‘é€ç»™æ‰€æœ‰çš„è¿½éšè€…ã€‚ å½“å®¢æˆ·æƒ³è¦ä»æ•°æ®å­˜å‚¨ç³»ç»Ÿè¯»å–æ•°æ®æ—¶ï¼Œå®ƒå¯ä»¥å‘é¢†å¯¼è€…æˆ–è¿½éšè€…æŸ¥è¯¢ã€‚ é€‚åˆäºè¯»å¤šå†™å°‘çš„åº”ç”¨åœºæ™¯ã€‚ åŒæ­¥å¤åˆ¶å’Œå¼‚æ­¥å¤åˆ¶ åŒæ­¥ å¼‚æ­¥ å¤šå‰¯æœ¬åˆ†å¸ƒå¼å­˜å‚¨ä¸­çš„ä¸€è‡´æ€§é—®é¢˜ å¼ºä¸€è‡´æ€§ ä¸€ä¸ªå®¢æˆ·ç«¯å†™å…¥æˆåŠŸï¼Œå…¶ä»–å®¢æˆ·ç«¯åç»­éƒ½å¯ä»¥è¯»å‡ºæ–°ç‰ˆæœ¬çš„å€¼ æ¯ä¸ªè¯»æ“ä½œä¸€å®šä¸ä¼šè¯»å‡ºæ¯”ä¸Šä¸€æ¬¡æ›´æ—§çš„ç‰ˆæœ¬ é¡ºåºä¸€è‡´æ€§ å› æœä¸€è‡´æ€§ æœ€ç»ˆä¸€è‡´æ€§ CAPå®šç† Consistensyï¼ˆä¸€è‡´æ€§ï¼‰ã€Partition Toleranceï¼ˆåˆ‡å‰²å®¹å¿æ€§ï¼‰ã€Availabilityï¼ˆå¯ç”¨æ€§ï¼‰ä¸‰è€…åªèƒ½å–å…¶äºŒï¼Œä¸å¯å…¼å¾—ä¸‰è€…ã€‚\nå¾ˆå¤šæ—¶å€™åªèƒ½å–CPæˆ–APï¼Œå› ä¸ºä¸€èˆ¬æ— æ³•ä¿è¯ç½‘ç»œæ¯æ—¶æ¯åˆ»ç•…é€š\nBASEå®šç† å¯¹CAPä¸­çš„ä¸€è‡´æ€§å’Œå¯ç”¨æ€§æƒè¡¡çš„ç»“æœï¼šåŸºæœ¬å¯ç”¨ï¼ˆBasically Availableï¼‰ã€è½¯ä»¶æ€ï¼ˆSoft Stateï¼‰ã€æœ€ç»ˆä¸€è‡´æ€§ï¼ˆEventually Consistencyï¼‰\næ•°æ®åˆ†åŒºçš„åŸºæœ¬æ–¹æ³• æ ¹æ®ä¸»é”®èŒƒå›´è¿›è¡Œåˆ†åŒº ä¸€èˆ¬éƒ½æ˜¯éå‡åŒ€åˆ†å¸ƒçš„ï¼Œæ‰€ä»¥éœ€è¦å»ºç«‹å…¨å±€ç´¢å¼•\næ ¹æ®ä¸»é”®çš„å“ˆå¸Œå€¼è¿›è¡Œåˆ†åŒº å“ˆå¸Œå‡½æ•° è¾“å…¥ï¼šé•¿åº¦ä¸å®šçš„01ä¸² è¾“å‡ºï¼šé•¿åº¦å›ºå®šçš„01ä¸² å€¼åŸŸç©ºé—´ï¼š$[0, 2^{n}-1]$ ç‰¹æ€§ ç¡®å®šæ€§ â€éšæœºæ€§â€œ æ— ç¢°æ’æ€§ï¼šä»»ä½•ä¸¤ä¸ªè¾“å…¥ï¼Œå®ƒä»¬è¾“å‡ºå€¼ç›¸ç­‰çš„æ¦‚ç‡ä¸º$2^{-n}$ ä¸»è¦æ€æƒ³ $$ hash(key)\\mod N $$\nä¼˜ç‚¹ ä¸€å®šç¨‹åº¦ä¸Šé¿å…äº†åæ–œå’Œçƒ­ç‚¹é—®é¢˜ æ— é¡»å…¨å±€ç´¢å¼• ç¼ºç‚¹ å½“èŠ‚ç‚¹æ•°é‡å˜åŠ¨æ—¶ï¼Œéœ€è¦å¤§é‡çš„æ•°æ®è¿ç§»ã€‚\nåŸºäºä¸€è‡´æ€§å“ˆå¸Œç®—æ³•çš„åˆ†åŒºâ€”â€”å“ˆå¸Œç¯ å½“æ–°å¢èŠ‚ç‚¹åï¼Œä»…ä»…éœ€è¦è¿ç§»å°‘é‡æ•°æ®ã€‚\nç¼ºç‚¹ï¼šåªèƒ½åœ¨èŠ‚ç‚¹ä¹‹é—´æ–°å¢æ–°èŠ‚ç‚¹ï¼Œè¿™æ ·ä¼šå¯¼è‡´è´Ÿè½½åˆ†é…ä¸å‡è¡¡ã€‚\nä½¿ç”¨è™šæ‹ŸèŠ‚ç‚¹æ”¹è¿›çš„ä¸€è‡´æ€§å“ˆå¸Œ æ¯ä¸ªç‰©ç†èŠ‚ç‚¹æœ‰è‹¥å¹²ä¸ªè™šæ‹ŸèŠ‚ç‚¹ï¼Œè¿™æ ·ä¸€ä¸ªç‰©ç†èŠ‚ç‚¹å¯ä»¥é€šè¿‡è™šæ‹ŸèŠ‚ç‚¹çš„æ–¹å¼å‡åŒ€åˆ†æ•£åœ¨å“ˆå¸Œç¯çš„å„ä¸ªéƒ¨åˆ†ï¼Œè§£å†³äº†æ•°æ®å€¾æ–œé—®é¢˜ã€‚\nHDFSåˆ†å¸ƒå¼æ–‡ä»¶ç³»ç»Ÿ NameNodeç»´æŠ¤çš„ä¸¤å¼ è¡¨ æ–‡ä»¶åâ€”â€”æ•°æ®å—å¯¹åº”è¡¨ï¼šæ¯ä¸ªæ–‡ä»¶è¢«åˆ‡ç‰‡ä¹‹åå¯¹åº”è‹¥å¹²ä¸ªæœ‰å”¯ä¸€æ ‡è¯†å·çš„æ•°æ®å— æ•°æ®å—â€”â€”ç‰©ç†èŠ‚ç‚¹å¯¹åº”è¡¨ï¼šæ¯ä¸ªæ•°æ®å—åœ¨ä¸åŒDataNodeå­˜å‚¨3ä»½ï¼ˆ3å¤‡ä»½ç­–ç•¥ï¼‰ å†™æµç¨‹ Clientå‘NameNodeè¯·æ±‚å¢åŠ æ•°æ®å—ï¼ˆç»´æŠ¤æ–‡ä»¶åâ€”â€”æ•°æ®å—å¯¹åº”è¡¨ï¼‰ NameNodeè¿”å›æ•°æ®å—å·åŠåˆ†é…çš„3ä¸ªDataNode IPåœ°å€ï¼ˆ3å¤‡ä»½ç­–ç•¥ï¼‰ Clientä¸NameNodeæµæ°´çº¿æ–¹å¼å†™å…¥æ•°æ®å—ï¼ˆå®Œæˆåç»´æŠ¤æ•°æ®å—â€”â€”ç‰©ç†èŠ‚ç‚¹å¯¹åº”è¡¨ï¼‰ è¯»æµç¨‹ å®¢æˆ·ç«¯å‘è¯·æ±‚NameNodeï¼Œä¼ é€å‚æ•°ï¼šæ–‡ä»¶åã€åç§»é‡ã€é•¿åº¦ NameNodeæŸ¥æ‰¾æ–‡ä»¶åâ€”â€”æ•°æ®å—å¯¹åº”è¡¨å’Œæ•°æ®å—â€”â€”ç‰©ç†èŠ‚ç‚¹å¯¹åº”è¡¨ï¼Œå°†å¯¹åº”DataNodeçš„IPåœ°å€è¿”å›ç»™CLient Clientå‘æœ€è¿‘çš„DataNodeå»ºç«‹è¿æ¥å®Œæˆè¯»å– MapReduceæ¨¡å‹å’Œåˆ†å¸ƒå¼è®¡ç®—æ¡†æ¶ MapReduceå¹¶è¡Œè®¡ç®—æ¨¡å‹ å•è¯è®¡æ•°çš„ä¾‹å­ Hadoop MapReduceè®¡ç®—æ¨¡å‹ Clientç±» è®¾ç½®å·¥ä½œå‚æ•° è®¾ç½®Map Reduce Jobå¯¹è±¡ è®¾ç½®è¦ä¸Šä¼ ç»™Hadoopå¹³å°çš„JaråŒ…æˆ–Class æŒ‡å®šMapperç±» æŒ‡å®šCombinerç±»ï¼ˆå¯é€‰ï¼‰ æŒ‡å®šReducerç±» è®¾å®šè¾“å‡ºæ•°æ®çš„æ ¼å¼ è®¾å®šè¾“å…¥ã€è¾“å‡ºæ–‡ä»¶è·¯å¾„ å¯åŠ¨è¯¥Jobç›´åˆ°è¿è¡Œç»“æŸ Mapperç±»ï¼šå®ç°Mapæ¥å£(K1, V1)-\u0026gt;(K2, V2) Combinerç±»ï¼šå®ç°Reduceæ¥å£(K2, list(V2))-\u0026gt;list(K3, V3) Reducerç±»ï¼šå®ç°Reduceæ¥å£(K3, list(V3))-\u0026gt;list(K4, V4) Sparkå¹³å°å’ŒåŸºäºRDD-DAGçš„è®¡ç®—æ¨¡å‹ Sparkç®€ä»‹ Sparkæ˜¯ä¸€ä¸ªå¿«é€Ÿã€é€šç”¨ã€å¯æ‰©å±•çš„åˆ†å¸ƒå¼è®¡ç®—å¹³å°ã€‚\nSparkå¹³å°ä½“ç³»ç»“æ„ åˆ†å¸ƒå¼å¼¹æ€§æ•°æ®é›†RDDs RDDså…¨ç§°Resilient Distributed Datasetsæ˜¯Sparkæœ€åŸºæœ¬çš„æ•°æ®æŠ½è±¡ï¼Œå®ƒæ˜¯åªè¯»çš„ã€åˆ†åŒºå­˜å‚¨çš„ã€åˆ†å¸ƒå¼çš„æ•°æ®é›†åˆã€‚\nå¯ä»¥å°†RDDsçœ‹ä½œä¸€ä¸ªåˆ†å¸ƒå¼å­˜å‚¨çš„â€œå¤§æ•°ç»„â€ï¼Œåº”ç”¨ç¨‹åºåªéœ€å…³å¿ƒå¦‚ä½•ç”±ä¸€ä¸ªRDDsè½¬æ¢ä¸ºå¦ä¸€ä¸ªRDDsï¼Œä¸ç”¨å…³å¿ƒRDDåœ¨åº•å±‚æ˜¯å¦‚ä½•åˆ†åŒºã€å¦‚ä½•åˆ†å¸ƒåˆ°å¤šä¸ªèŠ‚ç‚¹ä¸Šã€å¦‚ä½•åœ¨å†…å­˜ä¸­ç¼“å­˜ã€å†…å­˜ç¼“å­˜ä¸¢å¤±åå¦‚ä½•é‡æ–°ç”Ÿæˆã€‚\nå®¹é”™æ€§ å¦‚æœRDDsçš„æŸä¸ªåˆ†åŒºå¤±æ•ˆï¼ŒSparkä¼šæ ¹æ®DAGå¾€å›æŸ¥çœ‹å¹¶é‡æ–°æ¢å¤æ•°æ®ã€‚\nå°†è®¡ç®—ä»»åŠ¡æŠ½è±¡ä¸ºæœ‰å‘æ— ç¯å›¾ ","permalink":"https://fffzlfk.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/","summary":"Distributed Computing","title":"åˆ†å¸ƒå¼è®¡ç®—"},{"content":"Code is like humor. When you have to explain it, it's bad.\nHeyï¼Œæˆ‘æ˜¯fffzlfkä¸€åè¥¿ç”µCSåœ¨è¯»æœ¬ç§‘ç”Ÿ å­¦ä¹ ä¹‹ä½™ï¼Œæˆ‘è¿˜æ˜¯ä¸€ä¸ªå–œæ¬¢æŠ˜è…¾çš„äºº\nä½ å¯ä»¥åœ¨ä¸‹é¢æ‰¾åˆ°æˆ‘ GitHub Email ","permalink":"https://fffzlfk.github.io/about/","summary":"Code is like humor. When you have to explain it, it's bad.\nHeyï¼Œæˆ‘æ˜¯fffzlfkä¸€åè¥¿ç”µCSåœ¨è¯»æœ¬ç§‘ç”Ÿ å­¦ä¹ ä¹‹ä½™ï¼Œæˆ‘è¿˜æ˜¯ä¸€ä¸ªå–œæ¬¢æŠ˜è…¾çš„äºº\nä½ å¯ä»¥åœ¨ä¸‹é¢æ‰¾åˆ°æˆ‘ GitHub Email ","title":"About"},{"content":"ç¬¬ä¸€ç«  å¼•è¨€ è¯­è¨€ä¹‹é—´çš„ç¿»è¯‘ ç¼–è¯‘å™¨ä¸è§£é‡Šå™¨ è¯­è¨€ç¿»è¯‘ä¸¤ç§åŸºæœ¬å½¢æ€ å…ˆç¿»è¯‘åæ‰§è¡Œ è¾¹ç¿»è¯‘è¾¹æ‰§è¡Œ ç¼–è¯‘å™¨çš„å·¥ä½œåŸç†å’ŒåŸºæœ¬ç»„æˆ é€šç”¨ç¨‹åºè®¾è®¡è¯­è¨€çš„ä¸»è¦æˆåˆ† å£°æ˜+å®šä¹‰\nä»¥é˜¶æ®µåˆ’åˆ†ç¼–è¯‘å™¨ ç¼–è¯‘å™¨çš„åˆ†æ/ç»¼åˆæ¨¡å¼ ä½œä¸šé¢˜ ä½•è°“ç¼–è¯‘å™¨çš„å‰ç«¯å’Œåç«¯ï¼Ÿ å‰ç«¯ä¸»è¦ç”±ä¸æºè¯­è¨€æœ‰å…³ä½†ä¸ç›®æ ‡æœºæ— å…³çš„éƒ¨åˆ†ç»„æˆï¼Œé€šå¸¸åŒ…æ‹¬è¯æ³•åˆ†æã€è¯­æ³•åˆ†æã€è¯­ä¹‰åˆ†æå’Œä¸­é—´ä»£ç ç”Ÿæˆï¼Œæœ‰çš„ä»£ç ä¼˜åŒ–å·¥ä½œä¹Ÿå¯åŒ…æ‹¬åœ¨å‰ç«¯ã€‚ åç«¯åŒ…æ‹¬ç¼–è¯‘ç¨‹åºä¸­ä¸ç›®æ ‡æœºæœ‰å…³çš„éƒ¨åˆ†ï¼Œå¦‚ä¸ç›®æ ‡æœºæœ‰å…³çš„ä»£ç ä¼˜åŒ–å’Œç›®æ ‡ä»£ç ç”Ÿæˆç­‰ã€‚é€šå¸¸ï¼Œåç«¯ä¸ä¾èµ–æºè¯­è¨€è€Œä»…ä»…ä¾èµ–ä¸­é—´è¯­è¨€ã€‚ ç”»å‡ºç¼–è¯‘ç¨‹åºçš„æ€»ä½“ç»“æ„å›¾ï¼Œç®€è¿°å„éƒ¨åˆ†çš„ä¸»è¦åŠŸèƒ½ã€‚ è¯æ³•åˆ†æï¼šè¾“å…¥æºç¨‹åºï¼Œè¾“å‡ºå•è¯ç¬¦å· è¯­æ³•åˆ†æï¼šå¯¹å•è¯ç¬¦å·è¿›è¡Œè¯­æ³•åˆ†æï¼ˆæ ¹æ®è¯­æ³•è§„åˆ™è¿›è¡Œæ¨å¯¼æˆ–å½’çº¦ï¼‰ï¼Œè¯†åˆ«å‡ºå„ç±»è¯­æ³•å•ä½ï¼Œæœ€ç»ˆåˆ¤æ–­è¾“å…¥ä¸²æ˜¯å¦æ„æˆè¯­æ³•ä¸Šæ­£ç¡®çš„â€ç¨‹åºâ€œã€‚ è¯­ä¹‰åˆ†æä¸ä¸­é—´ä»£ç ç”Ÿæˆï¼šæŒ‰ç…§è¯­ä¹‰è§„åˆ™å¯¹è¯­æ³•åˆ†æå™¨å½’çº¦å‡ºï¼ˆæˆ–æ¨å¯¼å‡ºï¼‰çš„è¯­æ³•å•ä½è¿›è¡Œè¯­ä¹‰åˆ†æå¹¶æŠŠå®ƒä»¬ç¿»è¯‘æˆä¸€å®šå½¢å¼çš„ä¸­é—´ä»£ç  ä¸­é—´ä»£ç ä¼˜åŒ–ï¼šå¯¹ä¸­é—´ä»£ç è¿›è¡Œä¼˜åŒ–å¤„ç† ç›®æ ‡ä»£ç ç”Ÿæˆï¼šæŠŠä¸­é—´ä»£ç ç¿»è¯‘æˆç›®æ ‡ç¨‹åº ç¬¦å·è¡¨ç®¡ç†ï¼šç¼–è¯‘ç¨‹åºåœ¨å·¥ä½œä¸­ä¿æŒä¸€ç³»åˆ—çš„è¡¨æ ¼ï¼Œä»¥ç™»è®°æºç¨‹åºçš„å„ç±»ä¿¡æ¯çš„ç¼–è¯‘ä¸­å„é˜¶æ®µçš„è¿›å±•çŠ¶å†µã€‚ å‡ºé”™å¤„ç†ï¼šå¦‚æœç¨‹åºä¸­å‘ç°é”™è¯¯ï¼Œç¼–è¯‘å™¨å°±å°†ä¿¡æ¯å‘é€ç»™ç”¨æˆ·ã€‚ è¯•åˆ†æç¼–è¯‘ç¨‹åºæ˜¯å¦åˆ†éåº”è€ƒè™‘çš„å› ç´ åŠå¤šéæ‰«æçš„ä¼˜ç¼ºç‚¹ã€‚ å†³å®šéæ•°çš„å› ç´ ï¼š è®¡ç®—æœºå­˜å‚¨å®¹é‡å¤§å° ç¼–è¯‘ç¨‹åºåŠŸèƒ½å¼ºå¼± æºè¯­è¨€ç¹ç®€ ç›®æ ‡ç¨‹åºä¼˜åŒ–ç¨‹åº¦ è®¾è®¡å’Œå®ç°ç¼–è¯‘ç¨‹åºæ—¶ä½¿ç”¨å·¥å…·çš„å…ˆè¿›ç¨‹åº¦ å‚ä¸äººå‘˜å¤šå°‘å’Œç´ è´¨ç­‰ å¤šéæ‰«æçš„ä¼˜ç‚¹ï¼š åŠ å·¥å……åˆ† å‡ºé”™å¤„ç†ç»†è‡´ ç›®æ ‡ç¨‹åºè´¨é‡é«˜ å¤šéæ‰«æçš„ç¼ºç‚¹ï¼š ç¼–è¯‘æ—¶é—´é•¿ï¼Œå¼€é”€å¤§ ç¼–è¯‘ç¨‹åºï¼šä¸€ç§èƒ½å¤ŸæŠŠé«˜çº§è¯­è¨€ç¨‹åºç¿»è¯‘æˆä½çº§è¯­è¨€ï¼ˆæ±‡ç¼–è¯­è¨€ã€æœºå™¨è¯­è¨€ï¼‰ç¨‹åºçš„ç¨‹åº è¯­ä¹‰ï¼šä¸€ç§è¯­è¨€çš„å•è¯ç¬¦å·å’Œè¯­æ³•å•ä½çš„æ„ä¹‰ è¯­æ³•ï¼šæ‰€è°“ä¸€ä¸ªè¯­è¨€çš„è¯­æ³•æ˜¯è¿™æ ·çš„ä¸€ç»„è§„åˆ™ï¼Œç”¨å®ƒå¯ä»¥å½¢æˆå’Œäº§ç”Ÿä¸€ä¸ªåˆå¼çš„ç¨‹åº éï¼šéå°±æ˜¯å¯¹æºç¨‹åºçš„ä¸­é—´ç»“æ„ä»å¤´åˆ°å°¾æ‰«æä¸€æ¬¡ï¼Œå¹¶åšæœ‰å…³çš„åŠ å·¥å¤„ç†ï¼Œç”Ÿæˆæ–°çš„ä¸­é—´ç»“æœæˆ–ç›®æ ‡ç¨‹åºã€‚ ç¬¬äºŒç«  è¯æ³•åˆ†æ è¯æ³•åˆ†æä¸­çš„è‹¥å¹²é—®é¢˜ è®°å·ã€æ¨¡å¼ä¸å•è¯ å•è¯çš„åŸºæœ¬åˆ†ç±» å…³é”®å­—ï¼ˆä¿ç•™å­—ï¼‰ key(key word, or reversed word) æ ‡è¯†ç¬¦ id(identifier) å­—é¢é‡ literal ç‰¹æ®Šç¬¦å· ks(key symbol, or special symbol) è®°å·=è®°å·çš„ç±»åˆ«+è®°å·çš„å±æ€§\næ¨¡å¼çš„å½¢å¼åŒ–æè¿° å­—ç¬¦ä¸²ä¸è¯­è¨€ å®šä¹‰2.1ï¼šè¯­è¨€$L$æ˜¯æœ‰é™å­—æ¯è¡¨$\\sum$ä¸Šæœ‰é™é•¿åº¦å­—ç¬¦ä¸²çš„é›†åˆã€‚\nå­—ç¬¦ä¸²ï¼šç”±å­—æ¯è¡¨ä¸­çš„ç¬¦å·ç»„æˆçš„ä»»æ„æœ‰ç©·åºåˆ—ã€‚\nå­—ç¬¦ä¸²çš„é•¿åº¦ï¼šå­—ç¬¦ä¸²ä¸­çš„ç¬¦å·ä¸ªæ•°ã€‚\nå­—ç¬¦ä¸²åŸºæœ¬æ¦‚å¿µ è¡¨ç¤ºã€æœ¯è¯­ ä¸¾ä¾‹ $|S|$ $|abc|= 3$ $\\varepsilon$ $| \\varepsilon| = 0$ $S1S2$ $\u0026ldquo;abc\u0026quot;\u0026ldquo;def\u0026rdquo;=\u0026ldquo;abcdef\u0026rdquo;$ $S^n$ï¼ˆå¹‚ï¼‰ $\u0026ldquo;abc\u0026rdquo;^3 =\u0026ldquo;abcabcabc\u0026rdquo;$ $S$çš„å‰ç¼€ $\u0026ldquo;abc\u0026rdquo;$çš„å‰ç¼€å¯ä»¥æ˜¯ï¼š$Îµï¼Œaï¼Œab, abc$ $S$çš„åç¼€ $\u0026ldquo;abc\u0026rdquo;$çš„åç¼€å¯ä»¥æ˜¯ï¼š$Îµï¼Œcï¼Œbc, abc$ $S$çš„å­ä¸² $\u0026ldquo;abc\u0026rdquo;$çš„å­ä¸²å¯ä»¥æ˜¯$Îµï¼Œaï¼Œb, c, â€¦$ $S$çš„çœŸå‰ç¼€ $\u0026ldquo;abc\u0026rdquo;$çš„çœŸå‰ç¼€ï¼š$a, ab$ $S$çš„çœŸåç¼€ $\u0026ldquo;abc\u0026rdquo;$çš„çœŸåç¼€ï¼š$c, bc$ $S$çš„çœŸå­ä¸² $\u0026ldquo;abc\u0026rdquo;$çš„çœŸå­ä¸²ï¼š$a, b, c, ab, bc $ $S$çš„å­åºåˆ— $\u0026ldquo;abdf\u0026rdquo;$æ˜¯$\u0026ldquo;abcdef\u0026rdquo;$çš„ä¸€ä¸ªå­åºåˆ—ï¼ˆ$S$ä¸­å»æ‰$0$æˆ–è‹¥å¹²ä¸ªä¸ä¸€å®šè¿ç»­çš„å­—ç¬¦åå½¢æˆçš„å­—ç¬¦ä¸²ï¼‰ $S$çš„é€†è½¬$S^R$ $S=abc,S^R=cba$ å­—ç¬¦ä¸²é›†åˆçš„è¿ç®— è¡¨ç¤ºã€æœ¯è¯­ æ„ä¹‰ $\\varnothing$ ç©ºé›†åˆ ${\\epsilon}$ ç©ºä¸²ä½œä¸ºå”¯ä¸€å…ƒç´ çš„é›†åˆ $X = L \\cup M$ é›†åˆçš„å¹¶ï¼š$ X = \\{ s | \\in L\\ or\\ s \\in M \\} $ $X = L \\cap M$ é›†åˆçš„äº¤ï¼š$ X = \\{ s | \\in L\\ and\\ s \\in M \\} $ $X = L \\cap M$ é›†åˆçš„è¿æ¥ï¼š$ X = \\{ st | \\in L\\ and\\ s \\in M\\} $ $X = L^0$ é›†åˆçš„è¿æ¥ï¼š$ L^0 = \\{ \\epsilon \\} $ $X = L^*$ é›†åˆçš„Kleeneé—­åŒ…ï¼š$X=L^0 \\cup L^1 \\cup L^2 \\cup \u0026hellip; $ $X = L^+$ é›†åˆçš„æ­£é—­åŒ…ï¼š$X=L^1 \\cup L^2 \\cup L^3 \\cup \u0026hellip; $ æ­£è§„å¼ä¸æ­£è§„é›† æ­£è§„å¼çš„é€’å½’å®šä¹‰ $\\epsilon$å’Œ$\\varnothing$éƒ½æ˜¯$\\sum$ä¸Šçš„æ­£è§„å¼ï¼Œå®ƒè¡¨ç¤º$L(\\epsilon)=\\{ \\epsilon \\}$å’Œ$\\varnothing$ è‹¥$a$æ˜¯$\\sum$ä¸Šçš„å­—ç¬¦ï¼Œåˆ™$a$æ˜¯æ­£è§„å¼ï¼Œè¡¨ç¤º$L(a)=\\{a\\}$ è‹¥æ­£è§„å¼$r$å’Œ$s$åˆ†åˆ«è¡¨ç¤º$L(r)$å’Œ$L(s)$: $r | s$æ˜¯æ­£è§„å¼ï¼Œè¡¨ç¤ºé›†åˆ$L(r)\\cup L(s)$ $rs$ æ˜¯æ­£è§„å¼ï¼Œè¡¨ç¤ºé›†åˆ$L(r)L(s)$ $r^* $ æ˜¯æ­£è§„å¼ï¼Œè¡¨ç¤ºé›†åˆ $(L(r))* $ $r$æ˜¯æ­£è§„å¼ï¼Œè¡¨ç¤ºé›†åˆä»æ˜¯$L(r)$ è¿ç®— è¿ç®—ç¬¦çš„ä¼˜å…ˆçº§ä¸ç»“åˆæ€§ ä¸‰ç§è¿ç®—å‡å…·æœ‰å·¦ç»“åˆæ€§è´¨ ä¼˜å…ˆçº§ä»é«˜åˆ°ä½æ’åˆ—é¡ºåºä¸ºï¼šé—­åŒ…è¿ç®—ã€è¿æ¥è¿ç®—ã€æˆ–è¿ç®— æ­£è§„å¼çš„ç­‰ä»·ï¼šè‹¥æ­£è§„å¼$P$å’Œ$Q$è¡¨ç¤ºäº†åŒä¸€ä¸ªæ­£è§„é›†ï¼Œåˆ™ç§°På’ŒQæ˜¯ç­‰ä»·çš„ï¼Œè®°ä¸º$P=Q$ æ­£è§„å¼ç­‰ä»·çš„åˆ¤å®šï¼ˆè¯æ˜ï¼‰ æ ¹æ®å®šä¹‰ åˆ©ç”¨ä»£æ•°æ€§è´¨ $ r|s = s|r $ $r|(s|t) = (r|s)|t$ $r(s|t) = rs|rt$ $(s|t)r = sr|tr $ $(rs)t = r(st)$ $Îµr = rÎµ = r$ $r^* = (r+|Îµ) $ $r^{**} = r^* $ è®°å·çš„è¯´æ˜ ä¾‹å¦‚ï¼š\nrelation = \u0026lt; | \u0026lt;= | \u0026lt;\u0026gt; | \u0026gt; | \u0026gt;= | = id = (a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z |A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z) (a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z |A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z |0|1|2|3|4|5|6|7|8|9)* num = (0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)* (Îµ|.(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)*) (Îµ|E(+|-|Îµ)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)*) ç®€åŒ–æ­£è§„å¼æè¿° æ­£é—­åŒ…ï¼š$r^+ = rr^* = r^* rï¼Œr^* = r^+|Îµ$ å¯ç¼ºçœï¼š$r?=r|Îµ$ å­—ç¬¦ç»„ï¼šå¦‚$[abc]$ï¼Œå®ƒç­‰ä»·äºï¼š$a|b|c$ éå­—ç¬¦ç»„ï¼š$[^r]$ å¼•å…¥è¾…åŠ©å®šä¹‰ char = [a-zA-Z] digit = [0-9] digits = digit+ optional_fraction = ( . digits )? optional_exponent = ( E (+|-)? digits )? id = char ( char|digit )* num = digits optional_fraction optional_exponent è®°å·çš„è¯†åˆ«-æœ‰é™è‡ªåŠ¨æœº ä¸ç¡®å®šçš„æœ‰é™è‡ªåŠ¨æœºï¼ˆNondeterministic Finite Automatonï¼ŒNFAï¼‰ å®šä¹‰ï¼š$M=(S, \\sum, move, s_0, F) $\n$S$æ˜¯æœ‰é™ä¸ªçŠ¶æ€(state)çš„é›†åˆ $\\sum$æ˜¯æœ‰é™ä¸ªè¾“å…¥å­—ç¬¦ åŒ…æ‹¬ $Îµ$ çš„é›†åˆ $move(s_i, ch)=s_j$ $s_0$æ˜¯å”¯ä¸€çš„åˆæ€ $F$æ˜¯ç»ˆæ€é›† ç›´è§‚çš„è¡¨ç¤ºæ–¹å¼ çŠ¶æ€è½¬æ¢å›¾ çŠ¶æ€è½¬æ¢çŸ©é˜µ NFAå­˜åœ¨çš„é—®é¢˜ åªæœ‰å°è¯•äº†å…¨éƒ¨å¯èƒ½çš„è·¯å¾„ï¼Œæ‰èƒ½ç¡®å®šä¸€ä¸ªè¾“å…¥åºåˆ—ä¸è¢«æ¥å—ï¼Œè€Œè¿™äº›è·¯å¾„çš„æ¡æ•°éšç€è·¯å¾„é•¿åº¦çš„å¢é•¿æˆæŒ‡æ•°å¢é•¿ è¯†åˆ«è¿‡ç¨‹ä¸­éœ€è¦å¤§é‡çš„å›æº¯ï¼Œæ—¶é—´å¤æ‚åº¦å‡é«˜ä¸”ç®—æ³•è¶‹äºå¤æ‚ ç¡®å®šçš„æœ‰é™è‡ªåŠ¨æœºï¼ˆDeterministic Finite Automatonï¼ŒDFAï¼‰ å®šä¹‰ï¼šDFAæ˜¯NFAçš„ä¸€ä¸ªç‰¹ä¾‹ï¼Œå…¶ä¸­\næ²¡æœ‰çŠ¶æ€å…·æœ‰$\\epsilon$çŠ¶æ€è½¬ç§»$(\\epsilon -transition)$ï¼Œå³çŠ¶æ€å›¾ä¸­æ²¡æœ‰æ ‡è®°$\\epsilon$çš„è¾¹ å¯¹æ¯ä¸ªçŠ¶æ€$s$å’Œæ¯ä¸ªå­—ç¬¦$a$ï¼Œæœ€å¤šæœ‰ä¸€ä¸ªä¸‹ä¸€çŠ¶æ€ æ¨¡æ‹ŸDFAç®—æ³• s := s0; ch := nextchar; -- åˆå€¼ while ch != eof -- å¾ªç¯ loop s := move(s, ch); ch := nextchar; end loop; if s in F then return \u0026#34;yes\u0026#34;; else return \u0026#34;no\u0026#34;; end if; ä»æ­£è§„å¼åˆ°è¯æ³•åˆ†æå™¨ æ„é€ è¯æ³•åˆ†æå™¨çš„æ–¹æ³•å’Œæ­¥éª¤ ç”¨æ­£è§„å¼æè¿°æ¨¡å¼ æ„é€ NFA ç¡®å®šåŒ–ï¼ˆè½¬æ¢æˆç­‰ä»·çš„DFAï¼‰ æœ€å°åŒ–ï¼ˆä¼˜åŒ–DFAï¼‰ ä»ä¼˜åŒ–åçš„DFAæ„é€ è¯æ³•åˆ†æå™¨ ä»æ­£è§„å¼åˆ°NFA Thompsonç®—æ³•\nå¯¹$\\epsilon$ï¼Œ$N(\\epsilon)$ï¼š å¯¹äº$\\sum$ä¸Šçš„æ¯ä¸ªå­—ç¬¦$a$ï¼Œ$N(a)$ï¼š è‹¥$N(p)$å’Œ$N(q)$æ˜¯æ­£è§„å¼$p$å’Œ$q$çš„NFA å¯¹äº$p|q$ï¼Œæ„é€ $N(p|q)$ï¼š å¯¹äºæ­£è§„å¼$pq$ï¼Œæ„é€ NFA $N(pq)$ï¼š å¯¹äºæ­£è§„å¼$p^* $ï¼Œæ„é€ NFA $N(p^{*})$ï¼š ä»NFAåˆ°DFA å¹¶è¡Œæ–¹æ³• $smove(S, a)$ï¼šä»çŠ¶æ€é›†$S$ä¸­çš„æ¯ä¸ªçŠ¶æ€å‡ºå‘ï¼Œç»è¿‡æ ‡è®°ä¸º$a$çš„è¾¹ç›´æ¥åˆ°è¾¾çš„ä¸‹ä¸€çŠ¶æ€å…¨ä½“ $\\epsilon$-é—­åŒ…ï¼šä»çŠ¶æ€Tå‡ºå‘ï¼Œç»è¿‡è‹¥å¹²æ¬¡$\\epsilon$è½¬ç§»åˆ°è¾¾çš„çŠ¶æ€å…¨ä½“ $\\epsilon$-é—­åŒ… çš„å®šä¹‰\nTä¸­çš„æ‰€æœ‰çŠ¶æ€å±äº$\\epsilon$-é—­åŒ… å¦‚æœ$t$å±äº$\\epsilon$-é—­åŒ…(T)ä¸”$move(t, \\epsilon)=u$ï¼Œåˆ™$u$å±äº$\\epsilon$-é—­åŒ…(T) å†æ— å…¶å®ƒçŠ¶æ€å±äº$\\epsilon$-é—­åŒ…(T) æ±‚$\\epsilon$-é—­åŒ… çš„ç®—æ³•\nfunction Îµ-é—­åŒ…(T) is begin for Tä¸­çš„æ¯ä¸ªçŠ¶æ€t loop åŠ å…¥tåˆ°U; push(t); end loop; while æ ˆä¸ç©º loop pop(t); for æ¯ä¸ªu=move(t, Îµ) loop if uä¸åœ¨Uä¸­ then åŠ å…¥uåˆ°Uä¸­; push(u); endif; end loop; end loop; return U; end Îµ-é—­åŒ…; æ¨¡æ‹ŸNFA\nS := Îµ-é—­åŒ…({s0}); -- æ‰€æœ‰å¯èƒ½åˆæ€çš„é›†åˆ a := nextchar; while a != eof loop S := Îµ-é—­åŒ…(smove(S, a)); -- æ‰€æœ‰ä¸‹ä¸€çŠ¶æ€çš„é›†åˆ a := nextchar; end loop; if S and F != nil then return \u0026#34;yes\u0026#34;; else return \u0026#34;no\u0026#34;; end if; å­é›†æ³•æ„é€ DFA Dstates = {Îµ-é—­åŒ…({s0})}; // Dstatesä¸­ä»…æœ‰ä¸€ä¸ªçŠ¶æ€ä¸”æœªæ ‡è®° while Dstatesæœ‰å°šæœªæ ‡è®°çš„çŠ¶æ€T loop æ ‡è®°T; for æ¯ä¸€ä¸ªè¾“å…¥å­—ç¬¦a loop U := Îµ-é—­åŒ…(smove(T, a)) if U éç©º then Dtran[T, a] := U; if U ä¸åœ¨Dstatesä¸­ then Uä½œä¸ºå°šæœªæ ‡è®°çš„çŠ¶æ€åŠ å…¥Dstates; end if; end if; end loop; end loop; ä¾‹å¦‚ç”¨ä¸Šè¿°ç®—æ³•æ„é€ (a|b)*abbçš„DFAï¼š\nÎµ-é—­åŒ…({0}) = {0, 1, 2, 4, 7}* A Îµ-é—­åŒ…(smove(A, a)) = {3, 8, 6, 7, 1, 2, 4}* B Îµ-é—­åŒ…(smove(A, b)) = {5, 6, 7, 1, 2, 4}* C Îµ-é—­åŒ…(smove(B, a)) = {3, 8, 6, 7, 1, 2, 4} B Îµ-é—­åŒ…(smove(B, b)) = {9, 5, 6, 7, 1, 2, 4}* D Îµ-é—­åŒ…(smove(C, a)) = {3, 8, 6, 7, 1, 2, 4} B Îµ-é—­åŒ…(smove(C, b)) = {5, 6, 7, 1, 2, 4} C Îµ-é—­åŒ…(smove(D, a)) = {3, 8, 6, 7, 1, 2, 4} B Îµ-é—­åŒ…(smove(D, b)) = {5, 10, 6, 7, 1, 2, 4} E Îµ-é—­åŒ…(smove(E, a)) = {3, 8, 6, 7, 1, 2, 4} B Îµ-é—­åŒ…(smove(E, b)) = {5, 6, 7, 1, 2, 4} C æœ€å°åŒ–DFA å¯åŒºåˆ†:å¯¹äºDFAä¸­çš„ä»»ä½•ä¸¤ä¸ªçŠ¶æ€$t$å’Œ$s$ï¼Œè‹¥ä»ä¸€çŠ¶æ€å‡ºå‘æ¥å—è¾“å…¥å­—ç¬¦ä¸²$\\omega$ï¼Œè€Œä»å¦ä¸€çŠ¶æ€å‡ºå‘ä¸æ¥å—$\\omega$ï¼Œåˆ™ç§° $\\omega$åŒºåˆ†çŠ¶æ€$t$å’Œ$s$ã€‚å¦‚æœå­˜åœ¨æŸä¸ªèƒ½å¤ŸåŒºåˆ†çŠ¶æ€$s$å’ŒçŠ¶æ€$t$çš„ä¸²ï¼Œé‚£ä¹ˆå®ƒä»¬æ˜¯å¯åŒºåˆ†çš„ã€‚\næœ€å°åŒ–DFAç®—æ³•\nåˆå§‹åˆ’åˆ†$\\Pi=\\{S-F, F\\}, \\Pi_{new} = \\Pi$ã€‚$F$æ˜¯ç»ˆæ€é›†ï¼Œ$S-F$æ˜¯éç»ˆæ€é›† åº”ç”¨ä¸‹è¿°è¿‡ç¨‹æ„é€ æ–°çš„åˆ’åˆ†$\\Pi_{new}$: for $\\Pi$çš„æ¯ä¸€ä¸ªç»„$G$ loop åˆ’åˆ†$G$, $G$çš„ä¸¤ä¸ªçŠ¶æ€$s$å’Œ$t$åœ¨åŒä¸€ç»„ä¸­çš„å……è¦æ¡ä»¶æ˜¯ï¼š $$\\forall a \\in \\Sigma \\forall G_i \\in \\Pi (move(s, a) \\in G_i \\leftrightarrow move(t, a) \\in G_i)$$ç”¨æ–°çš„åˆ’åˆ†ç»„æ›¿ä»£$G$, å½¢æˆæ–°çš„åˆ’åˆ†$\\Pi_{new}$;\nend loop è‹¥$\\Pi_{new}=\\Pi$ï¼Œä»¤$\\Pi_{final} = \\Pi$ï¼Œè½¬4ï¼Œå¦åˆ™ä»¤$\\Pi = \\Pi_{new}$å¹¶é‡å¤æ­¥éª¤2 é€‰ä»£è¡¨å¹¶ä¿®æ”¹çŠ¶æ€è½¬ç§» åˆ é™¤æ­»çŠ¶æ€ï¼Œå³ä¸æ˜¯ç»ˆæ€ä¸”å¯¹æ‰€æœ‰è¾“å…¥å­—ç¬¦å‡è½¬å‘è‡ªèº«ï¼Œæˆ–ä»åˆæ€ä¸å¯åˆ°è¾¾çš„çŠ¶æ€ ç”±DFAæ„é€ è¯æ³•åˆ†æå™¨ è¡¨é©±åŠ¨çš„è¯æ³•åˆ†æå™¨(è‡ªåŠ¨ç”Ÿæˆ) ç›´æ¥ç¼–ç çš„è¯æ³•åˆ†æå™¨ è¡¨é©±åŠ¨ ç›´æ¥ç¼–ç  åˆ†æå™¨çš„é€Ÿåº¦ æ…¢ å¿« ç¨‹åºä¸æ¨¡å¼çš„å…³ç³» æ— å…³ æœ‰å…³ åˆ†æå™¨çš„è§„æ¨¡ è¾ƒå¤§ è¾ƒå° é€‚åˆç¼–å†™çš„æ–¹æ³• å·¥å…·ç”Ÿæˆ æ‰‹å·¥ç¼–å†™ æ­£è§„å¼è½¬æ¢ä¸ºæ­£è§„æ–‡æ³• ä»¤$V_T = \\sum$ ä»¤æ–‡æ³•çš„å¼€å§‹ç¬¦å·$S = R$ å¯¹å½¢å¦‚$A \\rightarrow ab$çš„è§„åˆ™è½¬æ¢ä¸º$A \\rightarrow aB$å’Œ$ B \\rightarrow b$ åœ¨æ–°çš„æ–‡æ³•ä¸­ï¼Œå°†å½¢å¦‚$A \\rightarrow a^{*}b$çš„è§„åˆ™è¿›ä¸€æ­¥è½¬æ¢ä¸º$A \\rightarrow aA | b$ ä¸æ–­åˆ©ç”¨3å’Œ4ï¼Œç›´åˆ°æ¯æ¡è§„åˆ™çš„å³éƒ¨æœ€å¤šåªå«æœ‰ä¸€ä¸ªç»ˆç»“ç¬¦ä¸ºæ­¢ ä½œä¸š è¡¨ç¤ºæºç¨‹åºä¸­ä¿¡æ¯å•å…ƒçš„å­—ç¬¦åºåˆ—å«åšè®°å· LEXæºç¨‹åºçš„ä¸‰ä¸ªç»„æˆéƒ¨åˆ†ï¼šå®šä¹‰éƒ¨åˆ†ã€è¯†åˆ«è§„åˆ™éƒ¨åˆ†ã€è¾…åŠ©å‡½æ•°éƒ¨åˆ† è¯æ³•åˆ†æå™¨çš„åŠŸèƒ½ï¼šä¾æ¬¡æ‰«æå­—ç¬¦ä¸²å½¢å¼çš„æºç¨‹åºä¸­çš„å„ä¸ªå­—ç¬¦ï¼Œé€ä¸ªè¯†åˆ«å…¶ä¸­çš„å•è¯ï¼Œå¹¶å°†å…¶è½¬æ¢ä¸ºå†…éƒ¨ç¼–ç å½¢å¼çš„å•è¯ç¬¦å·ä½œä¸ºè¾“å‡ºã€‚ ç®€è¦å™è¿°ä»æ­£è§„å¼æ„é€ è¯æ³•åˆ†æå™¨çš„ä¸€èˆ¬æ–¹æ³•å’Œè¿‡ç¨‹ ç”¨æ­£è§„å¼å¯¹æ¨¡å¼è¿›è¡Œæè¿° ä¸ºæ¯ä¸€ä¸ªæ­£è§„å¼æ„é€ NFA ç¡®å®šåŒ– æœ€å°åŒ– ä»ç®€åŒ–åçš„DFAæ„é€ è¯æ³•åˆ†æå™¨ ç®€è¿°DFAä¸NFAæœ‰ä½•åŒºåˆ«ï¼Ÿ NFAå¯ä»¥æœ‰$\\epsilon$è½¬ç§»ï¼Œè€ŒDFAæ²¡æœ‰ DFAçš„çŠ¶æ€è½¬ç§»å°†äº§ç”Ÿä¸€ä¸ªçŠ¶æ€æœºå’Œè€Œä¸æ˜¯å•ä¸ªçŠ¶æ€ æ­£è§„å¼ï¼šåˆç§°æ­£è§„å¼æˆ–æ­£åˆ™è¡¨è¾¾å¼ï¼Œæ˜¯æŒ‰ç…§ä¸€ç»„å®šä¹‰è§„åˆ™ï¼Œç”±è¾ƒç®€å•çš„æ­£è§„å¼æ„æˆçš„ï¼Œæ¯ä¸ªæ­£è§„å¼$r$è¡¨ç¤ºä¸€ä¸ªè¯­è¨€$L(r)$ã€‚å®šä¹‰è§„åˆ™å‘Šè¯‰æˆ‘ä»¬$L(r)$æ˜¯æ€æ ·ä»¥å„ç§æ–¹å¼ä»$r$çš„å­æ­£è§„å¼æ‰€è¡¨ç¤ºçš„è¯­è¨€ç»„åˆè€Œæˆçš„ã€‚ ç¬¬ä¸‰ç«  è¯­æ³•åˆ†æ åŸºæœ¬æœ¯è¯­ è¯­æ³•åˆ†æå™¨çš„ä½œç”¨ æ ¹æ®è¯æ³•åˆ†æå™¨æä¾›çš„è®°å·æµï¼Œä¸ºè¯­æ³•æ­£ç¡®çš„è¾“å…¥æ„é€ è¯­æ³•æ ‘ã€‚ æ£€æŸ¥è¾“å…¥ä¸­çš„è¯­æ³•ï¼ˆå¯èƒ½è¿˜åŒ…å«è¯æ³•é”™è¯¯ï¼‰ï¼Œå¹¶è°ƒç”¨å‡ºé”™å¤„ç†å™¨è¿›è¡Œé€‚å½“å¤„ç†ã€‚ è¯­æ³•é”™è¯¯çš„å¤„ç†åŸåˆ™ åŸºæœ¬æ¢å¤ç­–ç•¥ ç´§æ€¥æ–¹å¼æ¢å¤ï¼šä½¿ç”¨åŒæ­¥è®°å· çŸ­è¯­çº§æ¢å¤ï¼šé‡‡ç”¨ä¸²æ›¿æ¢çš„æ–¹å¼ å‡ºé”™äº§ç”Ÿå¼ï¼šæ•è·é”™è¯¯ å…¨å±€çº æ­£ ä¾‹ï¼š\nx := a + b y := c + d; ç´§æ€¥æ–¹å¼â€”â€”ä¸¢å¼ƒbåè‹¥å¹²è®°å·ï¼ŒçŸ¥é“é‡è§+x := a + b + d; çŸ­è¯­çº§æ¢å¤â€”â€”åŠ å…¥åˆ†å·ï¼Œä½¿ä¹‹æˆä¸ºä¸€ä¸ªèµ‹å€¼å¥y := c + d; ä¸Šä¸‹æ–‡æ— å…³æ³•ï¼ˆContext Free Grammerï¼ŒCFGï¼‰ ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•å°±æ˜¯è¯´è¿™ä¸ªæ–‡æ³•ä¸­æ‰€æœ‰äº§ç”Ÿå¼å·¦è¾¹åªæœ‰ä¸€ä¸ªéç»ˆç»“ç¬¦ã€‚\nCFGå®šä¹‰åŠè¡¨ç¤º å››å…ƒç»„$G=(N, T, P, S)$ï¼Œå…¶ä¸­\n$N$â€”â€”éç»ˆç»“ç¬¦ï¼ˆNonterminalsï¼‰æœ‰é™é›†åˆ $T$â€”â€”ç»ˆç»“ç¬¦ï¼ˆTerminalsï¼‰æœ‰é™é›†åˆï¼Œ$N \\cup T = \\emptyset $ $P$â€”â€”äº§ç”Ÿå¼ï¼ˆProductionsï¼‰æœ‰é™é›†åˆï¼Œ$A\\rightarrow a$ï¼Œå…¶ä¸­$A \\in N$(å·¦éƒ¨)ï¼Œ$a \\in (N\\cup T)^*$ (å³éƒ¨)ï¼Œè‹¥$a = \\epsilon$ï¼Œåˆ™ç§°$A \\rightarrow \\epsilon$ä¸ºç©ºäº§ç”Ÿå¼ $S$â€”â€”$S$æ˜¯éç»ˆç»“ç¬¦ï¼Œç§°ä¸ºå¼€å§‹ç¬¦å· ç”±äº§ç”Ÿå¼é›†è¡¨ç¤ºCFG $E \\rightarrow E + E$ $E \\rightarrow E * E$ $E \\rightarrow (E)$ $E \\rightarrow -E$ $E \\rightarrow id$ ç»ˆç»“ç¬¦ä¸éç»ˆç»“ç¬¦ä¹¦å†™ä¸Šçš„çº¦å®š å¤§å†™å­—æ¯$Aã€Bã€C$è¡¨ç¤ºéç»ˆç»“ç¬¦ å°å†™å­—æ¯$aã€bã€c$è¡¨ç¤ºç»ˆç»“ç¬¦ å°å†™å¸Œè…Šå­—æ¯$\\alphaã€\\betaã€\\delta $è¡¨ç¤ºä»»æ„æ–‡æ³•ç¬¦å·åºåˆ— CFGäº§ç”Ÿè¯­è¨€çš„åŸºæœ¬æ–¹æ³•â€”â€”æ¨å¯¼ ç›´æ¥æ¨å¯¼ï¼š$\\alpha A \\beta =\u0026gt; \\alpha \\gamma \\beta $ é›¶å¸ƒæˆ–å¤šæ­¥æ¨å¯¼ è‡³å°‘ä¸€æ­¥æ¨å¯¼ ç”±CFGæ‰€äº§ç”Ÿçš„è¯­è¨€L(G) $$L(G) = \\{ \\omega | S \\overset{+}{\\Rightarrow} and \\ \\omega \\in T^* \\} $$ $L(G)$ç§°ä¸º ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ ï¼ˆContext Free Language, CFLï¼‰$\\omega$ç§°ä¸ºå¥å­ï¼Œè‹¥$S \\overset{ * }{\\Rightarrow} \\alpha, \\alpha \\in (N \\cup T)^{ * } $ï¼Œåˆ™ç§°$\\alpha$ä¸º$G$çš„ä¸€ä¸ª å¥å‹ ã€‚\næœ€å·¦æ¨å¯¼å’Œæœ€å³æ¨å¯¼ï¼ˆè§„èŒƒæ¨å¯¼ï¼‰ æœ€å·¦æ¨å¯¼äº§ç”Ÿçš„å¥å‹ç§°ä¸ºå·¦å¥å‹\næœ€å³æ¨å¯¼è¢«ç§°ä¸ºè§„èŒƒæ¨å¯¼ è§„èŒƒå½’çº¦æ˜¯æŒ‡æœ€å³æ¨å¯¼çš„é€†è¿‡ç¨‹\næ¨å¯¼ä¸è¯­æ³•æ ‘ è¯­æ³•æ ‘å’ŒæŠ½è±¡è¯­æ³•æ ‘ äºŒä¹‰æ€§ä¸äºŒä¹‰æ€§çš„æ¶ˆé™¤ äºŒä¹‰æ€§ï¼šä¸€ä¸ªå¥å­å¯èƒ½å¯¹åº”å¤šæ£µè¯­æ³•æ ‘\næ–‡æ³•äºŒä¹‰æ€§ï¼šè‹¥æ–‡æ³•$G$å¯¹åŒä¸€å¥å­äº§ç”Ÿä¸æ­¢ä¸€æ£µè¯­æ³•æ ‘ï¼Œåˆ™ç§°è¯­æ³•æ ‘$G$æ˜¯äºŒä¹‰çš„ã€‚æˆ–è€…è¯´ï¼Œè‹¥æ–‡æ³•$G$å¯¹åŒä¸€ä¸ªå¥å­å­˜åœ¨ä¸¤ä¸ªä¸åŒçš„æœ€å·¦ï¼ˆæœ€å³ï¼‰æ¨å¯¼ï¼Œåˆ™ç§°æ–‡æ³•$G$æ˜¯äºŒä¹‰çš„ã€‚ è¯­è¨€çš„äºŒä¹‰æ€§ï¼šå¦‚æœäº§ç”Ÿä¸Šä¸‹æ–‡æ— å…³è¯­è¨€çš„æ¯ä¸€ä¸ªæ–‡æ³•éƒ½æ˜¯äºŒä¹‰çš„ï¼Œåˆ™æ­¤è¯­è¨€æ˜¯äºŒä¹‰çš„ äºŒä¹‰æ€§çš„æ¶ˆé™¤\næ”¹å†™äºŒä¹‰æ–‡æ³•ä¸ºéäºŒä¹‰æ€§æ–‡æ³• å¼•å…¥ä¸€ä¸ªæ–°çš„éç»ˆç»“ç¬¦ï¼Œå¢åŠ ä¸€ä¸ªå­ç»“æ„å¹¶æé«˜ä¸€çº§ä¼˜å…ˆçº§ é€’å½’éç»ˆç»“ç¬¦åœ¨ç»ˆç»“ç¬¦å·¦è¾¹ï¼Œè¿ç®—å…·æœ‰å·¦ç»“åˆæ€§ï¼Œå¦åˆ™å…·æœ‰å³ç»“åˆæ€§ æ¶ˆé™¤â€œæ‚¬ç©ºelseâ€é—®é¢˜\nä¸ºæ–‡æ³•ç¬¦å·è§„å®šä¼˜å…ˆçº§å’Œç»“åˆæ€§ ä¿®æ”¹è¯­è¨€çš„è¯­æ³•end if è¯­è¨€ä¸æ–‡æ³•ç®€ä»‹ æ­£è§„å¼ä¸ä¸Šä¸‹æ–‡æ— å…³æ³• æ­£è§„å¼åˆ°CFGçš„è½¬æ¢ è‹¥$0$ä¸ºåˆæ€ï¼Œåˆ™$A_0$ä¸ºå¼€å§‹ç¬¦å· å¯¹äº$move(i,a)=j$ï¼Œå¼•å…¥äº§ç”Ÿå¼$A_iâ†’aA_j$ å¯¹äº$move(i,Îµ)=j$ï¼Œå¼•å…¥äº§ç”Ÿå¼$A_iâ†’A_j$ è‹¥$i$æ˜¯ç»ˆæ€ï¼Œåˆ™å¼•å…¥äº§ç”Ÿå¼$A_i â†’Îµ$ã€‚ ä¸Šä¸‹æ–‡æœ‰å…³è¯­è¨€ ä¸èƒ½ç”¨CFGæè¿°çš„è¯­è¨€ $L1=\\{ \\omega c \\omega | \\omega \\in (a | b)^* \\}$æ ‡è¯†ç¬¦å£°æ˜ä¸å¼•ç”¨ä¸€è‡´æ€§çš„æŠ½è±¡ $L2=\\{a^nb^mc^nd^m|n \\ge 1\\ and\\ m \\ge 1\\}$ å½¢å‚ä¸å®å‚ä¸€è‡´æ€§çš„æŠ½è±¡ $L3=\\{ a^nb^nc^n|n \\ge 1\\}$ è®¡æ•°é—®é¢˜çš„æŠ½è±¡ ç›¸è¿‘çš„CFL $L1^{\u0026rsquo;}=\\{ \\omega c \\omega^r | \\omega \\in (a | b)^* \\} (S\\rightarrow aSa\\ |\\ bSb\\ |c)$ $L2^{\u0026rsquo;}=\\{ a^nb^mc^md^n|n\\ge 1, m \\ge 1\\} (S \\rightarrow aSd\\ | aAd\\ A \\rightarrow bAc\\ |\\ bc)$ $L2^{\u0026rsquo;\u0026rsquo;}=\\{ a^nb^nc^md^m | n \\ge 1, m \\ge 1\\} (S \\rightarrow AB\\ A\\rightarrow aAb\\ |\\ ab \\ B\\rightarrow cBd\\ | cd) $ $ L3^{\u0026rsquo;}=\\{ a^mb^mc^m | m, n \\ge 1\\}\\ (S \\rightarrow aAb | ab\\ C\\rightarrow cC|c)$ å½¢å¼è¯­è¨€ä¸è‡ªåŠ¨æœºç®€ä»‹ 0å‹æ–‡æ³•ï¼šè‹¥æ–‡æ³• $G=(N, T, P, S)$ çš„æ¯ä¸ªäº§ç”Ÿå¼ $Î±â†’Î²$ ä¸­ å‡æœ‰ $Î±âˆˆ(NâˆªT)^* $ ä¸”è‡³å°‘å«æœ‰ä¸€ä¸ªéç»ˆç»“ç¬¦ $Î²âˆˆ(NâˆªT)^*$åˆ™ç§° G ä¸º 0 å‹æ–‡æ³• ã€‚ é™åˆ¶ $G $çš„ä»»ä½•äº§ç”Ÿå¼ $Î±â†’Î²$ ($Sâ†’Îµ$ é™¤å¤–) æ»¡è¶³$ |Î±|â‰¤|\\beta |$ $G$ çš„ä»»ä½•äº§ç”Ÿå¼å½¢å¦‚ $Aâ†’Î²$ å…¶ä¸­ $AâˆˆN\\ Î²âˆˆ(NâˆªT)^*$ $G$ çš„ä»»ä½•äº§ç”Ÿå¼å½¢å¦‚ $Aâ†’a$ æˆ–è€… $Aâ†’aB$( æˆ–è€… $Aâ†’Ba$) å…¶ä¸­ $A$ å’Œ $B$$âˆˆN$ $aâˆˆT$ æ–‡æ³• è¯­è¨€ è‡ªåŠ¨æœº çŸ­è¯­æ–‡æ³•ï¼ˆ0å‹ï¼‰ çŸ­è¯­ç»“æ„è¯­è¨€ å›¾çµæœº CSGï¼ˆ1å‹ï¼‰ CSL çº¿æ€§ç•Œé™è‡ªåŠ¨æœº CFGï¼ˆ2å‹ï¼‰ CFL ä¸‹æ¨è‡ªåŠ¨æœº æ­£è§„æ–‡æ³• ï¼ˆ3å‹ï¼‰ æ­£è§„é›† æœ‰é™è‡ªåŠ¨æœº è‡ªä¸Šè€Œä¸‹è¯­æ³•åˆ†æ ä¸€èˆ¬æ–¹æ³•ï¼ˆè¯•æ¢ï¼‹å›æº¯ï¼Œè¾¹æ¨å¯¼è¾¹åŒ¹é…ï¼‰ æ¶ˆé™¤å·¦é€’å½’ æ¶ˆé™¤ç›´æ¥å·¦é€’å½’: $A\\rightarrow AÎ±|Î²$æ›¿æ¢ä¸º$A \\rightarrow \\beta A^{\u0026rsquo;}\\ \\ A^{\u0026rsquo;} \\rightarrow \\alpha A^{\u0026rsquo;} | \\epsilon$ æ¶ˆé™¤æ–‡æ³•çš„å·¦é€’å½’ï¼ˆç›´æ¥/é—´æ¥å·¦é€’å½’ï¼‰ï¼šå°†ä¸æ˜¯å·¦é€’å½’çš„éç»ˆç»“ç¬¦å³éƒ¨å±•å¼€åˆ°å…¶å®ƒäº§ç”Ÿå¼ä¸­ã€‚ åˆç†æ’åºéç»ˆç»“ç¬¦ï¼š$A_1,A_2,â€¦,A_n$(æ’åºæ–¹æ³•ä¸å”¯ä¸€) ç”¨$A_jâ†’Î´_1|Î´_2|\u0026hellip;|Î´_k$å³éƒ¨æ›¿æ¢$A_iâ†’A_jÎ³$ä¸­çš„$A_j$ï¼Œå¾—åˆ°$A_iâ†’Î´_1 Î³|Î´_2 Î³|\u0026hellip;|Î´_k Î³$ï¼› (å¦‚æœæœ‰)æ¶ˆé™¤$A_i$äº§ç”Ÿå¼ä¸­çš„ç›´æ¥å·¦é€’å½’ï¼› æå–å…¬å› å­ å°†$A \\rightarrow \\alpha {\\beta}_1 | \\alpha {\\beta}_2$æ›¿æ¢ä¸º$ A \\rightarrow \\alpha A^{\u0026rsquo;} \\ A^{\u0026rsquo;} \\rightarrow {\\beta}_1|{\\beta}_2$\né€’å½’ä¸‹é™åˆ†æ \u0026hellip;\né¢„æµ‹åˆ†æå™¨ éé€’å½’ï¼ˆè¡¨é©±åŠ¨ï¼‰é¢„æµ‹åˆ†æå™¨çš„å·¥ä½œæ¨¡å¼\nå·¥ä½œæ–¹å¼ æ ¼å±€ï¼šä¸‰å…ƒç»„(æ ˆå†…å®¹^topï¼Œå‰©ä½™è¾“å…¥^ipï¼Œæ”¹å˜æ ¼å±€çš„åŠ¨ä½œ) æ”¹å˜æ ¼å±€çš„åŠ¨ä½œ åŒ¹é…ç»ˆç»“ç¬¦ï¼šè‹¥^top = ^ip(ä½†â‰ â€˜#â€™)ï¼Œåˆ™popä¸”next(ip)ï¼› å±•å¼€éç»ˆç»“ç¬¦ï¼šè‹¥^top = Xä¸”^ip=aä¸”M[X, a] = Î±(Xâ†’Î±)ï¼Œåˆ™popä¸”push(Î±)ï¼ˆÎ±é€†åºå…¥æ ˆï¼‰; æŠ¥å‘Šåˆ†ææˆåŠŸï¼šè‹¥^top = ^ip = #ï¼Œåˆ™åˆ†ææˆåŠŸå¹¶ç»“æŸ; æŠ¥å‘Šå‡ºé”™ï¼šå…¶å®ƒæƒ…å†µï¼Œè°ƒç”¨é”™è¯¯æ¢å¤ä¾‹ç¨‹ã€‚ é¢„æµ‹åˆ†æè¡¨ FIRSTé›†åˆå’ŒFOLLOWé›†åˆ\nFIRSTé›†åˆï¼š$FIRST(\\alpha) = \\{ a | \\alpha \\overset{*}{=\u0026gt;} a\u0026hellip;, a \\in T \\} $ $\\alpha$çš„FIRSTé›†åˆå°±æ˜¯ç”±ä»$\\alpha$å¼€å§‹å¯å¯¼å‡ºçš„æ–‡æ³•ç¬¦å·åºåˆ—çš„å¼€å¤´ç»ˆç»“ç¬¦æ„æˆçš„é›†åˆã€‚\næ±‚è§£ ç›´æ¥æ”¶å–ï¼šå¯¹å½¢å¦‚$U \\rightarrow a\u0026hellip;$ çš„äº§ç”Ÿå¼ï¼ˆå…¶ä¸­$a$æ˜¯ç»ˆç»“ç¬¦ï¼‰ï¼ŒæŠŠ$a$æ”¶å…¥åˆ°$FIRST(U)$ä¸­ åå¤ä¼ é€ï¼šå¯¹å½¢å¦‚$U \\rightarrow P\u0026hellip;$ çš„äº§ç”Ÿå¼ï¼ˆå…¶ä¸­$P$æ˜¯éç»ˆç»“ç¬¦ï¼ŒæŠŠ$FIRST(P)$çš„å†…å®¹ä¼ é€åˆ°$FIRST(U)$ä¸­ FOLLOWé›†åˆï¼š$FOLLOW(A)=\\{ a | S \\overset{*}{=\u0026gt;} Aa \\}$ $A$çš„$FOLLOW$é›†åˆï¼Œå°±æ˜¯ç”±ä»å¼€å§‹ç¬¦å·å¯å¯¼å‡ºçš„å«Açš„æ–‡æ³•ç¬¦å·åºåˆ—ä¸­ç´§é‚»Aä¹‹åçš„ç»ˆç»“ç¬¦æ„æˆçš„é›†åˆã€‚\næ±‚è§£ åŠ å…¥$ \\# $åˆ°$FOLLOW(S)$ è‹¥æœ‰äº§ç”Ÿå¼$A \\rightarrow \\alpha B \\beta $ï¼Œåˆ™é™¤$\\epsilon$ å¤–ï¼Œ$FIRST(\\beta)$çš„å…¨ä½“åŠ å…¥åˆ°$FOLLOW(B)$ è‹¥æœ‰äº§ç”Ÿå¼$A \\rightarrow \\alpha B$æˆ–$A \\rightarrow \\alpha B \\beta ä¸” \\epsilon \\in FIRST(\\beta)$ï¼Œåˆ™$FOLLOW(A)$çš„å…¨ä½“åŠ å…¥$FOLLOW(B)$ ä¾‹é¢˜\næ„é€ é¢„æµ‹åˆ†æè¡¨\nå¯¹æ–‡æ³•çš„æ¯ä¸ªäº§ç”Ÿå¼$A \\rightarrow \\alpha$ï¼Œæ‰§è¡Œ2å’Œ3ï¼› å¯¹$FIRST(\\alpha)$çš„æ¯ä¸ªç»ˆç»“ç¬¦$a$ï¼Œå°†$A \\rightarrow \\alpha$åŠ å…¥åˆ°$M[A, a]$ä¸­ï¼› å¯¹$\\epsilon \\in FIRST(\\alpha )$ï¼Œåˆ™å¯¹$FOLLOW(A)$ä¸­çš„æ¯ä¸ªç»ˆç»“ç¬¦$b$ï¼ˆåŒ…æ‹¬$\\#$)ï¼Œå°†$A \\rightarrow a$åŠ å…¥åˆ°$M[A, b]$ä¸­ã€‚ LL(1)æ–‡æ³•\nåˆ¤æ–­LL(1)æ–‡æ³•çš„æ–¹æ³• æ„é€ åˆ†æè¡¨ æ¨è®ºåˆ¤æ–­ï¼š$G$æ˜¯$LL(1)$çš„ï¼Œå½“ä¸”ä»…å½“$G$çš„ä»»ä½•ä¸¤ä¸ªäº§ç”Ÿå¼$A \\rightarrow \\alpha | \\beta$æ¡ä»¶ $FIRST(\\alpha) \\cap FIRST(\\beta) = \\emptyset$ è‹¥$\\beta \\overset{*}{=\u0026gt;} \\epsilon$ï¼Œåˆ™$FIRST(\\alpha) \\cap FOLLOW(A)=\\emptyset$ å¼±ç‚¹ éš¾å†™ã€éš¾æ‡‚ åº”ç”¨èŒƒå›´æœ‰é™ï¼Œå¾€å¾€å†™ä¸å‡ºæ¥æŸäº›è¯­è¨€çš„$LL(1)$æ–‡æ³• å®é™…ç¼–è¯‘å™¨ä¸­ä½¿ç”¨æ›´å¤šçš„æ˜¯ä¸€ç±»$LL(1)$æ–‡æ³•çš„çœŸè¶…é›†ï¼Œå³$LR(1)$æ–‡æ³•ã€‚ è‡ªä¸‹è€Œä¸Šè¯­æ³•åˆ†æ çŸ­è¯­ è®¾$\\alpha \\beta \\delta$æ˜¯æ–‡æ³•$G$çš„ä¸€ä¸ªå¥å‹ï¼Œè‹¥å­˜åœ¨$S \\overset{*}{=\u0026gt;} \\alpha A \\delta$ï¼Œ$A \\overset{+}{=\u0026gt;}\\beta$ï¼Œåˆ™ç§°$\\beta$æ˜¯å¥å‹$\\alpha \\beta \\delta$(ç›¸å¯¹äº$A$)çš„çŸ­è¯­ã€‚\nç›´æ¥çŸ­è¯­ï¼š$A \\rightarrow \\beta$ å¥æŸ„ï¼šä¸€ä¸ªå¥å‹åœ°æœ€å·¦ç›´æ¥çŸ­è¯­è¢«ç§°ä¸ºå¥æŸ„ æœ€å·¦å½’çº¦â€”â€”â€å‰ªå¥æŸ„â€œè¿‡ç¨‹ LR(k)æ–‡æ³• $L$è¡¨ç¤ºä»å·¦åˆ°å³æ‰«æè¾“å…¥åºåˆ—ï¼Œ$R$è¡¨ç¤ºé€†åºçš„æœ€å³æ¨å¯¼ï¼Œ$k$è¡¨ç¤ºä¸ºç¡®å®šä¸‹ä¸€åŠ¨ä½œå‘å‰çœ‹çš„ç»ˆç»“ç¬¦ä¸ªæ•°\nLRåˆ†ææ³• ACTION[s, a]ï¼šæ ˆé¡¶çŠ¶æ€ä¸ºsé¢ä¸´aæ—¶é‡‡å–ä»€ä¹ˆåŠ¨ä½œ(shift or reduce) GOTO[s, X]ï¼šå½’çº¦åå¯¹åº”çš„çŠ¶æ€ LR(0)åˆ†æè¡¨çš„æ„é€  æ´»å‰ç¼€ï¼šä¸ºäº†æè¿°LRåˆ†æä¸­æ ˆå†…çš„ç¬¦å·çš„ç‰¹ç‚¹ å¦‚æœåœ¨ç¬¦å·åºåˆ—$\\alpha$çš„å³è¾¹å¢æ·»é›¶ä¸ªæˆ–å¤šä¸ªç»ˆç»“ç¬¦ä¹‹åï¼Œèƒ½å¤Ÿå½¢æˆä¸€ä¸ªå³å¥å‹å¹¶ä¸”$\\alpha$ä¸å«è¯¥å¥å‹å¥æŸ„ä¹‹åçš„ä»»ä½•ç¬¦å·ï¼Œåˆ™ç§°$\\alpha$ä¸ºæ–‡æ³•$G$çš„æ´»å‰ç¼€ã€‚\nå¯¹äºè§„èŒƒå¥å‹$\\alpha \\beta \\delta$ï¼Œ$\\beta$ä¸ºå¥æŸ„ï¼Œå¦‚æœ$\\alpha \\beta = u_1 u_2 \u0026hellip; u_r$ï¼Œåˆ™ç¬¦å·ä¸²$u_1 u_2 \u0026hellip;u_i(1 \\le i \\le r)$æ—¶$\\alpha \\beta \\delta$çš„æ´»å‰ç¼€\nä¸¾ä¾‹è¯´æ˜ä»¥ä¸‹æ–‡æ³•çš„æ´»å‰ç¼€ $G: S \\rightarrow aABe | aAbBec \\ A \\rightarrow b | bA \\ B \\rightarrow d $ æ´»å‰ç¼€ï¼š$a, aA, aAB, aABe, aAb, aAbBec, aAbd, aAd, ab, abb, abbb, ab+$ LR(0)é¡¹ç›® ä¸€ä¸ª$LR(0)$é¡¹ç›®(ç®€ç§°é¡¹ç›®)æ˜¯è¿™æ ·ä¸€ä¸ªäº§ç”Ÿå¼ï¼Œåœ¨å®ƒå³éƒ¨çš„æŸä¸ªä½ç½®æœ‰ä¸€ä¸ªç‚¹$â€œ.â€$ã€‚å¯¹äº$A \\rightarrow \\epsilon$ï¼Œå®ƒä»…æœ‰ä¸€ä¸ªé¡¹ç›®$A \\rightarrow .$\næ„ä¹‰ $A \\rightarrow . XYZ$ï¼Œè¯´æ˜å¸Œæœ›ä»åé¢è¾“å…¥ä¸²ä¸­çœ‹åˆ°å¯ä»¥ä»$XYZ$æ¨å‡ºçš„ç¬¦å·ä¸²ï¼Œéœ€è¦ç§»è¿›ï¼› $A \\rightarrow X . YZ$ï¼Œè¯´æ˜å·²ç»ä»è¾“å…¥ä¸²ä¸­çœ‹åˆ°å¯ä»¥ä»$X$æ¨å‡ºçš„ç¬¦å·ä¸²ï¼Œå¸Œæœ›è¿›ä¸€æ­¥çœ‹åˆ°å¯ä»¥ä»$YZ$æ¨å‡ºçš„ç¬¦å·ä¸²ï¼Œéœ€è¦ç»§ç»­ç§»è¿›ã€‚ $Aâ†’ XYZ . $ï¼Œè¯´æ˜å½“å‰æ ˆé¡¶å·²ç»å½¢æˆå¥æŸ„ï¼Œå¯ä»¥å½’çº¦ã€‚ è¯†åˆ«æ–‡æ³•Gçš„æ´»å‰ç¼€çš„NFA è‹¥çŠ¶æ€$i$ä¸º$X \\rightarrow X_1 \u0026hellip; X_{i-1} . X_i \u0026hellip; X_n$ï¼ŒçŠ¶æ€$j$ä¸º$X \\rightarrow X_1 \u0026hellip; X_{i-1} X_i . X_{i+1} \u0026hellip; X_n$ï¼Œåˆ™ä»çŠ¶æ€$i$è¿ä¸€æ¡$X_i$æœ‰å‘è¾¹åˆ°çŠ¶æ€$j$ è‹¥çŠ¶æ€$i$ä¸º$X \\rightarrow \\alpha .A \\beta$ï¼ŒAä¸ºéç»ˆç»“ç¬¦ï¼Œåˆ™ä»$i$è¿ä¸€æ¡$\\epsilon$åˆ°æ‰€æœ‰çŠ¶æ€$A \\rightarrow . \\gamma$ ç¡®å®šåŒ–åçš„DFA LR(0)é¡¹ç›®é›†è§„èŒƒæ—çš„æ„é€  æ‹“å¹¿æ–‡æ³•$G^{\u0026rsquo;}= G \\cup \\{ S^{\u0026rsquo;} \\rightarrow S\\}$ï¼šä¸ºäº†ä½¿å¾—æœ€ç»ˆæ„é€ çš„DFAçŠ¶æ€é›†ä¸­å…·æœ‰å”¯ä¸€çš„æ¥æ”¶çŠ¶æ€ NFAï¼ˆé¡¹ç›®ï¼‰-\u0026gt; DFAï¼ˆé¡¹ç›®é›†ï¼‰ $CLOSURE(I)$ï¼šä»é¡¹ç›®é›†$I$ä¸ç»è¿‡ä»»ä½•æ–‡æ³•ç¬¦å·åˆ°è¾¾çš„é¡¹ç›®å…¨ä½“ $GO(I, X)$ï¼šæ‰€æœ‰ä»$I$ç»æ–‡æ³•ç¬¦å·$X$èƒ½åˆ°è¾¾çš„é¡¹ç›®å…¨ä½“ï¼ˆä¸$somve$ä¸åŒï¼Œ$GO$å«æœ‰é—­åŒ…è®¡ç®—ï¼‰ $CLOSURE(I)$è®¡ç®—æ–¹æ³•ï¼š $I$çš„ä»»ä½•é¡¹ç›®å±äº$CLOSURE(I)$ è‹¥$A \\rightarrow \\alpha . B \\beta$å±äº$CLOSURE(I)$ï¼Œé¡¹ç›®$B \\rightarrow .\\gamma$ä¹Ÿå±äº$CLOSURE(I)$ é‡å¤ä»¥ä¸Šæ­¥éª¤ç›´åˆ°$CLOSURE(I)$ä¸å†å¢å¤§ $GO(I, X)=CLOSURE(J)$ æœ‰æ•ˆé¡¹ç›® è‹¥å­˜åœ¨æœ€å³æ¨å¯¼$S^{\u0026rsquo;} \\overset{*}{=\u0026gt;}\\alpha A \\omega =\u0026gt; \\alpha \\beta_1 \\beta_2 \\omega $ï¼Œåˆ™ç§°é¡¹ç›®$A \\rightarrow \\beta_1 . \\beta_2$å¯¹æ´»å‰ç¼€$\\alpha \\beta_1$æœ‰æ•ˆ\næ„ä¹‰ åˆ°ç›®å‰ä¸ºæ­¢è¯­æ³•åˆ†ææ˜¯æ­£ç¡®çš„ æŒ‡å¯¼ä¸‹ä¸€æ­¥çš„åˆ†æ $A \\rightarrow \\alpha a. \\beta$ï¼ˆå¯ç§»è¿›é¡¹ï¼‰ $B \\rightarrow \\beta.$ï¼ˆå¯å½’çº¦é¡¹ï¼‰ LR(0)åˆ†æè¡¨çš„æ„é€  åœ†ç‚¹åæ˜¯ç»ˆç»“ç¬¦ï¼Œéœ€è¦å¡«ACTIONç§»è¿› åœ†ç‚¹åæ˜¯éç»ˆç»“ç¬¦ï¼Œéœ€è¦å¡«GOTOè¡¨ åœ†ç‚¹åä¸ºç©ºï¼Œéœ€è¦å¡«ACTIONå½’çº¦ SLR(1)åˆ†æè¡¨çš„æ„é€  $LR(0)$è§„èŒƒæ—çš„ä¸€ä¸ªé¡¹ç›®é›†ä¸­å«æœ‰mä¸ªç§»è¿›é¡¹ç›®ï¼š$A_1 \\rightarrow \\alpha_1. a_1 \\beta_1, A_2 \\rightarrow \\alpha_2. a_2 \\beta_2 \u0026hellip; ,A_m \\rightarrow \\alpha_m. a_m \\beta_m$ï¼ŒåŒæ—¶æœ‰$n$ä¸ªå½’çº¦é¡¹ç›®ï¼š$B_1 \\rightarrow \\alpha_1., B_2 \\rightarrow \\alpha_2., \u0026hellip;, B_n \\rightarrow \\alpha_n., $\nå¦‚æœé›†åˆ$\\{a_1, \u0026hellip;, a_m\\}, FOLLOW(B_1), \u0026hellip;, FOLLOW(B_n)$ä¸¤ä¸¤ä¸ç›¸äº¤,åˆ™å¯ä»¥ç”¨SLR(1)æ¥è§£å†³ã€‚\nå¯¹äºå½“å‰è¾“å…¥ç¬¦å·$a$\nè‹¥$a \\in \\{ a_1, \u0026hellip;, a_m \\}$ï¼Œåˆ™ç§»è¿› è‹¥$a \\in FOLLOW(B_i)$ï¼Œåˆ™ç”¨äº§ç”Ÿå¼$B_i \\rightarrow \\alpha_i$å½’çº¦ å¦åˆ™ï¼ŒæŠ¥é”™ éSLR(1)æ–‡æ³• äºŒä¹‰æ–‡æ³• éäºŒä¹‰æ–‡æ³•çš„éSLR(1)æ–‡æ³• ä½œä¸š LRåˆ†ææ³•ä¸­ï¼Œåˆ†ææ ˆä¸­å­˜æ”¾çš„çŠ¶æ€æ˜¯è¯†åˆ«è§„èŒƒå¥å‹æ´»å‰ç¼€çš„DFAçŠ¶æ€ã€‚ ä¸€ä¸ªä¸Šä¸‹æ–‡æ— å…³æ³•æ‰€å«çš„å››ä¸ªç»„æˆéƒ¨åˆ†æ˜¯ä¸€ç»„ç»ˆç»“ç¬¦ã€ä¸€ç»„éç»ˆç»“ç¬¦ã€ä¸€ä¸ªå¼€å§‹ç¬¦å·ã€ä¸€ç»„äº§ç”Ÿå¼ è‡ªä¸‹è€Œä¸Šçš„è¯­æ³•åˆ†ææ–¹æ³•çš„åŸºæœ¬æ€æƒ³æ˜¯ï¼šä»ç»™å®šçš„ç»ˆç»“ç¬¦å¼€å§‹ï¼Œæ ¹æ®æ–‡æ³•çš„è§„åˆ™ä¸€æ­¥ä¸€æ­¥åœ°å‘ä¸Šè¿›è¡Œç›´æ¥å½’çº¦ï¼Œè¯•å›¾å½’çº¦åˆ°æ–‡æ³•çš„å¼€å§‹ç¬¦å·ã€‚ $LR(0)$åˆ†ææ³•çš„åç§°ä¸­ï¼ŒLçš„å«ä¹‰æ˜¯ä»å·¦å‘å³æ‰«æè¾“å…¥ä¸²ï¼Œ$R$çš„å«ä¹‰æ˜¯æœ€å·¦å½’çº¦ï¼Œ$0$çš„å«ä¹‰æ˜¯å‘åæŸ¥çœ‹$0$ä¸ªè¾“å…¥ç¬¦å·ã€‚ ä»¿ç…§æœ€å·¦æ¨å¯¼å’Œå·¦å¥å‹çš„å®šä¹‰ï¼Œè¯•å™è¿°æœ€å³æ¨å¯¼å’Œå³å¥å‹çš„å®šä¹‰ã€‚ æœ€å³æ¨å¯¼ï¼šåœ¨æ¨å¯¼è¿‡ç¨‹ä¸­ï¼Œè‹¥æ¯æ¬¡ç›´æ¥æ¨å¯¼å‡æ›¿æ¢å¥å‹æœ€å³è¾¹çš„éç»ˆç»“ç¬¦ï¼Œç§°ä¸ºæœ€å³æ¨å¯¼ å³å¥å‹ï¼šåœ¨æœ€å³æ¨å¯¼äº§ç”Ÿçš„å¥å‹è¢«ç§°ä¸ºå³å¥å‹ ç®€è¿°è‡ªä¸Šè€Œä¸‹åˆ†æçš„å®—æ—¨ å¯¹ç»™å®šè¾“å…¥ä¸²$w$ï¼Œè¯•å›¾ç”¨ä¸€åˆ‡å¯èƒ½çš„åŠæ³•ï¼Œä»æ–‡æ³•å¼€å§‹ç¬¦å·$S$å‡ºå‘ï¼Œè‡ªä¸Šè€Œä¸‹ï¼Œä»å·¦åˆ°å³åœ°ä¸ºè¾“å…¥ä¸²å»ºç«‹èµ·ä¸€æ£µä»¥$S$ä¸ºæ ¹ç»“ç‚¹çš„è¯­æ³•æ ‘ã€‚æˆ–è€…è¯´ï¼Œä¸ºè¾“å…¥ä¸²å¯»æ‰¾æœ€å·¦æ¨å¯¼$S \\overset{*}{=\u0026gt;} w$ã€‚è¿™ç§åˆ†æè¿‡ç¨‹æœ¬è´¨ä¸Šæ˜¯ä¸€ç§è¯•æ¢è¿‡ç¨‹ï¼Œæ˜¯åå¤ä½¿ç”¨ä¸åŒçš„äº§ç”Ÿå¼è°‹æ±‚åŒ¹é…è¾“å…¥ä¸²çš„è¿‡ç¨‹ï¼Œå¦‚æœè¿™ä¸€è¯•æ¢å¾—åˆ°æˆåŠŸï¼Œåˆ™è¯æ˜$w$æ˜¯ç›¸åº”æ–‡æ³•çš„ä¸€ä¸ªå¥å­ï¼Œåä¹‹ï¼Œåˆ™ä¸æ˜¯ã€‚ æ ¹æ®ç¨‹åºé”™è¯¯æ€§è´¨å¯ä»¥åˆ†ä¸ºå“ªå‡ ç§é”™è¯¯ï¼Ÿ è¯æ³•é”™è¯¯ è¯­æ³•é”™è¯¯ é™æ€è¯­ä¹‰é”™è¯¯ åŠ¨æ€è¯­ä¹‰é”™è¯¯ è‡ªä¸‹è€Œä¸Šåˆ†ææ³•çš„æ€æƒ³ è‡ªä¸‹è€Œä¸Šçš„æ€æƒ³å°±æ˜¯ä»è¾“å…¥ä¸²å¼€å§‹ï¼Œé€æ­¥è¿›è¡Œâ€å½’çº¦â€œï¼Œç›´è‡³å½’çº¦åˆ°æ–‡æ³•çš„å¼€å§‹ç¬¦å·ï¼›æˆ–è€…è¯´ä»è¯­æ³•æ ‘çš„æœ«ç«¯å¼€å§‹ï¼Œæ­¥æ­¥å‘ä¸Šâ€å½’çº¦â€œï¼Œç›´åˆ°æ ¹ç»“ç‚¹ã€‚ ç®€è¿°æ„é€ $LR$åˆ†æè¡¨çš„æŠ€æœ¯ $LR(0)$è¡¨æ„é€ ã€‚è¿™ç§æ–¹æ³•å±€é™æ€§å¤§ï¼Œä½†æ˜¯å®ƒæ˜¯å»ºç«‹å…¶ä»–è¾ƒä¸€èˆ¬LRåˆ†ææ³•çš„åŸºç¡€ã€‚ ç®€å•$LR$è¡¨$(SLR)$æ„é€ ï¼šè™½ç„¶ä¸€äº›æ–‡æ³•æ„é€ ä¸å‡º$SLR$åˆ†æè¡¨ï¼Œä½†æ˜¯è¿™æ˜¯ä¸€ç§æ¯”è¾ƒå®¹æ˜“å®ç°åˆææœ‰ä½¿ç”¨ä»·å€¼çš„æ–¹æ³•ã€‚ è§„èŒƒ$LR$è¡¨æ„é€ æ³•ï¼šè¿™ç§åˆ†æè¡¨èƒ½åŠ›æœ€å¼ºï¼Œèƒ½å¤Ÿé€‚åº”ä¸€å¤§ç±»æ–‡æ³•ï¼Œä½†æ˜¯å®ç°ä»£ä»·è¿‡é«˜ã€‚ å‘å‰$LR$è¡¨$(LALR)$æ„é€ æ³•ï¼šè¿™ç§åˆ†æè¡¨çš„èƒ½åŠ›ä»‹äºSLRå’Œè§„èŒƒLRä¹‹é—´ï¼Œå¯ä»¥é«˜æ•ˆçš„å®ç°ã€‚ æ´»å‰ç¼€ï¼šå³å¥å‹çš„å‰ç¼€ä¸”ä¸åŒ…å«å¥æŸ„ä¹‹åçš„ç¬¦å· ç¬¬å››ç«  è¯­æ³•åˆ¶å¯¼ç¿»è¯‘ä¸ä¸­é—´ä»£ç ç”Ÿæˆ è¯­æ³•åˆ¶å¯¼ç¿»è¯‘ç®€ä»‹ å±æ€§æ–‡æ³• $$ A \\rightarrow \\alpha \\ \\ b := f(c_1, c_2, \u0026hellip;, c_k)$$\nç»¼åˆå±æ€§ï¼š$b$æ˜¯$A$çš„å±æ€§ï¼Œ$c_1, c_2, \u0026hellip;, c_k$æ˜¯$\\alpha$ä¸­çš„æ–‡æ³•ç¬¦å·çš„å±æ€§æˆ–$A$çš„å…¶ä»–å±æ€§ï¼Œåˆ™ç§°$b$æ˜¯$A$çš„ç»¼åˆå±æ€§ ç»§æ‰¿å±æ€§ï¼š$b$æ˜¯$\\alpha$ä¸­çš„æ–‡æ³•ç¬¦å·$X_i$çš„å±æ€§ï¼Œ$c_1, c_2, \u0026hellip;, c_k$æ˜¯$A$çš„å±æ€§æˆ–$\\alpha$ä¸­çš„å…¶ä»–æ–‡æ³•ç¬¦å·å±æ€§ï¼Œåˆ™ç§°$b$æ˜¯$X_i$çš„ç»§æ‰¿å±æ€§ $b$ä¾èµ–äº$c_1, c_2, \u0026hellip;, c_k$ è™šæ‹Ÿå±æ€§ï¼š$f(c_1, c_2, \u0026hellip;, c_k)$ ä¸­é—´ä»£ç ç®€ä»‹ åç¼€å¼ï¼ˆé€†æ³¢å…°ï¼‰ ä¾‹ï¼š$a := 1 + 2 * 3$ åç¼€å¼ä¸ºï¼š$a 1 2 3 * + := $\nä¸‰åœ°å€ç  å½¢å¼ï¼š\n$result := arg1\\ op\\ arg2$ $result := op\\ arg1$ $op\\ arg1$ ç§ç±»\nä¸‰å…ƒå¼ï¼š(i)(op, arg1, arg2)å¯¹åº”ä¸‰åœ°å€ç (i) := arg1 op arg2 å››å…ƒå¼ï¼š(op, arg1, arg2, result)å¯¹åº”ä¸‰åœ°å€ç result := arg1 op arg2 å››å…ƒå¼çš„è¿ç®—ç»“æœä¸å…¶ä½ç½®æ— å…³ï¼Œä¸ºä»£ç ä¼˜åŒ–æä¾›äº†æå¤§çš„æ–¹ä¾¿ã€‚ å›¾å½¢è¡¨ç¤º æ ‘çš„è¯­æ³•åˆ¶å¯¼ç¿»è¯‘\nmknodeï¼šç”Ÿæˆæ ¹æˆ–å†…éƒ¨èŠ‚ç‚¹ mkleafï¼šç”Ÿæˆå¶å­èŠ‚ç‚¹ (1)A â†’ id := E\t{A.nptr := mknode(:=, mkleaf(entry(id.name)), E.nptr)} (2)E â†’ E1 + E2\t{E.nptr := mknode(+, E1.nptr, E2.nptr)} (3)E â†’ E1 * E2\t{E.nptr := mknode(*, E1.nptr, E2.nptr)} (4)E â†’ (E1)\t{E.nptr := E1.nptr} (5)E â†’ - E1\t{E.nptr := mknode(@, E1.nptr, )} (6)E â†’ id\t{E.nptr := mkleaf(entry((id.name))} ä¼˜åŒ–è¡¨ç¤ºâ€”â€”æœ‰å‘æ— ç¯å›¾ å…ˆæŸ¥çœ‹æ‰€è¦æ„é€ çš„èŠ‚ç‚¹æ˜¯å¦å·²ç»å­˜åœ¨ï¼Œè‹¥å­˜åœ¨åˆ™æ— éœ€æ„é€ æ–°çš„èŠ‚ç‚¹ï¼Œç›´æ¥è¿”å›æŒ‡å‘å·²å­˜åœ¨èŠ‚ç‚¹çš„æŒ‡é’ˆå³å¯ã€‚\nç¬¦å·è¡¨ç®€ä»‹ ç›¸å½“äºæ˜¯ä¸€ä¸ªå†…å­˜ï¼Œè¿æ¥å£°æ˜ä¸å¼•ç”¨çš„æ¡¥æ¢ï¼Œä¸€ä¸ªåå­—åœ¨å£°æ˜æ—¶ï¼Œç›¸å…³ä¿¡æ¯è¢«å¡«å†™è¿›ç¬¦å·è¡¨ï¼Œåœ¨å¼•ç”¨æ—¶æ ¹æ®ç¬¦å·è¡¨ä¸­çš„ä¿¡æ¯ç”Ÿæˆå¯æ‰§è¡Œè¯­å¥ã€‚\né™æ€ä½œç”¨åŸŸè§„åˆ™â€”â€”æ€»æ–¹é’ˆ æœ€è¿‘åµŒå¥—è§„åˆ™â€”â€”æ€»æ–¹é’ˆä¸‹çš„å…·ä½“è§„åˆ™ å£°æ˜è¯­å¥çš„ç¿»è¯‘ å˜é‡å£°æ˜çš„æ–‡æ³• D -\u0026gt; D ; D | id : T {enter(id.name, T.type, offset); offset := offset + T.width; } T -\u0026gt; int {T.type = integer; T.width := 4; } | real {T.type = real; T.width := 8; } | array [num] of T1 {T.type = array(num.val, T1.type); T.width := num.val * T1.width; } | ^T {T.type = pointer(T1.type); T.width := 4; } ä¾‹ï¼ša : array[10] of int; x : int\nè¿‡ç¨‹çš„å®šä¹‰ä¸å£°æ˜ å·¦å€¼å’Œå³å€¼ å·¦å€¼å¿…é¡»å…·æœ‰å­˜å‚¨ç©ºé—´ï¼Œå³å€¼å¯ä»¥ä»…ä»…æ˜¯ä¸€ä¸ªå€¼ å·¦å€¼æ˜¯å®¹å™¨ï¼Œå³å€¼æ˜¯å†…å®¹ å‚æ•°ä¼ é€’ å€¼è°ƒç”¨ï¼šCå‚æ•°ä¼ é€’ å¼•ç”¨è°ƒç”¨ï¼šC++å¼•ç”¨ä¼ é€’ å¤å†™â€”â€”æ¢å¤ æ¢åè°ƒç”¨ï¼šå®å®šä¹‰ ç®€å•ç®—æœ¯è¡¨è¾¾å¼ä¸èµ‹å€¼å¥ x := -a * b + cçš„è¯­æ³•åˆ¶å¯¼ç¿»è¯‘ï¼Œxã€aã€bæ˜¯æ•´å‹æ•°ï¼Œcæ˜¯å®å‹æ•°ã€‚\nå¸ƒå°”è¡¨è¾¾å¼ ç›´æ¥è®¡ç®— ","permalink":"https://fffzlfk.github.io/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/","summary":"Compiler Principles","title":"ç¼–è¯‘åŸç†"},{"content":"ç‰›é¡¿è¿­ä»£æ³• å¦‚å›¾ï¼Œä¸€æ¡æ›²çº¿$y=f(x)$ï¼Œåœ¨$f(x_n)$å¤„ç”»ä¸€æ¡åˆ‡çº¿äº¤xè½´äºç‚¹$x_{n+1}$ï¼Œæ¥ç€åœ¨$f(x_{n+1})$å¤„ç”»åˆ‡çº¿äº¤xè½´äºç‚¹$x_{n+2}$ï¼Œç»§ç»­â€¦â€¦ åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­äº¤ç‚¹$x_{n+m}$ä¼šæ— é™é€¼è¿‘æ›²çº¿é›¶ç‚¹ï¼Œå³å¾—åˆ°æ–¹ç¨‹$f(x) = 0$çš„è§£ã€‚ æ±‚å¹³æ–¹æ ¹ æ€è·¯ å³æ±‚å‡½æ•°$f(x) = x^2 - n $çš„é›¶ç‚¹ å¯¼å‡½æ•°$f^{\u0026rsquo;}(x) = 2x $ åœ¨ç‚¹$(x_n, x_n^2-n)$å¤„çš„åˆ‡çº¿æ–¹ç¨‹ä¸º$y - x_n^2 + n = 2x_n (x-x_n) $ï¼Œå³$y = 2x_nx - x_n^2 - n$ åˆ™åˆ‡çº¿ä¸xè½´çš„äº¤ç‚¹$x_{n+1}$ä¸º$$\\frac {x_n^2 - n} {2x_n}$$ é‡å¤è¿­ä»£ç›´åˆ°å¾—åˆ°ç²¾åº¦æ»¡æ„çš„å€¼ ä»£ç å®ç° package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func Sqrt(x float64) float64 { z := 1.0 for math.Abs(z * z - x) \u0026gt; 1e-12 { z -= (z * z - x) / (2 * z) } return z } func main() { fmt.Println(Sqrt(2)) } æ±‚kæ¬¡æ–¹æ ¹ æ€è·¯ $$x_{n+1} = x_{n} - \\frac {f(x_n)} {f^{\u0026rsquo;}(x_n)}$$ $$x_{n+1} = x_n - \\frac {x_n(1 - nx_n^{-k})} k$$ ä»£ç å®ç° package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func getRoot(x, k float64) float64 { z := 1.0 for math.Abs(math.Pow(z, k) - x) \u0026gt; 1e-9 { z -= z * (1 - x * math.Pow(z, -k)) / k } return z } func main() { fmt.Println(getRoot(27, 3)) } Benchmark(vs Binary Search) å®ç°åŠå…¶æµ‹è¯• // sqrt.go package sqrt import \u0026#34;errors\u0026#34; const EPSILON = 1e-8 var ErrNegativeSqrt = errors.New(\u0026#34;cannot Sqrt negative number\u0026#34;) type Float interface { float64 | float32 } func abs[T Float](x T) T { if x \u0026lt; 0 { return -x } return x } func SqrtWithNR[T Float](num T) (T, error) { if num \u0026lt; 0 { return 0, ErrNegativeSqrt } z := T(1.0) for abs(z*z-num) \u0026gt; EPSILON { z -= (z*z - num) / (2 * z) } return z, nil } func SqrtWithBS[T Float](num T) (T, error) { if num \u0026lt; 0 { return 0, ErrNegativeSqrt } l, r := T(0.0), num for abs(l*l-num) \u0026gt; EPSILON { m := (l + r) / 2 if m*m \u0026gt; num { r = m } else { l = m } } return l, nil } // sqrt_test.go package sqrt_test import ( \u0026#34;math\u0026#34; \u0026#34;sqrt\u0026#34; \u0026#34;testing\u0026#34; ) func TestSqrtWithNR(t *testing.T) { for i := 0; i \u0026lt; 10; i++ { num := float64(i) if z, err := sqrt.SqrtWithNR(num); err != nil { t.Error(err) } else if math.Abs(z*z-num) \u0026gt; sqrt.EPSILON { t.Errorf(\u0026#34;%f != %f\u0026#34;, z*z, num) } } } func TestSqrtWithBS(t *testing.T) { for i := 0; i \u0026lt; 10; i++ { num := float64(i) if z, err := sqrt.SqrtWithBS(num); err != nil { t.Error(err) } else if math.Abs(z*z-num) \u0026gt; sqrt.EPSILON { t.Errorf(\u0026#34;%f != %f\u0026#34;, z*z, num) } } } func BenchmarkSqrtWithNR(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { sqrt.SqrtWithNR(float64(i)) } } func BenchmarkSqrtWithBS(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { sqrt.SqrtWithBS(float64(i)) } } æµ‹è¯•ç»“æœ å¯ä»¥çœ‹å‡ºç‰›é¡¿æ³•ç›¸æ¯”äºäºŒåˆ†æŸ¥æ‰¾ï¼Œæ€§èƒ½è¦å¥½ï¼ğŸ¥°\n","permalink":"https://fffzlfk.github.io/posts/%E7%89%9B%E9%A1%BF%E6%B3%95%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9/","summary":"Newton\u0026rsquo;s method for the square root","title":"ç‰›é¡¿æ³•æ±‚å¹³æ–¹æ ¹"},{"content":"ä¸¤æ•°ä¹‹å’Œ é¢˜ç›®é“¾æ¥\nä»£ç  class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { unordered_map\u0026lt;int, int\u0026gt; M; for (int i = 0; i \u0026lt; nums.size(); i++) { if (M.count(target - nums[i])) { return {M[target - nums[i]], i}; } else { M[nums[i]] = i; } } return {0, 0}; } }; ä¸‰æ•°ä¹‹å’Œ é¢˜ç›®é“¾æ¥\næ€è·¯ åŒæŒ‡é’ˆ $O(n^2)$\nä»£ç  class Solution { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; a) { sort(begin(a), end(a)); ans.clear(); const int n = a.size(); for (int i = 0; i \u0026lt; n; i++) { if (i \u0026amp;\u0026amp; a[i-1] == a[i]) continue; int j = i + 1, k = n - 1; while (j \u0026lt; k) { if (a[i] + a[j] + a[k] \u0026lt; 0) ++j; else if (a[i] + a[j] + a[k] \u0026gt; 0) --k; else { ans.push_back({a[i], a[j], a[k]}); while (j \u0026lt; k \u0026amp;\u0026amp; a[j] == a[j+1]) j++; while (j \u0026lt; k \u0026amp;\u0026amp; a[k] == a[k-1]) k--; j++, k--; } } } return ans; } }; æ‰©å±•-æœ€æ¥è¿‘çš„ä¸‰æ•°ä¹‹å’Œ ä»£ç  class Solution { public: int threeSumClosest(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { sort(begin(nums), end(nums)); const int n = nums.size(); int ans, diff = INT_MAX; auto update = [\u0026amp;](int sum) { if (abs(sum - target) \u0026lt; diff) { diff = abs(sum - target); ans = sum; } }; for (int i = 0; i \u0026lt; n - 2; i++) { if (i \u0026amp;\u0026amp; nums[i] == nums[i-1]) continue; int l = i + 1, r = n - 1; while (l \u0026lt; r) { int s = nums[i] + nums[l] + nums[r]; if (s == target) return target; update(s); if (s \u0026lt; target) { while (l \u0026lt; r \u0026amp;\u0026amp; nums[l] == nums[l+1]) l++; l++; } else { while (l \u0026lt; r \u0026amp;\u0026amp; nums[r] == nums[r-1]) r--; r--; } } } return ans; } }; å››æ•°ä¹‹å’Œ é¢˜ç›®é“¾æ¥\næ€è·¯ åŒæŒ‡é’ˆ $O(n^3)$\nä»£ç  class Solution { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; fourSum(vector\u0026lt;int\u0026gt;\u0026amp; a, int target) { ans.clear(); sort(a.begin(), a.end()); const int n = a.size(); for (int i = 0; i \u0026lt; n; i++) { if (i \u0026amp;\u0026amp; a[i] == a[i-1]) continue; for (int j = i + 1; j \u0026lt; n; j++) { if (j \u0026gt; i + 1 \u0026amp;\u0026amp; a[j] == a[j-1]) continue; int l = j + 1, r = n - 1; while (l \u0026lt; r) { if (a[i] + a[j] + a[l] + a[r] \u0026lt; target) l++; else if (a[i] + a[j] + a[l] + a[r] \u0026gt; target) r--; else { ans.push_back({a[i], a[j], a[l], a[r]}); while (l \u0026lt; r \u0026amp;\u0026amp; a[l] == a[l+1]) l++; while (l \u0026lt; r \u0026amp;\u0026amp; a[r] == a[r-1]) r--; l++; r--; } } } } return ans; } }; ç»„åˆæ€»å’Œ é¢˜ç›®é“¾æ¥\næ¯ä¸ªæ•°å­—åœ¨æ¯ä¸ªç»„åˆä¸­å¯ä»¥ä½¿ç”¨æ— é™æ¬¡ã€‚\nä»£ç  class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; vector\u0026lt;int\u0026gt; tmp; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combinationSum(vector\u0026lt;int\u0026gt;\u0026amp; candidates, int target) { ans.clear(); tmp.clear(); dfs(candidates, target, 0); return ans; } void dfs(vector\u0026lt;int\u0026gt;\u0026amp; cand, int target, int idx) { if (idx == cand.size()) return; if (target == 0) { ans.emplace_back(tmp); return; } dfs(cand, target, idx+1); if (target-cand[idx] \u0026gt;= 0) { tmp.emplace_back(cand[idx]); dfs(cand, target-cand[idx], idx); tmp.pop_back(); // dfs(cand, target-cand[idx], idx+1); } } }; ç»„åˆæ€»å’Œ II é¢˜ç›®é“¾æ¥\næ¯ä¸ªæ•°å­—åœ¨æ¯ä¸ªç»„åˆä¸­åªèƒ½ä½¿ç”¨ä¸€æ¬¡ã€‚\nä»£ç  class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; vector\u0026lt;int\u0026gt; tmp; vector\u0026lt;int\u0026gt; candidates; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combinationSum2(vector\u0026lt;int\u0026gt; \u0026amp;candidates, int target) { ans.clear(); tmp.clear(); sort(candidates.begin(), candidates.end()); this-\u0026gt;candidates = candidates; dfs(0, target); return ans; } void dfs(int idx, int target) { if (target == 0) { ans.emplace_back(tmp); return; } for (int i = idx; i \u0026lt; candidates.size() \u0026amp;\u0026amp; (target \u0026gt;= candidates[i]); i++) { if (i \u0026gt; idx \u0026amp;\u0026amp; (candidates[i] == candidates[i-1])) continue; tmp.emplace_back(candidates[i]); dfs(i+1, target-candidates[i]); tmp.pop_back(); } } }; ç»„åˆæ€»å’Œ III é¢˜ç›®é“¾æ¥\næ€è·¯ äºŒè¿›åˆ¶çŠ¶æ€å‹ç¼©\nä»£ç  class Solution { public: vector\u0026lt;int\u0026gt; tmp; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combinationSum3(int k, int n) { for (int i = 0; i \u0026lt; (1\u0026lt;\u0026lt;9); i++) { if (check(i, k, n)) ans.emplace_back(tmp); } return ans; } bool check(int cur, int k, int n) { tmp.clear(); for (int i = 0; i \u0026lt; 9; i++) { if ((1\u0026lt;\u0026lt;i) \u0026amp; cur) tmp.emplace_back(i+1); } return (tmp.size() == k \u0026amp;\u0026amp; accumulate(tmp.begin(), tmp.end(), 0) == n); } }; ","permalink":"https://fffzlfk.github.io/posts/%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E9%97%AE%E9%A2%98/","summary":"the Sum of Subsequence","title":"å­æ•°ç»„å’Œé—®é¢˜"},{"content":"å¼•å…¥ å½“æˆ‘ä»¬æƒ³åœ¨ä¸€ä¸ªå‡½æ•°æ‰§è¡Œå‰åå¹²ç‚¹ä»€ä¹ˆäº‹æƒ…çš„æ—¶å€™ï¼Œå¯ä»¥è¿™ä¹ˆå†™ï¼š\ndef foo(): print(\u0026#39;foo()!!!\u0026#39;) def bar(): print(\u0026#39;Before\u0026#39;) foo() print(\u0026#39;After\u0026#39;) bar() è£…é¥°å™¨å®ç° ä½†è¿™æ ·çœ‹ç€æ€»æ˜¯å¾ˆåˆ«æ‰­ï¼Œæˆ‘ä»¬å¯ä»¥å†™æˆè¿™æ ·ï¼š\ndef foo(): print(\u0026#39;foo()!!!\u0026#39;) def bar(func): def inner(): print(f\u0026#39;Before {func.__name__}\u0026#39;) func() print(f\u0026#39;After {func.__name__}\u0026#39;) return inner bar(foo)() åœ¨Pythonä¸­functionæ˜¯ç¬¬ä¸€å…¬æ°‘ï¼Œæ‰€ä»¥å¯ä»¥å®ƒä½œä¸ºå‚æ•°\nè¿™æ ·æˆ‘ä»¬å°±å®ç°äº†ä¸€ä¸ªç®€å•çš„è£…é¥°å™¨ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°è¿™æ ·åœ¨è°ƒç”¨çš„æ—¶å€™æ¯”è¾ƒéº»çƒ¦ï¼ŒPythonè¿˜æä¾›äº†è¿™æ ·äº†ä¸€ä¸ªè¯­æ³•ç³–ï¼š\ndef bar(func): def inner(): print(f\u0026#39;In Bar Before {func.__name__}\u0026#39;) func() print(f\u0026#39;In Bar After {func.__name__}\u0026#39;) return inner @bar def foo(): print(\u0026#39;foo()!!!\u0026#39;) foo() é™¤æ­¤ä¹‹å¤–ï¼ŒPythonè£…é¥°å™¨å¯ä»¥æœ‰å¤šä¸ªï¼Œç›¸å½“ä¸ä¸€å±‚å±‚çš„åŒ…è£¹ï¼š\ndef bar(func): def inner(): print(f\u0026#39;In Bar Before {func.__name__}\u0026#39;) func() print(f\u0026#39;In Bar After {func.__name__}\u0026#39;) return inner def baz(func): def inner(): print(f\u0026#39;In Baz Before {func.__name__}\u0026#39;) func() print(f\u0026#39;In Baz After {func.__name__}\u0026#39;) return inner @bar @baz def foo(): print(\u0026#39;foo()!!!\u0026#39;) foo() ä¸Šè¿°ä»£ç çš„è¾“å‡ºä¸ºï¼š\nIn Bar Before inner\rIn Baz Before foo\rfoo()!!!\rIn Baz After foo\rIn Bar After inner ä¸€ä¸ªåº”ç”¨åœºæ™¯ æˆ‘ä»¬æœ‰ä¸€ä¸ªè¿™æ ·çš„å‡½æ•°ï¼š\nimport time def slow_method(): time.sleep(2) print(\u0026#39;Done!\u0026#39;) æˆ‘ä»¬æƒ³çŸ¥é“è¿™ä¸ªå‡½æ•°çš„è¿è¡Œæ—¶é—´ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨è£…é¥°å™¨æ¥å®ç°:\nimport time def timeit(func): def inner(): s = time.time() func() e = time.time() print(f\u0026#39;{func.__name__} Finished in {e - s}s.\u0026#39;) return inner @timeit def slow_method(): time.sleep(2) print(\u0026#39;Done!\u0026#39;) slow_method() è¿è¡Œç»“æœï¼š\nDone!\rslow_method Finished in 2.0159008502960205s. è¿™æ ·æˆ‘ä»¬å°±å®ç°äº†æˆ‘ä»¬çš„éœ€æ±‚ã€‚\nå½“è¢«è£…é¥°çš„å‡½æ•°æœ‰å‚æ•°æ—¶ï¼ŒåŒæ ·å¯ä»¥ï¼š\nimport time def timeit(func): def inner(*args): s = time.time() func(*args) e = time.time() print(f\u0026#39;{func.__name__} Finished in {e - s}s.\u0026#39;) return inner @timeit def slow_method(a, b): time.sleep(2) print(f\u0026#39;{a} + {b} = {a+b}\u0026#39;) print(\u0026#39;Done!\u0026#39;) slow_method(1, 2) è¿è¡Œç»“æœ\n1 + 2 = 3\rDone!\rslow_method Finished in 2.0069477558135986s. å·§ç”¨è£…é¥°å™¨æ¥å®ç°è®°å¿†åŒ–é€’å½’ é¦–å…ˆæˆ‘ä»¬æœ‰ä¸€ä¸ªæœ´ç´ çš„Fibonacciå‡½æ•°ï¼š\ndef fib(n): if n \u0026lt;= 1: return 1 return fib(n - 1) + fib(n - 2) å¾ˆæ˜æ˜¾æˆ‘ä»¬çŸ¥é“è¿™ä¸ªå‡½æ•°æ˜¯ååˆ†ä½æ•ˆçš„ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨è®°å¿†åŒ–é€’å½’æ¥ä¼˜åŒ–è¿™ä¸ªå‡½æ•°ã€‚\ncache = {} def fib(n): if n in cache: return cache[n] if n \u0026lt;= 1: return 1 cache[n] = fib(n - 1) + fib(n - 2) return cache[n] print(fib(333)) è¿™æ ·æˆ‘ä»¬å°±èƒ½ä½¿fibå‡½æ•°å¿«å¾ˆå¤šã€‚ä½†å®ç°ç¨å¾®æœ‰ç‚¹éº»çƒ¦ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨è£…é¥°å™¨æ¥ç®€åŒ–ä»£ç ï¼š\nclass MyCache(object): def __init__(self, func): self.func = func self.cache = {} def __call__(self, *args): if args not in self.cache: self.cache[args] = self.func(*args) return self.cache[args] @MyCache def fib(n): if n \u0026lt;= 1: return 1 return fib(n - 1) + fib(n - 2) print(fib(333)) è¿™æ ·æˆ‘ä»¬å°±éå¸¸ä¼˜é›…çš„å®ç°äº†fibå‡½æ•°ã€‚\nReference è£…é¥°å™¨ Decorator - Python Weekly EP3\n","permalink":"https://fffzlfk.github.io/posts/python%E8%A3%85%E9%A5%B0%E5%99%A8/","summary":"Python decorator","title":"Pythonè£…é¥°å™¨"},{"content":"Week 1 è´§ä»“é€‰å€ é¢˜ç›®é“¾æ¥\næ€è·¯ ç»å¯¹å€¼ä¸ç­‰å¼ï¼š$|a_1 - x| + |a_2 - x| + |a_3 - x| + \u0026hellip; + |a_n - x| \\ge |a_n-a_1| + |a_{n-1}-a_{2}|+\u0026hellip; $ ç»“è®ºï¼šå½“nä¸ºå¥‡æ•°ï¼Œxåº”åœ¨ä¸­ä½æ•°ï¼›å½“nä¸ºå¶æ•°æ—¶ï¼Œxåº”åœ¨ä¸­é—´ä¸¤ä¸ªæ•°ä¹‹é—´ã€‚\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 100005; int a[N]; int n; int main() { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; sort(a, a + n); int ans = 0; for (int i = 0; i \u0026lt; n; i++) ans += abs(a[i]-a[n/2]); cout \u0026lt;\u0026lt; ans; return 0; } æ•°å­—ä¸‰è§’å½¢-DP é¢˜ç›®é“¾æ¥\næ€è·¯ ä»ä¸‹åˆ°ä¸Šï¼Œ$ f[i][j] = max(f[i+1][j]+w[i][j], f[i+1][j+1]+w[i][j]) $\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 505; int f[N][N], w[N][N]; int n; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= i; j++) cin \u0026gt;\u0026gt; w[i][j]; for (int i = 1; i \u0026lt;= n; i++) f[n][i] = w[n][i]; for (int i = n-1; i \u0026gt;= 1; i--) for (int j = 1; j \u0026lt;= i; j++) f[i][j] = max(f[i+1][j]+w[i][j], f[i+1][j+1]+w[i][j]); cout \u0026lt;\u0026lt; f[1][1]; return 0; } ç®€åŒ–(ç­‰ä»·å˜æ¢)ç‰ˆä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 505; int f[N][N]; int n; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= i; j++) cin \u0026gt;\u0026gt; f[i][j]; for (int i = n-1; i \u0026gt;= 1; i--) for (int j = 1; j \u0026lt;= i; j++) f[i][j] += max(f[i+1][j], f[i+1][j+1]); cout \u0026lt;\u0026lt; f[1][1]; return 0; } Week 2 è›‡å½¢çŸ©é˜µ é¢˜ç›®é“¾æ¥\nä»£ç  #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 105; int n, m; const int dx[]{-1, 0, 1, 0}, dy[]{0, 1, 0, -1}; int q[N][N]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int x = 0, y = 0, d = 1; for (int i = 1; i \u0026lt;= n * m; i++) { q[x][y] = i; int a = x + dx[d], b = y + dy[d]; if (a \u0026lt; 0 || a \u0026gt;= n || b \u0026lt; 0 || b \u0026gt;= m || q[a][b]) { d = (d + 1) % 4; a = x + dx[d], b = y + dy[d]; } x = a, y = b; } for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) cout \u0026lt;\u0026lt; q[i][j] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; } return 0; } çº¢ä¸é»‘-Flood Fillç®—æ³• é¢˜ç›®é“¾æ¥\næ€è·¯ Flood-Fill\nBFSï¼ˆæœ€çŸ­è·ç¦»ï¼‰ while é˜Ÿåˆ—ä¸ºç©º\r{\rå–å‡ºé˜Ÿå¤´t\ræšä¸¾tçš„4ä¸ªé‚»æ ¼\rif æ ¼å­æ˜¯é™†åœ°å¹¶ä¸”æœªå¼€å‘\ræ ‡è®°ä¸ºå·²è¢«å¼€å‘\ræ’å…¥é˜Ÿåˆ—\r} DFSï¼ˆæ›´æ–¹ä¾¿ï¼‰ dfs(x, y)\r{\rå°†(x, y)æ ‡è®°ä¸ºå·²å¼€å‘\ræšä¸¾(x, y)çš„å››ä¸ªé‚»æ ¼\rif æ ¼å­æ˜¯é™†åœ°å¹¶ä¸”æœªå¼€å‘\rdfsè¯¥æ ¼å­\r} ä»£ç  BFS #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;algorithm\u0026gt; #define x first #define y second using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int N = 25; int n, m; char g[N][N]; int bfs(int sx, int sy) { queue\u0026lt;PII\u0026gt; Q; Q.push({sx, sy}); g[sx][sy] = \u0026#39;#\u0026#39;; int res = 0; const int dx[]{-1, 0, 1, 0}, dy[]{0, 1, 0, -1}; while (!Q.empty()) { auto t = Q.front(); Q.pop(); res++; for (int i = 0; i \u0026lt; 4; i++) { int nx = t.x + dx[i], ny = t.y + dy[i]; if (nx \u0026lt; 0 || nx \u0026gt;= n || ny \u0026lt; 0 || ny \u0026gt;= m || g[nx][ny] != \u0026#39;.\u0026#39;) continue; g[nx][ny] = \u0026#39;#\u0026#39;; Q.emplace(nx, ny); } } return res; } int main() { while (cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n , n || m) { for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; g[i]; int x, y; for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; m; j++) if (g[i][j] == \u0026#39;@\u0026#39;) { x = i; y = j; } cout \u0026lt;\u0026lt; bfs(x, y) \u0026lt;\u0026lt; endl; }\treturn 0; } DFS #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 25; char g[N][N]; int n, m; const int dx[]{-1, 0, 1, 0}, dy[]{0, 1, 0, -1}; int dfs(int x, int y) { g[x][y] = \u0026#39;#\u0026#39;; int res = 1; for (int i = 0; i \u0026lt; 4; i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx \u0026lt; 0 || nx \u0026gt;= n || ny \u0026lt; 0 || ny \u0026gt;= m || g[nx][ny] != \u0026#39;.\u0026#39;) continue; res += dfs(nx, ny); } return res; } int main() { while (cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n, n || m) { int x, y; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; g[i]; for (int j = 0; j \u0026lt; m; j++) if (g[i][j] == \u0026#39;@\u0026#39;) { x = i; y = j; } } cout \u0026lt;\u0026lt; dfs(x, y) \u0026lt;\u0026lt; endl; } return 0; } å›æ–‡å¹³æ–¹ é¢˜ç›®é“¾æ¥\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; char get(int n) { return n \u0026lt;= 9 ? \u0026#39;0\u0026#39; + n : \u0026#39;A\u0026#39; - 10 + n; } string base(int n, int b) { string s = \u0026#34;\u0026#34;; while (n) { s += get(n % b); n /= b; } reverse(s.begin(), s.end()); return s; } bool check(const string \u0026amp;s) { for (int i = 0, j = s.length() - 1; i \u0026lt; s.length(); i++, j--) if (s[i] != s[j]) return false; return true; } int main() { int b; cin \u0026gt;\u0026gt; b; for (int i = 1; i \u0026lt;= 300; i++) { auto t = base(i * i, b); if (check(t)) { cout \u0026lt;\u0026lt; base(i, b) \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; t \u0026lt;\u0026lt; endl; } } return 0; } å‰ªç»³å­-æµ®ç‚¹æ•°äºŒåˆ† é¢˜ç›®é“¾æ¥\næ€è·¯ äºŒåˆ† æœ€ä¼˜åŒ–-\u0026gt;åˆ¤å®šé—®é¢˜\næƒ…å†µ1ï¼šå¯ä»¥[mid, r] æƒ…å†µ2ï¼šä¸å¯ä»¥[l, mid) ä¿ç•™kä½å°æ•°ï¼šr-l \u0026lt; 1e-4\nä»£ç  #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100005; int n, m; int w[N]; bool check(double mid) { int cnt = 0; for (int i = 0; i \u0026lt; n; i++) cnt += w[i] / mid; return cnt \u0026gt;= m; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; w[i]; double l = 0.0, r = 1e9; for (int i = 0; i \u0026lt; 100; i++) { // while (r-l \u0026gt; 1e-4) double mid = (l + r) / 2; if (check(mid)) l = mid; else r = mid; } printf(\u0026#34;%.2f\\n\u0026#34;, l); return 0; } æ‰©å±•é¢˜ é¢˜ç›®é“¾æ¥\n#include \u0026lt;iostream\u0026gt; using namespace std; double n; bool check(double mid) { return mid*mid*mid \u0026lt; n; } int main() { cin \u0026gt;\u0026gt; n; double l = -22.0, r = 22.0; while (r - l \u0026gt; 1e-8) { double mid = (l+r) / 2; if (check(mid)) l = mid; else r = mid; } printf(\u0026#34;%.6f\\n\u0026#34;, l); return 0; } åˆ†å·§å…‹åŠ›-æ•´æ•°äºŒåˆ† é¢˜ç›®é“¾æ¥\næ€è·¯ $ \\sum_{i=0}^{n-1} \\lfloor \\frac {h_i} {mid} \\rfloor \\times \\lfloor \\frac{w_i}{mid} \\rfloor\\ge k $\næˆç«‹ï¼š$[mid, r], l = mid$ ä¸æˆç«‹ï¼š$[l, mid-1], r = mid-1 $ ä»£ç  #include \u0026lt;iostream\u0026gt; using namespace std; using ll = long long; const int N = 1e5+5; int h[N], w[N]; int n, k; bool check(int mid) { ll s = 0; for (int i = 0; i \u0026lt; n; i++) { s += 1LL * (h[i]/mid) * (w[i]/mid); if (s \u0026gt;= k) return true; } return false; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; h[i] \u0026gt;\u0026gt; w[i]; int l = 0, r = 1e5; while (l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (check(mid)) l = mid; else r = mid-1; } cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; endl; return 0; } äºŒåˆ†æ¨¡æ¿ int bsearch_1(int l, int r) { while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; else l = mid+1; } return l } int bsearch_2(int l, int r) { while (l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (check(mid)) l = mid; else r = mid-1; } } æ‰©å±•é¢˜ æ•°çš„èŒƒå›´\né¢˜ç›®é“¾æ¥\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int n, q; int a[100010]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; int k; while (q--) { cin \u0026gt;\u0026gt; k; int l = lower_bound(a, a+n, k)-a; int r = upper_bound(a, a+n, k)-a; printf(\u0026#34;%d \u0026#34;, a[l]==k? l : -1); printf(\u0026#34;%d\\n\u0026#34;, a[r-1]==k? r-1 : -1); } return 0; } æ—‹è½¬æ•°ç»„çš„æœ€å°æ•°å­—-ä¸å…·æœ‰å•è°ƒæ€§ï¼Œä½†å…·æœ‰äºŒæ®µæ€§\né¢˜ç›®é“¾æ¥\nclass Solution { public: int findMin(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if (nums.empty()) return -1; int n = nums.size(); while (n \u0026gt; 1 \u0026amp;\u0026amp; nums[0] == nums[n-1]) n--; if (nums[0] \u0026lt;= nums[n-1]) return nums[0]; int l = 0, r = n-1; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (nums[0] \u0026gt; nums[mid]) r = mid; else l = mid+1; } return nums[r]; } }; æ ¡é—¨å¤–çš„æ ‘-åŒºé—´åˆå¹¶ é¢˜ç›®é“¾æ¥\næ€è·¯ å…ˆæ±‚å‡ºæ‰€æœ‰ç§»åŠ¨æ ‘æœ¨çš„æ“ä½œçš„åŒºé—´çš„å¹¶é›†ï¼Œé‚£ä¹ˆé©¬è·¯ä¸Šå‰©ä½™éƒ¨åˆ†å³ä¸ºæœ€ç»ˆå‰©ä¸‹æ ‘æœ¨çš„éƒ¨åˆ†ã€‚\nåŒºé—´åˆå¹¶ç®—æ³•\nå°†æ‰€æœ‰åŒºé—´æŒ‰å·¦ç«¯ç‚¹ä»å°åˆ°å¤§æ’åº ä»å·¦åˆ°å³éå†æ¯ä¸ªåŒºé—´[L, R] $ l_i \\le R $ï¼Œ $R = max(R, r_i) $ $ l_i \u0026gt; R$, åˆ™å°†[L, R] å­˜ä¸‹æ¥ï¼ŒL, R\u0026lt;- $ l_i, r_i $ ä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; #define x first #define y second const int N = 105; pair\u0026lt;int, int\u0026gt; seg[N]; int l, m; int main() { cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; m; i++) cin \u0026gt;\u0026gt; seg[i].x \u0026gt;\u0026gt; seg[i].y; sort(seg, seg+m); int res = l + 1; int L = seg[0].x, R = seg[0].y; for (int i = 1; i \u0026lt; m; i++) if (seg[i].x \u0026lt;= R) R = max(R, seg[i].y); else { res -= R - L + 1; L = seg[i].x; R = seg[i].y; } res -= R - L + 1; cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } æ‰©å±•é¢˜-æŒ¤ç‰›å¥¶ é¢˜ç›®é“¾æ¥\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; #define x first #define y second const int N = 5005; pair\u0026lt;int, int\u0026gt; seg[N]; int n; int main() { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; seg[i].x \u0026gt;\u0026gt; seg[i].y; sort(seg, seg+n); int L = seg[0].x, R = seg[0].y; int a = 0, b = 0; for (int i = 1; i \u0026lt; n; i++) if (seg[i].x \u0026lt;= R) R = max(R, seg[i].y); else { b = max(b, seg[i].x-R); a = max(a, R-L); L = seg[i].x; R = seg[i].y; } a = max(a, R-L); cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; return 0; } å¥–å­¦é‡‘ é¢˜ç›®é“¾æ¥\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; int cnt = 0; struct node { int id; int grades[3]; int get_sum() const { int s = 0; for (int i = 0; i \u0026lt; 3; i++) s += grades[i]; return s; } friend istream\u0026amp; operator\u0026gt;\u0026gt;(istream\u0026amp; in, node \u0026amp;a) { a.id = ++cnt; for (int i = 0; i \u0026lt; 3; i++) in \u0026gt;\u0026gt; a.grades[i]; return in; } friend bool operator\u0026lt;(const node \u0026amp;a, const node \u0026amp;b) { int sa = a.get_sum(), sb = b.get_sum(); if (sa != sb) return sa \u0026lt; sb; else if (a.grades[0] != b.grades[0]) return a.grades[0] \u0026lt; b.grades[0]; else return a.id \u0026gt; b.id; } }; int n; priority_queue\u0026lt;node\u0026gt; Q; int main() { cin \u0026gt;\u0026gt; n; node tmp; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; tmp; Q.push(tmp); } for (int i = 0; i \u0026lt; 5; i++) { auto t = Q.top(); Q.pop(); cout \u0026lt;\u0026lt; t.id \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; t.get_sum() \u0026lt;\u0026lt; endl; } return 0; } Week 3 ç¿»ç¡¬å¸-é€’æ¨ é¢˜ç›®é“¾æ¥\næ€è·¯ æšä¸¾é€’æ¨ï¼šæ¯ä¸€ä¸ªæ“ä½œæ˜¯å”¯ä¸€ç¡®å®šçš„\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; string a, b; void turn(int i) { a[i] == \u0026#39;*\u0026#39; ? a[i] = \u0026#39;o\u0026#39; : a[i] = \u0026#39;*\u0026#39;; } int main() { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; int res = 0; for (int i = 0; i \u0026lt; a.length()-1; i++) if (a[i] != b[i]) { turn(i); turn(i+1); ++res; } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } æ‰©å±•é¢˜-è´¹è§£çš„å¼€å…³ æ€è·¯ æšä¸¾ç¬¬ä¸€è¡Œçš„ç‚¹å‡»æ–¹æ³•ï¼Œå…±32ç§ï¼Œå®Œæˆç¬¬ä¸€è¡Œçš„ç‚¹å‡»åï¼Œå›ºå®šç¬¬ä¸€è¡Œï¼Œ ä»ç¬¬ä¸€è¡Œå¼€å§‹é€’æ¨ï¼Œè‹¥è¾¾åˆ°ç¬¬nè¡Œä¸å…¨ä¸º0ï¼Œè¯´æ˜è¿™ç§ç‚¹å‡»æ–¹å¼ä¸åˆæ³•ã€‚ åœ¨æ‰€æœ‰åˆæ³•çš„ç‚¹å‡»æ–¹å¼ä¸­å–ç‚¹å‡»æ¬¡æ•°æœ€å°‘çš„å°±æ˜¯ç­”æ¡ˆã€‚ å¯¹ç¬¬ä¸€è¡Œçš„32æ¬¡æšä¸¾æ¶µç›–äº†è¯¥é—®é¢˜çš„æ•´ä¸ªçŠ¶æ€ç©ºé—´ï¼Œå› æ­¤è¯¥åšæ³•æ˜¯æ­£ç¡®çš„ æ—¶é—´å¤æ‚åº¦ï¼š32*20*5*500 = ä¸€ç™¾å…­åä¸‡ å¯¹ç¬¬ä¸€è¡Œæ“ä½œæœ‰32ç§å¯èƒ½ * å¯¹å‰å››è¡Œæœ‰20ç§æ“ä½œå¯èƒ½ * æ¯ä¸€æ¬¡æ“ä½œéƒ½è¦æ”¹å˜5ä¸ªç¯çš„çŠ¶æ€ * æœ€å¤šè¯»å…¥çš„æ—¶å€™å¯èƒ½æœ‰500æ¬¡lightçŸ©é˜µ æœ€å…³é”®çš„ä¸¤ä¸ªæ€§è´¨ æ¯ä¸€ä¸ªä½ç½®æœ€å¤šåªä¼šè¢«ç‚¹å‡»ä¸€æ¬¡ å¦‚æœå›ºå®šäº†ç¬¬ä¸€è¡Œï¼Œé‚£ä¹ˆæ»¡è¶³é¢˜æ„çš„ç‚¹å‡»æ–¹æ¡ˆæœ€å¤šåªæœ‰ä¸€ç§ ä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;climits\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; char s[5][5]; void turn(int i, int j) { const int dx[]{0, -1, 0, 1, 0}, dy[]{0, 0, 1, 0, -1}; for (int k = 0; k \u0026lt; 5; k++) { int nx = i + dx[k], ny = j + dy[k]; if (nx \u0026lt; 0 || nx \u0026gt;= 5 || ny \u0026lt; 0 || ny \u0026gt;= 5) continue; s[nx][ny] ^= 1; } } int work() { int res = INT_MAX; for (int k = 0; k \u0026lt; 1 \u0026lt;\u0026lt; 5; k++) { char back[5][5]; memcpy(back, s, sizeof s); int cnt = 0; for (int j = 0; j \u0026lt; 5; j++) { if ((k \u0026gt;\u0026gt; j) \u0026amp; 1) { turn(0, j); ++cnt; } } for (int i = 0; i \u0026lt; 4; i++) for (int j = 0; j \u0026lt; 5; j++) if (s[i][j] == \u0026#39;0\u0026#39;) { turn(i+1, j); ++cnt; } bool ok = true; for (int j = 0; j \u0026lt; 5; j++) if (s[4][j] == \u0026#39;0\u0026#39;) ok = false; if (ok) res = min(res, cnt); memcpy(s, back, sizeof back); } return res \u0026lt;= 6 ? res : -1; } int main() { int n; cin \u0026gt;\u0026gt; n; while (n--) { for (int i = 0; i \u0026lt; 5; i++) cin \u0026gt;\u0026gt; s[i]; cout \u0026lt;\u0026lt; work() \u0026lt;\u0026lt; endl; } return 0; } æ‰¾ç¡¬å¸ é¢˜ç›®é“¾æ¥\nå“ˆå¸Œè¡¨åšæ³•$O(n)$ æ€è·¯ å¯¹äºå½“å‰çš„å…ƒç´ tï¼ŒæŸ¥çœ‹ä¹‹å‰é›†åˆä¸­æ˜¯å¦å­˜åœ¨m-tï¼Œè‹¥å­˜åœ¨åˆ™æ›´æ–°ç­”æ¡ˆï¼Œå¦åˆ™æ·»åŠ åˆ°é›†åˆä¸­ã€‚\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;climits\u0026gt; #include \u0026lt;unordered_set\u0026gt; using namespace std; int n, m; unordered_set\u0026lt;int\u0026gt; S; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int v1 = INT_MAX, v2; int a, b; while (n--) { cin \u0026gt;\u0026gt; a; b = m - a; if (S.count(b)) { if (a \u0026gt; b) swap(a, b); if (v1 \u0026gt; a) { v1 = a; v2 = b; } } else S.insert(a); } printf(v1 == INT_MAX ? \u0026#34;No Solution\u0026#34; : \u0026#34;%d %d\\n\u0026#34;, v1, v2); return 0; } åŒæŒ‡é’ˆåšæ³•$O(nlogn)$ æ€è·¯ Note\nåŒæŒ‡é’ˆç®—æ³•ï¼šå¦‚æœi++å’Œj--å•è°ƒæ€§ç›¸åå°±èƒ½ç”¨åŒæŒ‡é’ˆåšæ³•ã€‚\n$a[i]+a[j] \\le m \\ and \\ j æœ€å¤§$\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int n, m; const int N = 1e5+5; int a[N]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; sort(a, a+n); for (int i = 0, j = n-1; i \u0026lt; n; i++) { while (i \u0026lt; j \u0026amp;\u0026amp; a[i] + a[j] \u0026gt; m) j--; if (i \u0026lt; j \u0026amp;\u0026amp; a[i]+a[j] == m) { cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; a[j] \u0026lt;\u0026lt; endl; return 0; } } cout \u0026lt;\u0026lt; \u0026#34;No Solution\u0026#34;; return 0; } åä¸‰å·æ˜ŸæœŸäº” é¢˜ç›®é“¾æ¥\næ€è·¯ æšä¸¾æ¯ä¸ªæœˆç¬¬ä¸€å¤©è·ç¦»1900-1-1è¿‡äº†å¤šå°‘å¤©days æ˜ŸæœŸï¼š$(days+12)\\ mod \\ 7 $ ä»£ç  #include \u0026lt;iostream\u0026gt; using namespace std; const int month[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; int n; int weekdays[7]; int main() { cin \u0026gt;\u0026gt; n; int days = 0; for (int year = 1900; year \u0026lt; 1900+n; year++) { for (int i = 1; i \u0026lt;= 12; i++) { weekdays[(days + 12) % 7]++; days += month[i]; if (i == 2 \u0026amp;\u0026amp; (year % 4 == 0 \u0026amp;\u0026amp; year % 100 != 0 || year % 400 == 0)) days++; } } for (int i = 5, j = 0; j \u0026lt; 7; i = (i+1) % 7, j++) cout \u0026lt;\u0026lt; weekdays[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; return 0; } å¹³æ–¹çŸ©é˜µ II é¢˜ç›®é“¾æ¥\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int n; int main() { while (cin \u0026gt;\u0026gt; n, n) { for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) cout \u0026lt;\u0026lt; abs(j-i) + 1 \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } cout \u0026lt;\u0026lt; endl; } return 0; } Longest-increasing-subsequence é¢˜ç›®é“¾æ¥\næ€è·¯ dp[i]: é•¿åº¦ä¸ºiçš„LISçš„æœ€åä¸€ä¸ªå…ƒç´ çš„æœ€å°å€¼ eg:[0,3,1,6,2,2,7] for each x: 0, dp = [0] 3, dp = [0, 3] 1, dp = [0, 1] 6, dp = [0, 1, 6] 2, dp = [0, 1, 2] 2, dp = [0, 1, 2] 7, dp = [0, 1, 2, 7] ans = len(dp) ä»£ç  class Solution: def lengthOfLIS(self, nums: List[int]) -\u0026gt; int: dp = [] for x in nums: i = bisect_left(dp, x) if i == len(dp): dp.append(x) else: dp[i] = x return len(dp) æ£‹ç›˜æŒ‘æˆ˜-å…«çš‡åé—®é¢˜ é¢˜ç›®é“¾æ¥\næ€è·¯ å¦‚ä½•åˆ¤æ–­æŸäº›ä½ç½®èƒ½ä¸èƒ½å¡«ï¼šå¯¹è§’çº¿ç”¨æˆªè·ç¼–å· dg: y=x+b, b = y-x+n udg: y=-x+b, b = y+x ä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 15; int path[N], col[N], dg[2*N], udg[2*N]; int n, ans; void dfs(int x) { if (x \u0026gt; n) { ans++; if (ans \u0026lt;= 3) { for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; path[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } for (int y = 1; y \u0026lt;= n; y++) { if (!col[y] \u0026amp;\u0026amp; !dg[y-x+n] \u0026amp;\u0026amp; !udg[y+x]) { path[x] = y; col[y] = dg[y-x+n] = udg[y+x] = true; dfs(x+1); col[y] = dg[y-x+n] = udg[y+x] = false; // path[x] = 0; } } } int main() { cin \u0026gt;\u0026gt; n; dfs(1); cout \u0026lt;\u0026lt; ans; return 0; } æ‰©å±•é¢˜-è§£æ•°ç‹¬ é¢˜ç›®é“¾æ¥\nclass Solution { public: vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; P; bool check(const vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, int r, int c, char n) { for (int i = 0; i \u0026lt; 9; i++) if (board[r][i] == n || board[i][c] == n) return false; r = r / 3 * 3; c = c / 3 * 3; for (int i = r; i \u0026lt; r + 3; i++) for (int j = c; j \u0026lt; c + 3; j++) if (board[i][j] == n) return false; return true; } bool dfs(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, int idx) { if (idx == (int)P.size()) return true; int r = P[idx].first, c = P[idx].second; for (int i = 1; i \u0026lt;= 9; i++) if (check(board, r, c, i+\u0026#39;0\u0026#39;)) { board[r][c] = i+\u0026#39;0\u0026#39;; if (dfs(board, idx+1)) return true; board[r][c] = \u0026#39;.\u0026#39;; } return false; } void solveSudoku(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board) { for (int i = 0; i \u0026lt; 9; i++) for (int j = 0; j \u0026lt; 9; j++) if (board[i][j] == \u0026#39;.\u0026#39;) P.emplace_back(i, j); dfs(board, 0); } }; è´§å¸ç³»ç»Ÿ-å®Œå…¨èƒŒåŒ… é¢˜ç›®é“¾æ¥\næ€è·¯ ä»£ç  #include \u0026lt;iostream\u0026gt; using namespace std; using ll = long long; const int N = 30, M = 10005; ll f[N][M]; int n, m; int w[N]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; w[i]; f[0][0] = 1; for (int i = 1; i \u0026lt;= n; i++) for (int j = 0; j \u0026lt;= m; j++) for (int k = 0; k * w[i] \u0026lt;= j; k++) f[i][j] += f[i-1][j-k*w[i]]; cout \u0026lt;\u0026lt; f[n][m] \u0026lt;\u0026lt; endl; return 0; } æ—¶é—´ä¼˜åŒ– $ f[i][j] = f[i-1][j]+f[i-1][j-w[i]]+f[i-1][j-2w[i]]+\u0026hellip;+f[i-1][j-kw[i]] $ $ f[i][j-v] = f[i-1][j-w[i]]+f[i-1][j-2w[i]]+\u0026hellip;+f[i-1][j-kw[i]] $ ç”±1-2å¾—ï¼š$ f[i][j] = f[i-1][j]+f[i][j-v] $ #include \u0026lt;iostream\u0026gt; using namespace std; using ll = long long; const int N = 30, M = 10005; ll f[N][M]; int n, m; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; f[0][0] = 1; for (int i = 1; i \u0026lt;= n; i++) { int v; cin \u0026gt;\u0026gt; v; for (int j = 0; j \u0026lt;= m; j++) { f[i][j] = f[i-1][j]; if (j \u0026gt;= v) f[i][j] += f[i][j-v]; } } cout \u0026lt;\u0026lt; f[n][m] \u0026lt;\u0026lt; endl; return 0; } ç©ºé—´ä¼˜åŒ– #include \u0026lt;iostream\u0026gt; using namespace std; using ll = long long; const int N = 30, M = 10005; ll f[M]; int n, m; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; f[0] = 1; for (int i = 1; i \u0026lt;= n; i++) { int v; cin \u0026gt;\u0026gt; v; for (int j = v; j \u0026lt;= m; j++) { f[j] += f[j-v]; // f[i][j] = f[i-1][j] + f[i][j-v] } } cout \u0026lt;\u0026lt; f[m] \u0026lt;\u0026lt; endl; return 0; } é˜¶ä¹˜ é¢˜ç›®é“¾æ¥\næ€è·¯ $ n! = 2^{\\alpha}*5^{\\beta}*x $ $ ans = \\frac{n!}{10^k}\\ mod\\ 10=$ æˆ‘ä»¬è¿›è¡Œè§‚å¯Ÿï¼Œå› ä¸º0åªå¯èƒ½ç”±2çš„å€æ•°å’Œ5çš„å€æ•°ç›¸ä¹˜å¾—åˆ°ï¼Œæ‰€ä»¥åœ¨è¿›è¡Œä¹˜æ³•çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬å°†2å’Œ5çš„å€æ•°ç»™æ¸…ç†æ‰ï¼Œè¿™æ ·å°±ä¿è¯äº†ä¸ä¼šå‡ºç°0ï¼Œç„¶åæˆ‘ä»¬æ§åˆ¶å…¶èŒƒå›´ï¼Œæ¯æ¬¡ç›¸ä¹˜å–å…¶ä¸ªä½ï¼Œå› ä¸ºä¸ªä½è‚¯å®šæ˜¯éé›¶å…ƒç´ ï¼Œåä½ä»¥åçš„æ•°å­—å®Œå…¨æ²¡æœ‰å¿…è¦ä¿ç•™ä¸‹æ¥ï¼Œæœ€åï¼Œæˆ‘ä»¬å°†å¤šå¤„ç†çš„2æˆ–è€…5é‡æ–°ä¹˜å›å»å†å–ä½™å³å¯\nä»£ç  #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; int d2 = 0, d5 = 0; int ans = 1; for (int i = 2; i \u0026lt;= n; i++) { int x = i; while (x % 2 == 0) x /= 2, d2++; while (x % 5 == 0) x /= 5, d5++; ans = ans * x % 10; } for (int i = 0; i \u0026lt; d2-d5; i++) ans = ans * 2 % 10; cout \u0026lt;\u0026lt; ans; return 0; } Week 4 æ»‘é›ªåœºè®¾è®¡-æšä¸¾ æ€è·¯ æœ€ä¼˜è§£ä¸­ï¼Œæ‰€æœ‰çš„é«˜åº¦éƒ½åœ¨$[0, 100]$ä¹‹é—´ åªéœ€æšä¸¾æ‰€æœ‰å¯èƒ½çš„åŒºé—´ ä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;climits\u0026gt; using namespace std; const int N = 1005; int a[N]; int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; int ans = INT_MAX; for (int l = 0; l \u0026lt;= 100-17; l++) { int r = l+17, cost = 0; for (int i = 0; i \u0026lt; n; i++) if (a[i] \u0026lt; l) cost += (l-a[i])*(l-a[i]); else if (a[i] \u0026gt; r) cost += (a[i]-r)*(a[i]-r); ans = min(ans, cost); } cout \u0026lt;\u0026lt; ans; return 0; } æ•´æ•°é›†åˆåˆ’åˆ†-è´ªå¿ƒ é¢˜ç›®é“¾æ¥\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int a[100005], res; int main() { #ifndef ONLINE_JUDGE freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; } sort(a, a + n); for (int i = 0; i \u0026lt; n; i++) { if (i \u0026gt;= n \u0026gt;\u0026gt; 1) res += a[i]; else res -= a[i]; } cout \u0026lt;\u0026lt; n % 2 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; res; return 0; } æ‰©å±•é¢˜-åŒå‘æœç´¢ é¢˜ç›®é“¾æ¥\næ€è·¯\nå…ˆæœç´¢å‰N/2ä¸ªç‰©å“å¯ä»¥å‡‘å‡ºæ¥çš„æ‰€æœ‰é‡é‡ï¼Œå­˜åˆ°æ•°ç»„ä¸­å» å¯¹æ‰€æœ‰é‡é‡æ’åºï¼Œåˆ¤é‡ åœ¨æœç´¢åä¸€åŠç‰©å“å¯ä»¥å‡‘å‡ºæ¥çš„æ‰€æœ‰é‡é‡yï¼Œåœ¨å‰ä¸€åŠç‰©å“æœç´¢å‡ºæ¥çš„é‡é‡äºŒåˆ†å‡ºä¸€ä¸ªyï¼Œä½¿å¾—x+y\u0026lt;=w, x+yæœ€å¤§ ä¼˜åŒ–\nä»å¤§åˆ°å°æšä¸¾æ‰€æœ‰é‡é‡ï¼Œä½¿å¾—æœç´¢åˆ°çš„å’Œæ›´å¿«è¾¾åˆ°ç›®æ ‡ å‡è¡¡ä¸¤æ¬¡æœç´¢æ—¶é—´ #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; using ll = long long; const int N = 46; int n, w, g[N], k, cnt, wgt[1 \u0026lt;\u0026lt; (23 + 2)]; void dfs_1(int x, int s) { if (x == k) { wgt[cnt++] = s; return; } if (s * 1ll + g[x] \u0026lt;= w) dfs_1(x + 1, s + g[x]); dfs_1(x + 1, s); } int ans; void dfs_2(int x, int s) { if (x == n) { int l = 0, r = cnt - 1; while (l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (s * 1ll + wgt[mid] \u0026lt;= w) l = mid; else r = mid - 1; } if (s * 1ll + wgt[l] \u0026lt;= w) ans = max(ans, s + wgt[l]); return; } if (s * 1ll + g[x] \u0026lt;= w) dfs_2(x + 1, s + g[x]); dfs_2(x + 1, s); } int main() { #ifndef ONLINE_JUDGE freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;w, \u0026amp;n); for (int i = 0; i \u0026lt; n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;g[i]); sort(g, g + n, greater\u0026lt;int\u0026gt;()); k = n / 2 + 2; dfs_1(0, 0); sort(wgt, wgt + cnt); cnt = unique(wgt, wgt + cnt) - wgt; dfs_2(k, 0); cout \u0026lt;\u0026lt; ans; return 0; } åˆå”±é˜Ÿå½¢-LIS é¢˜ç›®é“¾æ¥\næ€è·¯ f[i]: ä»å‰å¾€åï¼Œä»¥a[i]ç»“å°¾çš„æœ€é•¿ä¸Šå‡å­åºåˆ—çš„é•¿åº¦ g[i]: ä»åå¾€å‰ï¼Œä»¥a[i]ç»“å°¾çš„æœ€é•¿ä¸Šå‡å­åºåˆ—çš„é•¿åº¦ $ ans = n - max(f[i]+g[i]) + 1$ ä»£ç  $ n^2 $\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 105; int n, a[N]; int f[N], g[N]; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; i++) { f[i] = 1; for (int j = 1; j \u0026lt; i; j++) if (a[i] \u0026gt; a[j]) f[i] = max(f[i], f[j]+1); } for (int i = n; i \u0026gt;= 1; i--) { g[i] = 1; for (int j = n; j \u0026gt; i; j--) if (a[i] \u0026gt; a[j]) g[i] = max(g[i], g[j]+1); } int ans = 0; for (int k = 1; k \u0026lt;= n; k++) ans = max(ans, f[k] + g[k]); cout \u0026lt;\u0026lt; n - ans + 1; return 0; $ nlogn $\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 105; int f[N], g[N], a[N], n; int len1[N], len2[N]; int main() { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; int cnt = 0; for (int i = 0; i \u0026lt; n; i++) { auto it = lower_bound(f, f+cnt, a[i])-f; if (it == cnt) f[cnt++] = a[i]; else f[it] = a[i]; len1[i] = cnt; } cnt = 0; for (int i = n-1; i \u0026gt;= 0; i--) { auto it = lower_bound(g, g+cnt, a[i])-g; if (it == cnt) g[cnt++] = a[i]; else g[it] = a[i]; len2[i] = cnt; } int ans = 0; for (int i = 0; i \u0026lt; n; i++) ans = max(ans, len1[i]+len2[i]); cout \u0026lt;\u0026lt; n - ans + 1; return 0; } ç«æ˜Ÿäºº-æ’åˆ— æ€è·¯ å®ç°next_permutation()\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 10005; int n, m, a[N]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; while (m--) { int k = n-1; while (a[k-1] \u0026gt; a[k]) k--; k--; int t = k; while (t \u0026lt; n-1 \u0026amp;\u0026amp; a[t+1] \u0026gt; a[k]) t++; swap(a[t], a[k]); reverse(a+k+1, a+n); } for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; return 0; } æ˜Ÿç©ºä¹‹å¤œ-Flood-fill æ€è·¯ åˆ¤æ–­å½¢çŠ¶æ˜¯å¦ç›¸ä¼¼ å“ˆå¸Œï¼šä¸¤ä¸¤ä¹‹é—´çš„è·ç¦»ä¹‹å’Œ ä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; using P = pair\u0026lt;int, int\u0026gt;; #define x first #define y second const int N = 105; P c[N*N]; int cnt; char g[N][N]; int n, m; inline double get_dist(P a, P b) { return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)); } double get_hash() { double s = 0; for (int i = 0; i \u0026lt; cnt; i++) for (int j = i+1; j \u0026lt; cnt; j++) s += get_dist(c[i], c[j]); return s; } char get_id(double d) { static double hash[30]; static int idx = 0; for (int i = 0; i \u0026lt; idx; i++) { if (fabs(hash[i] - d) \u0026lt; 1e-8) return \u0026#39;a\u0026#39; + i; } hash[idx++] = d; return \u0026#39;a\u0026#39; + idx - 1; } void dfs(int i, int j) { g[i][j] = \u0026#39;0\u0026#39;; c[cnt++] = {i, j}; for (int x = i-1; x \u0026lt;= i+1; x++) for (int y = j-1; y \u0026lt;= j+1; y++) { if (x \u0026lt; 0 || x \u0026gt;= n || y \u0026lt; 0 || y \u0026gt;= m || g[x][y] == \u0026#39;0\u0026#39;) continue; dfs(x, y); } } int main() { cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; g[i]; for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; m; j++) { if (g[i][j] == \u0026#39;1\u0026#39;) { cnt = 0; dfs(i, j); auto d = get_hash(); auto id = get_id(d); for (int k = 0; k \u0026lt; cnt; k++) g[c[k].x][c[k].y] = id; } } for (int i = 0; i \u0026lt; n; i++) cout \u0026lt;\u0026lt; g[i] \u0026lt;\u0026lt; endl; return 0; } æ‘˜èŠ±ç”Ÿ-DP é¢˜ç›®é“¾æ¥\næ€è·¯ çŠ¶æ€è¡¨ç¤º é›†åˆï¼šå®šä¹‰f[i][j]ä¸ºä»(1, 1)åˆ°è¾¾(i, j)çš„æ‰€æœ‰æ–¹æ¡ˆ å±æ€§ï¼šæœ€å¤§å€¼ çŠ¶æ€è½¬ç§» (i, j)ä»(i-1, j)å³ä¸Šæ–¹è¿‡æ¥ (i, j)ä»(i, j-1)å³å·¦æ–¹è¿‡æ¥ ç©ºé—´å‹ç¼© f[i][j]åªéœ€è¦ç”¨åˆ°è¿™ä¸€å±‚å’Œä¸Šä¸€å±‚çš„få…ƒç´ ï¼Œæ‰€ä»¥å¯ä»¥å‹ç¼©æˆæ»šåŠ¨æ•°ç»„ã€‚åœ¨æ­¤ä¹‹ä¸Šï¼Œè¿˜å¯ä»¥ç›´æ¥å‹ç¼©æˆä¸€ç»´æ•°ç»„ã€‚ ä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 105; int f[N]; int n, m, t; int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) { cin \u0026gt;\u0026gt; t; f[j] = max(f[j], f[j-1]) + t; } cout \u0026lt;\u0026lt; f[m] \u0026lt;\u0026lt; endl; memset(f, 0, sizeof f); } } æœ€å¤§çš„å’Œ-æœ€å¤§å­çŸ©å½¢ é¢˜ç›®é“¾æ¥\næ€è·¯ å‰ç¼€å’Œæ•°ç»„A[i][j]è¡¨ç¤º $ \\sum_{i=1}^{n}{a[i][j]} $ æšä¸¾çŸ©å½¢ä¸Šä¸‹è¾¹ç•Œ æ±‚æœ€å¤§è¿ç»­å­åºåˆ—å’Œ ä»£ç  package main import ( \u0026#34;fmt\u0026#34; ) var M [201][201]int var n int func main() { fmt.Scanf(\u0026#34;%d\u0026#34;, \u0026amp;n) for i := 1; i \u0026lt;= n; i++ { for j := 1; j \u0026lt;= n; j++ { fmt.Scanf(\u0026#34;%d\u0026#34;, \u0026amp;M[i][j]) M[i][j] += M[i-1][j] } } ans := int(-1e9) for i := 1; i \u0026lt;= n; i++ { for j := i; j \u0026lt;= n; j++ { s := 0 for k := 1; k \u0026lt;= n; k++ { s = max(0, s) + M[j][k] - M[i-1][k] ans = max(ans, s) } } } fmt.Println(ans) } func max(a, b int) int { if a \u0026gt; b { return a } return b } æœ€å¤§çš„å’Œ-çº¿æ€§DP é¢˜ç›®é“¾æ¥\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;climits\u0026gt; using namespace std; const int N = 50005; int n, a[N], f[N], g[N]; // f[i]: 1~iæœ€å¤§è¿ç»­å­æ®µå’Œï¼Œg[i]:n~iæœ€å¤§è¿ç»­å­æ®µå’Œ int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); fill(f, f+n+2, INT_MIN); fill(g, g+n+2, INT_MIN); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); int s = 0; for (int i = 1; i \u0026lt;= n; i++) { s = max(s, 0) + a[i]; f[i] = max(f[i-1], s); } s = 0; for (int i = n; i \u0026gt;= 1; i--) { s = max(s, 0) + a[i]; g[i] = max(g[i+1], s); } int ans = INT_MIN; for (int i = 1; i \u0026lt; n; i++) ans = max(ans, f[i] + g[i+1]); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } æœ€å¤§å¼‚æˆ–å¯¹-trie é¢˜ç›®é“¾æ¥\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 1e5+5, M = 3e6+5; int a[N], son[M][2], idx, n; void insert(int x) { int p = 0; for (int i = 30; ~i; i--) { int t = x \u0026gt;\u0026gt; i \u0026amp; 1; if (!son[p][t]) son[p][t] = ++idx; p = son[p][t]; } } int query(int x) { int p = 0, res = 0; for (int i = 30; ~i; i--) { int t = x \u0026gt;\u0026gt; i \u0026amp; 1; if (son[p][!t]) { res += 1 \u0026lt;\u0026lt; i; p = son[p][!t]; } else { p = son[p][t]; } } return res; } int main() { cin \u0026gt;\u0026gt; n; int ans = 0; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; insert(a[i]); ans = max(ans, query(a[i])); } cout \u0026lt;\u0026lt; ans; return 0; } ç‰›äº¦æˆ–-trie+å‰ç¼€å’Œ é¢˜ç›®é“¾æ¥\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 1e5+5, M = 2e6+5; int son[M][2], a[N], id[M], idx, n; void insert(int x, int k) { int p = 0; for (int i = 20; ~i; i--) { int t = x \u0026gt;\u0026gt; i \u0026amp; 1; if (!son[p][t]) son[p][t] = ++idx; p = son[p][t]; } id[p] = k; } int query(int x) { int p = 0; for (int i = 20; ~i; i--) { int t = x \u0026gt;\u0026gt; i \u0026amp; 1; if (son[p][!t]) { p = son[p][!t]; } else { p = son[p][t]; } } return id[p]; } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; a[i] ^= a[i-1]; } insert(0, 0); int ans = -1, l, r; for (int i = 1; i \u0026lt;= n; i++) { int k = query(a[i]); int s = a[i] ^ a[k]; if (s \u0026gt; ans) { ans = s; l = k + 1, r = i; } insert(a[i], i); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; return 0; } Week 5 å¼€å¿ƒçš„é‡‘æ˜-01èƒŒåŒ… é¢˜ç›®é“¾æ¥\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int f[30005]; int n, m; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int v, w; for (int i = 0; i \u0026lt; m; i++) { cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; for (int j = n; j \u0026gt;= v; j--) f[j] = max(f[j], f[j-v]+w*v); } cout \u0026lt;\u0026lt; f[n] \u0026lt;\u0026lt; endl; return 0; } Kå€åŒºé—´-å‰ç¼€å’Œ é¢˜ç›®é“¾æ¥\næ€è·¯ æ±‚åŒºé—´å’Œï¼Œå¯ä»¥é€šè¿‡å‰ç¼€å’Œæ¥æ±‚å‡ºã€‚sum[r]âˆ’sum[lâˆ’1]å°±æ˜¯åŒºé—´[l,r]çš„å’Œã€‚å¦‚æœåŒºé—´[l,r]çš„å’Œæ˜¯kçš„å€æ•°åˆ™æœ‰(sum[r]âˆ’sum[lâˆ’1])ï¼Œå³sum[r]ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°ä¸€ä¸ªç»“è®ºï¼Œå¯¹å‰ç¼€å’Œå–æ¨¡ä¹‹åï¼Œä¸¤ä¸ªç›¸ç­‰çš„å‰ç¼€å’Œå°±èƒ½ç»„æˆä¸€ä¸ªkå€åŒºé—´ã€‚\næœ‰äº†è¿™ä¸ªç»“è®ºä¹‹åï¼Œæˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨ä¸¤å±‚forå¾ªç¯æ¥è®¡æ•°kå€åŒºé—´çš„ä¸ªæ•°ï¼Œä½†æ˜¯ç”±äºæ•°æ®æ¯”è¾ƒå¤§ï¼Œæˆ‘ä»¬ä¸èƒ½è¿™æ ·åšã€‚é‚£ä¹ˆæˆ‘ä»¬èƒ½ä¸èƒ½åœ¨è®¡ç®—å‰ç¼€å’Œçš„è¿‡ç¨‹ä¸­åŒæ—¶æ¥ç»Ÿè®¡kå€åŒºé—´çš„ä¸ªæ•°å‘¢ï¼Ÿå½“ç„¶å¯ä»¥ã€‚æˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªæ•°ç»„cntï¼Œè§„å®šcnt[i]è¡¨ç¤ºå½“å‰ä½ç½®ä¹‹å‰ï¼Œå‰ç¼€å’Œå–æ¨¡åç­‰äºiçš„ä¸ªæ•°ï¼Œä»¥åæ¯å‡ºç°ä¸€æ¬¡å‰ç¼€å’Œï¼ˆå–æ¨¡åï¼‰å’Œå®ƒç›¸ç­‰ï¼Œé‚£ä¹ˆkå€åŒºé—´å°±åŠ ä¸Šcnt[sum[i]]ï¼Œç„¶åcnt[sum[i]]++ã€‚è¿™æ ·ä¼¼ä¹ä¸å®¹æ˜“ç†è§£ï¼Œæˆ‘ä»¬ç”¨æ ·ä¾‹ä¸¾ä¸ªä¾‹å­ã€‚\nå¯¹äºæ•°åˆ— 1 2 3 4 5ï¼Œk = 2\nå¯¹å‰1ä¸ªæ•°çš„å’Œæ¨¡kåä¸º1ï¼Œåœ¨æ­¤ä¹‹å‰æœ‰0ä¸ªå‰ç¼€å’Œå–æ¨¡åä¸º1ï¼Œæ€»ä¸ªæ•°+0\nå¯¹å‰2ä¸ªæ•°çš„å’Œæ¨¡kåä¸º1ï¼Œåœ¨æ­¤ä¹‹å‰æœ‰1ä¸ªå‰ç¼€å’Œå–æ¨¡åä¸º1ï¼Œæ€»ä¸ªæ•°+1\nå¯¹å‰3ä¸ªæ•°çš„å’Œæ¨¡kåä¸º0ï¼Œåœ¨æ­¤ä¹‹å‰æœ‰0ä¸ªå‰ç¼€å’Œå–æ¨¡åä¸º0, æ€»ä¸ªæ•°+0\nå¯¹å‰4ä¸ªæ•°çš„å’Œæ¨¡kåä¸º0ï¼Œåœ¨æ­¤ä¹‹å‰æœ‰1ä¸ªå‰ç¼€å’Œå–æ¨¡åä¸º0ï¼Œæ€»ä¸ªæ•°+1\nå¯¹å‰5ä¸ªæ•°çš„å’Œæ¨¡kåä¸º1ï¼Œåœ¨æ­¤ä¹‹å‰æœ‰2ä¸ªå‰ç¼€å’Œå–æ¨¡åä¸º1ï¼Œæ€»ä¸ªæ•°+2\nä½†æ˜¯æˆ‘ä»¬è¿˜å¿½ç•¥äº†ä¸€ç‚¹ï¼Œå°±æ˜¯æˆ‘ä»¬è¿™æ ·åšæˆ‘ä»¬å°‘è®¡ç®—äº†åŒºé—´Â·[0,i]æ„æˆçš„kå€åŒºé—´ï¼Œå…¶ä¸ªæ•°ä¸ºcnt[0]ã€‚\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 1e5+5; int a[N], n, k, cnt[N]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; long ans = 0; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; a[i] = (a[i] + a[i-1]) % k; ans += cnt[a[i]]; cnt[a[i]]++; } cout \u0026lt;\u0026lt; ans + cnt[0]; return 0; } æ•°ç‹¬æ£€æŸ¥-æ¨¡æ‹Ÿ é¢˜ç›®é“¾æ¥\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 7; int n, m; int g[N*N][N*N]; bool st[N*N]; bool check_row() { for (int i = 0; i \u0026lt; m; i++) { memset(st, false, sizeof st); for (int j = 0; j \u0026lt; m; j++) { int t = g[i][j]; if (t \u0026lt; 1 || t \u0026gt; m) return false; if (st[t]) return false; st[t] = true; } } return true; } bool check_col() { for (int i = 0; i \u0026lt; m; i++) { memset(st, false, sizeof st); for (int j = 0; j \u0026lt; m; j++) { int t = g[j][i]; if (t \u0026lt; 1 || t \u0026gt; m) return false; if (st[t]) return false; st[t] = true; } } return true; } bool check_cell() { for (int i = 0; i \u0026lt; m; i += n) for (int j = 0; j \u0026lt; m; j += n) { memset(st, false, sizeof st); for (int dx = 0; dx \u0026lt; n; dx++) for (int dy = 0; dy \u0026lt; n; dy++) { int t = g[i+dx][j+dy]; if (t \u0026lt; 1 || t \u0026gt; m) return false; if (st[t]) return false; st[t] = true; } } return true; } int main() { int T; cin \u0026gt;\u0026gt; T; for (int t = 1; t \u0026lt;= T; t++) { cin \u0026gt;\u0026gt; n; m = n * n; for (int i = 0; i \u0026lt; m; i++) for (int j = 0; j \u0026lt; m; j++) cin \u0026gt;\u0026gt; g[i][j]; printf(check_row() \u0026amp;\u0026amp; check_col() \u0026amp;\u0026amp; check_cell() ? \u0026#34;Case #%d: Yes\\n\u0026#34; : \u0026#34;Case #%d: No\\n\u0026#34;, t); } return 0; } æœ€é•¿å…¬å…±å­åºåˆ—-LCS é¢˜ç›®é“¾æ¥\næ€è·¯ ä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 1005; int n, m, f[N][N]; char a[N], b[N]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; a + 1 \u0026gt;\u0026gt; b + 1; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) if (a[i] == b[j]) f[i][j] = f[i-1][j-1] + 1; else f[i][j] = max(f[i-1][j], f[i][j-1]); cout \u0026lt;\u0026lt; f[n][m]; return 0; } æ•°ç‹¬ç®€å•ç‰ˆ-æ•°ç‹¬ #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; char g[10][10]; bool row[10][10], col[10][10], cell[3][3][10]; bool dfs(int x, int y) { if (y == 9) { x++, y = 0; } if (x == 9) { for (int i = 0; i \u0026lt; 9; i++) cout \u0026lt;\u0026lt; g[i] \u0026lt;\u0026lt; endl; return true; } if (g[x][y] != \u0026#39;.\u0026#39;) return dfs(x, y+1); for (int i = 1; i \u0026lt;= 9; i++) { if (!row[x][i] \u0026amp;\u0026amp; !col[y][i] \u0026amp;\u0026amp; !cell[x/3][y/3][i]) { g[x][y] = i + \u0026#39;0\u0026#39;; row[x][i] = col[y][i] = cell[x/3][y/3][i] = true; if (dfs(x, y+1)) return true; row[x][i] = col[y][i] = cell[x/3][y/3][i] = false; g[x][y] = \u0026#39;.\u0026#39;; } } return false; } int main() { for (int i = 0; i \u0026lt; 9; i++) { cin \u0026gt;\u0026gt; g[i]; for (int j = 0; j \u0026lt; 9; j++) if (g[i][j] != \u0026#39;.\u0026#39;) { int t = g[i][j] - \u0026#39;0\u0026#39;; row[i][t] = col[j][t] = cell[i/3][j/3][t] = true; } } dfs(0, 0); } çŒ®ç»™é˜¿å°”å‰ä¾¬çš„èŠ±æŸ-BFS é¢˜ç›®é“¾æ¥\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int N = 205; const int dx[]{-1, 0, 1, 0}, dy[]{0, 1, 0, -1}; char g[N][N]; int dist[N][N]; int r, c; bool bfs(int x, int y) { memset(dist, 0, sizeof dist); queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; Q; Q.push({x, y}); while (!Q.empty()) { auto [tx, ty] = Q.front(); Q.pop(); if (g[tx][ty] == \u0026#39;E\u0026#39;) { cout \u0026lt;\u0026lt; dist[tx][ty] \u0026lt;\u0026lt; endl; return true; } for (int i = 0; i \u0026lt; 4; i++) { int nx = tx + dx[i], ny = ty + dy[i]; if (nx \u0026lt; 0 || nx \u0026gt;= r || ny \u0026lt; 0 || ny \u0026gt;= c || g[nx][ny] == \u0026#39;#\u0026#39;) continue; Q.push({nx, ny}); if (g[nx][ny] != \u0026#39;E\u0026#39;) g[nx][ny] = \u0026#39;#\u0026#39;; dist[nx][ny] = dist[tx][ty] + 1; } } cout \u0026lt;\u0026lt; \u0026#34;oop!\u0026#34; \u0026lt;\u0026lt; endl; return false; } int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; r \u0026gt;\u0026gt; c; for (int i = 0; i \u0026lt; r; i++) cin \u0026gt;\u0026gt; g[i]; bool is_break = false; for (int i = 0; i \u0026lt; r; i++) { for (int j = 0; j \u0026lt; c; j++) if (g[i][j] == \u0026#39;S\u0026#39;) { bfs(i, j); is_break = true; break; } if (is_break) break; } } return 0; } a^b-ä½è¿ç®— é¢˜ç›®é“¾æ¥\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; using ll = long long; int main() { ll a, b, p; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; p; ll res = 1; while (b) { if (b \u0026amp; 1) res = res * a % p; a = a * a % p; b \u0026gt;\u0026gt;= 1; } cout \u0026lt;\u0026lt; res % p \u0026lt;\u0026lt; endl; return 0; } è€æ‚æŠ€çš„ç‰›-è´ªå¿ƒ é¢˜ç›®é“¾æ¥\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;climits\u0026gt; using namespace std; const int N = 50005; int n; pair\u0026lt;int, int\u0026gt; a[N]; int main() { cin \u0026gt;\u0026gt; n; int w, s; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; w \u0026gt;\u0026gt; s; a[i] = {w+s, w}; } sort(a, a+n); int ans = INT_MIN, sum_w = 0; for (int i = 0; i \u0026lt; n; i++) { w = a[i].second, s = a[i].first - w; ans = max(ans, sum_w - s); sum_w += w; } cout \u0026lt;\u0026lt; ans; return 0; } æ•°åˆ—-äºŒè¿›åˆ¶ é¢˜ç›®é“¾æ¥\næ€è·¯ ä½¿ç”¨nçš„äºŒè¿›åˆ¶è¡¨ç¤º\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int pow(int a, int b) { int res = 1; while (b) { if (b \u0026amp; 1) res *= a; a *= a; b \u0026gt;\u0026gt;= 1; } return res; } int main() { int k, n; cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; n; int ans = 0; for (int i = 0; i \u0026lt; 10; i++) { if (n \u0026gt;\u0026gt; i \u0026amp; 1) ans += pow(k, i); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } å€Ÿæ•™å®¤-äºŒåˆ†\u0026amp;å·®åˆ† é¢˜ç›®é“¾æ¥\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; using ll = long long; const int N = 1e6 + 5; int r[N], d[N], s[N], t[N]; int n, m; ll b[N]; bool check(int mid) { for (int i = 1; i \u0026lt;= n; i++) b[i] = r[i] - r[i-1]; for (int i = 1; i \u0026lt;= mid; i++) { b[s[i]] -= d[i]; b[t[i]+1] += d[i]; } for (int i = 1; i \u0026lt;= n; i++) { b[i] += b[i-1]; if (b[i] \u0026lt; 0) return false; } return true; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; r[i]; for (int i = 1; i \u0026lt;= m; i++) cin \u0026gt;\u0026gt; d[i] \u0026gt;\u0026gt; s[i] \u0026gt;\u0026gt; t[i]; int l = 0, r = m; while (l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (check(mid)) l = mid; else r = mid - 1; } if (l == m) puts(\u0026#34;0\u0026#34;); else printf(\u0026#34;-1\\n%d\u0026#34;, l + 1); return 0; } å…³æŠ¼ç½ªçŠ¯-äºŒåˆ†\u0026amp;æŸ“è‰²æ³•åˆ¤æ–­äºŒåˆ†å›¾ é¢˜ç›®é“¾æ¥\næ€è·¯ äºŒåˆ†ç­”æ¡ˆï¼Œåˆ¤æ–­èƒ½å¦ä»¥å½“å‰ç­”æ¡ˆå¤§çš„ç‚¹æ„æˆäºŒåˆ†å›¾ ä½¿ç”¨æŸ“è‰²åˆ¤æ–­èƒ½å¦æ„æˆäºŒåˆ†å›¾ ä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 20005, M = 200005; int n, m; int h[N], ne[M], e[M], w[M], idx; int color[N]; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; } bool dfs(int u, int c, int mid) { color[u] = c; for (int i = h[u]; ~i; i = ne[i]) { if (w[i] \u0026lt;= mid) continue; int v = e[i]; if (color[v]) { if (color[v] == c) return false; } else if (!dfs(v, 3-c, mid)) return false; } return true; } bool check(int mid) { memset(color, 0, sizeof color); for (int i = 1; i \u0026lt;= n; i++) if (!color[i]) if (!dfs(i, 1, mid)) return false; return true; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); int a, b, c; memset(h, -1, sizeof h); while (m--) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); add(a, b, c); add(b, a, c); } int l = 0, r = 1e9; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; else l = mid + 1; } printf(\u0026#34;%d\u0026#34;, l); return 0; } Week 6 ä¹Œé¾Ÿæ£‹-çº¿æ€§DP é¢˜ç›®é“¾æ¥\næ€è·¯ çŠ¶æ€è¡¨ç¤ºï¼šf[b1,b2,b3,b4] è¡¨ç¤ºæ‰€æœ‰ç¬¬ i ç§å¡ç‰‡ä½¿ç”¨äº† bi å¼ çš„èµ°æ³•çš„æœ€å¤§åˆ†å€¼ã€‚\nçŠ¶æ€è®¡ç®—ï¼šå°† f[b1,b2,b3,b4] è¡¨ç¤ºçš„æ‰€æœ‰èµ°æ³•æŒ‰æœ€åä¸€æ­¥é€‰æ‹©å“ªå¼ å¡ç‰‡åˆ†æˆå››ç±»ï¼šç¬¬ i ç±»ä¸ºæœ€åä¸€æ­¥é€‰æ‹©ç¬¬ i ç§å¡ç‰‡ã€‚æ¯”å¦‚ i=2ï¼Œåˆ™è¿™ä¸€ç±»çš„æœ€å¤§åˆ†å€¼æ˜¯ f[b1,b2âˆ’1,b3,b4]+score[b1+2b2+3b3+4b4]ã€‚\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 45; int f[N][N][N][N], b[4], w[355]; int n, m; int main() { cin \u0026gt;\u0026gt; n\u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; w[i]; while (m--) { int t; cin \u0026gt;\u0026gt; t; b[t-1]++; } for (int A = 0; A \u0026lt;= b[0]; A++) for (int B = 0; B \u0026lt;= b[1]; B++) for (int C = 0; C \u0026lt;= b[2]; C++) for (int D = 0; D \u0026lt;= b[3]; D++) { int score = w[A * 1 + B * 2 + C * 3 + D * 4]; int \u0026amp;v = f[A][B][C][D]; v = score; if (A) v = max(v, f[A-1][B][C][D] + score); if (B) v = max(v, f[A][B-1][C][D] + score); if (C) v = max(v, f[A][B][C-1][D] + score); if (D) v = max(v, f[A][B][C][D-1] + score); } cout \u0026lt;\u0026lt; f[b[0]][b[1]][b[2]][b[3]]; return 0; } æ¯”ä¾‹ç®€åŒ–-æšä¸¾ é¢˜ç›®é“¾æ¥\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } int main() { int A, B, L; cin \u0026gt;\u0026gt; A \u0026gt;\u0026gt; B \u0026gt;\u0026gt; L; int a, b; double t = A * 1.0 / B; double delta = 1e9; for (int i = 1; i \u0026lt;= L; i++) { for (int j = 1; j \u0026lt;= L; j++) { if (gcd(i, j) == 1) { double x = i * 1.0 / j; if (x \u0026gt;= t \u0026amp;\u0026amp; x - t \u0026lt; delta) { delta = x - t; a = i, b = j; } } } } cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; b; return 0; } è®¡ç®—ç³»æ•° é¢˜ç›®é“¾æ¥\næ€è·¯ äºŒé¡¹å¼å®šç†ï¼š$ ans = C_k^n x^n y^m $ Pascalå…¬å¼ï¼š$ C_n^k = C_{n-1}^{k} + C_{n-1}^{k-1} $ ä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int mod = 10007; const int N = 1005; int C[N][N]; int pow(int a, int b) { int res = 1; a %= mod; while (b) { if (b \u0026amp; 1) res = res * a % mod; a = a * a % mod; b \u0026gt;\u0026gt;= 1; } return res % mod; } int main() { int a, b, k, n, m; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; k \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt;= k; i++) for (int j = 0; j \u0026lt;= i; j++) { if (!j) C[i][j] = 1; else C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod; } cout \u0026lt;\u0026lt; C[k][n] * pow(a, n) % mod * pow(b, m) % mod; return 0; } åˆå¹¶æœå­ ä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; int n; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; Q; int main() { cin \u0026gt;\u0026gt; n; int x; while (n--) { cin \u0026gt;\u0026gt; x; Q.push(move(x)); } int ans = 0; while (Q.size() \u0026gt; 1) { auto a = Q.top(); Q.pop(); auto b = Q.top(); Q.pop(); Q.push(a + b); ans += a + b; } cout \u0026lt;\u0026lt; ans; return 0; } ç§¯æœ¨å¤§èµ›-è´ªå¿ƒ\u0026amp;å·®åˆ† é¢˜ç›®é“¾æ¥\næ€è·¯ ä»åå¾€å‰æ“ä½œï¼Œå¦‚æœå½“å‰çš„ bi\u0026gt;0ï¼Œåˆ™å°†å…¶å‡1ï¼Œå¹¶å°†å…¶åçš„æŸä¸ªè´Ÿæ•°åŠ 1ã€‚\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 100005; int n, h[N]; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; h[i]; int res = 0; for (int i = n; i \u0026gt;= 1; i--) res += max(0, h[i]-h[i-1]); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } LeetCode-1755 æœ€æ¥è¿‘ç›®æ ‡å€¼çš„å­åºåˆ—å’Œ é¢˜ç›®é“¾æ¥\næ€è·¯ generate sums for all subset: DP $ sum_i = sum_{i-1} \\cup (sum_{i-1}+ nums[i]) $ å°†sum of subsetåˆ†æˆä¸¤éƒ¨åˆ†ï¼Œéå†å‰ä¸€éƒ¨åˆ†äºŒåˆ†åä¸€éƒ¨åˆ†ï¼Œå¹¶ä¸”æ’åº å»é‡ä¼˜åŒ– ä»£ç  å‚è€ƒé“¾æ¥\nclass Solution { public: int minAbsDifference(vector\u0026lt;int\u0026gt;\u0026amp; nums, int goal) { const int n = nums.size(); int ans = abs(goal); vector\u0026lt;int\u0026gt; t1{0}, t2{0}; t1.reserve(1 \u0026lt;\u0026lt; (n / 2 + 1)), t2.reserve(1 \u0026lt;\u0026lt; (n / 2 + 1)); for (int i = 0; i \u0026lt; n / 2; i++) for (int j = t1.size() - 1; j \u0026gt;= 0; j--) t1.push_back(nums[i] + t1[j]); for (int i = n / 2; i \u0026lt; n; i++) for (int j = t2.size() - 1; j \u0026gt;= 0; j--) t2.push_back(nums[i] + t2[j]); auto it = unique(begin(t1), end(t1)); t1.resize(distance(begin(t1), it)); sort(begin(t1), end(t1), greater\u0026lt;int\u0026gt;()); it = unique(begin(t2), end(t2)); t2.resize(distance(begin(t2), it)); sort(begin(t2), end(t2)); for (const auto \u0026amp;e : t1) { auto it = lower_bound(begin(t2), end(t2), goal - e); if (it != t2.end()) ans = min(ans, abs(goal - e - *it)); if (it != t2.begin()) ans = min(ans, abs(goal - e - *(--it))); } return ans; } }; Week 7 æœºå™¨äººè·³è·ƒé—®é¢˜-äºŒåˆ† æ€è·¯ æ³¨æ„midå¤§äºç­‰äº1e5æ—¶ï¼Œä¸€å®šå¯ä»¥å®Œæˆæ¸¸æˆ\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 1e5 + 5; int h[N], n; bool check(long mid) { for (int i = 1; i \u0026lt;= n; i++) { mid += mid - h[i]; if (mid \u0026gt; 1e5) return true; if (mid \u0026lt; 0) return false; } return true; } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; h[i]; int l = 0, r = 1e5; while (l \u0026lt; r) { const int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; else l = mid + 1; } cout \u0026lt;\u0026lt; l; return 0; } Zå­—å½¢æ‰«æ é¢˜ç›®é“¾æ¥\næ€è·¯ ä¸‹æ ‡ä¹‹å’Œä¸ºå¶æ•°ï¼Œä»ä¸‹åˆ°ä¸Šéå† ä¸‹æ ‡ä¹‹å’Œä¸ºå¥‡æ•°ï¼Œä»ä¸Šåˆ°ä¸‹éå† ä»£ç  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 505; int g[N][N], n; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= n; j++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;g[i][j]); for (int i = 2; i \u0026lt;= 2 * n; i ++) { if (i % 2 == 0) { for (int j = i; j \u0026gt;= 1; j--) { if (j \u0026gt;= 1 \u0026amp;\u0026amp; j \u0026lt;= n \u0026amp;\u0026amp; i - j \u0026gt;= 1 \u0026amp;\u0026amp; i - j \u0026lt;= n) printf(\u0026#34;%d \u0026#34;, g[j][i-j]); } } else { for (int j = 1; j \u0026lt;= n; j++) { if (j \u0026gt;= 1 \u0026amp;\u0026amp; j \u0026lt;= n \u0026amp;\u0026amp; i - j \u0026gt;= 1 \u0026amp;\u0026amp; i - j \u0026lt;= n) printf(\u0026#34;%d \u0026#34;, g[j][i-j]); } } } return 0; } åŠ¨æ€æ±‚è¿ç»­åŒºé—´å’Œ-çº¿æ®µæ ‘ é¢˜ç›®é“¾æ¥\nçº¿æ®µæ ‘-ä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 1e5 + 5; struct node { int l, r, sum; } tree[N \u0026lt;\u0026lt; 2]; int n, m, a[N]; void build(int u, int l, int r) { if (l == r) tree[u] = {l, r, a[l]}; else { const int mid = l + r \u0026gt;\u0026gt; 1; build(u\u0026lt;\u0026lt;1, l, mid), build(u\u0026lt;\u0026lt;1|1, mid+1, r); tree[u] = {l, r, tree[u\u0026lt;\u0026lt;1].sum + tree[u\u0026lt;\u0026lt;1|1].sum}; } } void update(int u, int i, int v) { if (tree[u].l == i \u0026amp;\u0026amp; tree[u].r == i) tree[u].sum += v; else { const int mid = tree[u].l + tree[u].r \u0026gt;\u0026gt; 1; if (i \u0026lt;= mid) update(u\u0026lt;\u0026lt;1, i, v); else update(u\u0026lt;\u0026lt;1|1, i, v); tree[u].sum = tree[u\u0026lt;\u0026lt;1].sum + tree[u\u0026lt;\u0026lt;1|1].sum; } } int query(int u, int l, int r) { if (tree[u].l == l \u0026amp;\u0026amp; tree[u].r == r) return tree[u].sum; const int mid = tree[u].l + tree[u].r \u0026gt;\u0026gt; 1; if (r \u0026lt;= mid) return query(u\u0026lt;\u0026lt;1, l, r); else if (l \u0026gt; mid) return query(u\u0026lt;\u0026lt;1|1, l, r); else return query(u\u0026lt;\u0026lt;1, l, mid) + query(u\u0026lt;\u0026lt;1|1, mid+1, r); } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); build(1, 1, n); int k, a, b; while (m--) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;k, \u0026amp;a, \u0026amp;b); if(!k) printf(\u0026#34;%d\\n\u0026#34;, query(1, a, b)); else update(1, a, b); } return 0; } æ ‘çŠ¶æ•°ç»„-ä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 1e5 + 5; int C[N], n, m; void add(int x, int k) { for (int i = x; i \u0026lt;= n; i += i \u0026amp; -i) C[i] += k; } int get_sum(int x) { int s = 0; for (int i = x; i \u0026gt;= 1; i -= i \u0026amp; -i) s += C[i]; return s; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); int t; for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); add(i, t); } int k, a, b; while (m--) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;k, \u0026amp;a, \u0026amp;b); if (!k) printf(\u0026#34;%d\\n\u0026#34;, get_sum(b) - get_sum(a-1)); else add(a, b); } return 0; } å¥‡æ€ªçš„æ•°-ç»„åˆè®¡æ•° é¢˜ç›®é“¾æ¥\næ€è·¯ åˆ’åˆ†ä¸ºä¸¤ç±» 0ã€1ï¼š$k$ä½, $ 2 \\le k \\le n - 2 $ 2ã€3ï¼š$n-k$ä½ æ”¾0ã€1ï¼šç¬¬ä¸€ä½ä¸èƒ½æ”¾, å‰©ä¸‹$n-1$ä½å¯ä»¥æ”¾$k$ä¸ª0ã€1-\u0026gt; $ C_{n-1}^{k} $ 0çš„ä¸ªæ•°ï¼š$1 \\le cnt_0 \\le k-1$, å…±$k-1$ç§å¯èƒ½ï¼Œ2çš„ä¸ªæ•°ï¼š$1 \\le cnt_2 \\le n-k-1$ï¼Œå…±$n-k-1$ç§å¯èƒ½ $ ans = \\sum_{k=2}^{n-2}{C_{n-1}^{k}(k-1)(n-k-1)} $ ä»£ç  #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1005; int n, C[N][N]; const int mod = 1e9 + 7; int main() { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt;= n; i++) for (int j = 0; j \u0026lt;= i; j++) if (!j) C[i][j] = 1; else C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod; int ans = 0; for (int k = 2; k \u0026lt;= n - 2; k++) { ans = (ans + C[n-1][k] * 1ll * (k - 1) % mod * (n - k - 1)) % mod; } cout \u0026lt;\u0026lt; ans; return 0; } æœ€ä¼˜é…é¤-å¤šæºBFS é¢˜ç›®é“¾æ¥\næ€è·¯ å°†èµ·ç‚¹éƒ½å…¥é˜Ÿåˆ—è¿›è¡ŒBFS\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int N = 1005; int n, m, k, d, dist[N][N], w[N][N]; queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; Q; void bfs() { const int dx[]{-1, 0, 1, 0}, dy[]{0, 1, 0, -1}; while (!Q.empty()) { auto [x, y] = Q.front(); Q.pop(); for (int i = 0; i \u0026lt; 4; i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx \u0026lt;= 0 || nx \u0026gt; n || ny \u0026lt;= 0 || ny \u0026gt; n || dist[nx][ny] != -1) continue; dist[nx][ny] = dist[x][y] + 1; Q.push({nx, ny}); } } } int main() { scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;k, \u0026amp;d); memset(dist, -1, sizeof dist); int x, y; while (m--) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); Q.push({x, y}); dist[x][y] = 0; } int c; for (int i = 0; i \u0026lt; k; i++) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;c); w[x][y] += c; } for (int i = 0; i \u0026lt; d; i++) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); dist[x][y] = -2; } bfs(); long ans = 0; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= n; j++) { if (w[i][j]) ans += w[i][j] * dist[i][j] * 1ll; } printf(\u0026#34;%ld\\n\u0026#34;, ans); return 0; } LeetCode-995 K è¿ç»­ä½çš„æœ€å°ç¿»è½¬æ¬¡æ•° é¢˜ç›®é“¾æ¥\næ€è·¯ å·®åˆ†æ•°ç»„d[i]è¡¨ç¤ºiä½ç½®éœ€è¦ç¿»è½¬çš„æ¬¡æ•° - i-1ä½ç½®éœ€è¦ç¿»è½¬çš„æ¬¡æ•° cntè¡¨ç¤ºå½“å‰ä½ç½®éœ€è¦ç¿»è½¬çš„æ¬¡æ•° è‹¥A[i]+cntæ˜¯å¶æ•°åˆ™éœ€è¦ç¿»è½¬ï¼šcnt++, d[i+k]++ è‹¥i+K \u0026gt; nåˆ™ä¸å¯èƒ½\nä»£ç  class Solution { public: int minKBitFlips(vector\u0026lt;int\u0026gt;\u0026amp; A, int K) { const int n = A.size(); vector\u0026lt;int\u0026gt; d(n + 1, 0); int cnt = 0, ans = 0; for (int i = 0; i \u0026lt; n; i++) { cnt += d[i]; if (!((A[i] + cnt) \u0026amp; 1)) { if (i + K \u0026gt; n) return -1; ++cnt; ++ans; d[i+K]--; } } return ans; } }; æœ€å°ç”Ÿæˆæ ‘ é¢˜ç›®é“¾æ¥\nPrim #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; using P = pair\u0026lt;int, int\u0026gt;; const int N = 2e5 + 5; vector\u0026lt;P\u0026gt; g[N]; bool vis[N]; int n, m; priority_queue\u0026lt;P\u0026gt; Q; int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); int a, b, c; while (m--) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); g[a].push_back({b, c}); g[b].push_back({a, c}); } Q.push({0, 1}); long ans = 0; for (int i = 0; i \u0026lt; n; i++) { while (true) { auto [w, v] = Q.top(); Q.pop(); if (vis[v]) continue; vis[v] = true; ans += -w; for (auto [_v, _w] : g[v]) { if (vis[_v]) continue; Q.push({-_w, _v}); } break; } } printf(\u0026#34;%ld\\n\u0026#34;, ans); return 0; } Kruskal #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; class UF { vector\u0026lt;int\u0026gt; id, sz; public: UF(int N) { id.resize(N); sz.resize(N); for (int i = 0; i \u0026lt; N; i++) { id[i] = i; sz[i] = 1; } } int find(int p) { while (p != id[p]) { id[p] = id[id[p]]; p = id[p]; } return p; } bool _union(int p, int q) { int i = find(p), j = find(q); if (i == j) return false; if (sz[i] \u0026lt; sz[j]) { id[i] = j; sz[j] += sz[i]; } else { id[j] = i; sz[i] += sz[j]; } return true; } }; struct node { int w, u, v; friend bool operator\u0026lt;(const node \u0026amp;a, const node\u0026amp; b) { if (a.w == b.w) { return make_pair(a.u, a.v) \u0026gt; make_pair(b.u, b.v); } return a.w \u0026gt; b.w; } }; int n, m; priority_queue\u0026lt;node\u0026gt; Q; int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); UF uf(n); int a, b, c; while (m--) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); Q.push({c, a, b}); } int cnt = 0; long ans = 0; while (!Q.empty() \u0026amp;\u0026amp; cnt \u0026lt; n - 1) { auto [w, u, v] = Q.top(); Q.pop(); if (uf._union(u-1, v-1)) { ans += w; ++cnt; } } printf(\u0026#34;%ld\\n\u0026#34;, ans); return 0; } å•æºæœ€çŸ­è·¯ é¢˜ç›®é“¾æ¥\nä»£ç  #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; using P = pair\u0026lt;int, int\u0026gt;; const int N = 2505, M = 12500; int h[N], e[M], ne[M], w[M], idx; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; } int n, m, dist[N]; bool st[N]; priority_queue\u0026lt;P\u0026gt; Q; void dijkstra(int s, int t) { memset(dist, 0x3f, sizeof dist); Q.push({0, s}); dist[s] = 0; while (!Q.empty()) { auto [d, u] = Q.top(); Q.pop(); if (st[u]) continue; st[u] = true; for (int i = h[u]; ~i; i = ne[i]) { int v = e[i]; if (dist[v] \u0026gt; -d + w[i]) { dist[v] = -d + w[i]; Q.push({-dist[v], v}); } } } } int main() { memset(h, -1, sizeof h); int s, t; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;s, \u0026amp;t); int a, b, c; while (m--) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); add(a, b, c); add(b, a, c); } dijkstra(s, t); printf(\u0026#34;%d\\n\u0026#34;, dist[t]); return 0; } ç½‘ç»œå»¶æ—¶-æ ‘å½¢DP é¢˜ç›®é“¾æ¥\næ€è·¯ æ ‘å½¢DPæ¨¡æ¿\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 20005; int h[N], e[N], ne[N], idx; int n, m, f[N]; // f[u]: è¡¨ç¤ºuåˆ°æœ€è¿œå¶èŠ‚ç‚¹çš„è·ç¦»ã€‚æ˜¾ç„¶å¦‚æœuæ˜¯èŠ‚ç‚¹ï¼Œåˆ™f[u]=0 void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; } int ans = 0; void dfs(int u) { // æ±‚ä»¥uä¸ºæ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹çš„æœ€å¤§è·ç¦» int a = 0, b = 0; // aè®°å½•uåˆ°æœ€è¿œå¶èŠ‚ç‚¹çš„è·ç¦»ï¼Œbè®°å½•uåˆ°æ¬¡è¿œå¶èŠ‚ç‚¹çš„è·ç¦» for (int i = h[u]; ~i; i = ne[i]) { int v = e[i]; dfs(v); //æ±‚å­èŠ‚ç‚¹jåˆ°æœ€è¿œå¶èŠ‚ç‚¹çš„è·ç¦» int t = f[v] + 1; //ué€šè¿‡jèƒ½åˆ°çš„æœ€è¿œå¶èŠ‚ç‚¹çš„è·ç¦» //æ›´æ–°a, b if (t \u0026gt;= a) b = a, a = t; else if (t \u0026gt; b) b = t; } f[u] = a; // æœ€åçš„ç­”æ¡ˆå°±æ˜¯uæ‰€èƒ½åˆ°çš„æœ€è¿œå¶èŠ‚ç‚¹è·ç¦»å’Œæ¬¡è¿œå¶èŠ‚ç‚¹è·ç¦»ä¹‹å’Œ ans = max(ans, a + b); } int main() { memset(h, -1, sizeof h); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); int j; for (int i = 2; i \u0026lt;= n + m; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;j); add(j, i); // å› ä¸ºæ˜¯è‡ªæ ¹å‘ä¸‹DPï¼Œæ‰€ä»¥å»ºä¸€æ¡è¾¹å³å¯ } dfs(1); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } åºåˆ—åŒ–äºŒå‰æ ‘ é¢˜ç›®é“¾æ¥\nä»£ç  class Solution: def serialize(self, root): ans = \u0026#34;\u0026#34; def dfs_s(root): nonlocal ans if not root: ans += \u0026#39;None \u0026#39; return else: ans += str(root.val) + \u0026#39; \u0026#39; dfs_s(root.left) dfs_s(root.right) dfs_s(root) return ans def deserialize(self, data): A = data.split() k = 0 def dfs_d(): nonlocal A, k if k == len(A): return None if A[k] == \u0026#39;None\u0026#39;: k += 1 return None root = TreeNode(int(A[k])) k += 1 root.left = dfs_d() root.right = dfs_d() return root return dfs_d() æœ€å¤§äº¦æˆ–å’Œ-çº¿æ€§åŸº é¢˜ç›®é“¾æ¥\næ€è·¯ æ„é€ çº¿æ€§åŸºçš„æ–¹æ³•å¦‚ä¸‹ï¼šå¯¹äºé›†åˆä¸­çš„æ¯ä¸ªæ•°xè½¬ä¸ºäºŒè¿›åˆ¶ï¼Œä»é«˜ä½å‘ä½ä½æ‰«ï¼Œå¯¹äºç¬¬iä½æ˜¯1çš„ï¼Œå¦‚æœp[i]ä¸å­˜åœ¨ï¼Œé‚£ä¹ˆp[i] = xç»“æŸæ‰«æï¼Œå¦‚æœå­˜åœ¨ï¼Œä»¤x = x ^ p[i] æŸ¥è¯¢é›†åˆå†…ä»»æ„å‡ ä¸ªå…ƒç´ xoræœ€å¤§å€¼ï¼šä»é«˜ä½å‘ä½ä½æ‰«ï¼Œè‹¥xorä¸Šå½“å‰æ‰«åˆ°çš„p[i]ç­”æ¡ˆå˜å¤§ï¼Œå°±æŠŠç­”æ¡ˆxorä¸Šp[i] æŸ¥è¯¢åŸé›†åˆå†…ä»»æ„å‡ ä¸ªå…ƒç´ xorçš„æœ€å°å€¼ï¼Œå°±æ˜¯çº¿æ€§åŸºé›†åˆæ‰€æœ‰å…ƒç´ ä¸­æœ€å°çš„é‚£ä¸ª ä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; using ull = unsigned long long; ull p[65]; int n; int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); auto insert = [](ull x) { for (int i = 63; ~i; i--) { if (!(x \u0026gt;\u0026gt; i \u0026amp; 1)) continue; if (!p[i]) { p[i] = x; break; } x ^= p[i]; } }; ull x; while (n--) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;x); insert(x); } ull ans = 0; for (int i = 63; ~i; i--) ans = max(ans, ans ^ p[i]); printf(\u0026#34;%lld\u0026#34;, ans); return 0; } é€šä¿¡ç½‘ç»œ-æšä¸¾+dfs é¢˜ç›®é“¾æ¥\nä»£ç  #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 1005, M = 10005; int h[N], e[M], ne[M], idx; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; } int n, m; bool st[N][N]; void dfs(int s, int u) { st[s][u] = true; for (int i = h[u]; ~i; i = ne[i]) { int v = e[i]; if (st[s][v]) continue; dfs(s, v); } } int main() { memset(h, -1, sizeof h); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); int a, b; while (m--) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); add(a, b); } for (int i = 1; i \u0026lt;= n; i++) dfs(i, i); int ans = 0; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) if (st[i][j]) st[j][i] = true; } for (int i = 1; i \u0026lt;= n; i++) { int j = 1; for (; j \u0026lt;= n; j++) if(!st[i][j]) break; if (j \u0026gt; n) ++ans; } cout \u0026lt;\u0026lt; ans; return 0; } å‹ç¼©ç¼–ç -åŒºé—´DP æ€è·¯ çŠ¶æ€è¡¨ç¤ºf[i][j] é›†åˆï¼šæ‰€æœ‰å°†[i, j]åˆå¹¶æˆä¸€å †çš„æ–¹æ¡ˆçš„é›†åˆ å±æ€§ï¼šæœ€å°å€¼ çŠ¶æ€è®¡ç®—ï¼šf[i][j] = min(f[i][j], f[i][k] + f[k+1][j] + s[j] - s[i-1]) ä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;climits\u0026gt; using namespace std; const int N = 1005; int n, f[N][N], s[N]; int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;s[i]); s[i] += s[i-1]; } for (int len = 2; len \u0026lt;= n; len++) for (int i = 1; i + len - 1 \u0026lt;= n; i++) { int j = i + len - 1; f[i][j] = INT_MAX; for (int k = i; k \u0026lt; j; k++) f[i][j] = min(f[i][j], f[i][k] + f[k+1][j] + s[j] - s[i-1]); } cout \u0026lt;\u0026lt; f[1][n]; } æ‚é¢˜è®°å½• ååºéå† é¢˜ç›®é“¾æ¥\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;functional\u0026gt; using namespace std; const int N = 30; struct node { char c; node *l, *r; node(char _c) : c(_c), l(nullptr), r(nullptr) {} }; void print(node *root) { if (!root) return; print(root-\u0026gt;l); print(root-\u0026gt;r); printf(\u0026#34;%c\u0026#34;, root-\u0026gt;c); } unordered_map\u0026lt;char, int\u0026gt; M; string A, B; node* dfs(int pl, int pr, int il, int ir) { if (pl \u0026gt; pr) return nullptr; auto it = M[A[pl]]; node *root = new node(A[pl]); root-\u0026gt;l = dfs(pl + 1, pl + 1 + it - il - 1, il, it - 1); root-\u0026gt;r = dfs(pl + 1 + it - il, pr, it + 1, ir); return root; }; int main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); cin \u0026gt;\u0026gt; A \u0026gt;\u0026gt; B; const int n = A.size(); for (int i = 0; i \u0026lt; n; i++) M[B[i]] = i; auto root = dfs(0, n - 1, 0, n - 1); print(root); return 0; } æ ‘çš„éå†-ä¸­åºååºæ±‚å±‚æ¬¡ é¢˜ç›®é“¾æ¥\nä»£ç  package main import \u0026#34;fmt\u0026#34; type TreeNode struct { val int left, right *TreeNode } var n int func main() { fmt.Scan(\u0026amp;n) after, in := make([]int, n), make([]int, n) for i := range after { fmt.Scan(\u0026amp;after[i]) } for i := range in { fmt.Scan(\u0026amp;in[i]) } mp := make(map[int]int) for i := range in { mp[in[i]] = i } var dfs func(il, ir, al, ar int) (*TreeNode) dfs = func(il, ir, al, ar int) (*TreeNode) { if al \u0026gt; ar { return nil } idx := mp[after[ar]] root := \u0026amp;TreeNode{ val: after[ar], left: dfs(il, idx-1, al, al+idx-il-1), right: dfs(idx+1, ir, al+idx-il, ar-1), } return root } root := dfs(0, n-1, 0, n-1) que := make([](*TreeNode), 0) que = append(que, root) for len(que) != 0 { front := que[0] fmt.Printf(\u0026#34;%d \u0026#34;, front.val) que = que[1:] if front.left != nil { que = append(que, front.left) } if front.right != nil { que = append(que, front.right) } } } æ ‘ä¸­çš„æœ€é•¿è·¯ é¢˜ç›®é“¾æ¥\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 1e5 + 5; int h[N], e[N], ne[N], idx; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; } int n, f[N], ans; void dfs(int u) { int a = 0, b = 0; for (int i = h[u]; ~i; i = ne[i]) { int v = e[i]; dfs(v); int t = f[v] + 1; if (t \u0026gt;= a) b = a, a = t; else if (t \u0026gt; b) b = t; } f[u] = a; ans = max(ans, a + b); } int main() { #ifndef ONLINE_JUDGE freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); memset(h, -1, sizeof h); cin \u0026gt;\u0026gt; n; int a, b; for (int i = 0; i \u0026lt; n - 1; i++) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; add(a, b); } dfs(1); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } RMQé—®é¢˜å†ä¸´ é¢˜ç›®é“¾æ¥\nä»£ç  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e4 + 5; struct node { int l, r, minv; } tree[N \u0026lt;\u0026lt; 2]; int n, m, a[N]; void build(int u, int l, int r) { if (l == r) tree[u] = {l, r, a[l]}; else { const int mid = l + r \u0026gt;\u0026gt; 1; build(u\u0026lt;\u0026lt;1, l, mid), build(u\u0026lt;\u0026lt;1|1, mid+1, r); tree[u] = {l, r, min(tree[u\u0026lt;\u0026lt;1].minv, tree[u\u0026lt;\u0026lt;1|1].minv)}; } } void update(int u, int i, int v) { if (tree[u].l == i \u0026amp;\u0026amp; tree[u].r == i) tree[u].minv = v; else { const int mid = tree[u].l + tree[u].r \u0026gt;\u0026gt; 1; if (i \u0026lt;= mid) update(u\u0026lt;\u0026lt;1, i, v); else update(u\u0026lt;\u0026lt;1|1, i, v); tree[u].minv = min(tree[u\u0026lt;\u0026lt;1].minv, tree[u\u0026lt;\u0026lt;1|1].minv); } } int query(int u, int l, int r) { if (tree[u].l == l \u0026amp;\u0026amp; tree[u].r == r) return tree[u].minv; const int mid = tree[u].l + tree[u].r \u0026gt;\u0026gt; 1; if (r \u0026lt;= mid) return query(u\u0026lt;\u0026lt;1, l, r); else if (l \u0026gt; mid) return query(u\u0026lt;\u0026lt;1|1, l, r); else return min(query(u\u0026lt;\u0026lt;1, l, mid), query(u\u0026lt;\u0026lt;1|1, mid+1, r)); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; cin \u0026gt;\u0026gt; m; build(1, 1, n); int a, b, c; while (m--) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; if (!a) cout \u0026lt;\u0026lt; query(1, b, c) \u0026lt;\u0026lt; endl; else update(1, b, c); } return 0; } æ— é—´é“ä¹‹å¹¶æŸ¥é›† é¢˜ç›®é“¾æ¥\nä»£ç  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class UF { vector\u0026lt;int\u0026gt; id, sz; public: UF(int N) { id.resize(N), sz.resize(N); for (int i = 0; i \u0026lt; N; i++) id[i] = i, sz[i] = 1; } int find(int x) { while (x != id[x]) { id[x] = id[id[x]]; x = id[x]; } return x; } bool is_connected(int p, int q) { int i = find(p), j = find(q); return i == j; } bool _union(int p, int q) { int i = find(p), j = find(q); if (i == j) return false; if (sz[i] \u0026lt; sz[j]) { id[i] = j; sz[j] += sz[i]; } else { id[j] = i; sz[i] += sz[j]; } return true; } }; unordered_map\u0026lt;string, int\u0026gt; M; int idx; int get_hash(const string \u0026amp;str) { if (M.count(str)) return M[str]; else return M[str] = idx++; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; UF uf(n); int op; string a, b; while (n--) { cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; int i = get_hash(a), j = get_hash(b); if (!op) uf._union(i, j); else { puts(uf.is_connected(i, j) ? \u0026#34;yes\u0026#34; : \u0026#34;no\u0026#34;); } } return 0; } äºŒåˆ†å›¾åˆ¤å®š é¢˜ç›®é“¾æ¥\næ€è·¯ æŸ“è‰²æ³•\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 1e4 + 5, M = 1e5; int h[N], e[M], ne[M], idx; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; } int n, m, color[N]; bool dfs(int u, int c) { color[u] = c; for (int i = h[u]; ~i; i = ne[i]) { int v = e[i]; if (color[v]) { if (color[v] == c) return false; } else if (!dfs(v, 3 - c)) return false; } return true; } int main() { ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int T; cin \u0026gt;\u0026gt; T; while (T--) { idx = 0; memset(h, -1, sizeof h); memset(color, 0, sizeof color); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int a, b; while (m--) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; add(a, b); add(b, a); } bool is_break = false; for (int i = 1; i \u0026lt;= n; i++) if (!color[i] \u0026amp;\u0026amp; !dfs(i, 1)) { is_break = true; break; } puts(is_break ? \u0026#34;Wrong\u0026#34; : \u0026#34;Correct\u0026#34;); } return 0; } çŒœå­—è°œ é¢˜ç›®é“¾æ¥\nä»£ç  class Solution { public: vector\u0026lt;int\u0026gt; findNumOfValidWords(vector\u0026lt;string\u0026gt;\u0026amp; words, vector\u0026lt;string\u0026gt;\u0026amp; puzzles) { unordered_map\u0026lt;int, int\u0026gt; mp; vector\u0026lt;int\u0026gt; ans(puzzles.size()); for (const auto \u0026amp;e : words) { int t = 0; for (const auto \u0026amp;c : e) t |= 1 \u0026lt;\u0026lt; (c - \u0026#39;a\u0026#39;); auto tmp = bitset\u0026lt;26\u0026gt;(t); if (tmp.count() \u0026gt; 7) continue; mp[t]++; } for (int i = 0; i \u0026lt; puzzles.size(); i++) { string p = puzzles[i]; int mask = 0; for (int i = 1; i \u0026lt; 7; i++) mask |= 1 \u0026lt;\u0026lt; (p[i] - \u0026#39;a\u0026#39;); int subset = mask; do { int t = subset | (1 \u0026lt;\u0026lt; (p[0] - \u0026#39;a\u0026#39;)); if (mp.count(t)) ans[i] += mp[t]; subset = (subset - 1) \u0026amp; mask; } while (subset != mask); } return ans; } }; è‡³å°‘æœ‰Kä¸ªé‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸² é¢˜ç›®é“¾æ¥\nCode in Golang func longestSubstring(s string, k int) (ans int) { if s == \u0026#34;\u0026#34; { return 0 } cnt := [26]int{} for _, v := range(s) { cnt[v-\u0026#39;a\u0026#39;]++ } var split byte for i, v := range(cnt) { if (v \u0026gt; 0 \u0026amp;\u0026amp; v \u0026lt; k) { split = \u0026#39;a\u0026#39; + byte(i) break } } if split == 0 { return len(s) } for _, v := range strings.Split(s, string(split)) { ans = max(ans, longestSubstring(v, k)) } return ans } func max(a, b int) int { if a \u0026gt; b { return a } return b } Code in Python class Solution: def longestSubstring(self, s: str, k: int) -\u0026gt; int: if len(s) \u0026lt; k: return 0 for v in set(s): if s.count(v) \u0026lt; k: return max(self.longestSubstring(t, k) for t in s.split(v)) return len(s) æ‰¾åˆ° K ä¸ªæœ€æ¥è¿‘çš„å…ƒç´  å †-$nlogk$åšæ³• class Solution { public: vector\u0026lt;int\u0026gt; findClosestElements(vector\u0026lt;int\u0026gt;\u0026amp; arr, int k, int x) { priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; Q; for (const auto \u0026amp;e : arr) { Q.push({abs(e - x), e}); if (Q.size() \u0026gt; k) Q.pop(); } vector\u0026lt;int\u0026gt; ans(k); int idx = 0; while (!Q.empty()) { ans[idx++] = Q.top().second; Q.pop(); } sort(ans.begin(), ans.end()); return ans; } }; äºŒåˆ†+åŒæŒ‡é’ˆ-$logn+k$åšæ³•(Rust) impl Solution { pub fn find_closest_elements(arr: Vec\u0026lt;i32\u0026gt;, k: i32, x: i32) -\u0026gt; Vec\u0026lt;i32\u0026gt; { let n: i32 = arr.len() as i32; let mut l: i32 = 0; let mut r: i32 = n - 1; while l \u0026lt; r { let mid: usize = ((l + r) / 2) as usize; if arr[mid] \u0026gt;= x { r = mid as i32; } else { l = (mid + 1) as i32; } } if r \u0026gt; 0 { let a = (i32::abs(arr[(r-1) as usize] - x), arr[(r-1) as usize]); let b = (i32::abs(arr[r as usize] - x), arr[r as usize]); if a \u0026lt; b { r -= 1; } } let mut i: i32 = r; let mut j: i32 = r; for u in 0..k-1 { if ((i - 1) \u0026lt; 0) { j += 1; } else if j + 1 \u0026gt;= n { i -= 1; } else { let a = (i32::abs(arr[(i-1) as usize] - x), arr[(i-1) as usize]); let b = (i32::abs(arr[(j+1) as usize] - x), arr[(j+1) as usize]); if a \u0026lt; b { i -= 1; } else { j += 1; } } } let mut ans = Vec::new(); for u in i..j+1 { ans.push(arr[u as usize]); } return ans; } } äºŒç»´åŒºåŸŸå’Œæ£€ç´¢ - çŸ©é˜µä¸å¯å˜ é¢˜ç›®é“¾æ¥\næ€è·¯ äºŒä½å‰ç¼€å’Œ æ„é€ : S[i][j] = a[i][j] + S[i-1][j] + S[i][j-1] - S[i-1][j-1] è®¡ç®—: ans = S[x2][y2] - S[x1-1][y2] - S[x2][y1-1] + S[x1-1][y1-1] ä»£ç  class NumMatrix { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; C; public: NumMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { if (matrix.empty()) return; const int n = matrix.size(), m = matrix[0].size(); C = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(n+1, vector\u0026lt;int\u0026gt;(m+1, 0)); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { C[i][j] = matrix[i-1][j-1] + C[i-1][j] + C[i][j-1] - C[i-1][j-1]; } } } int sumRegion(int row1, int col1, int row2, int col2) { int sum = C[row2+1][col2+1] - C[row1-1+1][col2+1] - C[row2+1][col1-1+1] + C[row1-1+1][col1-1+1]; return sum; } }; æ¯”ç‰¹ä½è®¡æ•°-åŠ¨æ€è§„åˆ’ é¢˜ç›®é“¾æ¥\næ€è·¯ y=x \u0026amp; (x - 1): yä¸ºå°†xçš„æœ€ä½è®¾ç½®ä½ä»1å˜æˆ0ä¹‹åçš„æ•° çŠ¶æ€å®šä¹‰ï¼šf[i]: içš„æ¯”ç‰¹ä½ä¸­1çš„ä¸ªæ•° çŠ¶æ€è®¡ç®—: f[i] = f[i \u0026amp; (i-1)] ä»£ç  class Solution { public: vector\u0026lt;int\u0026gt; countBits(int num) { vector\u0026lt;int\u0026gt; f(num+1); for (int i = 1; i \u0026lt;= num; i++) f[i] = f[i\u0026amp;(i-1)] + 1; return f; } }; class Solution: def countBits(self, num: int) -\u0026gt; List[int]: f = [0] * (num + 1) for i in range(1, num + 1): f[i] = f[i \u0026amp; (i - 1)] + 1 return f class Solution { public int[] countBits(int num) { int[] f = new int[num+1]; for (int i = 1; i \u0026lt;= num; i++) f[i] = f[i \u0026amp; (i - 1)] + 1; return f; } } func countBits(num int) []int { f := make([]int, num+1) for i := 1; i \u0026lt;= num; i++ { f[i] = f[i \u0026amp; (i - 1)] + 1 } return f } ä¿„ç½—æ–¯å¥—å¨ƒä¿¡å°é—®é¢˜-LIS é¢˜ç›®é“¾æ¥\nè§£é¢˜æ€è·¯ LISå˜å½¢\nä»£ç  $O(n^2)$ class Solution { public: int maxEnvelopes(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; E) { if (E.empty()) return 0; sort(begin(E), end(E), [](vector\u0026lt;int\u0026gt; a, vector\u0026lt;int\u0026gt; b) { return (a[0] \u0026lt; b[0] || (a[0] == b[0] \u0026amp;\u0026amp; a[1] \u0026gt; b[1])); }); const int n = E.size(); vector\u0026lt;int\u0026gt; f(n); for (int i = 0; i \u0026lt; n; i++) { f[i] = 1; for (int j = 0; j \u0026lt; i; j++) { if (E[i][1] \u0026gt; E[j][1]) f[i] = max(f[i], f[j] + 1); } } return *max_element(begin(f), end(f)); } }; $O(nlogn)$ class Solution { public: int maxEnvelopes(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; E) { if (E.empty()) return 0; sort(begin(E), end(E), [](vector\u0026lt;int\u0026gt; a, vector\u0026lt;int\u0026gt; b) { return (a[0] \u0026lt; b[0] || (a[0] == b[0] \u0026amp;\u0026amp; a[1] \u0026gt; b[1])); }); const int n = E.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f; for (int i = 0; i \u0026lt; n; i++) { auto it = lower_bound(begin(f), end(f), E[i], [](vector\u0026lt;int\u0026gt; a, vector\u0026lt;int\u0026gt; b) {return a[1] \u0026lt; b[1];}); if (it == f.end()) f.push_back(E[i]); else *it = E[i]; } for (int i = 0; i \u0026lt; f.size(); i++) cout \u0026lt;\u0026lt; f[i][0] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; f[i][1] \u0026lt;\u0026lt; endl; return f.size(); } }; ç”¨æ ˆå®ç°é˜Ÿåˆ—-åŒæ ˆ é¢˜ç›®é“¾æ¥\næ€è·¯ åŒæ ˆå®ç°é˜Ÿåˆ— å½“peek()å’Œpop()æ—¶ï¼Œå¦‚æœè¾“å‡ºæ ˆä¸ºç©ºï¼Œåˆ™å°†è¾“å…¥æ ˆå†…å®¹ä¾æ¬¡å¼¹å‡ºï¼Œå¹¶å‹å…¥è¾“å‡ºæ ˆ ä»£ç  ä»£ç  class MyQueue { stack\u0026lt;int\u0026gt; _in, out; void work() { while (!_in.empty()) { out.push(_in.top()); _in.pop(); } } public: /** _initialize your data structure here. */ MyQueue() { } /** Push element x to the back of queue. */ void push(int x) { _in.push(x); } /** Removes the element from _in front of queue and returns that element. */ int pop() { if (out.empty()) work(); auto res = out.top(); out.pop(); return res; } /** Get the front element. */ int peek() { if (out.empty()) work(); auto res = out.top(); return res; } /** Returns whether the queue is empty. */ bool empty() { return _in.empty() \u0026amp;\u0026amp; out.empty(); } }; /** * Your MyQueue object will be _instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj-\u0026gt;push(x); * _int param_2 = obj-\u0026gt;pop(); * _int param_3 = obj-\u0026gt;peek(); * bool param_4 = obj-\u0026gt;empty(); */ ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ -å•è°ƒæ ˆ é¢˜ç›®é“¾æ¥\næ€è·¯ å•è°ƒæ ˆå†…å¯¹åº”å…ƒç´ å•è°ƒä¸å¢ å½“é‡åˆ°ä¸€ä¸ªæ¯”å½“å‰æ ˆé¡¶å…ƒç´ å¤§çš„å…ƒç´ ï¼Œåˆ™å‡ºæ ˆï¼Œå¹¶ä¸”å‡ºæ ˆå…ƒç´ ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ ä¸ºå½“å‰å…ƒç´  å› ä¸ºç¯ï¼Œæ‰€ä»¥å°†ä¸‹æ ‡æ˜ å°„è‡³1..2n-1 ä»£ç  C++ class Solution { public: vector\u0026lt;int\u0026gt; nextGreaterElements(vector\u0026lt;int\u0026gt;\u0026amp; nums) { const int n = nums.size(); vector\u0026lt;int\u0026gt; ans(n, -1); stack\u0026lt;int\u0026gt; the_stack; for (int i = 0; i \u0026lt; 2 * n; i++) { while (!the_stack.empty() \u0026amp;\u0026amp; nums[i % n] \u0026gt; nums[the_stack.top()]) { ans[the_stack.top()] = nums[i % n]; the_stack.pop(); } the_stack.push(i % n); } return ans; } }; Java class Solution { public int[] nextGreaterElements(int[] nums) { final var n = nums.length; var ans = new int[n]; Arrays.fill(ans, -1); Stack\u0026lt;Integer\u0026gt; S = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 2 * n; i++) { while (!S.isEmpty() \u0026amp;\u0026amp; nums[S.peek()] \u0026lt; nums[i % n]) ans[S.pop()] = nums[i % n]; S.push(i % n); } return ans; } } Python3 class Solution: def nextGreaterElements(self, nums: List[int]) -\u0026gt; List[int]: n = len(nums) ans = [-1] * n the_stack = [] for i in range(2 * n): while the_stack and (nums[i % n] \u0026gt; nums[the_stack[-1]]): ans[the_stack.pop()] = nums[i % n] the_stack.append(i % n) return ans Golang func nextGreaterElements(nums []int) []int { n := len(nums) ans := make([]int, n) for i := range(ans) { ans[i] = -1 } stack := []int{} for i := 0; i \u0026lt; 2 * n; i++ { for len(stack) \u0026gt; 0 \u0026amp;\u0026amp; nums[i % n] \u0026gt; nums[stack[len(stack)-1]] { ans[stack[len(stack)-1]] = nums[i % n] stack = stack[:len(stack)-1] } stack = append(stack, i % n) } return ans } åˆ†å‰²å›æ–‡ä¸² é¢˜ç›®é“¾æ¥\næ€è·¯ dfs + DPé¢„å¤„ç† f[i][j] = f[i+1][j-1] \u0026amp;\u0026amp; (s[i] == s[j])\nä»£ç  class Solution { public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; partition(string s) { const int n = s.length(); vector\u0026lt;string\u0026gt; tmp; vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; ans; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; f(n, vector\u0026lt;bool\u0026gt;(n, true)); for (int i = n - 1; i \u0026gt;= 0; i--) { for (int j = i + 1; j \u0026lt; n; j++) f[i][j] = f[i+1][j-1] \u0026amp;\u0026amp; (s[i] == s[j]); } function\u0026lt;void(int)\u0026gt; dfs = [\u0026amp;](int i) { if (i \u0026gt;= n) { ans.push_back(tmp); return; } for (int j = i; j \u0026lt; n; j++) { if (f[i][j]) { tmp.push_back(s.substr(i, j - i + 1)); dfs(j+1); tmp.pop_back(); } } }; dfs(0); return ans; } }; ä»ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å‡ºå‘åˆ°æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„å—é™è·¯å¾„æ•°-è®°å¿†åŒ–æœç´¢ é¢˜ç›®é“¾æ¥\næ€è·¯ å•æºæœ€çŸ­è·¯+è®°å¿†åŒ–æœç´¢\nä»£ç  const int N = 2e4 + 5, M = 8e4 + 10; int h[N], e[M], ne[M], w[M], idx; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; } class Solution { public: int countRestrictedPaths(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges) { idx = 0; memset(h, -1, sizeof h); for (const auto \u0026amp;e : edges) { add(e[0], e[1], e[2]); add(e[1], e[0], e[2]); } vector\u0026lt;int\u0026gt; dist(n + 1, INT_MAX); vector\u0026lt;bool\u0026gt; st(n + 1, false); priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; Q; Q.push({0, n}); dist[n] = 0; while (!Q.empty()) { auto [wgt, u] = Q.top(); Q.pop(); if (st[u]) continue; st[u] = true; dist[u] = -wgt; for (int i = h[u]; ~i; i = ne[i]) { int v = e[i]; if (-wgt + w[i] \u0026lt; dist[v]) { dist[v] = -wgt + w[i]; Q.push({-dist[v], v}); } } } const int mod = 1e9 + 7; vector\u0026lt;int\u0026gt; f(n + 1, INT_MAX); function\u0026lt;int(int)\u0026gt; dfs = [\u0026amp;](int u) { if (u == n) return 1; if (f[u] != INT_MAX) return f[u]; int ans = 0; for (int i = h[u]; ~i; i = ne[i]) { int v = e[i]; if (dist[u] \u0026gt; dist[v]) ans = (ans + dfs(v)) % mod; } return f[u] = ans; }; return dfs(1); } }; å…¬å…±é’¥åŒ™ç›’-æ¨¡æ‹Ÿ é¢˜ç›®é“¾æ¥\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;tuple\u0026gt; using namespace std; const int N = 1005; pair\u0026lt;int, int\u0026gt; T[N]; int n, k, a[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); priority_queue\u0026lt;tuple\u0026lt;int, bool, int\u0026gt;\u0026gt; Q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; int w, s, c; for (int i = 1; i \u0026lt;= n; i++) a[i] = i; while (k--) { cin \u0026gt;\u0026gt; w \u0026gt;\u0026gt; s \u0026gt;\u0026gt; c; T[w] = {s, c}; Q.push({ -s, false, -w}); Q.push({ -(s + c), true, -w}); } while (Q.size()) { auto it = Q.top(); auto t = get\u0026lt;0\u0026gt;(it); auto b = get\u0026lt;1\u0026gt;(it); auto w = get\u0026lt;2\u0026gt;(it); Q.pop(); if (!b) { for (int i = 1; i \u0026lt;= n; i++) if (a[i] == -w) { a[i] = 0; break; } } else { for (int i = 1; i \u0026lt;= n; i++) if (!a[i]) { a[i] = -w; break; } } } for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; return 0; } åŸºæœ¬è®¡ç®—å™¨-æ ˆ é¢˜ç›®é“¾æ¥\nä»£ç  class Solution { public: int calculate(string s) { stack\u0026lt;int\u0026gt; sign; sign.push(1); int cur = 1; int ans = 0; const int n = s.length(); for (int i = 0; i \u0026lt; n; i++) { if (s[i] == \u0026#39; \u0026#39;) continue; else if (s[i] == \u0026#39;+\u0026#39;) cur = sign.top(); else if (s[i] == \u0026#39;-\u0026#39;) cur = -sign.top(); else if (s[i] == \u0026#39;(\u0026#39;) sign.push(cur); else if (s[i] == \u0026#39;)\u0026#39;) sign.pop(); else { int sum = 0; while (i \u0026lt; n \u0026amp;\u0026amp; s[i] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; s[i] \u0026lt;= \u0026#39;9\u0026#39;) { sum = sum * 10 + (s[i] - \u0026#39;0\u0026#39;); ++i; } --i; ans += sum * cur; } } return ans; } }; åŸºæœ¬è®¡ç®—å™¨II-æ ˆ é¢˜ç›®é“¾æ¥\næ€è·¯ å¦‚æœæ•°å­—å‰æ˜¯+, å°†æ•°å­—å‹æ ˆ å¦‚æœæ•°å­—å‰æ˜¯-, å°†æ•°å­—ç›¸åæ•°å‹æ ˆ å¦‚æœæ•°å­—å‰æ˜¯*, å°†æ ˆé¡¶å…ƒç´ ä¹˜ä»¥æ•°å­— å¦‚æœæ•°å­—å‰æ˜¯/, å°†æ ˆé¡¶å…ƒç´ é™¤ä»¥æ•°å­— ä»£ç  func calculate(s string) int { stack := []int{} num := 0 pre := \u0026#39;+\u0026#39; for i, v := range(s) { if v \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; v \u0026lt;= \u0026#39;9\u0026#39; { num = num * 10 + int(v - \u0026#39;0\u0026#39;) } if (!(v \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; v \u0026lt;= \u0026#39;9\u0026#39;) \u0026amp;\u0026amp; v != \u0026#39; \u0026#39;) || i == len(s)-1 { switch pre { case \u0026#39;+\u0026#39;: stack = append(stack, num) case \u0026#39;-\u0026#39;: stack = append(stack, -num) case \u0026#39;*\u0026#39;: stack[len(stack)-1] *= num case \u0026#39;/\u0026#39;: stack[len(stack)-1] /= num } pre = v num = 0 } } ans := 0 for _, v := range(stack) { ans += v } return ans } éªŒè¯äºŒå‰æ ‘çš„å‰åºåºåˆ—åŒ– é¢˜ç›®é“¾æ¥\nè§£é¢˜æ€è·¯ éå†è¿‡ç¨‹ä¸­ï¼š\næ ¹ç»“ç‚¹æä¾›ä¸¤ä¸ªå‡ºåº¦ é™¤äº†æ ¹ç»“ç‚¹ä»¥å¤–çš„éç©ºç»“ç‚¹æä¾›ä¸€ä¸ªå…¥åº¦æ•°ã€ä¸¤ä¸ªå‡ºåº¦ ç©ºç»“ç‚¹æä¾›ä¸€ä¸ªå…¥åº¦ è¿˜æ²¡éå†ç»“æŸæ—¶å€™æ»¡è¶³ï¼šå…¥åº¦ \u0026lt; å‡ºåº¦\nä»£ç  func isValidSerialization(preorder string) bool { if preorder == \u0026#34;#\u0026#34; { return true } res := strings.Split(preorder, \u0026#34;,\u0026#34;) in, out := 0, 0 for i := range(res) { if i == 0 { if res[i] == \u0026#34;#\u0026#34; { return false } out += 2 continue } if res[i] == \u0026#34;#\u0026#34; { in++ } else { in++ out += 2 } if i != len(res)-1 \u0026amp;\u0026amp; out \u0026lt;= in { return false } } return in == out } è®¾è®¡å“ˆå¸Œé›†åˆ é¢˜ç›®é“¾æ¥\næ€è·¯ æ‹‰é“¾æ³•\nä»£ç  C++ constexpr int N = 10007; class MyHashSet { int h[N], e[N], ne[N], idx; public: /** Initialize your data structure here. */ MyHashSet() { idx = 0; memset(h, -1, sizeof h); } void add(int key) { if (!contains(key)) { int k = key % N; e[idx] = key; ne[idx] = h[k]; h[k] = idx++; } } void remove(int key) { int k = key % N; if (h[k] == -1) return; if (e[h[k]] == key) // ç¬¬ä¸€ä¸ªç»“ç‚¹å°±æ˜¯ h[k] = ne[h[k]]; for (int i = h[k]; ~i \u0026amp;\u0026amp; ~ne[i]; i = ne[i]) { if (e[ne[i]] == key) { ne[i] = ne[ne[i]]; } } } /** Returns true if this set contains the specified element */ bool contains(int key) { int k = key % N; for (int i = h[k]; ~i; i = ne[i]) { if (e[i] == key) return true; } return false; } }; Golang const N = 10007 type MyHashSet struct { h []int e []int ne []int idx int } /** Initialize your data structure here. */ func Constructor() MyHashSet { t := make([]int, N) for i := range(t) { t[i] = -1 } return MyHashSet{t, make([]int, N), make([]int, N), 0} } func (this *MyHashSet) Add(key int) { if !this.Contains(key) { k := (key % N + N) % N this.e[this.idx] = key this.ne[this.idx] = this.h[k] this.h[k] = this.idx this.idx++ } } func (this *MyHashSet) Remove(key int) { k := (key % N + N) % N if this.h[k] == -1 { return } if this.e[this.h[k]] == key { this.h[k] = this.ne[this.h[k]] } for i := this.h[k]; i != -1 \u0026amp;\u0026amp; this.ne[i] != -1; i = this.ne[i] { if this.e[this.ne[i]] == key { this.ne[i] = this.ne[this.ne[i]] } } } /** Returns true if this set contains the specified element */ func (this *MyHashSet) Contains(key int) bool { k := (key % N + N) % N for i := this.h[k]; i != -1; i = this.ne[i] { if this.e[i] == key { return true } } return false } è®¾è®¡å“ˆå¸Œæ˜ å°„ é¢˜ç›®é“¾æ¥\næ€è·¯ æ‹‰é“¾æ³•\nä»£ç  const N = 10007 type Pair struct { k int v int } type MyHashMap struct { h []int e []Pair ne []int idx int } /** Initialize your data structure here. */ func Constructor() MyHashMap { h := make([]int, N) for i := range(h) { h[i] = -1 } return MyHashMap{h, make([]Pair, N), make([]int, N), 0} } /** value will always be non-negative. */ func (this *MyHashMap) Put(key int, value int) { if this.Get(key) == -1 { k := (key % N + N) % N this.e[this.idx] = Pair{key, value} this.ne[this.idx] = this.h[k] this.h[k] = this.idx this.idx++ } else { k := (key % N + N) % N for i := this.h[k]; i != -1; i = this.ne[i] { if this.e[i].k == key { this.e[i].v = value } } } } /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */ func (this *MyHashMap) Get(key int) int { k := (key % N + N) % N for i := this.h[k]; i != -1; i = this.ne[i] { if this.e[i].k == key { return this.e[i].v } } return -1 } /** Removes the mapping of the specified value key if this map contains a mapping for the key */ func (this *MyHashMap) Remove(key int) { k := (key % N + N) % N if this.h[k] == -1 { return } if this.e[this.h[k]].k == key { this.h[k] = this.ne[this.h[k]] } for i := this.h[k]; i != -1 \u0026amp;\u0026amp; this.ne[i] != -1; i = this.ne[i] { if this.e[this.ne[i]].k == key { this.ne[i] = this.ne[this.ne[i]] } } } ä¸åŒçš„å­åºåˆ—-DP æ€è·¯ $$ f[i][j] = \\begin{cases} f[i+1][j+1] + f[i+1][j], \u0026amp;s[i] = t[j]\u0026amp; \\cr f[i+1][j], \u0026amp;s[i] \\ne t[j] \\end{cases} $$\nä»£ç  func numDistinct(s string, t string) int { n, m := len(s), len(t) if n \u0026lt; m { return 0 } f := make([][]int, n+1) for i := range f { f[i] = make([]int, m+1) f[i][m] = 1 } for i := n-1; i \u0026gt;= 0; i-- { for j := m-1; j \u0026gt;= 0; j-- { if s[i] == t[j] { f[i][j] = f[i+1][j+1] + f[i+1][j] } else { f[i][j] = f[i+1][j] } } } return f[0][0] } åè½¬é“¾è¡¨II é¢˜ç›®é“¾æ¥\næ€è·¯ åˆ›å»ºå¤´ç»“ç‚¹ a := m-1 å°†[m+1,n]æŒ‡é’ˆåè½¬ a-\u0026gt;next-\u0026gt;next = n+1 a-\u0026gt;next = n ä»£ç  func reverseBetween(head *ListNode, left int, right int) *ListNode { dummy := \u0026amp;ListNode{0, head} a := dummy for i := 0; i \u0026lt; left-1; i++ { a = a.Next } pre, cur := a.Next, a.Next.Next for i := 0; i \u0026lt; right-left; i++ { tmp := cur.Next cur.Next = pre pre = cur cur = tmp } a.Next.Next = cur a.Next = pre return dummy.Next } åè½¬é“¾è¡¨ é¢˜ç›®é“¾æ¥\nè¿­ä»£æ³• func reverseList(head *ListNode) *ListNode { var pre *ListNode cur := head for cur != nil { tmp := cur.Next cur.Next = pre pre = cur cur = tmp } return pre } é€’å½’æ³• æ€è·¯ é¦–å…ˆæˆ‘ä»¬å…ˆè€ƒè™‘ reverseList å‡½æ•°èƒ½åšä»€ä¹ˆï¼Œå®ƒå¯ä»¥ç¿»è½¬ä¸€ä¸ªé“¾è¡¨ï¼Œå¹¶è¿”å›æ–°é“¾è¡¨çš„å¤´èŠ‚ç‚¹ï¼Œä¹Ÿå°±æ˜¯åŸé“¾è¡¨çš„å°¾èŠ‚ç‚¹ã€‚ æ‰€ä»¥æˆ‘ä»¬å¯ä»¥å…ˆé€’å½’å¤„ç† reverseList(head-\u0026gt;next)ï¼Œè¿™æ ·æˆ‘ä»¬å¯ä»¥å°†ä»¥head-\u0026gt;nextä¸ºå¤´èŠ‚ç‚¹çš„é“¾è¡¨ç¿»è½¬ï¼Œå¹¶å¾—åˆ°åŸé“¾è¡¨çš„å°¾èŠ‚ç‚¹tailï¼Œæ­¤æ—¶head-\u0026gt;nextæ˜¯æ–°é“¾è¡¨çš„å°¾èŠ‚ç‚¹ï¼Œæˆ‘ä»¬ä»¤å®ƒçš„nextæŒ‡é’ˆæŒ‡å‘headï¼Œå¹¶å°†head-\u0026gt;nextæŒ‡å‘ç©ºå³å¯å°†æ•´ä¸ªé“¾è¡¨ç¿»è½¬ï¼Œä¸”æ–°é“¾è¡¨çš„å¤´èŠ‚ç‚¹æ˜¯tail ä»£ç  func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } tail := reverseList(head.Next) head.Next.Next = head head.Next = nil return tail } è¡¨è¾¾å¼æ±‚å€¼-æ ˆ é¢˜ç›®é“¾æ¥\næ€è·¯ ä½¿ç”¨ä¸¤ä¸ªæ ˆï¼Œä¸€ä¸ªå­˜æ“ä½œæ•°ï¼Œå¦ä¸€ä¸ªå­˜è¿ç®—ç¬¦ é‡åˆ°å·¦æ‹¬å·å…¥æ ˆï¼Œé‡åˆ°å³æ‹¬å·è¿›è¡Œè®¡ç®—ç›´åˆ°æ ˆé¡¶ä¸ºå·¦æ‹¬å· ä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;stack\u0026gt; using namespace std; int main() { string str; cin \u0026gt;\u0026gt; str; const int n = str.length(); stack\u0026lt;int\u0026gt; stk; stack\u0026lt;char\u0026gt; op; auto calculate = [\u0026amp;]() { int a = stk.top(); stk.pop(); int b = stk.top(); stk.pop(); char c = op.top(); op.pop(); switch (c) { case \u0026#39;+\u0026#39;: stk.push(b + a); break; case \u0026#39;-\u0026#39;: stk.push(b - a); break; case \u0026#39;*\u0026#39;: stk.push(b * a); break; case \u0026#39;/\u0026#39;: stk.push(b / a); break; } }; unordered_map\u0026lt;char, int\u0026gt; mp = {{\u0026#39;+\u0026#39;, 1}, {\u0026#39;-\u0026#39;, 1}, {\u0026#39;*\u0026#39;, 2}, {\u0026#39;/\u0026#39;, 2}}; for (int i = 0; i \u0026lt; n; i++) { auto c = str[i]; if (isdigit(c)) { int j = i; int num = 0; while (j \u0026lt; n \u0026amp;\u0026amp; isdigit(str[j])) { num = num * 10 + str[j] - \u0026#39;0\u0026#39;; j++; } stk.push(num); i = j - 1; } else if (c == \u0026#39;(\u0026#39;) { op.push(c); } else if (c == \u0026#39;)\u0026#39;) { while (op.size() \u0026amp;\u0026amp; op.top() != \u0026#39;(\u0026#39;) { calculate(); } op.pop(); } else { while (op.size() \u0026amp;\u0026amp; mp[op.top()] \u0026gt;= mp[c]) { calculate(); } op.push(c); } } while (op.size()) { calculate(); } cout \u0026lt;\u0026lt; stk.top() \u0026lt;\u0026lt; endl; return 0; } çŸ©é˜µç½®é›¶ é¢˜ç›®é“¾æ¥\næ€è·¯ ç”¨ä¸¤ä¸ªå˜é‡è®°å½•ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—æ˜¯å¦æœ‰0ã€‚ éå†æ•´ä¸ªçŸ©é˜µï¼Œç”¨çŸ©é˜µçš„ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—è®°å½•å¯¹åº”çš„è¡Œå’Œåˆ—æ˜¯å¦æœ‰0ã€‚ æŠŠå«æœ‰0çš„è¡Œå’Œåˆ—éƒ½ç½®æˆ0ã€‚ ä»£ç  func setZeroes(matrix [][]int) { n, m := len(matrix), len(matrix[0]) r0, c0 := 1, 1 // ç¬¬0è¡Œæ˜¯å¦åº”è¯¥ç½®ä¸º0 for i := 0; i \u0026lt; m; i++ { if matrix[0][i] == 0 { r0 = 0 } } // ç¬¬0åˆ—æ˜¯å¦åº”è¯¥ç½®ä¸º0 for i := 0; i \u0026lt; n; i++ { if matrix[i][0] == 0 { c0 = 0 } } for i := 1; i \u0026lt; n; i++ { for j := 1; j \u0026lt; m; j++ { if matrix[i][j] == 0 { matrix[i][0] = 0 matrix[0][j] = 0 } } } // matrix[0][i]è¡¨ç¤ºç¬¬iåˆ—æ˜¯å¦è¯¥ç½®ä¸º0 // matrix[i][0]è¡¨ç¤ºç¬¬iè¡Œæ˜¯å¦è¯¥ç½®ä¸º0 // æŠŠå«æœ‰0çš„è¡Œå’Œåˆ—éƒ½ç½®æˆ0 ç”¨ç¬¬0è¡Œå’Œç¬¬0åˆ—æ ‡è®° for i := 1; i \u0026lt; m; i++ { if matrix[0][i] == 0 { for j := 1; j \u0026lt; n; j++ { matrix[j][i] = 0 } } } for i := 1; i \u0026lt; n; i++ { if matrix[i][0] == 0 { for j := 1; j \u0026lt; m; j++ { matrix[i][j] = 0 } } } if r0 == 0 { for i := 0; i \u0026lt; m; i++ { matrix[0][i] = 0 } } if c0 == 0 { for i := 0; i \u0026lt; n; i++ { matrix[i][0] = 0 } } } ä¸ç”¨åŠ å‡ä¹˜é™¤åšåŠ æ³• é¢˜ç›®é“¾æ¥\næ€è·¯ ä¸¤ä¸ªæ•´æ•°åšå¼‚æˆ–è¿ç®—ï¼Œå¾—åˆ°ä¸è¿›ä½åŠ æ³•çš„è¿ç®—ç»“æœ ä¸¤ä¸ªæ•´æ•°åšä¸è¿ç®—ï¼Œç„¶åå·¦ç§»ä¸€ä½ï¼Œå¾—åˆ°è¿›ä½çš„è¿ç®—ç»“æœ å°†ä¸Šé¢å¾—åˆ°çš„ä¸¤ä¸ªç»“æœç›¸åŠ ï¼Œå³é‡å¤ä¸Šè¿°æ­¥éª¤ç›´åˆ°è¿›ä½çš„ç»“æœä¸º0 ä»£ç  func add(num1 int, num2 int) int { for num2 != 0 { sum, carry := num1 ^ num2, (num1 \u0026amp; num2) \u0026lt;\u0026lt; 1 num1, num2 = sum, carry } return num1 } 132æ¨¡å¼-å•è°ƒæ ˆ é¢˜ç›®é“¾æ¥\næ€è·¯ ä»å³åˆ°å·¦ç»´æŠ¤ä¸€ä¸ªå•è°ƒé€’å‡çš„æ ˆ ç»´æŠ¤ä¸€ä¸ªæ¬¡å¤§å€¼(åˆå§‹å€¼ä¸ºINT_MIN) å¦‚æœå½“å‰çš„å€¼å°äºæ¬¡å¤§å€¼åˆ™æ‰¾åˆ°132å­åºåˆ— ä»£ç  func find132pattern(nums []int) bool { n := len(nums) stk := make([]int, 0) second := math.MinInt64 for i := n - 1; i \u0026gt;= 0; i-- { if nums[i] \u0026lt; second { return true } for len(stk) \u0026gt; 0 \u0026amp;\u0026amp; stk[len(stk)-1] \u0026lt; nums[i] { second = stk[len(stk)-1] stk = stk[:len(stk)-1] } stk = append(stk, nums[i]) } return false } ç›´æ–¹å›¾ä¸­æœ€å¤§çŸ©å½¢-å•è°ƒæ ˆ é¢˜ç›®é“¾æ¥\næ€è·¯ å•è°ƒæ ˆå¯ä»¥è§£å†³ï¼šå·¦è¾¹æ¯”å½“å‰å€¼å¤§æˆ–å°çš„ç¬¬ä¸€ä¸ªæ•°\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; constexpr int N = 100005; int n, h[N], l[N], r[N], stk[N]; void work() { for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;h[i]); // è®¾ç½®è¾¹ç•Œä¸º-1 h[0] = h[n+1] = -1; // å¯»æ‰¾å·¦è¾¹ç•Œ stk[0] = 0; int tt = 0; for (int i = 1; i \u0026lt;= n; i++) { while (h[stk[tt]] \u0026gt;= h[i]) { tt--; } l[i] = stk[tt]; stk[++tt] = i; } // å¯»æ‰¾å·¦è¾¹ç•Œ stk[0] = n+1; tt = 0; for (int i = n; i \u0026gt;= 1; i--) { while (h[stk[tt]] \u0026gt;= h[i]) { tt--; } r[i] = stk[tt]; stk[++tt] = i; } long long ans = 0; for (int i = 1; i \u0026lt;= n; i++) { ans = max(ans, h[i] * 1ll * (r[i]-l[i]-1)); } printf(\u0026#34;%lld\\n\u0026#34;, ans); } int main() { while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;n)) { if (!n) return 0; work(); } return 0; } åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´  é¢˜ç›®é“¾æ¥\næ€è·¯ preä¿å­˜å½“å‰ç»“ç‚¹å‰é©±ç»“ç‚¹ æ‰¾åˆ°å³è¾¹ç¬¬ä¸€ä¸ªä¸ç›¸ç­‰çš„ç»“ç‚¹right å¦‚æœcur.Next == rightåˆ™ä¸ç”¨åˆ ï¼Œå¦åˆ™pre.Next = rightåˆ é™¤ ä»£ç  func deleteDuplicates(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } pre := \u0026amp;ListNode{0, head} ans, cur := pre, head for cur != nil { right := cur for right != nil \u0026amp;\u0026amp; right.Val == cur.Val { right = right.Next } if cur.Next == right { pre = cur } else { pre.Next = right } cur = right } return ans.Next } å¯è¾¾æ€§ç»Ÿè®¡-æ‹“æ‰‘æ’åº é¢˜ç›®é“¾æ¥\næ€è·¯ ä»xå‡ºå‘èƒ½å¤Ÿåˆ°è¾¾çš„ç‚¹ï¼Œæ˜¯ä»â€œxçš„å„ä¸ªåç»­èŠ‚ç‚¹yâ€å‡ºå‘èƒ½å¤Ÿåˆ°è¾¾çš„ç‚¹çš„å¹¶é›†ï¼Œå†åŠ ä¸Šxç‚¹æœ¬èº« å¯ä»¥æ±‚å‡ºæ‹“æ‰‘åºï¼ŒæŒ‰ç…§æ‹“æ‰‘åºé€†åºè¿›è¡Œè®¡ç®— ä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;bitset\u0026gt; using namespace std; const int N = 30005; int h[N], ne[N], e[N], idx, d[N]; int n, m; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; } int seq[N], cnt; bitset\u0026lt;N\u0026gt; f[N]; void toposort() { int que[N]; int hh = 0, tt = -1; for (int i = 1; i \u0026lt;= n; i++) if (!d[i]) que[++tt] = i; while (hh \u0026lt;= tt) { int front = que[hh++]; seq[cnt++] = front; for (int i = h[front]; ~i; i = ne[i]) { int j = e[i]; if (--d[j] == 0) que[++tt] = j; } } } int main() { memset(h, -1, sizeof h); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); int a, b; while (m--) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); add(a, b); d[b]++; } toposort(); for (int i = n-1; ~i; i--) { int j = seq[i]; f[j][j] = 1; for (int k = h[j]; ~k; k = ne[k]) { f[j] |= f[e[k]]; } } for (int i = 1; i \u0026lt;= n; i++) printf(\u0026#34;%lld\\n\u0026#34;, f[i].count()); return 0; } äºŒå‰æ ‘çš„ä¸‹ä¸€ä¸ªç»“ç‚¹ é¢˜ç›®é“¾æ¥\næ€è·¯ è‹¥å½“å‰ç»“ç‚¹æœ‰å³å„¿å­ï¼Œåˆ™å³å­æ ‘ä¸­æœ€å·¦ä¾§çš„ç»“ç‚¹å°±æ˜¯å½“å‰ç»“ç‚¹çš„åç»§ å¦‚æœå½“å‰æ²¡æœ‰å³å„¿å­ï¼Œåˆ™è¦æ²¿ç€fatheråŸŸä¸€ç›´å‘ä¸Šæ‰¾ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªæ˜¯å…¶fatherå·¦å„¿å­çš„ç»“ç‚¹ï¼Œè¯¥ç»“ç‚¹çš„fatherå°±æ˜¯å½“å‰ç»“ç‚¹çš„åç»§ ä»£ç  func inorderSuccessor(p *TreeNode) *TreeNode { if p.Right != nil { p = p.Right for p.Left != nil { p = p.Left } return p } for (p.Father != nil \u0026amp;\u0026amp; p == p.Father.Right) { p = p.Father } return p.Father } äºŒå‰æœç´¢æ ‘è¿­ä»£å™¨-ä¸­åºéå†éé€’å½’ é¢˜ç›®é“¾æ¥\næ€è·¯ å°†æ ¹èŠ‚ç‚¹çš„å·¦é“¾å…¥æ ˆ å½“å–å‡ºä¸€ä¸ªå…ƒç´ åï¼Œå¦‚æœè¿™ä¸ªç»“ç‚¹æœ‰å³å­æ ‘ï¼Œåˆ™å°†å…¶å³å­æ ‘çš„å·¦é“¾å…¥æ ˆ ä»£ç  type BSTIterator struct { stk []*TreeNode } func Constructor(root *TreeNode) BSTIterator { stk := make([](*TreeNode), 0) for root != nil { stk = append(stk, root) root = root.Left } return BSTIterator{stk} } func (this *BSTIterator) Next() int { root := this.stk[len(this.stk)-1] this.stk = this.stk[:len(this.stk)-1] ret := root.Val root = root.Right for root != nil { this.stk = append(this.stk, root) root = root.Left } return ret } func (this *BSTIterator) HasNext() bool { return len(this.stk) \u0026gt; 0 } ç¿»è½¬å•è¯é¡ºåº é¢˜ç›®é“¾æ¥\næ€è·¯ å°†æ•´ä¸ªå­—ç¬¦ä¸²ç¿»è½¬ ç¿»è½¬æ¯ä¸ªå•è¯ æ—¶é—´å¤æ‚åº¦ ç©ºé—´å¤æ‚åº¦ $O(n)$ $O(1)$ ä»£ç  class Solution { public: string reverseWords(string s) { const int n = s.length(); reverse(begin(s), end(s)); for (int i = 0; i \u0026lt; n; i++) { int j = i + 1; while (j \u0026lt; n \u0026amp;\u0026amp; s[j] != \u0026#39; \u0026#39;) ++j; reverse(begin(s) + i, begin(s) + j); i = j; } return s; } }; æœç´¢äºŒç»´çŸ©é˜µ-äºŒåˆ† é¢˜ç›®é“¾æ¥\nä»£ç  æ—¶é—´å¤æ‚åº¦ ç©ºé—´å¤æ‚åº¦ $O(log(n^2)) = O(logn)$ $O(1)$ func searchMatrix(M [][]int, target int) bool { n, m := len(M), len(M[0]) l, r := 0, n * m - 1 for l \u0026lt; r { mid := (l + r + 1) \u0026gt;\u0026gt; 1 if M[mid/m][mid%m] \u0026lt;= target { l = mid } else { r = mid - 1 } } return M[l/m][l%m] == target } äºŒç»´æ•°ç»„ä¸­çš„æŸ¥æ‰¾ é¢˜ç›®é“¾æ¥\næ€è·¯ æˆ‘ä»¬å¯ä»¥å‘ç°ï¼šxå·¦è¾¹çš„æ•°éƒ½å°äºç­‰äºxï¼Œxä¸‹è¾¹çš„æ•°éƒ½å¤§äºç­‰äºx\nå¦‚æœ x ç­‰äºtargetï¼Œåˆ™è¯´æ˜æˆ‘ä»¬æ‰¾åˆ°äº†ç›®æ ‡å€¼ï¼Œè¿”å›trueï¼› å¦‚æœ x å°äºtargetï¼Œåˆ™ x å·¦è¾¹çš„æ•°ä¸€å®šéƒ½å°äºtargetï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥æ’é™¤å½“å‰ä¸€æ•´è¡Œçš„æ•° å¦‚æœ x å¤§äºtargetï¼Œåˆ™ x ä¸‹è¾¹çš„æ•°ä¸€å®šéƒ½å¤§äºtargetï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥æ’åºå½“å‰ä¸€æ•´åˆ—çš„æ•° æ—¶é—´å¤æ‚åº¦ ç©ºé—´å¤æ‚åº¦ $O(m+n)$ $O(1)$ ä»£ç  func findNumberIn2DArray(M [][]int, target int) bool { if len(M) == 0 { return false } i, j := 0, len(M[0]) - 1 for i \u0026lt; len(M) \u0026amp;\u0026amp; j \u0026gt;= 0 { if M[i][j] == target { return true } else if (M[i][j] \u0026lt; target) { i++ } else { j-- } } return false } å­é›†II æ€è·¯ å…ˆæ’åºï¼ŒæŠŠæ‰€æœ‰ç›¸åŒçš„å…ƒç´ æ”¾åœ¨ä¸€èµ·ï¼Œä¹‹åç»Ÿè®¡ç›¸åŒå…ƒç´ ä¸ªæ•°ï¼Œå¯¹äºæ¯ä¸ªç›¸åŒå…ƒç´ å¯ä»¥é€‰æ‹©çš„æ¬¡æ•°ä¸º0-t(tè¡¨ç¤ºå…ƒç´ å‡ºç°æ¬¡æ•°) å°†æ‰€æœ‰å…ƒç´ çš„æ‰€æœ‰æ¬¡æ•°å¯èƒ½ç›¸äº’ç»„åˆå³å¯å¾—åˆ°æ‰€æœ‰è§£é›† æ—¶é—´å¤æ‚åº¦ ç©ºé—´å¤æ‚åº¦ $O(n2^n)$ $O(n)$ ä»£ç  class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsetsWithDup(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); sort(begin(nums), end(nums)); vector\u0026lt;int\u0026gt; tmp; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; function\u0026lt;void(int)\u0026gt; dfs = [\u0026amp;](int u){ if (u \u0026gt;= n) { ans.emplace_back(tmp); return; } int k = 0; while (u + k \u0026lt; n \u0026amp;\u0026amp; nums[u] == nums[u+k]) k++; for (int i = 0; i \u0026lt;= k; i++) { dfs(u + k); tmp.emplace_back(nums[u]); } for (int i = 0; i \u0026lt;= k; i++) tmp.pop_back(); }; dfs(0); return ans; } }; é€’å½’å®ç°ç»„åˆå‹æšä¸¾ é¢˜ç›®é“¾æ¥\næ€è·¯ æ—¶é—´å¤æ‚åº¦ ç©ºé—´å¤æ‚åº¦ $O(2^n)$ $O(n)$ ä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 30; int n, m; int path[N]; // uæ˜¯å±‚æ•°ï¼Œstartæ˜¯èµ·å§‹å€¼ void dfs(int u, int start) { if (u \u0026gt; m) { for (int i = 1; i \u0026lt;= m; i++) cout \u0026lt;\u0026lt; path[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; return; } for (int i = start; i \u0026lt;= n; i++) { path[u] = i; dfs(u + 1, i + 1); path[u] = 0; } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; dfs(1, 1); return 0; } ç›´æ–¹å›¾çš„æ°´é‡-å•è°ƒæ ˆ|DP é¢˜ç›®é“¾æ¥\nå•è°ƒæ ˆ æ€è·¯ ç»´æŠ¤ä¸€ä¸ªå•è°ƒæ ˆï¼ˆä¸¥æ ¼é€’å‡ï¼‰ï¼Œé‚£ä¹ˆä¸€å®šæœ‰height[t] \u0026gt; height[left](leftæ˜¯æ ˆé¡¶ä¸‹é¢çš„å…ƒç´ ) è‹¥height[i] \u0026gt; height[t]åˆ™å¯å½¢æˆä¸€ä¸ªç››æ°´åŒºåŸŸï¼Œå®½åº¦ä¸ºi-left-1ï¼Œé«˜åº¦ä¸ºmin(height[i], height[left])-height[t] æ—¶é—´å¤æ‚åº¦ ç©ºé—´å¤æ‚åº¦ $O(n)$ $O(n)$ ä»£ç  func trap(height []int) int { stk := make([]int, 0) ans := 0 for i := range height { for len(stk) \u0026gt; 0 \u0026amp;\u0026amp; height[i] \u0026gt;= height[stk[len(stk)-1]] { top := stk[len(stk)-1] stk = stk[:len(stk)-1] if len(stk) \u0026lt;= 0 { break } left := stk[len(stk)-1] ans += (i - left - 1) * (min(height[i], height[left])-height[top]) } stk = append(stk, i) } return ans } func min(a, b int) int { if a \u0026lt; b { return a } return b } DP æ€è·¯ å¯¹äºä¸‹æ ‡ iï¼Œæ°´èƒ½åˆ°è¾¾çš„æœ€å¤§é«˜åº¦ç­‰äºä¸‹æ ‡ i ä¸¤è¾¹çš„æœ€å¤§é«˜åº¦çš„æœ€å°å€¼ï¼Œä¸‹æ ‡ i å¤„èƒ½æ¥çš„æ°´çš„é‡ç­‰äºä¸‹æ ‡ i å¤„çš„æ°´èƒ½åˆ°è¾¾çš„æœ€å¤§é«˜åº¦å‡å» height[i]ã€‚\næ—¶é—´å¤æ‚åº¦ ç©ºé—´å¤æ‚åº¦ $O(n)$ $O(n)$ ä»£ç  func trap(height []int) int { n := len(height) if n == 0 { return 0 } left, right := make([]int, n), make([]int, n) left[0] = height[0] for i := 1; i \u0026lt; n; i++ { left[i] = max(left[i-1], height[i]) } right[n-1] = height[n-1] for i := n-2; i \u0026gt;= 0; i-- { right[i] = max(right[i+1], height[i]) } ans := 0 for i := range height { ans += min(left[i], right[i]) - height[i] } return ans } func min(a, b int) int { if a \u0026lt; b { return a } return b } func max(a, b int) int { if a \u0026gt; b { return a } return b } é›¨-æœ€çŸ­è·¯å˜å½¢ é¢˜ç›®é“¾æ¥\næ€è·¯ å°†æµ·æ°´æŠ½è±¡ä¸ºä¸€ä¸ªæºç‚¹ æ±‚æµ·æ°´åˆ°æ¯ä¸ªç‚¹æ‰€ç»è¿‡çš„ç‚¹çš„æœ€å¤§æƒå€¼çš„æœ€çŸ­è·¯ ä»£ç  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;container/heap\u0026#34; ) type Node struct { x int y int d int } type NodeHeap []Node func (n NodeHeap) Len() int { return len(n) } func (n NodeHeap) Swap(i, j int) { n[i], n[j] = n[j], n[i] } func (n NodeHeap) Less(i, j int) bool { return n[i].d \u0026lt; n[j].d } func (n *NodeHeap) Push(h interface{}) { *n = append(*n, h.(Node)) } func (n *NodeHeap) Pop() (x interface{}) { x = (*n)[len(*n)-1] *n = (*n)[:len(*n)-1] return } func main() { var T int fmt.Scan(\u0026amp;T) var n, m int for C := 1; C \u0026lt;= T; C++ { fmt.Scan(\u0026amp;n, \u0026amp;m) h := make([][]int, n+1) dist := make([][]int, n+1) st := make([][]bool, n+1) for i := 1; i \u0026lt;= n; i++ { h[i] = make([]int, m+1) st[i] = make([]bool, m+1) dist[i] = make([]int, m+1) for j := 1; j \u0026lt;= m; j++ { fmt.Scan(\u0026amp;h[i][j]) dist[i][j] = int(^uint(0)\u0026gt;\u0026gt;1) } } hp := \u0026amp;NodeHeap{} heap.Init(hp) for i := 1; i \u0026lt;= n; i++ { heap.Push(hp, Node{i, 1, h[i][1]}) dist[i][1] = h[i][1] heap.Push(hp, Node{i, m, h[i][m]}) dist[i][m] = h[i][m] } for i := 2; i \u0026lt;= m; i++ { heap.Push(hp, Node{1, i, h[1][i]}) dist[1][i] = h[1][i] heap.Push(hp, Node{n, i, h[n][i]}) dist[n][i] = h[n][i] } ans := 0 dx, dy := [4]int{-1, 0, 1, 0}, [4]int{0, 1, 0, -1} for hp.Len() \u0026gt; 0 { top := heap.Pop(hp).(Node) st[top.x][top.y] = true ans += top.d - h[top.x][top.y] for i := range dx { nx, ny := top.x + dx[i], top.y + dy[i] if nx \u0026lt; 1 || nx \u0026gt; n || ny \u0026lt; 1 || ny \u0026gt; m || st[nx][ny] { continue } if dist[nx][ny] \u0026gt; max(top.d, h[nx][ny]) { dist[nx][ny] = max(top.d, h[nx][ny]) heap.Push(hp, Node{nx, ny, dist[nx][ny]}) } } } fmt.Printf(\u0026#34;Case #%d: %d\\n\u0026#34;, C, ans) } } func max(a, b int) (x int) { if a \u0026gt; b { x = a } else { x = b } return } å¯†ç è„±è½-LCS é¢˜ç›®é“¾æ¥\næ€è·¯ æ±‚å­—ç¬¦ä¸²åŠå…¶ç¿»è½¬ä¸²çš„LCSé•¿åº¦\næ—¶é—´å¤æ‚åº¦ ç©ºé—´å¤æ‚åº¦ $O(n^2)$ $O(n^2)$ ä»£ç  package main import \u0026#34;fmt\u0026#34; func reverse(s string) (res string) { a := []rune(s) n := len(a) for i, j := 0, n-1; i \u0026lt; j; i, j = i+1, j-1 { a[i], a[j] = a[j], a[i] } return string(a) } func main() { var a, b string fmt.Scanf(\u0026#34;%s\u0026#34;, \u0026amp;a) n := len(a) b = reverse(a) f := make([][]int, n+1) for i := range f { f[i] = make([]int, n+1) } for i := 1; i \u0026lt;= n; i++ { for j := 1; j \u0026lt;= n; j++ { if a[i-1] == b[j-1] { f[i][j] = f[i-1][j-1] + 1 } else { f[i][j] = max(f[i-1][j], f[i][j-1]) } } } fmt.Println(n - f[n][n]) } func max(a, b int) int { if a \u0026gt; b { return a } return b } æ£®æ—ä¸­çš„å…”å­ é¢˜ç›®é“¾æ¥\næ€è·¯ ç»Ÿè®¡æ¯ç§$x$å‡ºç°çš„æ¬¡æ•° è‹¥$x$å‡ºç°äº†$k$æ¬¡ä¸ºäº†ä½¿å¾—å…”å­æ•°é‡æœ€å°ï¼Œåˆ™å…”å­ç§ç±»æ•°ä¸º $\\lceil \\frac{k}{x+1} \\rceil$, ä¸”æ¯ç§å…”å­æ•°é‡ä¸º$x+1$ åˆ™å…”å­æ€»æ•°ä¸º$\\sum_i^n{ \\lceil \\frac{k_i}{x_i+1} \\rceil \\times (x_i+1)}$ ä¾‹å¦‚æœ‰13åªå…”å­å›ç­”5ï¼Œåˆ™è‡³å°‘æœ‰å…­åªåŒä¸€ç§ç±»å…”å­è®°ä¸ºçº¢è‰²ï¼Œè¿˜æœ‰å…­åªå¦ä¸€ç§ç±»è®°ä¸ºè“è‰²ï¼Œè¿˜å‰©ä¸‹ä¸€åªå…”å­å›ç­”5ï¼Œåˆ™å¿…ç„¶è¿˜æœ‰äº”åªå…”å­ä¸è¿™ä¸€åªå…”å­é¢œè‰²ç›¸åŒè®°ä¸ºç™½è‰²ã€‚ç»¼ä¸Šæœ‰$\\lceil \\frac{13}{5+1} \\rceil \\times (5+1) = 18$åªå…”å­ã€‚ æ—¶é—´å¤æ‚åº¦ ç©ºé—´å¤æ‚åº¦ $O(n)$ $O(n)$ ä»£ç  func numRabbits(answers []int) int { mp := make(map[int]int) for i := range answers { mp[answers[i]]++ } ret := 0 for k, v := range mp { ret += (v + k) / (k + 1) * (k + 1); } return ret; } çŸ³å­åˆå¹¶-åŒºé—´DP é¢˜ç›®é“¾æ¥\næ€è·¯ $f[i][j]$è¡¨ç¤ºå°†è¡¨ç¤ºå°† $i$ åˆ° $j$ åˆå¹¶æˆä¸€å †çš„æ–¹æ¡ˆçš„é›†åˆï¼Œå±æ€§æ˜¯æœ€å°å€¼ $f[i][j]=min_{iâ‰¤kâ‰¤jâˆ’1}\\{f[i][k]+f[k+1][j]+s[j]âˆ’s[iâˆ’1]\\}$ æ—¶é—´å¤æ‚åº¦ ç©ºé—´å¤æ‚åº¦ $O(n^3)$ $O(n^2)$ ä»£ç  package main import \u0026#34;fmt\u0026#34; const N = 305 var n int var s [N]int var f [N][N]int func main() { fmt.Scan(\u0026amp;n) for i := 1; i \u0026lt;= n; i++ { fmt.Scan(\u0026amp;s[i]) s[i] += s[i-1] } for len := 2; len \u0026lt;= n; len++ { for i := 1; i + len - 1 \u0026lt;= n; i++ { j := i + len - 1 f[i][j] = int(^uint(0) \u0026gt;\u0026gt; 1) for k := i; k \u0026lt; j; k++ { f[i][j] = min(f[i][j], f[i][k] + f[k+1][j] + s[j] - s[i-1]) } } } fmt.Println(f[1][n]) } func min(a, b int) int { if a \u0026lt; b { return a } return b } ç¯å½¢çŸ³å­åˆå¹¶ é¢˜ç›®é“¾æ¥\næ€è·¯ ç ´ç¯æˆé“¾ æ±‚æ‰€æœ‰åŒºé—´é•¿åº¦ä¸ºnçš„é“¾å½¢çŸ³å­åˆå¹¶ æšä¸¾é•¿åº¦ä¸ºnçš„åŒºé—´ï¼Œå–max ä»£ç  package main import \u0026#34;fmt\u0026#34; const ( N = 405 INT_MAX = int(^uint(0) \u0026gt;\u0026gt; 1) INT_MIN = -INT_MAX - 1 ) var ( n int f [N][N]int g [N][N]int s [N]int a [N]int ) func main() { fmt.Scan(\u0026amp;n) for i := 1; i \u0026lt;= n; i++ { fmt.Scan(\u0026amp;a[i]) a[i+n] = a[i] } for i := 1; i \u0026lt;= 2*n; i++ { s[i] = s[i-1] + a[i] } for l := 2; l \u0026lt;= n; l++ { for i := 1; i+l-1 \u0026lt;= 2*n; i++ { j := i + l - 1 f[i][j], g[i][j] = INT_MAX, INT_MIN for k := i; k \u0026lt; j; k++ { f[i][j], g[i][j] = min(f[i][j], f[i][k]+f[k+1][j]+s[j]-s[i-1]), max(g[i][j], g[i][k]+g[k+1][j]+s[j]-s[i-1]) } } } minv, maxv := INT_MAX, INT_MIN for i := 1; i \u0026lt;= n; i++ { minv = min(minv, f[i][i+n-1]) maxv = max(maxv, g[i][i+n-1]) } fmt.Println(minv) fmt.Println(maxv) } func min(a, b int) int { if a \u0026lt; b { return a } return b } func max(a, b int) int { if a \u0026gt; b { return a } return b } åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„ é¢˜ç›®é“¾æ¥\nè§£é¢˜æ€è·¯ æŒ‡é’ˆä»åå¾€å‰ç§»åŠ¨ æ¯æ¬¡å°†è¾ƒå¤§å€¼æ’åˆ°åé¢ æ—¶é—´å¤æ‚åº¦ ç©ºé—´å¤æ‚åº¦ $O(m+n)$ $O(1)$ ä»£ç  func merge(A []int, m int, B []int, n int) { i, j := m-1, n-1 for k := m+n-1; k \u0026gt;= 0; k-- { if i == -1 { A[k] = B[j] j-- } else if j == -1 { A[k] = A[i] i-- } else if A[i] \u0026gt; B[j] { A[k] = A[i] i-- } else { A[k] = B[j] j-- } } } åˆ é™¤æœ‰åºæ•°ç»„ä¸­çš„é‡å¤é¡¹II é¢˜ç›®é“¾æ¥\næ€è·¯ kæŒ‡å‘æ–°æ•°ç»„çš„æœ«å°¾ éå†æ•°ç»„ï¼Œè‹¥å½“å‰å…ƒç´ ä¸ç­‰äºnums[k-2]åˆ™æ’å…¥æ–°æ•°ç»„çš„æœ«å°¾ æ—¶é—´å¤æ‚åº¦ ç©ºé—´å¤æ‚åº¦ $O(n)$ $O(1)$ ä»£ç  func removeDuplicates(nums []int) int { n := len(nums) if n \u0026lt;= 2 { return n } k := 2 for i := 2; i \u0026lt; n; i++ { if nums[i] != nums[k-2] { nums[k] = nums[i] k++ } } return k } æœç´¢æ—‹è½¬æ’åºæ•°ç»„II-äºŒåˆ† é¢˜ç›®é“¾æ¥\næ€è·¯ nums[l] == nums[mid]ï¼šä¸èƒ½ç¡®å®šå“ªä¸€ä¸ªåŒºé—´æ˜¯æœ‰åºçš„ï¼Œl++ nums[l] \u0026lt; nums[mid]ï¼šå·¦åŒºé—´æ˜¯æœ‰åºçš„ nums[l] \u0026gt; nums[mid]ï¼šå³åŒºé—´æ˜¯æœ‰åºçš„ æ—¶é—´å¤æ‚åº¦ ç©ºé—´å¤æ‚åº¦ $O(n)$ $O(1)$ ä»£ç  func search(nums []int, target int) bool { n := len(nums) if n == 0 { return false } l, r := 0, n-1 for l \u0026lt;= r { mid := (l + r) \u0026gt;\u0026gt; 1 if nums[mid] == target { return true } else if nums[l] == nums[mid] { l++ continue } else if nums[l] \u0026lt; nums[mid] { if nums[l] \u0026lt;= target \u0026amp;\u0026amp; target \u0026lt; nums[mid] { r = mid - 1 } else { l = mid + 1 } } else { if nums[mid] \u0026lt; target \u0026amp;\u0026amp; target \u0026lt;= nums[r] { l = mid + 1 } else { r = mid - 1 } } } return false } 0åˆ°n-1ä¸­ç¼ºå¤±çš„æ•°å­—-äºŒåˆ† é¢˜ç›®é“¾æ¥\næ€è·¯ \u0026lt;img src=\u0026ldquo;https://cdn.acwing.com/media/article/image/2019/05/31/1_37a28f4683-%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97.png\u0026quot; position=\u0026ldquo;center\u0026rdquo; style=\u0026ldquo;zoom: 80% ;\u0026rdquo;\næ—¶é—´å¤æ‚åº¦ ç©ºé—´å¤æ‚åº¦ $O(logn)$ $O(1)$ ä»£ç  class Solution { public: int getMissingNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) { const int n = nums.size(); if (!n) { return 0; } if (nums[n-1] == n-1) { return n; } int l = 0, r = n-1; while (l \u0026lt; r) { const int mid = (l + r) \u0026gt;\u0026gt; 1; if (nums[mid] != mid) { r = mid; } else { l = mid + 1; } } return l; } }; ç§»å»Kä½æ•°å­—-è´ªå¿ƒ é¢˜ç›®é“¾æ¥\næ€è·¯ å¦‚æœå­—ç¬¦ä¸²å·²ç»æ˜¯æœ‰åºçš„ï¼Œåˆ™åº”è¯¥åˆ é™¤å$k$ä½ å¦‚æœå‡ºç°é€†åºï¼Œåˆ™åº”è¯¥æŠŠå‰ä¸€ä¸ªå…ƒç´ åˆ é™¤ æ—¶é—´å¤æ‚åº¦ ç©ºé—´å¤æ‚åº¦ $O(n)$ $O(1)$ ä»£ç  package main import ( \u0026#34;fmt\u0026#34; ) func main() { var s string var k int fmt.Scan(\u0026amp;s, \u0026amp;k) ans := \u0026#34;0\u0026#34; for _, v := range s { for k \u0026gt; 0 \u0026amp;\u0026amp; ans[len(ans)-1] \u0026gt; byte(v) { ans = ans[:len(ans)-1] k-- } ans += string(v) } for k \u0026gt; 0 { ans = ans[:len(ans)-1] k-- } i := 0 for i \u0026lt; len(ans) - 1 \u0026amp;\u0026amp; ans[i] == \u0026#39;0\u0026#39; { i++ } fmt.Println(ans[i:]) } äºŒå‰æœç´¢æ ‘èŠ‚ç‚¹æœ€å°è·ç¦» é¢˜ç›®é“¾æ¥\næ€è·¯ äºŒå‰æœç´¢æ ‘ä¸­åºéå†æœ‰åº\næ—¶é—´å¤æ‚åº¦ ç©ºé—´å¤æ‚åº¦ $O(n)$ $O(1)$ ä»£ç  const MAX int = int(^uint(0) \u0026gt;\u0026gt; 1) func minDiffInBST(root *TreeNode) (ans int) { ans = MAX var last int is_first := false var dfs func(root *TreeNode) dfs = func(root *TreeNode) { if root == nil { return } dfs(root.Left) if (!is_first) { is_first = true } else { ans = min(ans, root.Val - last) } last = root.Val dfs(root.Right) } dfs(root) return } func min(a, b int) int { if a \u0026lt; b { return a } return b } å®ç°Trieæ ‘ æ€è·¯ å­—å…¸æ ‘ ä»£ç  type Trie struct { son [26]*Trie isEnd bool } /** Initialize your data structure here. */ func Constructor() Trie { return Trie{} } func (this *Trie) query(word string) (res *Trie) { node := this for _, v := range word { t := v - \u0026#39;a\u0026#39; if node.son[t] == nil { res = nil return } node = node.son[t] } res = node return } /** Inserts a word into the trie. */ func (this *Trie) Insert(word string) { node := this for _, v := range word { t := v - \u0026#39;a\u0026#39; if node.son[t] == nil { node.son[t] = \u0026amp;Trie{} } node = node.son[t] } node.isEnd = true } /** Returns if the word is in the trie. */ func (this *Trie) Search(word string) bool { node := this.query(word) return node != nil \u0026amp;\u0026amp; node.isEnd } /** Returns if there is any word in the trie that starts with the given prefix. */ func (this *Trie) StartsWith(prefix string) bool { return this.query(prefix) != nil } å‰ç¼€ç»Ÿè®¡-Trie é¢˜ç›®é“¾æ¥\né“¾è¡¨ä»£ç  package main import \u0026#34;fmt\u0026#34; type Trie struct { son [26]*Trie isEnd bool cnt int } func NewTrie() *Trie { return \u0026amp;Trie{} } func (t *Trie) insert(word string) { node := t for _, v := range word { c := v - \u0026#39;a\u0026#39; if node.son[c] == nil { node.son[c] = NewTrie() } node = node.son[c] } node.cnt++ node.isEnd = true } func (t *Trie) query(word string) (ans int) { node := t for _, v := range word { c := v - \u0026#39;a\u0026#39; if node.son[c] == nil { return ans } node = node.son[c] ans += node.cnt } return } func main() { var n, m int fmt.Scan(\u0026amp;n, \u0026amp;m) var s string t := NewTrie() for i := 0; i \u0026lt; n; i++ { fmt.Scan(\u0026amp;s) t.insert(s) } for i := 0; i \u0026lt; m; i++ { fmt.Scan(\u0026amp;s) fmt.Println(t.query(s)) } } æ•°ç»„ä»£ç  package main import \u0026#34;fmt\u0026#34; const N = 1e6 + 5 var ( n, m int son [N][26]int idx int cnt [N]int ) func insert(word string) { p := 0 for _, v := range word { t := v - \u0026#39;a\u0026#39; if son[p][t] == 0 { idx++ son[p][t] = idx } p = son[p][t] } cnt[p]++ } func query(word string) (ans int) { p := 0 for _, v := range word { t := v - \u0026#39;a\u0026#39; if son[p][t] == 0 { return } p = son[p][t] ans += cnt[p] } return } func main() { fmt.Scan(\u0026amp;n, \u0026amp;m) var s string for i := 0; i \u0026lt; n; i++ { fmt.Scan(\u0026amp;s) insert(s) } for i := 0; i \u0026lt; m; i++ { fmt.Scan(\u0026amp;s) fmt.Println(query(s)) } } æ‰“å®¶åŠ«èˆII-DP è§£é¢˜æ€è·¯ æ—¶é—´å¤æ‚åº¦ ç©ºé—´å¤æ‚åº¦ $O(n)$ $O(n)$ ä»£ç  func rob(nums []int) int { n := len(nums) if n == 1 { return nums[0] } f := make([][2]int, n) f[0][0], f[0][1] = math.MinInt64, nums[0] for i := 1; i \u0026lt; n; i++ { f[i][0] = max(f[i-1][0], f[i-1][1]) f[i][1] = f[i-1][0] + nums[i] } res := f[n-1][0] f[0][0], f[0][1] = 0, math.MinInt64 for i := 1; i \u0026lt; n; i++ { f[i][0] = max(f[i-1][0], f[i-1][1]) f[i][1] = f[i-1][0] + nums[i] } return max(res, max(f[n-1][0], f[n-1][1])) } func max(a, b int) int { if a \u0026gt; b { return a } return b } æ‰°ä¹±å­—ç¬¦ä¸²-DP é¢˜ç›®é“¾æ¥\næ€è·¯ çŠ¶æ€è¡¨ç¤ºf[i][j][k] é›†åˆï¼šs1[i..i+k-1]å’Œs2[j..j+k-1]æ‰€æœ‰åŒ¹é…çš„æ–¹æ¡ˆçš„é›†åˆ å±æ€§ï¼šé›†åˆæ˜¯å¦ä¸ºç©ºé›† çŠ¶æ€è®¡ç®—ï¼šf[i][j][k]æŒ‰s1ç¬¬ä¸€æ®µçš„é•¿åº¦åˆ’åˆ†æˆk-1ç±»ï¼Œæœ‰ä¸¤ç§åŒ¹é…æ–¹æ¡ˆ f[i][j][u] \u0026amp;\u0026amp; f[i+u][j+u][k-u] f[i][j+k-u][u] \u0026amp;\u0026amp; f[i+u][j][k-u] æ—¶é—´å¤æ‚åº¦ ç©ºé—´å¤æ‚åº¦ $O(n^4)$ $O(n^3)$ ä»£ç  func isScramble(s1 string, s2 string) bool { n := len(s1) f := make([][][]bool, n) for i := range f { f[i] = make([][]bool, n) for j := range f[i] { f[i][j] = make([]bool, n+1) } } for k := 1; k \u0026lt;= n; k++ { for i := 0; i+k-1 \u0026lt; n; i++ { for j := 0; j+k-1 \u0026lt; n; j++ { if k == 1 { if s1[i] == s2[j] { f[i][j][k] = true } } else { for u := 1; u \u0026lt; k; u++ { if f[i][j][u] \u0026amp;\u0026amp; f[i+u][j+u][k-u] || f[i][j+k-u][u] \u0026amp;\u0026amp; f[i+u][j][k-u] { f[i][j][k] = true break } } } } } } return f[0][0][n] } é‡å¤å…ƒç´ III-æ»‘åŠ¨çª—å£ é¢˜ç›®é“¾æ¥\næ€è·¯ æœ‰åºé›†åˆä¸­æŸ¥æ‰¾å¤§äºç­‰äº x - t çš„æœ€å°çš„å…ƒç´  yï¼Œå¦‚æœ y å­˜åœ¨ï¼Œä¸” y \u0026lt;= x + tåˆ™å­˜åœ¨ æœ‰åºé›†åˆä¸­å…ƒç´ æ•°é‡è¶…è¿‡äº† kï¼Œå°†æœ‰åºé›†åˆä¸­æœ€æ—©è¢«æ’å…¥çš„å…ƒç´ åˆ é™¤å³å¯ æ—¶é—´å¤æ‚åº¦ ç©ºé—´å¤æ‚åº¦ $O(nlogk)$ $O(k)$ ä»£ç  class Solution { public: bool containsNearbyAlmostDuplicate(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k, int t) { set\u0026lt;long\u0026gt; st; const int n = nums.size(); for (int i = 0; i \u0026lt; n; i++) { auto it = st.lower_bound(nums[i]*1l-t); if (it != end(st) \u0026amp;\u0026amp; *it \u0026lt;= nums[i]*1l+t) { return true; } st.insert(nums[i]); if (i-k \u0026gt;= 0) st.erase(nums[i-k]); } return false; } }; è§£ç æ–¹æ³•-dp é¢˜ç›®é“¾æ¥\næ€è·¯ çŠ¶æ€è¡¨ç¤ºï¼š$f[i]$è¡¨ç¤ºå‰ $i$ ä¸ªæ•°å­—å…±æœ‰å¤šå°‘ç§è§£ç æ–¹å¼ã€‚ çŠ¶æ€è½¬ç§»ï¼š å¦‚æœç¬¬ $i$ ä¸ªæ•°å­—ä¸æ˜¯$0$ï¼Œåˆ™ $i$ ä¸ªæ•°å­—å¯ä»¥å•ç‹¬è§£ç æˆä¸€ä¸ªå­—æ¯ï¼Œæ­¤æ—¶çš„æ–¹æ¡ˆæ•°ç­‰äºç”¨å‰ $iâˆ’1$ ä¸ªæ•°å­—è§£ç çš„æ–¹æ¡ˆæ•°ï¼Œå³ $f[iâˆ’1]$ å¦‚æœç¬¬ $iâˆ’1$ä¸ªæ•°å­—å’Œç¬¬ $i$ä¸ªæ•°å­—ç»„æˆçš„ä¸¤ä½æ•°åœ¨ $10$ åˆ° $26$ ä¹‹é—´ï¼Œåˆ™å¯ä»¥å°†è¿™ä¸¤ä½æ•°å­—è§£ç æˆä¸€ä¸ªå­—ç¬¦ï¼Œæ­¤æ—¶çš„æ–¹æ¡ˆæ•°ç­‰äºç”¨å‰ $iâˆ’2$ ä¸ªæ•°å­—è§£ç çš„æ–¹æ¡ˆæ•°ï¼Œå³ $f[iâˆ’2]$ æ—¶é—´å¤æ‚åº¦ ç©ºé—´å¤æ‚åº¦ $O(n)$ $O(n)$ ä»£ç  func numDecodings(s string) int { n := len(s) f := make([]int, n+1) f[0] = 1 for i := 1; i \u0026lt;= n; i++ { if s[i-1] != \u0026#39;0\u0026#39; { f[i] += f[i-1] } if i \u0026gt; 1 { t := (s[i-2] - \u0026#39;0\u0026#39;) * 10 + s[i-1] - \u0026#39;0\u0026#39; if t \u0026gt;= 10 \u0026amp;\u0026amp; t \u0026lt;= 26 { f[i] += f[i-2] } } } return f[n] } çŸ©å½¢åŒºåŸŸä¸è¶…è¿‡ K çš„æœ€å¤§æ•°å€¼å’Œ-å‰ç¼€å’Œ é¢˜ç›®é“¾æ¥\næ€è·¯ äºŒé‡å¾ªç¯æšä¸¾çŸ©å½¢çš„ä¸Šè¾¹ç•Œå’Œä¸‹è¾¹ç•Œï¼Œæ—¶é—´å¤æ‚åº¦O(n^2) åœ¨ä¸€ç»´æ•°ç»„æ±‚å’Œä¸è¶…è¿‡Kçš„æœ€å¤§å­æ•°ç»„çš„å’Œï¼Œæˆ‘ä»¬å¯ä»¥åœ¨O(nlogn)çš„æ—¶é—´å¤æ‚åº¦å†…æ±‚è§£ã€‚æˆ‘ä»¬çŸ¥é“å¯ä»¥ä½¿ç”¨å‰ç¼€å’Œæ±‚è§£å­åŒºé—´å’Œï¼šsum(A[i:j])=preSum[j]âˆ’preSum[iâˆ’1]ã€‚é‚£ä¹ˆå¯¹äºæ¯ä¸€ä¸ªpreSum[j]ï¼Œæˆ‘ä»¬å¯ä»¥å°†é‡åˆ°è¿‡çš„å‰ç¼€åå­˜å…¥ä¸€ä¸ªsetä¸­ï¼Œå†ä»setä¸­æ‰¾åˆ°ä¸€ä¸ªå¤§äºç­‰äºpreSum[j]âˆ’kçš„æœ€å°å€¼ï¼Œè¿™æ ·ä»–ä»¬çš„å·®å€¼å°±æ˜¯å°äºç­‰äºkkçš„æœ€å¤§å€¼ã€‚è¿™ç§æŸ¥æ‰¾çš„æ—¶é—´å¤æ‚åº¦æ˜¯lognçš„ï¼Œæ€»å…±éœ€è¦æŸ¥æ‰¾næ¬¡ï¼Œæ‰€ä»¥æ€»å…±çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(nlogn) æ—¶é—´å¤æ‚åº¦ ç©ºé—´å¤æ‚åº¦ $O(m^2nlogn)$ $O(n)$ ä»£ç  class Solution { public: int maxSumSubmatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; A, int k) { const int m = A.size(), n = A[0].size(); int ans = INT_MIN; for (int i = 0; i \u0026lt; m; i++) { vector\u0026lt;int\u0026gt; sum(n); for (int j = i; j \u0026lt; m; j++) { for (int k = 0; k \u0026lt; n; k++) { sum[k] += A[j][k]; } set\u0026lt;int\u0026gt; st{0}; int s = 0; for (const auto \u0026amp;e : sum) { s += e; auto it = st.lower_bound(s - k); if (it != st.end()) { ans = max(ans, s - *it); } st.insert(s); } } } return ans; } }; æœ€å¤§æ•´é™¤å­é›†-dp é¢˜ç›®é“¾æ¥\nè§£é¢˜æ€è·¯ å‰æï¼šå‡åº çŠ¶æ€é›†åˆï¼š$f[i]$è¡¨ç¤ºæœ€å¤§å…ƒç´ ä¸º$nums[i]$çš„æœ‰æ•ˆè§£å­é›† å±æ€§ï¼šæœ‰æ•ˆå­é›†å¤§å° çŠ¶æ€è®¡ç®—ï¼š$f[i]=max(f[i], f[j]+1), j=0..i-1$ å€’åºéå†$f$æ‰¾åˆ°é›†åˆå…ƒç´  æ—¶é—´å¤æ‚åº¦ ç©ºé—´å¤æ‚åº¦ $O(n^2)$ $O(n)$ ä»£ç  func largestDivisibleSubset(nums []int) []int { sort.Ints(nums) n := len(nums) f := make([]int, n) for i := range f { f[i] = 1 } maxLen := 1 for i := range f { for j := 0; j \u0026lt; i; j++ { if nums[i] % nums[j] == 0 { f[i] = max(f[i], f[j] + 1) maxLen = max(maxLen, f[i]) } } } ans := make([]int, maxLen) end := true for i := n-1; i \u0026gt;= 0 \u0026amp;\u0026amp; maxLen \u0026gt; 0; i-- { if f[i] == maxLen \u0026amp;\u0026amp; (end || ans[maxLen] % nums[i] == 0) { ans[maxLen-1] = nums[i] end = false maxLen-- } } return ans } func max(a, b int) int { if a \u0026gt; b { return a } return b } æ•´æ•°æ‹†åˆ†-å®Œå…¨èƒŒåŒ… é¢˜ç›®é“¾æ¥\næ€è·¯ å®Œå…¨èƒŒåŒ…\nçŠ¶æ€è¡¨ç¤ºï¼š$f[i]$è¡¨ç¤º$i$çš„ä¸åŒæ‹†åˆ†æ–¹å¼æ•° çŠ¶æ€è®¡ç®—ï¼š$f[i]=f[j]+f[j-2^i], 0 \\le 2^i \\le n$ æ—¶é—´å¤æ‚åº¦ ç©ºé—´å¤æ‚åº¦ $O(nlogn)$ $O(n)$ ä»£ç  package main import \u0026#34;fmt\u0026#34; const ( N = 1e6 + 5 mod = 1e9 ) var ( n int f [N]int ) func main() { fmt.Scan(\u0026amp;n) f[0] = 1 for i := 0; 1\u0026lt;\u0026lt;i \u0026lt;= n; i++ { for j := 1\u0026lt;\u0026lt;i; j \u0026lt;= n; j++ { f[j] = (f[j] + f[j-1\u0026lt;\u0026lt;i]) % mod } } fmt.Println(f[n]) } func max(a, b int) int { if a \u0026gt; b { return a } return b } ç»„åˆæ€»å’ŒIV-DP é¢˜ç›®é“¾æ¥\næ€è·¯ è€ƒè™‘é¡ºåºèƒŒåŒ…-\u0026gt;å…ˆæšä¸¾ä½“ç§¯ï¼Œå†æšä¸¾ç‰©å“\næ—¶é—´å¤æ‚åº¦ ç©ºé—´å¤æ‚åº¦ $O(mn)$ $O(n)$ ä»£ç  func combinationSum4(nums []int, target int) int { f := make([]int, target+1) f[0] = 1 for i := 0; i \u0026lt;= target; i++ { for _, v := range nums { if i \u0026gt;= v { f[i] += f[i-v] } } } return f[target] } æœ€å¤§çš„å’Œ-å‰ç¼€å’Œ\u0026amp;æ»‘åŠ¨çª—å£ é¢˜ç›®è¿æ¥\nä»£ç  package main import \u0026#34;fmt\u0026#34; const N = 1e5 + 5 var ( n int k int A [N]int B [N]bool ) func main() { fmt.Scan(\u0026amp;n, \u0026amp;k) for i := 0; i \u0026lt; n; i++ { fmt.Scan(\u0026amp;A[i]) } sum := 0 for i := 0; i \u0026lt; n; i++ { fmt.Scan(\u0026amp;B[i]) if B[i] { sum += A[i] } } ans := 0 for i := 0; i \u0026lt; n; i++ { if !B[i] { sum += A[i] } if i \u0026gt;= k \u0026amp;\u0026amp; !B[i-k] { sum -= A[i-k] } ans = max(ans, sum) } fmt.Println(ans) } func max(a, b int) int { if a \u0026gt; b { return a } return b } å…«æ•°ç -A* é¢˜ç›®é“¾æ¥\nä»£ç  #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;unordered_map\u0026gt; using namespace std; const int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1}; const string go = \u0026#34;urdl\u0026#34;; string s, t = \u0026#34;12345678x\u0026#34;; int get_f(const string \u0026amp;sts, int g) { int f = g; for (int i = 0; i \u0026lt; 9; i++) { if (sts[i] != t[i]) { f++; } } return f; } unordered_map\u0026lt;string, int\u0026gt; mp; priority_queue\u0026lt;pair\u0026lt;int, string\u0026gt;\u0026gt; que; unordered_map\u0026lt;string, pair\u0026lt;char, string\u0026gt;\u0026gt; path; int get_x(const string \u0026amp;sts) { for (int i = 0; i \u0026lt; 9; i++) { if (sts[i] == \u0026#39;x\u0026#39;) return i; } return -1; } void dfs(const string \u0026amp;tmp) { if (!path.count(tmp)) return; dfs(path[tmp].second); printf(\u0026#34;%c\u0026#34;, path[tmp].first); } bool check(const string \u0026amp;tmp) { int cnt = 0; for (int i = 0; i \u0026lt; 9; i++) { if (tmp[i] == \u0026#39;x\u0026#39;) continue; for (int j = i + 1; j \u0026lt; 9; j++) { if (tmp[j] != \u0026#39;x\u0026#39; \u0026amp;\u0026amp; tmp[i] \u0026gt; tmp[j]) cnt++; } } return (cnt \u0026amp; 1) == 0; } void bfs() { que.push({0, s}); mp[s] = 0; if (!check(s)) { puts(\u0026#34;unsolvable\u0026#34;); return; } while (que.size()) { auto [_, sts] = que.top(); que.pop(); if (sts == t) { break; } auto idx = get_x(sts); auto x = idx / 3, y = idx % 3; for (int i = 0; i \u0026lt; 4; i++) { auto cp = sts; auto nx = x + dx[i], ny = y + dy[i]; if (nx \u0026gt;= 0 \u0026amp;\u0026amp; nx \u0026lt;= 2 \u0026amp;\u0026amp; ny \u0026gt;= 0 \u0026amp;\u0026amp; ny \u0026lt;= 2) { swap(cp[nx * 3 + ny], cp[idx]); if (mp.count(cp)) continue; path[cp] = {go[i], sts}; mp[cp] = mp[sts] + 1; que.push({-get_f(cp, mp[cp]), cp}); } } } dfs(t); } int main() { char tmp; for (int i = 0; i \u0026lt; 9; i++) { cin \u0026gt;\u0026gt; tmp; s += tmp; } bfs(); return 0; } æœ€é•¿é€’å¢å­åºåˆ—çš„ä¸ªæ•°-LIS é¢˜ç›®é“¾æ¥\nä»£ç  func findNumberOfLIS(nums []int) int { n := len(nums) dp, cnt := make([]int, n), make([]int, n) maxLen, ans := 0, 0 for i := range nums { dp[i], cnt[i] = 1, 1 for j := 0; j \u0026lt; i; j++ { if nums[i] \u0026gt; nums[j] { if dp[j] + 1 \u0026gt; dp[i] { dp[i] = dp[j] + 1 cnt[i] = cnt[j] } else if dp[j] + 1 == dp[i] { cnt[i] += cnt[j] } } } if maxLen \u0026lt; dp[i] { maxLen = dp[i] ans = cnt[i] } else if maxLen == dp[i] { ans += cnt[i] } } return ans } ç‰›çš„å­¦æœ¯åœˆå­I-äºŒåˆ† é¢˜ç›®é“¾æ¥\nä»£ç  #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;climits\u0026gt; using std::cin; int n, l; std::vector\u0026lt;int\u0026gt; cite; bool check(const int \u0026amp;mid) { int cnt = 0; for (const auto \u0026amp;e : cite) { if (e \u0026gt;= mid) { cnt++; } } return cnt \u0026gt;= mid; } int binary_search(int l, int r) { while (l \u0026lt; r) { const auto mid = (l + r + 1) \u0026gt;\u0026gt; 1; if (check(mid)) { l = mid; } else { r = mid - 1; } } return l; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; l; cite.resize(n); int max_cite = 0; int min_cite = INT_MAX; for (auto \u0026amp;\u0026amp; e : cite) { cin \u0026gt;\u0026gt; e; max_cite = std::max(max_cite, e); min_cite = std::min(min_cite, e); } auto res = binary_search(min_cite, max_cite); sort(begin(cite), end(cite)); max_cite += l; for (auto it = cite.rbegin(); it != cite.rend(); it++) { if (l == 0) break; if (*it \u0026lt;= res) { (*it)++; l--; } } res = binary_search(min_cite, max_cite); printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } ç‰›å¹´-åŒä½™ é¢˜ç›®é“¾æ¥\nä»£ç  #include \u0026lt;algorithm\u0026gt; #include \u0026lt;array\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;unordered_map\u0026gt; using std::cin; const std::unordered_map\u0026lt;std::string, int\u0026gt; zodiac_map = { {\u0026#34;Ox\u0026#34;, 0}, {\u0026#34;Tiger\u0026#34;, 1}, {\u0026#34;Rabbit\u0026#34;, 2}, {\u0026#34;Dragon\u0026#34;, 3}, {\u0026#34;Snake\u0026#34;, 4}, {\u0026#34;Horse\u0026#34;, 5}, {\u0026#34;Goat\u0026#34;, 6}, {\u0026#34;Monkey\u0026#34;, 7}, {\u0026#34;Rooster\u0026#34;, 8}, {\u0026#34;Dog\u0026#34;, 9}, {\u0026#34;Pig\u0026#34;, 10}, {\u0026#34;Rat\u0026#34;, 11}, }; std::unordered_map\u0026lt;std::string, int\u0026gt; year; int main() { int n; cin \u0026gt;\u0026gt; n; year[\u0026#34;Bessie\u0026#34;] = 0; for (int i = 0; i \u0026lt; n; ++i) { std::array\u0026lt;std::string, 8\u0026gt; strs; for (auto \u0026amp;\u0026amp;str : strs) { cin \u0026gt;\u0026gt; str; } if (strs[3] == \u0026#34;previous\u0026#34;) { const auto x = year[strs[7]]; const auto zodiac = zodiac_map.find(strs[4])-\u0026gt;second; auto r = ((x - zodiac) % 12 + 12) % 12; if (r == 0) { r = 12; } year[strs[0]] = x - r; } else { const auto x = year[strs[7]]; const auto zodiac = zodiac_map.find(strs[4])-\u0026gt;second; auto r = ((zodiac - x) % 12 + 12) % 12; if (r == 0) { r = 12; } year[strs[0]] = x + r; } } printf(\u0026#34;%d\\n\u0026#34;, std::abs(year[\u0026#34;Elsie\u0026#34;])); return 0; } æ‰¾å‡ºç¼ºå¤±çš„è§‚æµ‹æ•°æ® é¢˜ç›®é“¾æ¥\nä»£ç  impl Solution { pub fn missing_rolls(rolls: Vec\u0026lt;i32\u0026gt;, mean: i32, n: i32) -\u0026gt; Vec\u0026lt;i32\u0026gt; { let m = rolls.len() as i32; let left = mean * (m + n) - rolls.iter().sum::\u0026lt;i32\u0026gt;(); let ave = left / n; let remainder = left % n; if ave \u0026lt;= 0 || ave \u0026gt; 6 || ave == 6 \u0026amp;\u0026amp; remainder != 0 { return vec![]; } let mut res = vec![ave; n as usize]; for item in res.iter_mut().take(remainder as usize) { *item += 1; } res } } function missingRolls(rolls: number[], mean: number, n: number): number[] { const m = rolls.length const left = mean * (m + n) - rolls.reduce((a, b) =\u0026gt; a + b) const ave = Math.floor(left / n) const remainder = left % n if (ave \u0026lt;= 0 || ave \u0026gt; 6 || (ave === 6 \u0026amp;\u0026amp; remainder !== 0)) return [] const missing = Array.from({ length: n }, (_, i) =\u0026gt; ave + (remainder \u0026gt; i ? 1 : 0)) return missing } å¦‚æœç›¸é‚»ä¸¤ä¸ªé¢œè‰²å‡ç›¸åŒåˆ™åˆ é™¤å½“å‰é¢œè‰² é¢˜ç›®é“¾æ¥\nä»£ç  class Solution { public: bool winnerOfGame(string colors) { int freq[2] = {0, 0}; char cur = \u0026#39;C\u0026#39;; int cnt = 0; for (char c : colors) { if (c != cur) { cur = c; cnt = 1; } else if (cnt++; cnt \u0026gt;= 3) { ++freq[cur - \u0026#39;A\u0026#39;]; } } return freq[0] \u0026gt; freq[1]; } }; è€ƒè¯•çš„æœ€å¤§å›°æ‰°åº¦ é¢˜ç›®é“¾æ¥\næ€è·¯ åŒæŒ‡é’ˆ\næšä¸¾å³æŒ‡é’ˆï¼Œè®¡ç®— answer_key[left, right] ä¸­å¦ä¸€ä¸ªå­—ç¬¦å‡ºç°çš„æ¬¡æ•° $s$ å½“ $s$ å¤§äº $k$ï¼Œå·¦ç«¯ç‚¹å³ç§» ç»´æŠ¤æœ€å¤§çª—å£é•¿åº¦ ä»£ç  impl Solution { pub fn max_consecutive_answers(answer_key: String, k: i32) -\u0026gt; i32 { let answer_key = answer_key.chars().collect::\u0026lt;Vec\u0026lt;char\u0026gt;\u0026gt;(); fn help(answer_key: \u0026amp;[char], k: i32, ch: char) -\u0026gt; i32 { let mut s = 0; let mut left = 0; let mut max = 0; for right in 0..answer_key.len() { s += (answer_key[right] == ch) as i32; while s \u0026gt; k { s -= (answer_key[left] == ch) as i32; left += 1; } max = max.max((right - left + 1) as i32); } max } help(\u0026amp;answer_key, k, \u0026#39;T\u0026#39;).max(help(\u0026amp;answer_key, k, \u0026#39;F\u0026#39;)) } } åŒºåŸŸå’Œæ£€ç´¢-æ•°ç»„å¯ä¿®æ”¹ é¢˜ç›®é“¾æ¥\næ€è·¯ çº¿æ®µæ ‘è£¸é¢˜\nä»£ç  use std::ops::{Add, AddAssign}; /// This stucture implements a segmented tree that /// can efficiently answer range queries on arrays. pub struct SegmentTree\u0026lt;T: Default + Add + Copy\u0026gt; { len: usize, buf: Vec\u0026lt;T\u0026gt;, } impl\u0026lt;T: Default + Add\u0026lt;Output = T\u0026gt; + AddAssign + Copy\u0026gt; SegmentTree\u0026lt;T\u0026gt; { /// function to build the tree pub fn from_vec(arr: \u0026amp;[T]) -\u0026gt; Self { let len = arr.len(); let mut buf: Vec\u0026lt;T\u0026gt; = vec![T::default(); 2 * len]; buf[len..(len + len)].clone_from_slice(\u0026amp;arr[0..len]); for i in (1..len).rev() { buf[i] = buf[2 * i] + buf[2 * i + 1]; } SegmentTree { len, buf } } /// function to get sum on interval [l, r] pub fn query(\u0026amp;self, mut l: usize, mut r: usize) -\u0026gt; T { l += self.len; r += self.len; let mut res = T::default(); while l \u0026lt;= r { if l % 2 == 1 { res += self.buf[l]; l += 1; } if r % 2 == 0 { res += self.buf[r]; r -= 1; } l /= 2; r /= 2; } res } /// function to update a tree node pub fn update(\u0026amp;mut self, mut idx: usize, val: T) { idx += self.len; self.buf[idx] = val; idx /= 2; while idx != 0 { self.buf[idx] = self.buf[2 * idx] + self.buf[2 * idx + 1]; idx /= 2; } } } struct NumArray { segment_tree: SegmentTree\u0026lt;i32\u0026gt;, } impl NumArray { fn new(nums: Vec\u0026lt;i32\u0026gt;) -\u0026gt; Self { let segment_tree = SegmentTree::from_vec(\u0026amp;nums); NumArray { segment_tree } } fn update(\u0026amp;mut self, index: i32, val: i32) { self.segment_tree.update(index as usize, val); } fn sum_range(\u0026amp;self, left: i32, right: i32) -\u0026gt; i32 { self.segment_tree.query(left as usize, right as usize) } } ä¸¤æ£µäºŒå‰æœç´¢æ ‘ä¸­çš„æ‰€æœ‰å…ƒç´  é¢˜ç›®é“¾æ¥\næ€è·¯ ä¸­åºéå† + å½’å¹¶\nä»£ç  use std::cell::RefCell; use std::rc::Rc; impl Solution { pub fn get_all_elements( root1: Option\u0026lt;Rc\u0026lt;RefCell\u0026lt;TreeNode\u0026gt;\u0026gt;\u0026gt;, root2: Option\u0026lt;Rc\u0026lt;RefCell\u0026lt;TreeNode\u0026gt;\u0026gt;\u0026gt;, ) -\u0026gt; Vec\u0026lt;i32\u0026gt; { fn dfs(root: Option\u0026lt;Rc\u0026lt;RefCell\u0026lt;TreeNode\u0026gt;\u0026gt;\u0026gt;, res: \u0026amp;mut Vec\u0026lt;i32\u0026gt;) { if let Some(node) = root { dfs(node.borrow().left.clone(), res); res.push(node.borrow().val); dfs(node.borrow().right.clone(), res); } } let mut res1 = vec![]; dfs(root1, \u0026amp;mut res1); let mut res2 = vec![]; dfs(root2, \u0026amp;mut res2); let mut merged = vec![0; res1.len() + res2.len()]; let mut i = 0; let mut j = 0; let mut k = 0; while i \u0026lt; res1.len() \u0026amp;\u0026amp; j \u0026lt; res2.len() { if res1[i] \u0026lt; res2[j] { merged[k] = res1[i]; i += 1; } else { merged[k] = res2[j]; j += 1; } k += 1; } while i \u0026lt; res1.len() { merged[k] = res1[i]; i += 1; k += 1; } while j \u0026lt; res2.len() { merged[k] = res2[j]; j += 1; k += 1; } merged } } function getAllElements(root1: TreeNode | null, root2: TreeNode | null): number[] { function dfs(root: TreeNode | null): number[] { if (root === null) return [] const left = dfs(root.left) const right = dfs(root.right) return [...left, root.val, ...right] } const arr1 = dfs(root1) const arr2 = dfs(root2) const arr = [] let i = 0 let j = 0 while (i \u0026lt; arr1.length \u0026amp;\u0026amp; j \u0026lt; arr2.length) { if (arr1[i] \u0026lt; arr2[j]) { arr.push(arr1[i]) i++ } else { arr.push(arr2[j]) j++ } } while (i \u0026lt; arr1.length) { arr.push(arr1[i]) i++ } while (j \u0026lt; arr2.length) { arr.push(arr2[j]) j++ } return arr } æœ€è¿‘çš„è¯·æ±‚æ¬¡æ•° é¢˜ç›®é“¾æ¥\næ€è·¯ ä½¿ç”¨é˜Ÿåˆ—æ¥ç»´æŠ¤æœ€è¿‘ $3000$ ä¸ªè¯·æ±‚çš„æ—¶é—´\nä»£ç  use std::collections::VecDeque; struct RecentCounter { pings: VecDeque\u0026lt;i32\u0026gt;, } impl RecentCounter { fn new() -\u0026gt; Self { Self { pings: VecDeque::new(), } } fn ping(\u0026amp;mut self, t: i32) -\u0026gt; i32 { self.pings.push_back(t); while let Some(x) = self.pings.front() { if x + 3000 \u0026lt; t { self.pings.pop_front(); } else { break; } } self.pings.len() as i32 } } class RecentCounter { pings: number[] = [] constructor() { } ping(t: number): number { this.pings.push(t) while (this.pings[0] \u0026lt; t - 3000) { this.pings.shift() } return this.pings.length } } ","permalink":"https://fffzlfk.github.io/posts/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/","summary":"Algorithms Problems","title":"æ¯æ—¥ä¸€é¢˜"},{"content":"SQLæ¦‚è¿° SQLçš„ç‰¹ç‚¹ ç»¼åˆç»Ÿä¸€ï¼šé›†DQã€DDLã€DMLã€DCLäºä¸€ä½“ é«˜åº¦éè¿‡ç¨‹åŒ–ï¼šä¸ç”¨è€ƒè™‘å¦‚ä½•å®ç°ï¼Œåªéœ€æå‡ºâ€œåšä»€ä¹ˆâ€ï¼Œä¸å…³å¿ƒâ€œæ€ä¹ˆåšâ€ é¢å‘é›†åˆçš„æ“ä½œæ–¹å¼ï¼šæŸ¥è¯¢ã€æ’å…¥ã€åˆ é™¤ã€æ›´æ–°æ“ä½œå¯¹è±¡åŠç»“æœéƒ½æ˜¯é›†åˆ ä»¥åŒä¸€ç§è¯­æ³•ç»“æ„æä¾›ä¸¤ç§ä½¿ç”¨æ–¹æ³•ï¼šå¯äº¤äº’å¼å’ŒåµŒå…¥å¼ä½¿ç”¨ ä»¥ç®€æ·çš„è‡ªç„¶è¯­è¨€å®ç°å¯¹æ•°æ®åº“çš„å®šä¹‰ã€æ“ä½œå’Œæ§åˆ¶åŠŸèƒ½ï¼šå®šä¹‰äº†å°‘é‡çš„å…³é”®å­—å®ç°å¯¹æ•°æ®åº“çš„å®šä¹‰ã€æ“çºµå’Œæ§åˆ¶åŠŸèƒ½ SQLæ‰€ä½¿ç”¨çš„åŠ¨è¯ï¼ˆæ ¸å¿ƒåŠŸèƒ½ï¼‰ SQLåŠŸèƒ½ åŠ¨è¯ æ•°æ®æŸ¥è¯¢ SELECT æ•°æ®å®šä¹‰ CREATE, DROP, ALTER æ•°æ®æ“ä½œ INSERT, UPDATE, DELETE æ•°æ®æ§åˆ¶ GRANT, REVOKE æ•°æ®å®šä¹‰ SQLçš„æ•°æ®å®šä¹‰è¯­å¥ SQLä¸­çš„æ•°æ®ç±»å‹ åŸºæœ¬è¡¨çš„å®šä¹‰ åˆ›å»ºåŸºæœ¬è¡¨ CREATE TABLE \u0026lt;è¡¨å\u0026gt; ( \u0026lt;åˆ—å\u0026gt; \u0026lt;æ•°æ®ç±»å‹\u0026gt;[\u0026lt;åˆ—çº§å®Œæ•´æ€§çº¦æŸæ¡ä»¶\u0026gt;] [, \u0026lt;åˆ—å\u0026gt; \u0026lt;æ•°æ®ç±»å‹\u0026gt;[\u0026lt;åˆ—çº§å®Œæ•´æ€§çº¦æŸæ¡ä»¶\u0026gt;] ] â€¦ [, \u0026lt;è¡¨çº§å®Œæ•´æ€§çº¦æŸæ¡ä»¶\u0026gt; ] ) ; å¸¸ç”¨çš„å®Œæ•´æ€§çº¦æŸ ä¸»ç çº¦æŸï¼šPRIMARY KEY (\u0026lt;åˆ—å1\u0026gt;, \u0026lt;åˆ—å2\u0026gt;,â€¦) éç©ºå€¼çº¦æŸï¼šNOT NULL å”¯ä¸€æ€§çº¦æŸï¼šUNIQUE å‚ç…§å®Œæ•´æ€§çº¦æŸï¼šFOREIGN KEY (\u0026lt;åˆ—å\u0026gt;) REFERENCES \u0026lt;è¡¨å\u0026gt;(\u0026lt;åˆ—å\u0026gt;) ä¸€èˆ¬æ€§çº¦æŸï¼šCHECK(\u0026lt;è°“è¯\u0026gt;) åˆ é™¤åŸºæœ¬è¡¨ DROP TABLE \u0026lt;è¡¨å\u0026gt; [RESTRICT|CASCADE]; RESTRICTï¼šåˆ é™¤è¡¨æ˜¯æœ‰é™åˆ¶çš„ï¼š\næ¬²åˆ é™¤çš„åŸºæœ¬è¡¨ä¸èƒ½è¢«å…¶ä»–è¡¨çš„çº¦æŸæ‰€å¼•ç”¨ å¦‚æœå­˜åœ¨ä¾èµ–è¯¥è¡¨çš„å¯¹è±¡ï¼Œåˆ™æ­¤è¡¨ä¸èƒ½è¢«åˆ é™¤ CASCADEï¼šçº§è”ï¼Œåˆ é™¤è¯¥è¡¨æ²¡æœ‰é™åˆ¶ã€‚ åœ¨åˆ é™¤åŸºæœ¬è¡¨çš„åŒæ—¶ï¼Œç›¸å…³çš„ä¾èµ–å¯¹è±¡ä¸€èµ·åˆ é™¤\nâš ï¸ç¼ºçœæ˜¯RESTRICT\nä¿®æ”¹åŸºæœ¬è¡¨ ALTER TABLE \u0026lt;è¡¨å\u0026gt; [ADD[COLUMN] \u0026lt;æ–°åˆ—å\u0026gt; \u0026lt;æ•°æ®ç±»å‹\u0026gt; [ å®Œæ•´æ€§çº¦æŸ ]] [ADD \u0026lt;è¡¨çº§å®Œæ•´æ€§çº¦æŸ\u0026gt;] [DROP [ COLUMN ] \u0026lt;åˆ—å\u0026gt; [CASCADE|RESTRICT]] [DROP CONSTRAINT\u0026lt;å®Œæ•´æ€§çº¦æŸå\u0026gt;[RESTRICT|CASCADE]] [ALTER COLUMN\u0026lt;åˆ—å\u0026gt; \u0026lt;æ•°æ®ç±»å‹\u0026gt;]; \u0026lt;è¡¨å\u0026gt;ï¼šè¦ä¿®æ”¹çš„åŸºæœ¬è¡¨ ADDå­å¥ï¼šå¢åŠ æ–°åˆ—å’Œæ–°çš„å®Œæ•´æ€§çº¦æŸæ¡ä»¶ DROP COLUMNå­å¥: ç”¨äºåˆ é™¤è¡¨ä¸­çš„åˆ— DROP CONSTRAINTå­å¥ï¼šåˆ é™¤æŒ‡å®šçš„å®Œæ•´æ€§çº¦æŸæ¡ä»¶ ALTER COLUMNå­å¥ï¼šç”¨äºä¿®æ”¹åˆ—åå’Œæ•°æ®ç±»å‹ âš ï¸åˆ é™¤å±æ€§åˆ—\né—´æ¥åˆ é™¤(ç”±DBAæˆ–è¡¨çš„Owneræ“ä½œ) æŠŠè¡¨ä¸­è¦ä¿ç•™çš„åˆ—åŠå…¶å†…å®¹å¤åˆ¶åˆ°ä¸€ä¸ªæ–°è¡¨ä¸­ åˆ é™¤åŸè¡¨ å†å°†æ–°è¡¨é‡å‘½åä¸ºåŸè¡¨å ç›´æ¥åˆ é™¤(SQL-99)\nä¾‹ï¼šALTER TABLE S Drop Scome ; ç´¢å¼•çš„å®šä¹‰ ç´¢å¼•çš„åˆ†ç±» æ™®é€šç´¢å¼•(Normal Index)ï¼šä¸€ä¸ªç´¢å¼•å€¼å¯èƒ½å¯¹åº”å¤šæ¡å­˜å‚¨è®°å½• å•ä¸€ç´¢å¼•(Unique Index)ï¼šæ¯ä¸€ä¸ªç´¢å¼•å€¼åªå¯¹åº”å”¯ä¸€çš„æ•°æ®è®°å½•ã€‚ èšç°‡ç´¢å¼•(Cluster Index)ï¼šåŸºæœ¬è¡¨æŒ‰ç…§ç´¢å¼•é¡¹é¡ºåºç»„ç»‡å­˜å‚¨ã€‚ ä¸€ä¸ªåŸºæœ¬è¡¨ä¸Šæœ€å¤šåªèƒ½å»ºç«‹ä¸€ä¸ªèšç°‡ç´¢å¼• åœ¨æœ€ç»å¸¸æŸ¥è¯¢çš„åˆ—ä¸Šå»ºç«‹èšç°‡ç´¢å¼• ç»å¸¸æ›´æ–°çš„åˆ—ä¸å®œå»ºç«‹èšç°‡ç´¢å¼• åˆ›å»ºç´¢å¼• CREATE [UNIQUE] | [CLUSTER] INDEX \u0026lt;ç´¢å¼•å\u0026gt; ON \u0026lt;è¡¨å\u0026gt;(\u0026lt;åˆ—å\u0026gt;[\u0026lt;æ¬¡åº\u0026gt;][,\u0026lt;åˆ—å\u0026gt;[\u0026lt;æ¬¡åº\u0026gt;] ]â€¦); ç”¨\u0026lt;è¡¨å\u0026gt;æŒ‡å®šè¦å»ºç´¢å¼•çš„åŸºæœ¬è¡¨åå­— ç´¢å¼•å¯ä»¥å»ºç«‹åœ¨è¯¥è¡¨çš„ä¸€åˆ—æˆ–å¤šåˆ—ä¸Šï¼Œå„åˆ—åä¹‹é—´ç”¨é€—å·åˆ†éš” ç”¨\u0026lt;æ¬¡åº\u0026gt;æŒ‡å®šç´¢å¼•å€¼çš„æ’åˆ—æ¬¡åºã€‚å‡åºï¼šASCï¼Œé™åºï¼šDESCï¼Œç¼ºçœå€¼ï¼šASC UNIQUEè¡¨æ˜æ­¤ç´¢å¼•çš„æ¯ä¸€ä¸ªç´¢å¼•å€¼å¯¹åº”å”¯ä¸€çš„æ•°æ®è®°å½• CLUSTERè¡¨ç¤ºè¦å»ºç«‹çš„ç´¢å¼•æ˜¯èšç°‡ç´¢å¼• ä¾‹7: ä¸ºå­¦ç”Ÿè¡¨Så’Œé€‰è¯¾è¡¨SCå»ºç«‹ç´¢å¼•ã€‚å…¶ä¸­Sè¡¨æŒ‰å­¦å·å‡åºå»ºå”¯ä¸€ç´¢å¼•ï¼ŒæŒ‰å¹´é¾„é™åºå»ºç«‹æ™®é€šç´¢å¼•ï¼ŒSCè¡¨æŒ‰å­¦å·å‡åºå’Œè¯¾ç¨‹å·é™åºå»ºå”¯ä¸€ç´¢å¼•ã€‚\nCREATE UNIQUE INDEX Stusno ON S (Sno); CREATE INDEX Stusage ON S (Sage DESC); CREATE UNIQUE INDEX SCno ON SC(Sno ASC, Cno DESC); åˆ é™¤ç´¢å¼• DROP INDEX \u0026lt;ç´¢å¼•å\u0026gt;;\nä¿®æ”¹ç´¢å¼• ALTER INDEX \u0026lt;æ—§ç´¢å¼•å\u0026gt; RENAME TO \u0026lt;æ–°ç´¢å¼•å\u0026gt;;\næ•°æ®æŸ¥è¯¢ æŸ¥è¯¢è¯­æ³•\nSELECT [ALL | DISTINCT] \u0026lt;ç›®æ ‡åˆ—è¡¨è¾¾å¼\u0026gt; [,\u0026lt;ç›®æ ‡åˆ—è¡¨è¾¾å¼\u0026gt;] â€¦ FROM \u0026lt;è¡¨åæˆ–è§†å›¾å\u0026gt;[, \u0026lt;è¡¨åæˆ–è§†å›¾å\u0026gt; ] â€¦ [ WHERE \u0026lt;æ¡ä»¶è¡¨è¾¾å¼\u0026gt; ] [ GROUP BY \u0026lt;åˆ—å1\u0026gt; [ HAVING \u0026lt;æ¡ä»¶è¡¨è¾¾å¼\u0026gt; ] ] [ ORDER BY \u0026lt;åˆ—å2\u0026gt; [ ASC | DESC ] ] ; å•è¡¨æŸ¥è¯¢ ç›®æ ‡åˆ—ä¸ºè¡¨è¾¾å¼çš„æŸ¥è¯¢\nSELECT Sname, 1996 - Sage FROM Student ; ä½¿ç”¨åˆ«åæ”¹å˜æŸ¥è¯¢ç»“æœçš„åˆ—æ ‡é¢˜\nSELECT Sname NAME, \u0026#39;Year of Birth:\u0026#39; BIRTH, 1996 - Sage BIRTHYEAR, ISLOWER ( Sdept ) DEPARTMENT æ¶ˆé™¤ç»“æœä¸­é‡å¤çš„è¡Œ\nSELECT **DISTINCT** Sno FROM SC ; é™å®šæŸ¥è¯¢èŒƒå›´\næŸ¥è¯¢æ¡ä»¶ è°“ã€€è¯ æ¯”ã€€è¾ƒ = , \u0026lt; , \u0026gt; , \u0026lt;= , \u0026gt;= , \u0026lt;\u0026gt; , != , !\u0026gt; , !\u0026lt; ; NOT + ä¸Šè¿°æ¯”è¾ƒç¬¦ ç¡®å®šèŒƒå›´ BETWEEN â€¦ AND â€¦ , NOT BETWEEN â€¦ AND â€¦ ç¡®å®šé›†åˆ IN, NOT IN å­—ç¬¦åŒ¹é… LIKE, NOT LIKE ç©ºã€€å€¼ IS NULL, IS NOT NULL å¤šé‡æ¡ä»¶ AND, OR - ç¡®å®šèŒƒå›´\nSELECT Sname, Sdept, Sage FROM Student WHERE Sage BETWEEN 20 AND 23 ; ç¡®å®šé›†åˆ\nSELECT Sname, Ssex FROM Student WHERE Sdept NOT IN (\u0026#39;IS\u0026#39;, \u0026#39;MA\u0026#39;, \u0026#39;CS\u0026#39;) ; å­—ç¬¦ä¸²åŒ¹é…\n[NOT] LIKE â€˜\u0026lt;åŒ¹é…æ¨¡æ¿\u0026gt;â€™ [ESCAPE â€˜\u0026lt;æ¢ç å­—ç¬¦\u0026gt;â€™] %(ç™¾åˆ†å·)ï¼šä»£è¡¨ä»»æ„é•¿åº¦(å¯ä»¥ä¸º0)çš„å­—ç¬¦ä¸²ã€‚\nä¾‹ï¼ša%bè¡¨ç¤ºä»¥aå¼€å¤´ï¼Œä»¥bç»“å°¾çš„ä»»æ„é•¿åº¦çš„å­—ç¬¦ä¸²ã€‚å¦‚acbï¼Œaddgbï¼Œab ç­‰éƒ½æ»¡è¶³è¯¥åŒ¹é…ä¸²ã€‚\n_(ä¸‹æ¨ªçº¿)ï¼šä»£è¡¨ä»»æ„å•ä¸ªå­—ç¬¦ã€‚\nä¾‹ï¼ša_bè¡¨ç¤ºä»¥aå¼€å¤´ï¼Œä»¥bç»“å°¾çš„é•¿åº¦ä¸º3çš„ä»»æ„å­—ç¬¦ä¸²ã€‚å¦‚acbï¼Œafbç­‰éƒ½æ»¡è¶³è¯¥åŒ¹é…ä¸²ï¼Œä¸€ä¸ªæ±‰å­—ä¸¤ä¸ªä¸‹æ¨ªçº¿\nå½“è¦æŸ¥è¯¢çš„å­—ç¬¦ä¸²æœ¬èº«å°±å«æœ‰ % æˆ– _ æ—¶ï¼Œè¦ä½¿ç”¨ ESCAPE '\u0026lt;æ¢ç å­—ç¬¦\u0026gt;'çŸ­è¯­å¯¹é€šé…ç¬¦è¿›è¡Œè½¬ä¹‰ã€‚\nSELECT Cno, Ccredit FROM Course WHERE Cname LIKE \u0026#39;DB\\_Design\u0026#39; ESCAPE \u0026#39;\\\u0026#39; ; ;è½¬ä¹‰ç¬¦â€˜\\â€™è¡¨ç¤ºæ¨¡æ¿ä¸­å‡ºç°åœ¨å…¶åçš„ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸å†æ˜¯é€šé…ç¬¦ï¼Œè€Œæ˜¯å­—ç¬¦æœ¬èº«ã€‚ æ¶‰åŠç©ºå€¼çš„æŸ¥è¯¢\nä½¿ç”¨è°“è¯ IS NULL æˆ– IS NOT NULLï¼Œâ€œIS NULLâ€ ä¸èƒ½ç”¨ â€œ= NULLâ€ ä»£æ›¿ï¼\næ’åºè¾“å‡º\nORDER BY å‡åºï¼šASC ï¼Œæ’åˆ—ä¸ºç©ºå€¼çš„å…ƒç»„æœ€åæ˜¾ç¤º ï¼ˆç©ºå€¼æœ€å¤§ï¼‰ é™åºï¼šDESC èšé›†å‡½æ•°\nè®¡æ•° COUNT (ä½¿ç”¨ DISTINCT é¿å…é‡å¤è®¡æ•°) è®¡ç®—æ€»å’Œ SUM è®¡ç®—å¹³å‡å€¼ AVG æ±‚æœ€å¤§å€¼ MAX æ±‚æœ€å°å€¼ MIN [ GROUP BY \u0026lt;åˆ—å1\u0026gt;[, åˆ—å2â€¦] [ HAVING \u0026lt;æ¡ä»¶è¡¨è¾¾å¼\u0026gt; ] ] æœªå¯¹æŸ¥è¯¢ç»“æœåˆ†ç»„ï¼Œé›†å‡½æ•°å°†ä½œç”¨äºæ•´ä¸ªæŸ¥è¯¢ç»“æœ\nå¯¹æŸ¥è¯¢ç»“æœåˆ†ç»„åï¼Œé›†å‡½æ•°å°†åˆ†åˆ«ä½œç”¨äºæ¯ä¸ªç»„\nâš ï¸ä½¿ç”¨GROUP BYå­å¥åï¼ŒSELECTå­å¥çš„åˆ—åè¡¨ä¸­åªèƒ½å‡ºç°åˆ†ç»„å±æ€§å’Œé›†å‡½æ•°\né›†å‡½æ•°åªèƒ½ç”¨äºSELECTå­å¥å’Œ HAVINGçŸ­è¯­ä¹‹ä¸­ï¼Œè€Œç»å¯¹ä¸èƒ½å‡ºç°åœ¨ WHERE å­å¥ä¸­(WHEREå­å¥æ‰§è¡Œè¿‡ç¨‹æ˜¯å¯¹è®°å½•é€ä¸€æ£€éªŒï¼Œå¹¶æ²¡æœ‰ç»“æœé›†ï¼Œæ•…æ— æ³•æ–½åŠ é›†å‡½æ•°)ã€‚\nè¿æ¥æŸ¥è¯¢ ç­‰å€¼è¿æ¥ã€è‡ªç„¶è¿æ¥\nSELECTå­å¥å’ŒWHEREå­å¥ä¸­å‡ºç°çš„ä¸¤ä¸ªåŒåå±æ€§å‰è¦åŠ æ‰€å±è¡¨åä½œå‰è¾ä»¥åŒºåˆ«ï¼Œæ— åŒååˆ™å¯çœå‰è¾ã€‚\nè‡ªèº«è¿æ¥\néœ€è¦ç»™è¡¨èµ·åˆ«åä»¥ç¤ºåŒºåˆ«ï¼Œç”±äºæ‰€æœ‰çš„å±æ€§åéƒ½æ˜¯åŒåå±æ€§ï¼Œ å› æ­¤å¿…é¡»ä½¿ç”¨åˆ«åå‰ç¼€\nå¤–è¿æ¥ Outer Join\nå·¦å¤–è¿æ¥ï¼šåœ¨è¿æ¥çš„å³è¾¹å‡ºç°ç©ºè¡Œ å³å¤–è¿æ¥ï¼šåœ¨è¿æ¥çš„å·¦è¾¹å‡ºç°ç©ºè¡Œ å·¦å³å¤–é“¾æ¥ï¼šåœ¨è¿æ¥çš„å·¦å³å‡ºç°ç©ºè¡Œ Note\nè¿æ¥ç±»å‹\n- å†…è¿æ¥ï¼ˆINNER JOINï¼‰\n- å·¦å¤–è¿æ¥ï¼ˆLEFT OUTER JOINï¼‰\n- å³å¤–è¿æ¥ï¼ˆRIGHT OUTER JOINï¼‰\n- å…¨å¤–è¿æ¥ï¼ˆFULL OUTER JOINï¼‰\nåµŒå¥—æŸ¥è¯¢ å¸¦æœ‰INè°“è¯çš„å­æŸ¥è¯¢ å¸¦æœ‰æ¯”è¾ƒè¿ç®—ç¬¦çš„å­æŸ¥è¯¢ âš ï¸ç‰¹åˆ«æ³¨æ„ï¼šå­æŸ¥è¯¢ä¸€å®šè¦è·Ÿåœ¨æ¯”è¾ƒç¬¦ä¹‹åï¼ å¸¦æœ‰ANY(SOME)æˆ–ALLè°“è¯çš„æŸ¥è¯¢ å¸¦æœ‰EXISTSè°“è¯çš„å­æŸ¥è¯¢ EXISTSè°“è¯çš„æ„ä¹‰ï¼š\næ˜¯å­˜åœ¨é‡è¯åœ¨SQLä¸­çš„åº”ç”¨ å¸¦æœ‰EXISTSè°“è¯çš„å­æŸ¥è¯¢ä¸è¿”å›ä»»ä½•æ•°æ®ï¼Œåªäº§ç”Ÿé€»è¾‘çœŸå€¼â€œtrueâ€æˆ–é€»è¾‘å‡å€¼â€œfalseâ€ è‹¥å†…å±‚æŸ¥è¯¢ç»“æœéç©ºï¼Œåˆ™è¿”å›çœŸå€¼ è‹¥å†…å±‚æŸ¥è¯¢ç»“æœä¸ºç©ºï¼Œåˆ™è¿”å›å‡å€¼ ç”±EXISTSå¼•å‡ºçš„å­æŸ¥è¯¢ï¼Œå…¶ç›®æ ‡åˆ—è¡¨è¾¾å¼é€šå¸¸éƒ½ç”¨*ï¼šå› ä¸ºå¸¦EXISTSçš„å­æŸ¥è¯¢åªè¿”å›çœŸå€¼æˆ–å‡å€¼ï¼Œç»™å‡ºåˆ—åæ— å®é™…æ„ä¹‰ åµŒå¥—æŸ¥è¯¢å°ç»“ åµŒå¥—æŸ¥è¯¢åˆ†ä¸ºç›¸å…³å­æŸ¥è¯¢å’Œä¸ç›¸å…³å­æŸ¥è¯¢\nä¸ç›¸å…³å­æŸ¥è¯¢çš„æ‰§è¡Œä¸ä¾èµ–äºçˆ¶æŸ¥è¯¢çš„ä»»ä½•æ¡ä»¶ è¯­å¥ä¸Šä¸å‡ºç°çˆ¶æŸ¥è¯¢ä¸­çš„å±æ€§ æ‰§è¡Œä¸Šé¦–å…ˆè¿è¡Œï¼Œä¸”åªè¿è¡Œä¸€æ¬¡å³å¯å¾—åˆ°ç¡®å®šçš„ç»“æœ å­æŸ¥è¯¢çš„ç»“æœé›†å°†ä½œä¸ºçˆ¶æŸ¥è¯¢çš„æ¡ä»¶ä½¿ç”¨ ç›¸å…³å­æŸ¥è¯¢çš„æ‰§è¡Œä¸çˆ¶æŸ¥è¯¢çš„å½“å‰å€¼ç›¸å…³ è¯­å¥ä¸Šå‡ºç°çˆ¶æŸ¥è¯¢ä¸­çš„å±æ€§ æ‰§è¡Œä¸Šçˆ¶æŸ¥è¯¢çš„å½“å‰å€¼ä¼šä½œä¸ºå­æŸ¥è¯¢çš„æ¡ä»¶ å­æŸ¥è¯¢çš„å±æ€§ä¸ä¼šå‡ºç°åœ¨çˆ¶æŸ¥è¯¢çš„è¾“å‡ºä¸Š(Select å­å¥) å­æŸ¥è¯¢ä¸èƒ½ä½¿ç”¨ORDER BYå­å¥ï¼Œ ORDER BYå­å¥åªèƒ½å¯¹æœ€ç»ˆç»“æœæ’åº é›†åˆæŸ¥è¯¢ å°†ä¸¤ä¸ªSELECT-FROM-WHEREæŸ¥è¯¢å—ç”¨é›†åˆæ“ä½œå‘½ä»¤è”ç»“èµ·æ¥çš„æŸ¥è¯¢\né›†åˆæ“ä½œå‘½ä»¤ å¹¶æ“ä½œï¼ˆUNIONï¼‰ äº¤æ“ä½œï¼ˆINTERSECTï¼‰ å·®æ“ä½œï¼ˆEXCEPTï¼‰ è¯­å¥å½¢å¼ \u0026lt;æŸ¥è¯¢å—\u0026gt; UNION [ALL] | INTERSECT | EXCEPT \u0026lt;æŸ¥è¯¢å—\u0026gt; ; æ•°æ®æ›´æ–° æ’å…¥æ•°æ® æ’å…¥å•ä¸ªå…ƒç»„ æ’å…¥å­æŸ¥è¯¢ç»“æœ INSERT INTO \u0026lt;è¡¨å\u0026gt; [(\u0026lt;å±æ€§åˆ—1\u0026gt; [, \u0026lt;å±æ€§åˆ—2\u0026gt;â€¦ )] å­æŸ¥è¯¢ ; ä¿®æ”¹æ•°æ® åˆ é™¤æ•°æ® DELETE FROM \u0026lt;è¡¨å\u0026gt; [WHERE \u0026lt;æ¡ä»¶\u0026gt;] ; æ³¨æ„äº‹é¡¹ DBMSåœ¨æ‰§è¡Œæ’å…¥ã€åˆ é™¤ã€ä¿®æ”¹è¯­å¥æ—¶å¿…é¡»ä¿è¯æ•°æ®åº“çš„å®Œæ•´æ€§å’Œä¸€è‡´æ€§ã€‚\n","permalink":"https://fffzlfk.github.io/posts/sql/","summary":"SQL è¯­å¥","title":"SQL"},{"content":"å•æ ¸å¤„ç†å™¨8086/8088 å¯„å­˜å™¨ç»“æ„ é€šç”¨å¯„å­˜å™¨ Reg ç‰¹æ®Šç”¨é€” AX,AL I/O æŒ‡ä»¤çš„æ•°æ®å¯„å­˜å™¨ï¼›ä¹˜æ³•æŒ‡ä»¤å­˜æ”¾è¢«ä¹˜æ•°æˆ–ç§¯(éšå«)ï¼Œé™¤æ³•æŒ‡ä»¤å­˜æ”¾è¢«é™¤æ•°æˆ–å•†(éšå«) AH LAHFæŒ‡ä»¤çš„ç›®æ ‡å¯„å­˜å™¨(éšå«) AL æ•°åˆ¶è½¬æ¢æˆ–åè¿›åˆ¶è¿ç®—æŒ‡ä»¤å’ŒXLATæŒ‡ä»¤çš„ç´¯åŠ å™¨(éšå«) BX é—´æ¥å¯»å€çš„åŸºå€å¯„å­˜å™¨ XLATæŒ‡ä»¤çš„åŸºå€å¯„å­˜å™¨(éšå«) CX ä¸²æ“ä½œå’ŒLOOPæŒ‡ä»¤çš„è®¡æ•°å™¨(éšå«) DX å­—ä¹˜æ³•/é™¤æ³•æŒ‡ä»¤å­˜æ”¾ä¹˜ç§¯é«˜16ä½æˆ–è¢«é™¤æ•°é«˜ä½æˆ–ä½™æ•°(éšå«) é—´æ¥å¯»å€çš„ I/O ç«¯å£åœ°å€ SI ä¸²æ“ä½œçš„æºå˜å€å¯„å­˜å™¨(éšå«)ã€é—´æ¥å¯»å€çš„å˜å€å¯„å­˜å™¨ DI ä¸²æ“ä½œçš„ç›®æ ‡å˜å€å¯„å­˜å™¨(éšå«)ã€é—´æ¥å¯»å€çš„å˜å€å¯„å­˜å™¨ BP å¯¹å †æ ˆåŒºé—´æ¥å¯»å€çš„åŸºå€æŒ‡é’ˆ SP å †æ ˆæ“ä½œçš„å †æ ˆé¡¶éƒ¨æŒ‡é’ˆ æ ‡å¿—å¯„å­˜å™¨ 6ä¸ªçŠ¶æ€æ ‡å¿—ä½\nCFï¼Œè¿›ä½æ ‡å¿—ã€‚æœ¬æ¬¡è¿ç®—æœ€é«˜ä½æœ‰è¿›ä½æˆ–å€Ÿä½å‘ç”Ÿï¼Œåˆ™CF=1ã€‚STCï¼ˆCLCï¼‰æŒ‡ä»¤ä½¿CF=1ï¼ˆ=0ï¼‰ï¼ŒCMCæŒ‡ä»¤ä½¿ä¹‹å–åã€‚ï¼ˆç”¨äºæ— ç¬¦å·æ•°ï¼‰\nPFï¼Œå¥‡å¶æ ¡éªŒæ ‡å¿—ï¼šä½ 8 ä½æœ‰å¶æ•°ä¸ª 1 åˆ™ PF = 1\nAFï¼šè¾…åŠ©è¿›ä½æ ‡å¿—\nä½ 4 ä½å‘é«˜å››ä½æœ‰è¿›ä½æˆ–å€Ÿä½ï¼Œ AF = 1 ï¼ˆç”¨äº BCD è®¡ç®—ï¼‰\nZFï¼šå…¨é›¶æ ‡å¿—\nè¿ç®—ç»“æœä¸º 0 æ—¶ï¼ŒZF = 1ï¼›\nSFï¼šç¬¦å·æ ‡å¿—\nè¿ç®—ç»“æœæœ€é«˜ä½ä¸º1ï¼ŒSF = 1 ï¼ˆè¡¨ç¤ºè´Ÿæ•°ï¼‰\nOFï¼šæº¢å‡ºæ ‡å¿—\nè¿ç®—äº§ç”Ÿæº¢å‡º ï¼ˆä¸¤è´Ÿæ•°ç›¸åŠ ä¸ºæ­£ï¼‰ï¼ˆæœ‰ç¬¦å·æ•°ï¼‰æ—¶ï¼Œ OF =1\n3 ä¸ªæ§åˆ¶æ ‡å¿—ä½\nTFï¼šå•æ­¥æ ‡å¿— IFï¼šä¸­æ–­æ ‡å¿—ï¼šIF = 1 å…è®¸ï¼ŒIF=0 ç¦æ­¢ CPU å“åº”å¯å±è”½ä¸­æ–­ ï¼ˆINTRï¼‰ DFï¼šæ–¹å‘æ ‡å¿—ï¼Œä¸²æ“ä½œæŒ‡ä»¤çš„åœ°å€å˜åŒ–æ–¹å‘ ä¸»å­˜ç»“æ„ åŒä½“ç»“æ„ æ—¢èƒ½å®ç°16ä½å­˜å‚¨ï¼Œä¹Ÿå¯ä»¥å®ç°8ä½å­˜å‚¨ã€‚ åˆ†æ®µç»“æ„ 68320H + 1280H -------- 695A0H èŠ¯ç‰‡å¼•è„š 8086èŠ¯ç‰‡å¼•è„š 8088èŠ¯ç‰‡å¼•è„š 8086vs.8088 æŒ‡ä»¤é¢„å–åºåˆ—ï¼š4Bytes\u0026lt;=\u0026gt;6Bytes AD7~AD0\nAD15~AD0 =\u0026gt; æ€»çº¿ä¼ é€’æ•°æ®æ›´å¿« 8088ï¼š$ \\overline{SSO} $, 8086: $ \\overline{BHE} / S7 $ 8088: $ IO/\\overline M $, 8086: $ M/\\overline{IO} $ å·¥ä½œæ—¶åº æ—¶é’Ÿå‘¨æœŸï¼šCPUå¤„ç†åŠ¨ä½œæœ€å°å•ä½ æ€»çº¿å‘¨æœŸï¼šå­˜å‚¨å™¨è¯»å†™ã€I/Oè¯»å†™ã€ä¸­æ–­å“åº” æŒ‡ä»¤å‘¨æœŸï¼šå–æŒ‡+æ‰§è¡Œ ä¸»å­˜è¯»æ—¶åºåˆ†æ ä¹ é¢˜ 2.2 è‹¥8086CPUå·¥ä½œåœ¨æœ€å°æ¨¡å¼ä¸‹ï¼š\nå½“CPUè®¿é—®å‚¨å­˜å™¨æ—¶ï¼Œè¦åˆ©ç”¨å“ªäº›ä¿¡å·ï¼Ÿ $AD0 \\sim AD15ã€A16\\sim A19ã€ALEã€\\overline{BHE}ã€DT/\\overline{R}ã€\\overline{DEN}ã€M/\\overline{IO}ã€\\overline{RD}ã€\\overline{WR}$\nå½“CPUè®¿é—®å¤–è®¾ç«¯å£æ—¶ï¼Œè¦åˆ©ç”¨å“ªäº›ä¿¡å·ï¼Ÿ $AD0 \\sim AD15ã€ALEã€\\overline{BHE}ã€DT/\\overline{R}ã€\\overline{DEN}ã€M/\\overline{IO}ã€\\overline{RD}ã€\\overline{WR}$\nå½“HOLDæœ‰æ•ˆå¹¶å¾—åˆ°å›åº”æ—¶ï¼ŒCPUçš„å“ªäº›ä¿¡å·ç½®é«˜é˜»ï¼Ÿ CPUæ‰€æœ‰ä¸‰æ€è¾“å‡ºçš„åœ°å€ã€æ•°æ®å’Œç›¸å…³æ§åˆ¶ä¿¡å·ã€‚\n2.2 è‹¥8086CPUå·¥ä½œåœ¨æœ€å¤§æ¨¡å¼ä¸‹ï¼š\nS0ã€S1ã€S2å¯ä»¥è¡¨ç¤ºå“ªäº›CPUçš„çŠ¶æ€ï¼Ÿ INTAå‘¨æœŸã€I/Oè¯»å‘¨æœŸã€I/Oå†™å‘¨æœŸã€æš‚åœã€å–å€¼å‘¨æœŸã€å­˜å‚¨å™¨è¯»å‘¨æœŸã€å­˜å‚¨å™¨å†™å‘¨æœŸ\nCPUçš„$ \\overline{RQ}/\\overline{GT} $ä¿¡å·çš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿ $ \\overline{RQ}/\\overline{GT} $æ˜¯è£å†³æ€»çº¿ä½¿ç”¨æƒçš„è¯·æ±‚/å…è®¸ä¿¡å·\nIntelæŒ‡ä»¤ç³»ç»Ÿä¸ç¨‹åºè®¾è®¡ ç¨‹åºæ¡†æ¶ STACK SEGMENT STACK DB 100 DUP(0) STACK ENDS DATA SEGMENT NUM8 DB 16,25 NUM16 DW 36,64 ARRAY8 DB 20 DUP(0) â€¦â€¦â€¦ â€¦â€¦â€¦â€¦ DATA ENDS CODE SEGMENT ASSUME CS:CODE,DS:DATA,SS:STACK START: MOV AX,DATA MOV DS,AX â€¦â€¦â€¦â€¦ MOV AX,4C00H INT 21H CODE ENDS END START å­ç¨‹åºç»“æ„\nâ€¦â€¦ CALL SUB1 â€¦â€¦ SUB1 PROC PUSH â€¦ â€¦â€¦ POP â€¦ RET SUB1 ENDP æ•°æ®ä¼ é€ã€å¯»å€ã€ç®—æœ¯è¿ç®—æŒ‡ä»¤ æ•°æ®ä¼ é€ MOVæŒ‡ä»¤\nMOVæŒ‡ä»¤å¿…é¡»éµä»çš„çš„è§„åˆ™ï¼š ä¸¤ä¸ªæ“ä½œæ•°çš„å°ºå¯¸å¿…é¡»ä¸€è‡´ ä¸¤ä¸ªæ“ä½œæ•°ä¸èƒ½åŒä¸ºæ“ä½œæ•° ç›®çš„æ“ä½œæ•°ä¸èƒ½ä½CS, EIPå’ŒIP ç«‹å³æ•°ä¸èƒ½ç›´æ¥é€è‡³æ®µå¯„å­˜å™¨ mov r/m16,sreg mov sreg,r/m16 MOVæŒ‡ä»¤æ ¼å¼ mov reg, reg mov mem, reg mov reg, mem mov mem, imm mov reg, emm æ•´æ•°çš„é›¶/ç¬¦å·æ‰©å±•\nMOVZX MOVSZ XCHGæŒ‡ä»¤\näº¤æ¢ä¸¤ä¸ªæ“ä½œæ•°çš„å†…å®¹\nåŠ æ³•å’Œå‡æ³• INCå’ŒDECæŒ‡ä»¤\ninc reg/mem dec reg/mem \u0026lt; notice tip \u0026gt; INCå’ŒDECæŒ‡ä»¤ä¸å½±å“è¿›ä½æ ‡å¿— \u0026lt; /notice \u0026gt;\nADDã€SUBã€NEGæŒ‡ä»¤\nå½±å“çš„æ ‡å¿—ä½ï¼šCF, ZF, SF, OF, AF, PF\nå’Œæ•°æ®ç›¸å…³çš„æ“ä½œç¬¦å’Œä¼ªæŒ‡ä»¤ OFFSETæ“ä½œç¬¦\nPTRæ“ä½œç¬¦\nç”¨æ¥é‡è½½æ“ä½œæ•°çš„é»˜è®¤å°ºå¯¸ å¿…é¡»å’Œæ ‡å‡†æ•°æ®ç±»å‹è”åˆä½¿ç”¨ .data myDouble DWORD 12345678h .code mov ax, myDouble ; é”™è¯¯ mov ax, WORD PTR myDouble ; ax = 5678h mov ax, WORD PTR [myDouble+2] ; ax = 1234h mov bl, BYTE PTR myDouble ; bl = 78h TYPEæ“ä½œç¬¦ è¿”å›æŒ‰å­—èŠ‚è®¡ç®—çš„å˜é‡çš„å•ä¸ªå…ƒç´ çš„å¤§å°\nLENGTHOFæ“ä½œç¬¦ è®¡ç®—æ•°ç»„å…ƒç´ çš„ä¸ªæ•°\nSIZEOFæ“ä½œç¬¦ SIZEOFè¿”å›å€¼=LENGTHOFè¿”å›å€¼*TYPEè¿”å›å€¼\né—´æ¥å¯»å€ é—´æ¥æ“ä½œæ•°(å¯„å­˜å™¨é—´æ¥å¯»å€)\nPTRä¸é—´æ¥æ“ä½œæ•°çš„è”åˆä½¿ç”¨ï¼š\ninc [esi] ; error: operand must have size inc BYTE PTR [esi] æ•°ç»„\nä¾‹ï¼šä¸‰ä¸ªåŒå­—ç›¸åŠ \n.data arrayD DWORD 10000h,20000h,30000h .code mov esi, OFFSET arrayD mov eax, [esi] add esi, 4 add eax, [esi] add esi, 4 add eax, [esi] å˜å€æ“ä½œæ•°(å¯„å­˜å™¨ç›¸å¯¹å¯»å€)\nä¾‹ï¼š\n.data arrayB BYTE 10h, 20h, 30h .code mov esi, 0 mov al, [arrayB+esi] ; AL = 10h mov al, arrayB[esi] ; åŒä¸Šï¼Œå¦ä¸€ç§æ ¼å¼ mov esi, OFFSET arrayB mov al, [esi] ; AL = 10h mov al, [esi+1] ; AL = 20h mov al, [esi+2] ; AL = 30h JMPå’ŒLOOPæŒ‡ä»¤ JMPï¼šæ— æ¡ä»¶è½¬ç§» LOOP:æ¡ä»¶è½¬ç§» åœ¨å®åœ°å€æ¨¡å¼ä¸‹ï¼Œç”¨åšé»˜è®¤å¾ªç¯è®¡æ•°å™¨çš„æ˜¯CXè€Œä¸æ˜¯ECX åœ¨ä»»ä½•æ¨¡å¼ä¸‹ï¼ŒLOOPDæŒ‡ä»¤éƒ½ä½¿ç”¨ECXä½œä¸ºå¾ªç¯è®¡æ•°å™¨ï¼ŒLOOPWéƒ½ä½¿ç”¨CXä½œä¸ºå¾ªç¯è®¡æ•°å™¨ å¾ªç¯çš„ç›®çš„åœ°å€ä¸å½“å‰åœ°å€åªèƒ½åœ¨ç›¸è·-128åˆ°+127å­—èŠ‚çš„èŒƒå›´ä¹‹å†…ã€‚æœºå™¨æŒ‡ä»¤å¹³å‡åœ¨3å­—èŠ‚å·¦å³ï¼Œå› æ­¤ä¸€ä¸ªå¾ªç¯å¹³å‡æœ€å¤šåªèƒ½åŒ…å«å¤§çº¦42æ¡æŒ‡ä»¤ å¾ªç¯çš„åµŒå¥— .data count DWORD ? .code mov ecx, 100 L1: mov count, ecx mov ecx, 20 L2: ... ... loop L2 mov ecx, count loop L1 å°ç»“ï¼šæ“ä½œæ•°ç±»å‹ï¼ˆå¯»å€æ–¹å¼ï¼‰ ç›´æ¥æ“ä½œæ•°ï¼ˆç›´æ¥å¯»å€ï¼‰ å˜é‡çš„åå­—ï¼Œä»£è¡¨å˜é‡çš„åœ°å€ ç›´æ¥åç§»æ“ä½œæ•° åœ¨å˜é‡çš„åå­—ä¸ŠåŠ ä¸€ä¸ªåç§»é‡ é—´æ¥æ“ä½œæ•°ï¼ˆå¯„å­˜å™¨é—´æ¥å¯»å€ï¼‰ ç”¨æ–¹æ‹¬å·æ‹¬èµ·çš„åŒ…å«æ•°æ®åœ°å€çš„å¯„å­˜å™¨ å˜å€æ“ä½œæ•°ï¼ˆå¯„å­˜å™¨ç›¸å¯¹å¯»å€ï¼‰ æŠŠå¸¸é‡å’Œé—´æ¥æ“ä½œæ•°ç»“åˆåœ¨ä¸€èµ· è¿‡ç¨‹ ä¸å¤–éƒ¨åº“é“¾æ¥ ç¨‹åºä¸­è¦ç”¨PROTOä¼ªæŒ‡ä»¤å£°æ˜è¦è°ƒç”¨çš„ç¨‹åº: WriteString PROTO ç”¨ä¸€æ¡CALLæŒ‡ä»¤æ‰§è¡ŒWriteStringè¿‡ç¨‹: call WriteString å½“ç¨‹åºè¢«ç¼–è¯‘æ—¶ï¼Œç¼–è¯‘å™¨ä¸ºCALLæŒ‡ä»¤çš„ç›®æ ‡åœ°å€ç•™å‡ºç©ºç™½ï¼Œè¯¥ç©ºç™½å°†æœ‰é“¾æ¥å™¨å¡«å…… è¿æ¥å™¨åœ¨é“¾æ¥åº“ä¸­æŸ¥æ‰¾WriteStringè¿™ä¸ªåå­—ï¼Œä»åº“ä¸­æŠŠåˆé€‚çš„æœºå™¨æŒ‡ä»¤æ‹·è´åˆ°ç¨‹åºçš„å¯æ‰§è¡Œæ–‡ä»¶ä¸­ï¼Œå¹¶æŠŠWriteStringçš„åœ°å€æ’å…¥åˆ°CALLæŒ‡ä»¤ä¸­ å †æ ˆæ“ä½œ å †æ ˆ å‹æ ˆæ“ä½œï¼š 32ä½çš„å‹æ ˆï¼ˆPUSHï¼‰æ“ä½œå°†å †æ ˆæŒ‡é’ˆå‡4ï¼Œå¹¶å°†è¿›æ ˆæ•°æ®æ‹·è´åˆ°å †æ ˆæŒ‡é’ˆæ‰€æŒ‡å‘çš„ä½ç½®\nå‡ºæ ˆæ“ä½œï¼š å‡ºæ ˆï¼ˆPOPï¼‰æ“ä½œä»å †æ ˆé¡¶ç«¯ç§»èµ°ä¸€ä¸ªå€¼å¹¶å°†å…¶ç½®äºå¯„å­˜å™¨æˆ–å˜é‡ä¸­ã€‚åœ¨å€¼ä»æ ˆé¡¶å¼¹å‡ºåï¼Œå †æ ˆæŒ‡é’ˆç›¸åº”å¢åŠ ã€‚\nå †æ ˆçš„ç”¨é€”ï¼š\nä¸´æ—¶ä¿å­˜åŒºåŸŸ CALLæŒ‡ä»¤ç”¨å †æ ˆä¿å­˜å½“å‰è¿‡ç¨‹çš„âš ï¸è¿”å›åœ°å€ è°ƒç”¨è¿‡ç¨‹æ—¶,é€šè¿‡å †æ ˆ:âš ï¸ä¼ é€’å‚æ•° è¿‡ç¨‹å†…çš„âš ï¸å±€éƒ¨å˜é‡åœ¨å †æ ˆä¸Šåˆ›å»ºï¼Œè¿‡ç¨‹ç»“æŸæ—¶ï¼Œè¿™äº›å˜é‡è¢«ä¸¢å¼ƒ PUSHå’ŒPOPæŒ‡ä»¤ PUSHæŒ‡ä»¤\næ‰§è¡Œè¿‡ç¨‹ å‡å°ESPçš„å€¼ 16ä½æ“ä½œæ•°ï¼šESPå‡2 32ä½æ“ä½œæ•°ï¼šESPå‡4 å°†ä¸€ä¸ª16ä½æˆ–32ä½çš„æºæ“ä½œæ•°æ‹·è´è‡³å †æ ˆä¸Š æŒ‡ä»¤æ ¼å¼ push r/m16\rpush r/m32\rpush imm32 ä¿æŠ¤æ¨¡å¼ä¸‹çš„ç«‹å³æ•°æ€»æ˜¯32ä½çš„ï¼› åœ¨å®åœ°å€æ¨¡å¼ä¸‹ï¼Œå¦‚æœæœªä½¿ç”¨.386ï¼ˆæˆ–æ›´é«˜ï¼‰å¤„ç†å™¨ä¼ªæŒ‡ä»¤ï¼Œé»˜è®¤çš„ç«‹å³æ•°æ˜¯16ä½çš„ POPæŒ‡ä»¤\næ‰§è¡Œè¿‡ç¨‹ å°†ESPæ‰€æŒ‡å‘çš„å †æ ˆå…ƒç´ æ‹·è´åˆ°16ä½æˆ–32ä½çš„ç›®çš„æ“ä½œæ•°ä¸­ å¢åŠ ESPçš„å€¼ 16ä½æ“ä½œæ•°ï¼šESPåŠ 2 32ä½æ“ä½œæ•°ï¼šESPåŠ 4 æŒ‡ä»¤æ ¼å¼ pop r/m16\rpop r/m32 PUSHFDå’ŒPOPFDæŒ‡ä»¤\n32ä½ï¼š PUSHFDï¼šåœ¨å †æ ˆå‹å…¥32ä½EFLAGSå¯„å­˜å™¨çš„å€¼ POPFDï¼šå°†å †æ ˆé¡¶éƒ¨çš„å€¼å¼¹å‡ºå¹¶é€è‡³EFLAGSå¯„å­˜å™¨ å®åœ°å€æ¨¡å¼ï¼š PUSHFï¼šåœ¨å †æ ˆä¸Šå‹å…¥16ä½FLAGSå¯„å­˜å™¨çš„å€¼ POPFï¼šå°†å †æ ˆé¡¶éƒ¨çš„å€¼å¼¹å‡ºå¹¶é€è‡³FLAGSå¯„å­˜å™¨ PUSHAD,PUSHA,POPADå’ŒPOPAæŒ‡ä»¤\n32ä½ï¼š PUSHADï¼šå°†EAXã€ECXã€EDXã€EBXã€ESPã€EBPã€ESIã€EDIæŒ‰é¡ºåºå‹å…¥å †æ ˆ POPADï¼šæŒ‰ç›¸åé¡ºåºå¼¹å‡ºè¿™äº›é€šç”¨å¯„å­˜å™¨ 80286ï¼š PUSHAï¼šä»¥ç”¨æ ·çš„é¡ºåºå‹å…¥AXã€CXã€DXã€BXã€SPã€BPã€SIã€DI POPAï¼šä»¥ç›¸åçš„é¡ºåºå¼¹å‡º è¿‡ç¨‹çš„å®šä¹‰å’Œä½¿ç”¨ PROCä¼ªæŒ‡ä»¤\nSumof PROC add eax, ebx add eax, ecx ret Sumof ENDP CALLå’ŒRETæŒ‡ä»¤\nè°ƒç”¨å’Œè¿”å›çš„ä¾‹å­ å¯åµŒå¥—ä½¿ç”¨\nå±€éƒ¨æ ‡å·å’Œå…¨å±€æ ‡å·\nL1:: ; global label ... L2: ; local babel ... æ¡ä»¶å¤„ç† å¸ƒå°”å’Œæ¯”è¾ƒæŒ‡ä»¤ ANDæŒ‡ä»¤ï¼šæŒ‰ä½ä¸ å½±å“çš„æ ‡å¿—ä½ï¼š æ€»æ˜¯æ¸…é™¤OFå’ŒCFï¼› æ ¹æ®ç»“æœä¿®æ”¹SFï¼ŒZFï¼ŒPF ä¸»è¦ç”¨é€”ï¼šå¯¹ç‰¹å®šçš„ä½æ¸…0 å¤§å†™å­—æ¯å’Œå°å†™å­—æ¯çš„ASCIIç ä¹‹é—´çš„å…³ç³»ï¼š \u0026lsquo;a\u0026rsquo;: 61h, 01100001b \u0026lsquo;A\u0026rsquo;: 41h, 01000001b ORæŒ‡ä»¤ï¼šæŒ‰ä½æˆ– ä¸»è¦ç”¨é€”ï¼šå¯¹ç‰¹å®šçš„ä½ç½®1 XORæŒ‡ä»¤ï¼šæŒ‰ä½å¼‚æˆ– ç”¨é€”ï¼š å¯¹æŸäº›ä½å–å åˆ¤æ–­16ä½æˆ–32ä½å€¼çš„å¥‡å¶æ€§ mov ax, 64C1h ; 0110 0100 1100 0001 xor ah, al ; PE, å¥‡å¶ä½è¢«è®¾ç½® ç®€å•æ•°æ®åŠ å¯† å°†æŸä¸ªæ“ä½œæ•°ä¸åŒæ ·çš„æ“ä½œæ•°æ‰§è¡Œä¸¤æ¬¡å¼‚æˆ–æ“ä½œä¹‹åï¼Œå…¶å€¼ä¿æŒä¸å˜ $$ (X\\oplus Y) \\oplus Y = X $$ NOTæŒ‡ä»¤ï¼šå–å \u0026lt; notice warning \u0026gt; NOTæŒ‡ä»¤ä¸å½±å“ä»»ä½•çŠ¶æ€æ ‡å¿— \u0026lt; /notice \u0026gt; TESTæŒ‡ä»¤ï¼šä¸¤æ“ä½œæ•°æŒ‰ä½ä¸ï¼Œæ ¹æ®ç»“æœè®¾ç½®æ ‡å¿—ä½ï¼Œä½†ä¸å›é€ç»“æœï¼ˆä¸ä¿®æ”¹ç›®çš„æ“ä½œæ•°ï¼‰ ç”¨é€”ï¼šæµ‹è¯•æŸä¸€ä½æ˜¯â€œ0â€è¿˜æ˜¯â€œ1â€ test al, 00001001b ; test bits 0 and 3 åˆ¤æ–­ZFæ˜¯å¦ç­‰äº1 å½±å“çš„æ ‡å¿—ä½ï¼šæ¸…é™¤OFã€CFï¼›ä¿®æ”¹SFã€ZFã€PF CMPæŒ‡ä»¤ åŠŸèƒ½ï¼šä¸å‡æ³•æŒ‡ä»¤ä¸€æ ·æ‰§è¡Œå‡æ³•æ“ä½œï¼Œä½†ä¸å›é€ç»“æœï¼Œåªå½±å“æ ‡å¿—ä½\nå½±å“çš„æ ‡å¿—ä½ï¼šæ ¹æ®ç›¸å‡ç»“æœä¿®æ”¹OFã€SFã€ZFã€CFã€AFã€PF\næ— ç¬¦å·æ“ä½œæ•°çš„æ¯”è¾ƒ\nCMPçš„ç»“æœ ZF CF ç›®çš„ \u0026lt; æº 0 1 ç›®çš„ \u0026gt; æº 0 0 ç›®çš„ = æº 1 0 æœ‰ç¬¦å·æ“ä½œæ•°çš„æ¯”è¾ƒ\nmov ax, 5 cmp ax, 10 ; CF = 1 mov si, 105 cmp si, 0 ; ZF = 0, CF = 0 mov ax, 1000 mov cx, 1000 cmp ax, cx ; ZF = 1 è®¾ç½®å’Œæ¸…é™¤å•ä¸ªCPUæ ‡å¿—\ntest al, 0 ; è®¾ç½®é›¶æ ‡å¿— and al, 0 ; è®¾ç½®é›¶æ ‡å¿— or al, 0 ; è®¾ç½®é›¶æ ‡å¿— or al, 80h ; è®¾ç½®ç¬¦å·æ ‡å¿— and al, 7Fh ; æ¸…æ¥šç¬¦å·æ ‡å¿— stc ; è®¾ç½®è¿›ä½æ ‡å¿— clc ; æ¸…é™¤è¿›ä½æ ‡å¿— mov al, 7Fh ; AL = +127 inc al ; AL = 80h or eax, 0 ; æ¸…é™¤æº¢å‡ºæ ‡å¿— æ¡ä»¶è·³è½¬ æ¡ä»¶ç»“æ„\nä½¿ç”¨CMPã€TESTã€ANDä¹‹ç±»çš„æŒ‡ä»¤ä¿®æ”¹CPUæ ‡å¿—\nä½¿ç”¨æ¡ä»¶è·³è½¬æŒ‡ä»¤æµ‹è¯•æ ‡å¿—å€¼ï¼Œå·²å†³å®šæ˜¯å¦å‘æ–°çš„åˆ†æ”¯è½¬ç§»\ncmp al, 0 jz L1 ; jump if ZF = 1 ... L1: and dl, 10110000b jnz L2 ; jump if ZF = 0 ... L2: JcondæŒ‡ä»¤\nåŠŸèƒ½ï¼š æ¡ä»¶æ ‡å¿—ä¸ºçœŸï¼šåˆ†æ”¯è½¬ç§»åˆ°æ–°çš„ç›®æ ‡æ ‡å·å¤„ æ¡ä»¶æ ‡å¿—ä¸ºå‡ï¼šæ‰§è¡Œç´§è·Ÿåœ¨æ¡ä»¶è·³è½¬æŒ‡ä»¤ä¹‹åçš„æŒ‡ä»¤ æ ¼å¼ï¼š ä¾‹ï¼š mov ax, 5 mov ax, 5 mov ax, 5 cmp ax, 5 cmp ax, 6 mov ax, 6 je L1 j1 L1 jg L1 æ¡ä»¶è·³è½¬æŒ‡ä»¤çš„ç±»å‹\nåŸºäºç‰¹å®šCPUæ ‡å¿—å€¼\nåŠ©è®°ç¬¦ æè¿° æ ‡å¿—å€¼ JZ ä¸ºé›¶åˆ™è·³è½¬ ZF = 1 JNZ ä¸ä¸ºé›¶åˆ™è·³è½¬ ZF = 0 JC å¦‚æœè®¾ç½®è¿›ä½æ ‡å¿—åˆ™è·³è½¬ CF = 1 JNC å¦‚æœæœªè®¾ç½®è¿›ä½æ ‡å¿—åˆ™è·³è½¬ CF = 0 JO å¦‚æœè®¾ç½®æº¢å‡ºæ ‡å¿—åˆ™è·³è½¬ OF = 1 JNO å¦‚æœæœªè®¾ç½®æº¢å‡ºæ ‡å¿—åˆ™è·³è½¬ OF = 0 JS å¦‚æœè®¾ç½®ç¬¦å·æ ‡å¿—åˆ™è·³è½¬ SF = 1 JNS å¦‚æœæœªè®¾ç½®ç¬¦å·æ ‡å¿—åˆ™è·³è½¬ SF = 0 JP å¦‚æœè®¾ç½®äº†å¥‡å¶æ ‡å¿—åˆ™è·³è½¬ï¼ˆå¶ï¼‰ PF = 1 JNP å¦‚æœæœªè®¾ç½®å¥‡å¶æ ‡å¿—åˆ™è·³è½¬ï¼ˆå¥‡ï¼‰ PF = 0 ä¾æ®ç›¸ç­‰æ¯”è¾ƒçš„è·³è½¬æŒ‡ä»¤\nåŠ©è®°ç¬¦ æè¿° JE ç›¸ç­‰åˆ™è·³è½¬ JNE ä¸ç›¸ç­‰åˆ™ä¸è·³è½¬ JCXZ CX = 0 åˆ™è·³è½¬ JECXZ ECX = 0 åˆ™è·³è½¬ åŸºäºæ— ç¬¦å·æ•´æ•°æ¯”è¾ƒç»“æœçš„è·³è½¬æŒ‡ä»¤\nA:Above, B: Below, E:Equal\nåŠ©è®°åºœ æè¿° JA å¤§äºåˆ™è·³è½¬(leftOp \u0026gt; rightOp) JNBE ä¸ï¼ˆå°äºæˆ–ç­‰äºï¼‰ï¼ˆåŒJAï¼‰ JAE å¤§äºæˆ–ç­‰äºåˆ™è·³è½¬ (leftOp \u0026gt;= rightOp) JNB ä¸å°äºåˆ™è·³è½¬ ï¼ˆåŒJAEï¼‰ JB å°äºåˆ™è·³è½¬(leftOp \u0026lt; rightOp) JNAE ä¸ï¼ˆå¤§äºæˆ–ç­‰äºï¼‰ï¼ˆåŒJBï¼‰ JBE å°äºæˆ–ç­‰äºåˆ™è·³è½¬(leftOp \u0026lt;= rightOp) JNA ä¸å¤§äºåˆ™è·³è½¬ï¼ˆåŒJBEï¼‰ åŸºäºæœ‰ç¬¦å·æ•´æ•°æ¯”è¾ƒç»“æœçš„è·³è½¬æŒ‡ä»¤\nG: Grater, L: Less, E: Equal\nåŠ©è®°åºœ æè¿° JG å¤§äºåˆ™è·³è½¬(leftOp \u0026gt; rightOp) JNLE ä¸ï¼ˆå°äºæˆ–ç­‰äºï¼‰ï¼ˆåŒJAï¼‰ JGE å¤§äºæˆ–ç­‰äºåˆ™è·³è½¬ (leftOp \u0026gt;= rightOp) JNL ä¸å°äºåˆ™è·³è½¬ ï¼ˆåŒJAEï¼‰ JL å°äºåˆ™è·³è½¬(leftOp \u0026lt; rightOp) JNGE ä¸ï¼ˆå¤§äºæˆ–ç­‰äºï¼‰ï¼ˆåŒJBï¼‰ JLE å°äºæˆ–ç­‰äºåˆ™è·³è½¬(leftOp \u0026lt;= rightOp) JNG ä¸å¤§äºåˆ™è·³è½¬ï¼ˆåŒJBEï¼‰ mov al, 7Fh ; (7Fh or +127) cmp al, 80h ; (80h or -128) ja IsAbove ; no : 7F not \u0026gt; 180h mov al, 7Fh ; (7Fh or +127) cmp al, 80h ; (80h or -128) jg IsAbove ; yes: +127 \u0026gt; -128 æ¡ä»¶å¾ªç¯æŒ‡ä»¤ LOOPZå’ŒLOOPEæŒ‡ä»¤\nå«ä¹‰ï¼šLoop if zeroï¼ŒLoop if equal äºŒè€…ç­‰ä»· æ‰§è¡Œé€»è¾‘ï¼š ECX = ECX - 1\nif ECX \u0026gt; 0 and ZF = 1, jump to destination LOOPNZå’ŒLOOPNEæŒ‡ä»¤\nå«ä¹‰ï¼šLoop if not zeroï¼Œ Loop if not equal äºŒè€…ç­‰ä»· æ‰§è¡Œé€»è¾‘ï¼š ECX = ECX - 1\nif ECX \u0026gt; 0 and ZF = 0, jump to destination ; æ‰«ææ•°ç»„ä¸­çš„æ¯ä¸ªæ•°å€¼ï¼Œç›´åˆ°å‘ç°æ­£æ•°ä¸ºæ­¢ .data array SWORD -3,-6,-1,-10,10,30,40,4 sentinel SWORD 0 .code mov esi, OFFSET array mov ecx, LENGTHOF array next: test WORD PTR [esi], 8000h ; test highest bit pushfd ; push flags on stack add esi, TYPE array popfd ; pop flags from stack loopnz next ; continue jnz quit ; none found sub esi, TYPE array ; SI points to value æ•´æ•°è¿ç®—æŒ‡ä»¤ ç§»ä½å’Œå¾ªç¯ç§»ä½æŒ‡ä»¤ \u0026lt; notice note \u0026gt; Shift Left Right Arithmetic Rotate Carry \u0026lt; /notice \u0026gt;\nç§»ä½æŒ‡ä»¤\nåŠ©è®°ç¬¦ æè¿° SHL é€»è¾‘å·¦ç§» SHR é€»è¾‘å³ç§» SAL ç®—æ•°å·¦ç§» SAR ç®—æ•°å³ç§» ROL å¾ªç¯å·¦ç§» ROR å¾ªç¯å³ç§» RCL å¸¦è¿›ä½çš„å¾ªç¯å·¦ç§» RCR å¸¦è¿›ä½çš„å¾ªç¯å³ç§» SHLD åŒç²¾åº¦å·¦ç§» SHRD åŒç²¾åº¦å³ç§» ä¸Šè¿°æŒ‡ä»¤å½±å“OFã€CF\né€»è¾‘ç§»ä½å’Œç®—æœ¯ç§»ä½ å¾ªç¯å·¦ç§»ROLå’Œå¾ªç¯å³ç§»ROR å¸¦è¿›ä½çš„å¾ªç¯å·¦ç§»RCLå’Œå³ç§»RCR SHLD/SHRDæŒ‡ä»¤\næ ¼å¼ï¼šSHLD ç›®çš„æ“ä½œæ•°ï¼Œæºæ“ä½œæ•°ï¼Œç§»ä½ä½æ•° è¦æ±‚è‡³å°‘æ˜¯Intel386å¤„ç†å™¨ SHLDï¼šåŒç²¾åº¦å·¦ç§»ï¼ŒShift Left Double\nå°†ç›®çš„æ“ä½œæ•°å·¦ç§»æŒ‡å®šçš„ä½æ•°ï¼Œä½ä½ç©ºå‡ºæ¥çš„ä½ç”¨æºæ“ä½œæ•°çš„é«˜ä½å¡«å…… SHRDï¼šåŒç²¾åº¦å³ç§»ï¼ŒShift Right Double\nå°†ç›®çš„æ“ä½œæ•°å³ç§»æŒ‡å®šçš„ä½æ•°ï¼Œç©ºå‡ºæ¥çš„ä½ç”±æºæ“ä½œæ•°çš„ä½ä½æ¥å¡«å……ã€‚ æ ¼å¼ï¼š\nåŠ©è®°ç¬¦ ç›®çš„æ“ä½œæ•°ï¼Œç§»ä½ä½æ•°\nSHL reg, imm8 SAL mem, imm8 ROR reg, CL RCL mem, CL 8088/8086è¦æ±‚imm8å¿…é¡»ç­‰äº1ï¼›80286ä»¥ä¸Šï¼Œimm8å¯ä»¥ä¸ºâ€œä»»æ„â€æ•´æ•° CLæ–¹å¼å¯ç”¨äºä»»ä½•Intel x86å¤„ç†å™¨ ä¹˜æ³•å’Œé™¤æ³•æŒ‡ä»¤ MULæŒ‡ä»¤\næ ¼å¼ï¼ˆæ“ä½œæ•°ä¸ºä¹˜æ•°ï¼‰ï¼š\nMUL r/m8\nMUL r/m16\nMUL r/m32 åŠŸèƒ½ï¼šæ— ç¬¦å·ä¹˜æ³•ã€‚å°†8ä½ã€16ä½æˆ–32ä½çš„æ“ä½œæ•°ä¸ALã€AXæˆ–EAXç›¸ä¹˜ è¢«ä¹˜æ•° ä¹˜æ•° ç§¯ CF = 1çš„æ¡ä»¶ AL r/m8 AX AH $\\neq$ 0 AX r/m16 DX:AX DX $\\neq$ 0 EAX r/m32 EDX:EAX EDX $\\neq$ 0 IMULæŒ‡ä»¤ï¼šæœ‰ç¬¦å·ä¹˜æ³•\nå¦‚æœç´¯ç§¯çš„é«˜åŠéƒ¨åˆ†ä¸æ˜¯ä½åŠéƒ¨åˆ†çš„ç¬¦å·æ‰©å±•ï¼ˆæ¢è€Œè¨€ä¹‹å°±æ˜¯ä½åŠéƒ¨åˆ†ä¸è¶³å¤Ÿè¡¨ç¤ºç´¯ç§¯ï¼‰ï¼Œåˆ™è®¾ç½®CFå’ŒOF\nä¾‹ï¼š\nmov al, 48 ; 48D = 30H mov bl, 4 imul bl ; AX = 00C0h, OF = 1 mov al, -4 mov bl, 4 imul bl ; AX = FFF0h, OF = 0 mov ax, 48 mov bx, 4 imul ax ; DX:AX = 000000C0h, OF = 1 DIVæŒ‡ä»¤ï¼šæ— ç¬¦å·é™¤æ³•\nè¢«é™¤æ•° é™¤æ•° å•† ä½™æ•° AX r/m8 AL AH DX:AX r/m16 AX DX EDX:EAX r/m32 EAX EDX æœ‰ç¬¦å·æ•´æ•°é™¤æ³•\nCBW, CWD, CDQæŒ‡ä»¤ CBW(Convert Byte to Word): å°†ALä¸­çš„ç¬¦å·ä½æ‰©å±•åˆ°AH CWD(Convert Word to Doubleword): å°†AXä¸­çš„ç¬¦å·ä½æ‰©å±•åˆ°DX CDQ(Convert DoubleWord QuadWord): å°†EAXä¸­çš„ç¬¦å·ä½æ‰©å±•åˆ°EDX IDIVæŒ‡ä»¤ï¼šæœ‰ç¬¦å·æ•°æ•´æ•°çš„é™¤æ³•è¿ç®—\nä¾‹ï¼š .data byteVal SBYTE -48 .code mov al, byteVal cbw ; extend AL into AH mov bl, 5 idiv bl ; AL = -9, AH = -3 .data wordVal SWORD -5000 .code mov ax, wordVal cwd ; extend AX into DX mov bx, 256 idiv bx ; AX = -19, DX = -136 é™¤æ³•æº¢å‡º å½“é™¤æ³•äº§ç”Ÿçš„å•†å¤ªå¤§è€Œæ— æ³•å®¹çº³åœ¨ç›®çš„æ“ä½œæ•°ä¸­çš„æ—¶å€™ï¼Œå°†å¯¼è‡´é™¤æ³•æº¢å‡ºï¼Œä½¿CPUè§¦å‘ä¸€ä¸ªä¸­æ–­ï¼Œå½“å‰ç¨‹åºè¢«ç»ˆæ­¢ è¯•å›¾é™¤ä»¥0ä¹Ÿä¼šå‘ç”Ÿç›¸åŒçš„æƒ…å†µ è§£å†³åŠæ³• ä½¿ç”¨32ä½çš„é™¤æ•°æ¥å‡å°é™¤æ³•æº¢å‡ºçš„å¯èƒ½æ€§ æµ‹è¯•é™¤æ•°ï¼Œå¦‚æœé™¤æ•°ç­‰äº0åˆ™è·³è¿‡é™¤æ³•æŒ‡ä»¤ æ‰©å±•åŠ æ³•å’Œå‡æ³• ADCæŒ‡ä»¤ï¼šæ‰©å±•åŠ æ³•\nç›®çš„æ“ä½œæ•° + æºæ“ä½œæ•° + è¿›ä½æ ‡å¿—-\u0026gt;ç›®çš„æ“ä½œæ•° SBBæŒ‡ä»¤ï¼šæ‰©å±•å‡æ³•\nç›®çš„æ“ä½œæ•° + æºæ“ä½œæ•° - è¿›ä½æ ‡å¿—-\u0026gt;ç›®çš„æ“ä½œæ•° ASCIIå’Œå‹ç¼©åè¿›åˆ¶ç®—æ•° AAAï¼šåŠ æ³•ä¹‹åè¿›è¡ŒASCIIç è°ƒæ•´ mov ag, 0 mov al, \u0026#39;8\u0026#39; ; AX = 0038h add al, \u0026#39;2\u0026#39; ; AX = 006Ah aaa ; AX = 0100h or ax, 3030h ; AX = 3130h = \u0026#39;10\u0026#39; AASï¼šå‡æ³•ä¹‹åè¿›è¡ŒASCIIç è°ƒæ•´ AAMï¼šä¹˜æ³•ä¹‹åè¿›è¡ŒASCIIç è°ƒæ•´ AADï¼šé™¤æ³•ä¹‹åè¿›è¡ŒASCIIç è°ƒæ•´ å‹ç¼©çš„åè¿›åˆ¶æ•´æ•° DAAæŒ‡ä»¤ï¼šå°†ADDæˆ–ADCæŒ‡ä»¤æ‰§è¡ŒåALä¸­çš„ç»“æœè½¬æ¢æˆå‹ç¼©çš„åè¿›åˆ¶æ ¼å¼ DASæŒ‡ä»¤ï¼šå°†SUBæˆ–SBBæŒ‡ä»¤æ‰§è¡ŒåALä¸­çš„ç»“æœè½¬æ¢æˆå‹ç¼©çš„åè¿›åˆ¶æ ¼å¼ ä¾‹ï¼š mov al, 35h add al, 48h ; AL = 7Dh daa ; AL = 83h mov bl, 48h mov al, 85h sub al, bl ; AL = 3Dh das ; AL = 37h å­—ç¬¦ä¸²ä¸æ•°ç»„ åŸºæœ¬å­—ç¬¦ä¸²æ“ä½œæŒ‡ä»¤ æŒ‡ä»¤ æè¿° MOVSB, MOVSW, MOVSD ç§»åŠ¨å­—ç¬¦ä¸²æ•°æ®ï¼šæ‹·è´DS:(E)SIå¯»å€çš„å†…å­˜æ“ä½œæ•°è‡³ES:(E)DI CMPSB, SMPSW, CMPSD æ¯”è¾ƒå­—ç¬¦ä¸²ï¼šæ¯”è¾ƒå†…å­˜ä¸­ç”±DS:(E)SIå¯»å€å’ŒES:(E)DIå¯»å€çš„å­—ç¬¦ä¸²ã€‚æº-ç›®çš„ SCASB, SCASW, SCASD æ‰«æå­—ç¬¦ä¸²ï¼šæ‰«æES:(E)DIæŒ‡å‘çš„å†…å­˜å­—ç¬¦ä¸²æŸ¥æ‰¾ä¸ç´¯åŠ å™¨åŒ¹é…çš„å€¼ STOSB, STOSW, STOSD å­˜å‚¨å­—ç¬¦ä¸²ï¼šå°†ç´¯åŠ å™¨å†…å®¹å­˜å‚¨åˆ°ç”±ES:(E)DIå¯»å€çš„å†…å­˜ä¸­ LODSB, LODSW, LODSD å°†å­—ç¬¦ä¸²æ•°æ®è£…å…¥ç´¯åŠ å™¨ï¼šå°†ç”±DS:(E)SIå¯»å€çš„å†…å­˜å•å…ƒè£…å…¥ç´¯åŠ å™¨ä¸­ ä½¿ç”¨é‡å¤å‰ç¼€\nå­—ç¬¦ä¸²æ“ä½œæŒ‡ä»¤æ¯æ¬¡åªèƒ½å¤„ç†ä¸€ä¸ªå†…å­˜å€¼ã€‚ é€šè¿‡å¢åŠ ä¸€ä¸ªé‡å¤å‰ç¼€ï¼Œå­—ç¬¦ä¸²æŒ‡ä»¤å°±ä¼šä½¿ç”¨ECXä½œä¸ºè®¡æ•°å™¨è¿›è¡Œé‡å¤ â€”â€” å®ç°ç”¨ä¸€æ¡æŒ‡ä»¤å¤„ç†æ•´ä¸ªæ•°ç»„ã€‚ å¯ä»¥ä½¿ç”¨çš„é‡å¤å‰ç¼€ REP ECX \u0026gt; 0æ—¶é‡å¤ REPZ, REPE å½“ZFï¼1ä¸”ECXï¼0æ—¶é‡å¤ REPNE, REPNZ å½“ZFï¼0ä¸”ECXï¼0æ—¶é‡å¤ æ–¹å‘æ ‡å¿—ï¼šç®€å•å­—ç¬¦ä¸²æŒ‡ä»¤ä½¿ç”¨æ–¹å‘æ ‡å¿—æ¥å†³å®šESIå’ŒEDIæ˜¯è‡ªåŠ¨å¢åŠ è¿˜æ˜¯è‡ªåŠ¨å‡å°‘ã€‚ æ–¹å‘æ ‡å¿—ä½ DFï¼0ï¼šESIã€EDI è‡ªåŠ¨å¢åŠ ï¼› æ–¹å‘æ ‡å¿—ä½ DFï¼1ï¼šESIã€EDI è‡ªåŠ¨å‡å°‘ã€‚ æ–¹å‘æ ‡å¿—å¯ä»¥é€šè¿‡CLDå’ŒSTDæŒ‡ä»¤æ”¹å˜ï¼š CLD\t; æ¸…é™¤æ–¹å‘æ ‡å¿— STD\t; è®¾ç½®æ–¹å‘æ ‡å¿— MOVSBã€MOVSW å’Œ MOVSD æŒ‡ä»¤\n.data source DWORD 20 DUP(0FFFFFFFFh) target DWORD 20 DUP(?) .code cld\t; direction = forward mov ecx,LENGTHOF source\t; set REP counter mov esi,OFFSET source\t; ESI points to source mov edi,OFFSET target\t; EDI points to target rep movsd\t; copy doublewords CMPSBã€CMPSW å’Œ CMPSD æŒ‡ä»¤\néšå«æ‰§è¡Œï¼šæº-ç›®çš„ï¼Œè¿™ä¸ CMP æŒ‡ä»¤ç›¸å\nmov esi,OFFSET source mov edi,OFFSET target cld\t; direction = up mov ecx,count\t; repetition counter repe cmpsd\t; repeat while equal SCASBã€SCASW å’Œ SCASD æŒ‡ä»¤\nå°†AL/AX/EAXä¸­çš„å€¼åŒç›®æ ‡å†…å­˜(ç”±DIå¯»å€)ä¸­çš„å­—èŠ‚ã€å­—æˆ–åŒå­—ç›¸æ¯”è¾ƒã€‚ ä¾‹:æ‰«æä¸€ä¸ªåŒ¹é…å­—ç¬¦ï¼šåœ¨å­—ç¬¦ä¸²å˜é‡alphaä¸­æŸ¥æ‰¾å­—æ¯â€œFâ€ .data alpha BYTE \u0026#34;ABCDEFGH\u0026#34;,0 .code mov edi,OFFSET alpha\t; EDI points to the string mov al,\u0026#39;F\u0026#39;\t; search for the letter F mov ecx,LENGTHOF alpha ; set the search count cld\t; direction = up repne scasb\t; repeat while not equal jnz quit\t; quit if letter not found dec edi\t; found: back up EDI quit: STOSBã€STOSW å’Œ STOSD æŒ‡ä»¤\nå°†AL/AX/EAXçš„å†…å®¹å­˜å‚¨åœ¨EDIæŒ‡å‘çš„å†…å­˜å•å…ƒä¸­ï¼ŒåŒæ—¶EDIçš„å€¼æ ¹æ®æ–¹å‘æ ‡å¿—å¢åŠ æˆ–å‡å°‘ã€‚å¯ä¸REPå‰ç¼€è”åˆä½¿ç”¨ã€‚ ä¾‹ï¼šå°†string1çš„æ¯ä¸ªå­—èŠ‚åˆå§‹åŒ–ä¸º0FFhã€‚ .data count = 100 string1 BYTE count DUP(?) .code mov al,0FFh\t; value to be stored mov edi,OFFSET string1 ; ES:DI points to target mov ecx,count\t; character count cld\t; direction = forward rep stosb\t; fill with contents of AL LODSBã€LODSW å’Œ LODSD æŒ‡ä»¤\nä»ESIæŒ‡å‘çš„å†…å­˜ä½ç½®å‘AL/AX/EAXä¸­è£…å…¥ä¸€ä¸ªå€¼ï¼ŒåŒæ—¶ESIçš„å€¼æ ¹æ®æ–¹å‘æ ‡å¿—å¢åŠ æˆ–å‡å°‘ã€‚ ä¸€èˆ¬ä¸ä¸REPå‰ç¼€è”åˆä½¿ç”¨ã€‚ äºŒç»´æ•°ç»„ åŸºå€å˜å€æ“ä½œæ•°ï¼šå°†ä¸¤ä¸ªå¯„å­˜å™¨çš„å€¼ç›¸åŠ (ç§°ä¸ºåŸºå€å¯„å­˜å™¨ã€å˜å€å¯„å­˜å™¨)æ¥äº§ç”Ÿåç§»åœ°å€ ä¿æŠ¤æ¨¡å¼ç¨‹åºä¸­ï¼Œå¯ä½¿ç”¨ä»»æ„ä¸¤ä¸ª32ä½é€šç”¨å¯„å­˜å™¨ å®åœ°å€æ¨¡å¼ä¸‹ï¼Œ16ä½å¯„å­˜å™¨å…è®¸çš„ç»„åˆæ˜¯ï¼š[bx+si], [bx+di], [bp+si], [bp+di]\nâš ï¸åº”å°½é‡é¿å…ä½¿ç”¨BPå¯„å­˜å™¨ï¼Œé™¤éè¦è®¿é—®å †æ ˆæ“ä½œæ•° .data array WORD 1000h,2000h,3000h .code mov ebx,OFFSET array mov esi,2 mov ax,[ebx+esi]\t; AX = 2000h è¡¨æ ¼çš„ä¾‹å­ ç›¸å¯¹åŸºå€å˜å€æ“ä½œæ•°:æœ‰æ•ˆåœ°å€åç§»ï¼åç§»ï¼‹åŸºå€å¯„å­˜å™¨ï¼‹å˜å€å¯„å­˜å™¨ å‡ ç§å¸¸è§çš„æ ¼å¼ï¼š [base + index + displacement] displacement[base + index] displacement[base][index] åç§»(Displacement)ï¼šå˜é‡çš„åå­—ï¼›å¸¸é‡è¡¨è¾¾å¼ åŸºå€ã€å˜å€ï¼š ä¿æŠ¤æ¨¡å¼ï¼šä»»æ„32ä½å¯„å­˜å™¨ å®åœ°å€æ¨¡å¼ï¼šBXã€BPï¼›SIã€DI è¡¨æ ¼çš„ä¾‹å­ï¼štableB[ebx + esi] ä¹ é¢˜ 3.8 åœ¨DATAä¸ºé¦–åœ°å€çš„å†…å­˜åŒºåŸŸä¸­å­˜æ”¾100ä¸ªæ— ç¬¦å·æ•°ï¼Œè¯•ç¼–å†™ç¨‹åºæ‰¾å‡ºå…¶ä¸­æœ€å¤§çš„æ•°ï¼Œå¹¶å°†å…¶æ”¾åœ¨KVFFä¸­ã€‚\nstack segment stack db 512 dup(?) stack ends data segment nums db 170, 248, 69, 67, 81, 104, 76, 178, 226, 201 db 234, 230, 194, 85, 206, 92, 63, 28, 211, 237, 195, 240, 225 db 126, 117, 173, 162, 78, 179, 252, 9, 202, 23, 152, 125, 32, 16 db 86, 165, 27, 190, 137, 37, 172, 13, 228, 112, 146, 75, 225, 65 db 92, 150, 38, 77, 43, 233, 94, 88, 118, 60, 127, 214, 69, 44, 25 db 134, 137, 154, 209, 167, 32, 174, 13, 178, 65, 74, 35, 234, 95 db 70, 179, 98, 140, 185, 159, 14, 114, 105, 239, 137, 147, 227, 238 db 228, 198, 135, 220, 203, 255 KVFF db ? data ends code segment assume CS:code, DS:data, SS:stack start: mov ax, data mov ds, ax mov dl, 0 mov si, OFFSET nums mov cx, 100 comp: cmp dl, BYTE PTR [si] jb exch L: inc si loop comp mov KVFF, dl mov ah, 4ch int 21h exch: mov dl, BYTE PTR [si] jmp L code ends end start 3.13 è¯•ç¼–å†™ç¨‹åºï¼Œç»™ä»å†…å­˜40000Håˆ°4BFFFHçš„æ¯ä¸ªå•å…ƒå‡å†™å…¥55Hï¼Œå¹¶é€ä¸ªå•å…ƒè¯»å‡ºæ¯”è¾ƒã€‚è‹¥å†™å…¥çš„ä¸è¯»å‡ºçš„å®Œå…¨ä¸€è‡´ï¼Œåˆ™å°†ALç½®7EHï¼Œå¦åˆ™å°†ALç½®81Hã€‚\nstack segment stack db 512 dup(?) stack ends code segment assume cs:code, ss:stack start: mov ax, 4000h mov ds, ax mov si, 0000h mov cx, 0BFFFh write: mov BYTE PTR [si], 55h inc si loop write mov si, 0000h mov cx, 0BFFFh read: cmp BYTE PTR [si], 55h jnz not_equal equal: inc si loop read mov al, 7eh mov ax, 4c00h int 21h not_equal: mov al, 81h mov ax, 4c00h int 21h code ends end start æ€»çº¿æŠ€æœ¯ æ€»çº¿æ¦‚è¿° æ€»çº¿çš„åˆ†ç±» æŒ‰è¿æ¥çš„å±‚æ¬¡ ç‰‡å†…æ€»çº¿ å…ƒä»¶çº§æ€»çº¿ ç³»ç»Ÿæ€»çº¿ï¼ˆå†…æ€»çº¿ï¼‰ é€šä¿¡æ€»çº¿ï¼ˆå¤–æ€»çº¿ã€I/Oæ€»çº¿ï¼‰ æŒ‰æ•°æ®ä¼ è¾“ä½æ•° å¹¶è¡Œæ€»çº¿ ä¸²è¡Œæ€»çº¿ æ ‡å‡†åŒ–æ€»çº¿ å†…æ€»çº¿ ISAæ€»çº¿(Industry Stanrard Architechure) ISAç‰¹ç‚¹ æ”¯æŒ8ä½ã€16ä½æ“ä½œ å°†å°†XTä¸ATæ€»çº¿çš„è¿è¡Œé€Ÿåº¦æå‡è‡³8MHz æ›´å¼ºè°ƒI/Oå¤„ç†èƒ½åŠ›ï¼š64KBçš„I/Oç©ºé—´ã€11çº§ç¡¬ä»¶ä¸­æ–­ã€7çº§DMAé€šé“ åœ°å€ã€æ•°æ®å¤šè·¯å¤ç”¨ æ˜¯å¤šä¸»æ§è®¾å¤‡æ€»çº¿ã€å¸¦å¤„ç†å™¨çš„æ™ºèƒ½å¡éƒ½å¯ä»¥æˆä¸ºISAçš„ä¸»æ§è®¾å¤‡ æ›¾å¹¿æ³›æµè¡Œï¼Œæ”¯æŒçš„å‚å•†ä¼—å¤š ä¿¡å·å®šä¹‰ æ•°æ®æ€»çº¿ä¸º16ä½ï¼ˆæ”¯æŒ8ä½ã€16ä½æ“ä½œï¼‰ æé€Ÿï¼š$ \\overline{0WS} $ï¼Œé›¶ç­‰å¾…çŠ¶æ€ï¼Œä¹Ÿå«$ \\overline{NOWS} $ï¼ˆNo Wait Stateï¼‰ å‡ä½ï¼š$ \\overline{MEMCS16},\\overline{IOCS16} $ ä½æ•°å¯é€‰ï¼š$ \\overline{SBHE} $ å¯»å€èƒ½åŠ›è¾¾åˆ°16MBï¼Œåœ°å€ã€æ•°æ®çº¿ä¸å¤ç”¨ ä¸­æ–­æ‰©å……ä¸º11ä¸ªï¼ˆPC/XTä½6ä¸ªï¼‰ DMAæ‰©å……ä¸º7ä¸ªï¼ˆPC/XTä½4ä¸ªï¼‰ ISAæ˜¯ä¸€ç§å¤šä¸»æ§æ€»çº¿ï¼š$\\overline{MASTER} $ é€Ÿåº¦ï¼šCLK(B20, Output)\n4.77MHz-\u0026gt;8.33MHz-\u0026gt;12MHz PCIæ€»çº¿(Peripheral Component Interconnect Local Bus) PCIæ€»çº¿çš„ç‰¹ç‚¹ ä¸ä¾èµ–äºå¤„ç†å™¨ æ‰©å……æ€§å¥½ã€å¤šæ€»çº¿å…±å­˜ å…·æœ‰è‡ªåŠ¨é…ç½®èƒ½åŠ›ï¼Œæ”¯æŒå³æ’å³ç”¨ï¼ˆPnPï¼‰ æ•°æ®ã€åœ°å€å¥‡å¶æ ¡éªŒåŠŸèƒ½ æ•°æ®å®½åº¦32ä½ï¼Œå¯æ‰©å±•ä¸º64ä½ï¼›2.0ç‰ˆæœ¬æ”¯æŒ33MHzæ—¶é’Ÿï¼Œ2.1ç‰ˆæœ¬å¢åŠ äº†å¯¹66MHzæ€»çº¿æ“ä½œçš„æ”¯æŒ ä¿¡å·å¤ç”¨ï¼Œæ”¯æŒæ— é™è¯»å†™çªå‘æ“ä½œ æ”¯æŒå¤šä¸»æ§è®¾å¤‡ é€‚åº”æ€§å¹¿ å¹¶è¡Œæ€»çº¿æ“ä½œ ä¿¡å·å®šä¹‰ PCIæ€»çº¿å®šä¹‰çš„ä¿¡å·å¯åˆ†ä¸ºä¹ç±» ç³»ç»Ÿä¿¡å· æ•°æ®å’Œåœ°å€ä¿¡å· æ¥å£æ§åˆ¶ä¿¡å· ä»²è£ä¿¡å· é”™è¯¯æŠ¥å‘Šä¿¡å· ä¸­æ–­ä¿¡å· é«˜é€Ÿç¼“å­˜æ”¯æŒä¿¡å· 64ä½æ‰©å±•ä¿¡å· JTAGä¿¡å· PCIæ€»çº¿å®šä¹‰çš„ä¿¡å·ä¹Ÿå¯åˆ†ä¸ºå¿…å¤‡å’Œå¯é€‰ä¸¤å¤§ç±» ä¸»æ§è®¾å¤‡éœ€è¦49ä¸ªå¿…å¤‡ä¿¡å·\nç›®æ ‡è®¾å¤‡éœ€è¦47å¿…å¤‡ä¿¡å· å¯é€‰ä¿¡å·çº¿å…±51ä¸ªï¼Œä¸»è¦ç”¨äº 64ä½æ‰©å±• ä¸­æ–­è¯·æ±‚ é«˜é€Ÿç¼“å­˜æ”¯æŒ ç­‰ PCIEæ€»çº¿ï¼ˆPCI Expressï¼‰ å¤–æ€»çº¿ï¼ˆé€šä¿¡æ€»çº¿ï¼‰ RS-232Cä¸²è¡Œé€šä¿¡æ¥å£ ç‰¹ç‚¹ ä¸²è¡Œå¼‚æ­¥æ€»çº¿ ä¼ è¾“ä¿¡å·çº¿å°‘ å®šä¹‰äº†20å¤šä¸ªä¿¡å·çº¿ å®é™…åº”ç”¨ä¸­ä¸€èˆ¬åªç”¨åˆ°3è‡³7æ¡ ä¼ è¾“è·ç¦»è¾ƒè¿œã€‚ä¸€èˆ¬ä¸º15ç±³ é‡‡ç”¨ä¸å½’é›¶ç¼–ç ï¼ˆNRZï¼‰å’Œè´Ÿé€»è¾‘ï¼šé€»è¾‘1ä¸º-15Vè‡³-3Vï¼Œé€»è¾‘0ä¸º+3Vè‡³+15V é‡‡ç”¨éå¹³è¡¡ä¼ è¾“æ–¹å¼ï¼Œå³å•ç«¯é€šä¿¡ ä¼ è¾“é€Ÿç‡è¾ƒä½ ç”µæ°”ç‰¹æ€§ã€å¼•è„šåŠŸèƒ½ï¼š25é’ˆ/9é’ˆ Då‹è¿æ¥å™¨ ä¿¡å· ä¼ é€ä¿¡æ¯ä¿¡å·\nTxDï¼šå‘é€æ•°æ®çº¿ (DTE-\u0026gt;DCE)\nRxDï¼šæ¥æ”¶æ•°æ®çº¿ (DTE\u0026lt;-DCE) è”ç»œä¿¡å·\nRTSï¼šè¯·æ±‚å‘é€ (DTE-\u0026gt;DCE)\nCTSï¼šæ¸…æ¥šå‘é€ (DTE\u0026lt;-DCE)\nDTRï¼šDTEå‡†å¤‡å°±ç»ª (DTE-\u0026gt;DCE)\nDSRï¼šSCEå‡†å¤‡å°±ç»ª (DTE\u0026lt;-DCE)\nDCDï¼šæ•°æ®è½½æ³¢æ£€æµ‹ (DTE\u0026lt;-DCE)\nRIï¼šæŒ¯é“ƒæŒ‡ç¤º (DTE\u0026lt;-DCE) ç”µå¹³ æ•°æ®ä¿¡å· æ§åˆ¶ä¿¡å· é€»è¾‘1 -3~-15Vï¼ˆä¼ å·ï¼‰ +3~+15Vï¼ˆæ¥é€šï¼ŒONçŠ¶æ€ï¼‰ é€»è¾‘0 +3~+15Vï¼ˆç©ºå·ï¼‰ -3~-15Vï¼ˆæ–­å¼€ï¼ŒOFFçŠ¶æ€ï¼‰ ï¼ˆä¸€èˆ¬ä¸º12Vï¼‰ ä¾‹ï¼šä¿¡æ¯æ ¼å¼\nä¼ é€ASCIIç â€œCâ€ï¼ˆ43Hï¼‰ RS-232çš„åº”ç”¨ ä½¿ç”¨Modemè¿æ¥ è½¯ç¡¬ä»¶ç³»ç»Ÿè°ƒè¯•ï¼šæ§åˆ¶å°ã€è¶…çº§ç»ˆç«¯ ç›´æ¥è¿æ¥ï¼šè®¡ç®—æœºï¼ˆDTEï¼‰\u0026lt;-\u0026gt; è®¡ç®—æœºï¼ˆDTEï¼‰ äº¤å‰è¿æ¥æ–¹å¼ ä¸‰çº¿ç»æµæ–¹å¼ RS423ã€RS422ã€RS485ï¼š RS423ï¼šå•ç«¯è¾“å‡ºã€å·®åˆ†æ¥æ”¶ï¼ˆéå¹³è¡¡ä¼ è¾“ï¼‰ 1200ç±³ 1Kbps 90ç±³ 100Kbps RS422ã€RS485ï¼šå·®åˆ†è¾“å‡ºã€å·®åˆ†æ¥æ”¶ï¼ˆå¹³è¡¡å·®åˆ†ä¼ è¾“ï¼‰ 1200ç±³ 100Kbps 100ç±³ 1Mbps 12ç±³ 10Mbps USBæ€»çº¿ï¼ˆUniversal Serial Busï¼‰ USBæ€»çº¿å„ç‰ˆæœ¬å‚æ•°æ¯”è¾ƒ ç¿»è½¬ä¸å½’é›¶ï¼ˆNRZ-Iï¼‰ç¼–ç  å½“æ•°æ®ä¸º0æ—¶ï¼Œç”µå¹³ç¿»è½¬ï¼›æ•°æ®ä¸º1æ—¶ï¼Œç”µå¹³ä¸ç¿»è½¬ æ¯”ç‰¹å¡«å……æŠ€æœ¯ï¼šå½“æ•°æ®ä¸­å‡ºç°è¿ç»­6ä¸ª'1\u0026rsquo;æ—¶å°±å¿…é¡»æ’å…¥1ä¸ª'0\u0026rsquo; å‘é€æ•°æ®ï¼šå¹¶è¡Œæ•°æ®-\u0026gt;ä¸²è¡Œæ•°æ®ï¼Œæ¯”ç‰¹å¡«å……ï¼ŒNRZIç¼–ç  æ¥æ”¶æ•°æ®ï¼šNRZIè§£ç ï¼Œå»é™¤å¡«å……æ¯”ç‰¹ï¼Œè½¬æ¢æˆå¹¶è¡Œæ•°æ® 8b/10bç¼–ç  ä¼ é€çš„ä¿¡æ¯ä»¥æ¯8æ¯”ç‰¹ä¸ºä¸€ç»„è¢«ç¼–ç ä¸ºä¸€ä¸ª10æ¯”ç‰¹çš„æ•°æ®ï¼›æ¥æ”¶ç«¯å°†10æ¯”ç‰¹æ•°æ®è§£ç è¿˜åŸä¸º8æ¯”ç‰¹æ•°æ® ç›®çš„ï¼šä½¿å¾—æ•´ä¸ªæ¯”ç‰¹æµä¸­å°½é‡ä¿æŒäº†0å’Œ1çš„å¹³è¡¡ SATAã€PCI-Expressä¹Ÿä½¿ç”¨äº†8b/10bç¼–ç  USB3.2ä½¿ç”¨128b/132bç¼–ç  å¯¹USBçš„éœ€æ±‚ å½“æ—¶PCæœºI/Oæ¨¡å¼çš„ç¼ºç‚¹ PCå¤–è®¾æ—¥ç›Šä¸°å¯Œï¼Œæ¥å£ã€æ‰©å±•æ§½æœ‰é™ï¼›ç§ç±»æ—¥ç›Šç¹å¤šçš„æ¥å£ç”µç¼†çº¿ I/Oèµ„æºåˆ†é…(I/Oç©ºé—´ã€IRQã€DMA)-\u0026gt;æ¥å£å¡ä¸€å¤šï¼Œä¸Šè¿°èµ„æºå¯èƒ½è€—å°½ çƒ­æ’æ‹”ã€PnPçš„éœ€æ±‚ USB2.0çš„ç‰¹ç‚¹/ä¼˜ç‚¹ å•ä¸€æ¥å£ç±»å‹ æ¯ä¸ªUSBæ€»çº¿æ”¯æŒ127ä¸ªå¤–è®¾ æ•´ä¸ªUSBç³»ç»Ÿåªç”¨ä¸€ä¸ªç«¯å£ã€ä¸€ä¸ªä¸­æ–­-\u0026gt;èŠ‚çœç³»ç»Ÿèµ„æº æ”¯æŒçƒ­æ’æ‹”ã€åŠ¨æ€åŠ è½½é©±åŠ¨ç¨‹åºï¼›å¸¦ç”µæ‹”å‡ºåè‡ªåŠ¨å›æ”¶èµ„æºï¼›PnPï¼Œè‡ªåŠ¨é…ç½® ä¸‰ç§é€Ÿç‡ï¼Œé€‚åº”ä¸åŒç±»å‹å¤–è®¾ è®¾å¤‡ä¾›ç”µ å››ç§ä¼ è¾“ç±»å‹ æ§åˆ¶ä¼ è¾“ åŒæ­¥ä¼ è¾“ ä¸­æ–­ä¼ è¾“ æ‰¹é‡ä¼ è¾“ USB3.0 ATAæ€»çº¿ PATA SATA æ€»çº¿çš„é©±åŠ¨å’Œæ§åˆ¶ æ€»çº¿ç«äº‰ä¸è´Ÿè½½ æ€»çº¿ç«äº‰ï¼šåŒä¸€æ€»çº¿ä¸Šï¼ŒåŒä¸€æ—¶åˆ»ï¼Œæœ‰ä¸¤ä¸ªæˆ–ä¸¤ä¸ªä»¥ä¸Šçš„å™¨ä»¶è¾“å‡ºå…¶çŠ¶æ€ TTLï¼šæ­¤æ—¶æ€»çº¿ä¸Šä¼šæ˜¯ä¸€ç§ä¸é«˜ä¸ä½çš„éTTLç”µå¹³ï¼Œä¸¥é‡æ—¶ä¼šçƒ§åå™¨ä»¶ å¯¹é›†ç”µæå¼€è·¯è¾“å‡ºï¼šçº¿ä¸é€»è¾‘ï¼ˆOpen Collectorï¼‰ ç”¨ä¸‰æ€ç”µè·¯ä¸¥æ ¼ï¼Œæ§åˆ¶é€»è¾‘ æ€»çº¿çš„è´Ÿè½½ ç›´æµè´Ÿè½½ è¾“å‡ºé«˜ç”µå¹³æ—¶ï¼Œé©±åŠ¨é—¨çš„$ I_{OH} \\ge \\sum_{i=1}^{N}{IH_i} $ è¾“å‡ºé«˜ç”µå¹³æ—¶ï¼Œé©±åŠ¨é—¨çš„$ I_{OL} \\ge \\sum_{i=1}^{N}{IL_i} $ äº¤æµè´Ÿè½½ï¼š$ C_P \\ge (\\sum_{i=1}^{N}{C_{Ii}+$ç”µè·¯æ¿å¸ƒçº¿å¼•å…¥çš„ç”µå®¹$+$ä¼ è¾“çº¿å¼•å…¥çš„ç”µå®¹}) $ æ€»çº¿é©±åŠ¨è®¾è®¡ å‡ ç§å¸¸ç”¨çš„èŠ¯ç‰‡\nå•å‘é©±åŠ¨å™¨ï¼ˆä¸‰æ€è¾“å‡ºï¼‰ åŒå‘é©±åŠ¨å™¨ï¼ˆä¸‰æ€è¾“å‡ºï¼‰ é”å­˜å™¨ï¼ˆä¸‰æ€è¾“å‡ºï¼‰ ç³»ç»Ÿæ€»çº¿çš„é©±åŠ¨ä¸æ§åˆ¶\næ‰©å±•æ’ä»¶æ¿ï¼ˆå¡ï¼‰çš„æ¿å†…é©±åŠ¨\nä¾‹é¢˜\næŸå†…å­˜æ¿ï¼Œæ¿å†…åœ°å€ä¸ºA0000Hï½FFFFFHï¼Œè¯•ç”»å‡ºæ¿å†…åŒå‘æ•°æ®æ€»çº¿é©±åŠ¨ä¸æ§åˆ¶ç”µè·¯ã€‚ é˜²æ­¢æ€»çº¿ç«äº‰åŸåˆ™ï¼šåªæœ‰å½“CPUè¯»æœ¬ç”µè·¯æ¿å†…çš„å†…å­˜åœ°å€æ—¶ï¼Œæ‰å…è®¸åŒå‘é©±åŠ¨å™¨æŒ‡å‘ç³»ç»Ÿæ€»çº¿çš„ä¸‰æ€é—¨æ˜¯å¯¼é€šçš„ã€‚ å¯¹æ¿å†…å†…å­˜åœ°å€è¿›è¡Œåˆ†æï¼Œæ‰¾å‡ºåœ°å€ç‰¹å¾ã€‚A0000Hï½FFFFFH è®¾è®¡è¯‘ç ç”µè·¯ï¼Œç”¨æ¥æ§åˆ¶åŒå‘æ•°æ®æ€»çº¿é©±åŠ¨å™¨ï¼Œä½¿ä¹‹æ»¡è¶³é˜²æ­¢æ€»çº¿ç«äº‰åŸåˆ™ã€‚ æŸå¾®å‹æœºç”µè·¯æ¿ä¸Šæœ‰å†…å­˜C0000Hï½EFFFFHå’Œæ¥å£A000Hï½BFFFHï¼Œè¯•ç”»å‡ºè¯¥ç”µè·¯æ¿æ¿å†…åŒå‘æ•°æ®æ€»çº¿é©±åŠ¨ä¸æ§åˆ¶ç”µè·¯ã€‚ï¼ˆP128ï¼Œä¾‹4.3ï¼‰ é˜²æ­¢æ€»çº¿ç«äº‰åŸåˆ™ï¼šåªæœ‰å½“CPUè¯»æ¿å†…å†…å­˜æˆ–è¯»æ¿å†…æ¥å£æ—¶ï¼Œæ‰å…è®¸åŒå‘æ•°æ®é©±åŠ¨å™¨æŒ‡å‘ç³»ç»Ÿæ€»çº¿çš„ä¸‰æ€é—¨æ˜¯å¯¼é€šçš„ã€‚ åœ°å€åˆ†æï¼ˆå†…å­˜åœ°å€ã€æ¥å£åœ°å€ï¼‰ ç”»é©±åŠ¨ä¸æ§åˆ¶ç”µè·¯ å‡ ç§å¯ä¾›é€‰æ‹©çš„è¯‘ç æ–¹å¼ åŸºæœ¬é—¨ç”µè·¯ è¯‘ç å™¨ï¼Œå¦‚74LS138 è¯‘ç PROM CPLDã€FPGA é‡‡ç”¨8086 CPUçš„å¾®æœºç³»ç»Ÿï¼Œå…¶ä¸»å­˜åœ°å€èŒƒå›´ä¸ºC0000Hï½C7FFFHï¼Œç”±4å—å¤§å°ä¸º8kï‚´8bçš„èŠ¯ç‰‡æ„æˆä¸»å­˜æ¿ï¼Œè¯•ç”»å‡ºæ¿å†…åŒå‘æ•°æ®æ€»çº¿é©±åŠ¨æ§åˆ¶ç”µè·¯åŠå•å‘ä¿¡å·é©±åŠ¨ç”µè·¯ã€‚ ä¸»å­˜åœ°å€åˆ†æ åŒå‘æ•°æ®æ€»çº¿é©±åŠ¨æ§åˆ¶ç”µè·¯\u000båŠå•å‘ä¿¡å·é©±åŠ¨ç”µè·¯ æ€»çº¿è®¾è®¡ä¸­çš„å·¥ç¨‹é—®é¢˜ æ€»çº¿äº¤å‰ä¸²æ‰° å‡å°‘æ€»çº¿é•¿åº¦ å¢åŠ æ€»çº¿é—´çš„è·ç¦» é™ä½æ€»çº¿ä¸Šçš„è´Ÿè½½ é™ä½æ€»çº¿ä¿¡å·çš„å·¥ä½œé¢‘ç‡ ä¸¤æ¡ä¿¡å·çº¿ä¹‹é—´åŠ ä¸€æ¡åœ°çº¿ å‡å°‘æ€»çº¿çš„å¹³è¡Œèµ°å‘ åœ†æ»‘è„‰å†²ä¿¡å·çš„è¾¹ç¼˜ é‡‡ç”¨åŒç»çº¿ æ€»çº¿çš„å»¶æ—¶ å°½é‡å‡å°‘æ€»çº¿é•¿åº¦ é‡‡ç”¨å»¶æ—¶å°ã€è¾“å‡ºè¾“å‡ºç”µå®¹å°ã€é©±åŠ¨èƒ½åŠ›å¼ºçš„å…ƒå™¨ä»¶ éœ€è¦åŒæ­¥çš„ä¿¡å·çº¿ï¼Œå¸ƒçº¿æ—¶å€™åº”åŒ¹é…é•¿åº¦ æ€»çº¿ä¿¡å·çš„åå°„ åœ¨æ»¡è¶³ç³»ç»ŸåŠŸèƒ½çš„å‰æä¸‹ï¼Œé™ä½ä¼ è¾“ä¿¡å·çš„é¢‘ç‡ å°½é‡ä½¿ä¿¡å·æºå†…é˜»ã€æ€»çº¿ç‰¹æ€§é˜»æŠ—ã€è´Ÿè½½é˜»æŠ—ä¸‰è€…ç›¸åŒ¹é… é™åˆ¶æ€»çº¿é•¿åº¦ PCä¸­çš„æ€»çº¿ 8086å¾®å¤„ç†å™¨16ä½å¾®æœºï¼šISAæ€»çº¿ æ€»çº¿ä¿¡å·ä¾æ®8086å¤„ç†å™¨ä¿¡å·å®šä¹‰ 8086å¤„ç†å™¨ä¸ISAæ€»çº¿å¯ä»¥å®ç°ç›´æ¥å¯¹æ¥ åˆ©ç”¨ISAæ€»çº¿å¯ä»¥ç›´æ¥è¯»å†™ä¸»å­˜æˆ–I/Oæ¥å£ 80386å¾®å¤„ç†å™¨32ä½å¾®æœºï¼šä¸CPUæ— å…³çš„PCIæ€»çº¿ PCIæ€»çº¿å…·æœ‰è¾ƒå¿«çš„æ•°æ®ä¼ è¾“é€Ÿç‡ PCIæ€»çº¿æ”¯æŒå³æ’å³ç”¨å’Œçƒ­æ’æ‹” åŸºäºPCIæ€»çº¿çš„å¾®æœºç³»ç»Ÿè¿˜æ”¯æŒå¤šæ€»çº¿ç»“æ„ï¼Œè¿›è€Œä½¿ç³»ç»Ÿå…·æœ‰ä¸€å®šçš„å¹¶è¡Œæ“ä½œèƒ½åŠ› å­˜å‚¨æŠ€æœ¯ æ¦‚è¿° å­˜å‚¨å™¨çš„åˆ†ç±» ä¸»è¦æ€§èƒ½æŒ‡æ ‡ å®¹é‡ é€Ÿåº¦ï¼šå­˜å–æ—¶é—´ æˆæœ¬ï¼šä»·æ ¼ å¸¸ç”¨å­˜å‚¨å™¨èŠ¯ç‰‡åŠè¿æ¥ä½¿ç”¨ é™æ€éšæœºè¯»/å†™å­˜å‚¨å™¨ï¼ˆSRAMï¼‰åŠæ¥å£è®¾è®¡ é™æ€éšæœºè¯»å†™å­˜å‚¨å™¨ï¼ˆStatic Random Access Memory\nåˆ†ç±»\nåŒæ­¥å‹ å¼‚æ­¥å‹ å¼‚æ­¥SRAM\nå…¸å‹èŠ¯ç‰‡ï¼š6264ï¼ˆ8K $\\times $ 8bitï¼‰ å¼•çº¿ å·¥ä½œè¿‡ç¨‹ã€æ—¶åº å†™å…¥æ—¶åº è¯»å‡ºæ—¶åº è¿æ¥ä½¿ç”¨ å…¨åœ°å€è¯‘ç ä¸éƒ¨åˆ†åœ°å€è¯‘ç  SRAM 6264å…¨åœ°å€è¯‘ç è¿æ¥ SRAM 6264éƒ¨åˆ†åœ°å€è¯‘ç è¿æ¥ è¯‘ç ç”µè·¯çš„é€‰æ‹© åˆ©ç”¨è¯‘ç èŠ¯ç‰‡ ä½¿ç”¨ROMä½œè¯‘ç å™¨\nç°åœ¨è¦ç”¨4ç‰‡6264æ„æˆä¸€ä¸ªå­˜å‚¨å®¹é‡ä¸º32KBçš„å­˜å‚¨å™¨ï¼Œå…¶åœ°å€ç©ºé—´ä¸ºE0000Hï½E7FFFHã€‚ç”¨ä¸€å—512Ã—4çš„PROMèŠ¯ç‰‡63S241ä½œä¸ºROMè¯‘ç å™¨ åˆ©ç”¨æ•°å­—æ¯”è¾ƒå™¨ä½œè¯‘ç å™¨ åˆ©ç”¨PLDåšè¯‘ç å™¨ å­˜å–æ—¶é—´ æ§åˆ¶ä¿¡å·çš„è¿æ¥ï¼š8088/8086 æœ€å°æ¨¡å¼ã€æœ€å¤§æ¨¡å¼$ M/\\overline{IO},\\overline{RD},\\overline{WR} =\u0026gt; \\overline{MEMR},\\overline{MEMW} $ ä¾‹ï¼šå·²çŸ¥8088å¾®å¤„ç†å™¨æ—¶é’Ÿä¸º4.77MHzï¼Œåœ°å€å»¶æ—¶æ—¶é—´$t_{da}ï¼110ns$ï¼Œå­˜å‚¨ç³»ç»Ÿå„ç§é™„åŠ çš„å»¶æ—¶æ—¶$t_D$ï¼200nsã€‚é—®ï¼šç”¨å­˜å–å‘¨æœŸä¸º250nsçš„å­˜å‚¨èŠ¯ç‰‡èƒ½å¦æ»¡è¶³ç³»ç»Ÿè¦æ±‚ï¼Ÿ\n$$ \\begin{align} t(R,W)+t_{da}+t_D \u0026amp;{\\le} 3T \\cr t(R,W) \u0026amp;{\\le} 3Tï¼ t_{da}ï¼ t_{D} \\cr 3Ã—210ï¼200ï¼110 \u0026amp;ï¼ 320ns \\cr \\end{align} $$ ä¸ºå­˜å‚¨å™¨æä¾›çš„å­˜å–æ—¶é—´\nå­˜å‚¨å™¨è¦æ±‚çš„å­˜å–æ—¶é—´ä¸º250ns â†’ èƒ½æ»¡è¶³ç³»ç»Ÿè¦æ±‚ åªè¯»å­˜å‚¨å™¨ï¼ˆROMï¼‰åŠæ¥å£è®¾è®¡ EPROMï¼ˆç´«å¤–çº¿å¯æ“¦é™¤åªè¯»å­˜å‚¨å™¨ï¼‰ï¼š2764èŠ¯ç‰‡ï¼ˆ8K$\\times 8bitï¼‰\nå¼•çº¿ A12~A0 D7~D0 $\\overline{CE}$ï¼šç‰‡é€‰ $\\overline{OE}$ï¼šæ•°æ®è¾“å‡ºå…è®¸ $\\overline{PGM}$ï¼šç¼–ç¨‹æ—¶ï¼šç¼–ç¨‹è„‰å†²è¾“å…¥ï¼›è¯»æ—¶ï¼šâ€œ1â€ è¿æ¥ï¼šè‹¥åˆ©ç”¨å…¨åœ°å€è¯‘ç å°†EPROM 2764æ¥åœ¨é¦–åœ°å€ä¸ºA0000Hçš„å†…å­˜åŒºï¼Œè¯•ç”»è¿æ¥å›¾ ç¼–ç¨‹ æ“¦é™¤ï¼šç´«å¤–çº¿ 15ï½20min â†’ æ¯å•å…ƒå†…å®¹å‡ä¸ºFFH EPROMç¼–ç¨‹ EEPROM\nå…¸å‹EERROMèŠ¯ç‰‡ä»‹ç»ï¼š98C64A ä¼˜ç‚¹ï¼šå¯å•å­—èŠ‚éšæœºè¯»å†™ï¼ˆä¸éœ€æ“¦é™¤ï¼Œç›´æ¥è¯»å†™ï¼‰ ç¼ºç‚¹ï¼šå­˜å‚¨å¯†åº¦é«˜ï¼Œå•ä½æˆæœ¬é«˜ è¿æ¥ä½¿ç”¨ï¼šå°†55Hå†™æ»¡98C64A é—ªå­˜EEPROMï¼šFLASH\nNORå‹ ç‹¬ç«‹æ•°æ®ã€åœ°å€æ€»çº¿ï¼Œå¯ä»¥éšæœºå¿«é€Ÿè¯»å– è¯»æ“ä½œé€Ÿåº¦å¿«ï¼Œæ“¦é™¤ã€ç¼–ç¨‹é€Ÿåº¦æ…¢ NANDå‹ ä»¥é¡µ(256æˆ–512B)ä¸ºå•ä½è¯»/ç¼–ç¨‹ ä»¥å—(4Kã€8Kã€16K)ä¸ºå•ä½æ“¦é™¤ï¼ˆæœ€å¤š4msï¼‰ ä¸²è¡Œè¯»å–å¿«ã€éšæœºè¯»å–æ…¢ å…¶ä»–å­˜å‚¨å™¨ åŒç«¯å£å­˜å‚¨å™¨ å…ˆè¿›å…ˆå‡ºï¼ˆFIFOï¼‰å­˜å‚¨å™¨ é“ç”µå­˜å‚¨å™¨ï¼ˆFRAMï¼‰ Intel 16/32ä½å¾®æœºç³»ç»Ÿçš„ä¸»å­˜è®¾è®¡ï¼ˆSRAMéƒ¨åˆ†ï¼‰ 8086ã€8088å¤„ç†å™¨çš„å†…å­˜æ¥å£ å­˜å‚¨å™¨SRAM 6116ï¼ˆ$ 2K\\times 8bitï¼‰$ ä¸8088çš„8ä½æ€»çº¿è¿æ¥\nSRAM 6116ä¸8086çš„16ä½æ€»çº¿è¿æ¥\n$ \\overline{A0}$é€‰å¶åœ°å€ $ \\overline{BHE} $é€‰å¥‡åœ°å€ å­˜å‚¨å™¨çš„å­—æ‰©å…… å­˜å‚¨å™¨çš„ä½æ‰©å…… 6264ä¸8086ç³»ç»Ÿæ€»çº¿çš„è¿æ¥ 80386ã€80486çš„å†…å­˜æ¥å£ ä¸å†…å­˜æ¥å£ç›¸å…³çš„ä¿¡å· åœ°å€ä¿¡å·A2ï½A31å…±30ä¸ªåœ°å€ä¿¡å·ï¼Œå…¶ç¼–ç å¯å¯»å€1Gä¸ª32ä½çš„å­˜å‚¨å•å…ƒã€‚è¿™é‡Œæ²¡æœ‰A0å’ŒA1ï¼Œè¿™ä¸¤ä¸ªä¿¡å·å·²åœ¨80386ã€80486å†…éƒ¨è¯‘ç ï¼Œç”¨äºäº§ç”Ÿ4ä¸ªä½“é€‰æ‹©ä¿¡å·ã€‚ ä½“é€‰æ‹©ä¿¡å·$ \\overline{BE0}ï½\\overline{BE3} $ 32ä½çš„æ•°æ®ä¿¡å·D0ï½D31åˆ†ä¸º4ä¸ªå­—èŠ‚ï¼Œåˆ†åˆ«æ˜¯D0ï½D7ã€D8ï½D15ã€D16ï½D23 å’Œ D24ï½D31ã€‚ æ§åˆ¶ä¿¡å·$ M/\\overline{IO} $ $D/\\overline{C}$ï¼ˆæ•°æ®/æ§åˆ¶ï¼‰ä¿¡å·ï¼Œä½ç”µå¹³ä¸ºå¤„ç†å™¨ä¸­æ­¢æˆ–æ­£åœ¨å“åº”ä¸­æ–­ï¼Œé«˜ç”µå¹³è¡¨ç¤ºæ­£åœ¨ä¼ é€æ•°æ®ï¼› $W/\\overline{R}$ï¼ˆè¯»/å†™ï¼‰ä¿¡å·ï¼Œä½ç”µå¹³è¡¨ç¤ºè¯»å†…å­˜æˆ–æ¥å£ï¼Œé«˜ç”µå¹³è¡¨ç¤ºå†™å†…å­˜æˆ–æ¥å£ Pentiumå¤„ç†å™¨çš„å†…å­˜ç»„ç»‡ åŠ¨æ€éšæœºè¯»/å†™å­˜å‚¨å™¨ï¼ˆDRAMï¼‰åŠæ¥å£è®¾è®¡ ç®€å•å¼‚æ­¥DRAM å¼•çº¿ åœ°å€çº¿å¤ç”¨ï¼šå…ˆè¾“å…¥è¡Œåœ°å€ï¼Œå†è¾“å…¥åˆ—åœ°å€ $\\overline{WE}$å†™å…è®¸ $D_{IN}ã€D_{OUT} $ å·¥ä½œæ–¹å¼åŠæ—¶åº è¯»æ“ä½œ å†™æ“ä½œ æå‰å†™ è¯»å˜å†™ åˆ·æ–°ï¼š2-4msåˆ·æ–°ä¸€æ¬¡ è¿æ¥ä½¿ç”¨/æ¥å£è®¾è®¡ è¡Œåˆ—ä¿¡å·çš„å½¢æˆ è¯»å†™ åˆ·æ–° åŒæ­¥åŠ¨æ€å­˜å‚¨å™¨SDRAM æ¦‚è¿°\nSDR SDRAMï¼ˆSingle Data Rate Synchronous Dynamic RAMï¼‰ï¼šå•å€é€Ÿç‡åŒæ­¥åŠ¨æ€éšæœºå­˜å‚¨å™¨ åªåœ¨æ—¶é’Ÿçš„ä¸Šå‡æ²¿ä¼ è¾“å‘½ä»¤ã€åœ°å€å’Œæ•°æ® DDR(Double Date Rate) æ—¶é’Ÿä¸Šå‡æ²¿ã€ä¸‹é™æ²¿å„ä¼ é€ä¸€æ¬¡æ•°æ® ä»DDR2å¼€å§‹ï¼Œæ¥å£çš„é¢‘ç‡å¼€å§‹é«˜äºå­˜å‚¨å•å…ƒçš„æ ¸å¿ƒé¢‘ç‡ SDRAMå’Œæ ‡å‡†DRAMçš„ä¸»è¦ä¸åŒ åŒæ­¥å’Œå¼‚æ­¥ å†…éƒ¨ç»„ç»‡ç»“æ„ SDRAMå†…éƒ¨åˆ†ä½“ æ ‡å‡†çš„DRAMå¯ä»¥çœ‹æˆå†…éƒ¨åªæœ‰ä¸€ä¸ªä½“çš„SDRAM è¯»å†™æ–¹å¼ä¸åŒ SDRAMå…·æœ‰çªå‘è¯»å†™èƒ½åŠ› çªå‘(Burst)æ˜¯æŒ‡åœ¨åŒä¸€è¡Œä¸­ç›¸é‚»çš„å­˜å‚¨å•å…ƒè¿ç»­è¿›è¡Œæ•°æ®ä¼ è¾“çš„æ–¹å¼ã€‚ è¿ç»­ä¼ è¾“æ‰€æ¶‰åŠåˆ°çš„å­˜å‚¨å•å…ƒ(åˆ—)çš„æ•°é‡å°±æ˜¯çªå‘é•¿åº¦(Burst Lengthsï¼ŒBL) æ™ºèƒ½åŒ– åœ¨SDRAMèŠ¯ç‰‡å†…éƒ¨è®¾ç½®æœ‰æ¨¡å¼å¯„å­˜å™¨ ä¸€èˆ¬çš„æ ‡å‡†DRAMåªæœ‰ä¸€ç§å·¥ä½œæ¨¡å¼ å…¸å‹çš„SDRAMèŠ¯ç‰‡(ä¸‰æ˜ŸK4S511632D(32MÃ—16 bit SDRAM))\nå¼•çº¿ åœ°å€è¾“å…¥ è¡Œåœ°å€ï¼šRA0~RA12 åˆ—åœ°å€ï¼šCA0~CA9 bankåœ°å€è¾“å…¥ æ•°æ®è¾“å…¥/è¾“å‡º è¾“å‡ºå…è®¸ å¸¸ç”¨æŒ‡æ ‡ å®¹é‡ï¼šå­˜å‚¨å•å…ƒÃ—ä½“Ã—æ¯å•å…ƒå­˜å‚¨ä½æ•° æ—¶é’Ÿå‘¨æœŸ å­˜å–æ—¶é—´ CASçš„å»¶è¿Ÿæ—¶é—´ï¼ˆCas latencyï¼‰ ç»¼åˆæ€§èƒ½çš„è¯„ä»·ï¼šæ€»å»¶è¿Ÿæ—¶é—´=ç³»ç»Ÿæ—¶é’Ÿå‘¨æœŸÃ—CLæ¨¡å¼æ•°+å­˜å–æ—¶é—´ æ—¶åº SDRAMæ§åˆ¶å™¨\nå®ç°æ–¹å¼ ä»¥å—åŒ—æ¡¥èŠ¯ç‰‡ç»„ä¸ºä¸»è¦æ ¸å¿ƒçš„PCæœºç³»ç»Ÿ æŸäº›ä¸ºå¾®å¤„ç†å™¨ä¸­é›†æˆäº†SDRAMæ§åˆ¶å™¨ è®¾è®¡ä¸CPUæˆ–ç³»ç»Ÿæ€»çº¿è¿æ¥çš„ç‹¬ç«‹SDRAMæ§åˆ¶å™¨ï¼ŒSDRAMèŠ¯ç‰‡è¿æ¥åœ¨SDRAMæ§åˆ¶å™¨ä¸Š SDRAMçš„åŸºæœ¬æ“ä½œ å¯¹SDRAMçš„è®¿é—®çš„ä¸‰ç§æƒ…å†µ å½“å‰è®¿é—®çš„è¡Œæ‰€åœ¨çš„å­˜å‚¨ä½“ä¸­ï¼Œè¡Œç¼“å†²å™¨æ˜¯å…³é—­çš„ å‘é€æ¿€æ´»å‘½ä»¤ å‘é€è¯»å†™å‘½ä»¤å’Œåˆ—åœ°å€ è¯»å†™å»¶è¿Ÿä¸­ç­‰ å½“å‰è®¿é—®çš„è¡Œçš„æ•°æ®ï¼Œåˆšå¥½ä¿å­˜åœ¨ç›¸åº”å­˜å‚¨ä½“çš„è¡Œç¼“å†²å™¨ä¸­ ç›´æ¥å‘é€è¯»/å†™å‘½ä»¤å’Œåˆ—åœ°å€ è¯»å†™å»¶è¿Ÿæœ€å° å½“å‰è®¿é—®çš„è¡Œæ‰€åœ¨çš„å­˜å‚¨ä½“ä¸­ï¼Œè¡Œç¼“å†²å™¨æ‰“å¼€ï¼Œå­˜çš„æ˜¯å¦ä¸€ä¸ªè¡Œçš„æ•°æ® å…ˆå‘é€Perchargeæˆ–Precharge Allå‘½ä»¤å…³é—­è¡Œç¼“å†²å™¨ å†å‘é€æ¿€æ´»å‘½ä»¤æ¿€æ´»è¯¥è¡Œ æœ€åå‘é€è¯»/å†™å’Œåˆ—åœ°å€ è¯»/å†™å»¶è¿Ÿæœ€å¤§ SDRAMæ§åˆ¶å™¨çš„åŸºæœ¬ç»„æˆ è¿ç»­å†…å­˜åœ°å€æ˜ å°„ äº¤é”™å†…å­˜åœ°å€æ˜ å°„ï¼šå°†è¿ç»­çš„é€»è¾‘åœ°å€æ˜ å°„åˆ°ä¸åŒçš„å­˜å‚¨ä½“ä¸­ SDRAMçš„æ§åˆ¶ä¼˜åŒ– è¡Œå…³é—­ä¼˜å…ˆç­–ç•¥ï¼ˆClose-Page Policyï¼‰ï¼šè¡Œæ¿€æ´»ã€åˆ—è¯»/å†™ã€é¢„å……ç”µ è¡Œæ‰“å¼€ä¼˜å…ˆç­–ç•¥ï¼ˆOpen-Page Policyï¼‰ è®¿é—®è¯·æ±‚ç©ºé—´å±€éƒ¨æ€§å¾ˆå¥½ï¼Œå¤§å¤§å‡å°‘è¯»å†™å»¶è¿Ÿ è®¿é—®è¯·æ±‚ç©ºé—´åˆ†å¸ƒå¾ˆåˆ†æ•£ï¼Œé€ æˆè¾ƒå¤§è¯»å†™å»¶è¿Ÿ DDR SDRAM DDR SDRAMä¸SDRAMçš„ä¸åŒ åˆå§‹åŒ– æ—¶é’Ÿ æ•°æ®é€‰å–è„‰å†² å†™å…¥å»¶æ—¶ çªå‘é•¿åº¦å’Œå†™å…¥æ©ç  DDR SDRAMï¼Œçªå‘é•¿åº¦åªæœ‰2ã€4ã€8ï¼Œæ²¡æœ‰SDRAMçš„éšæœºå­˜å–çš„æ“ä½œå’Œå…¨é¡µè§¦å‘æ–¹å¼ï¼›åŒæ—¶ï¼Œçªå‘é•¿åº¦çš„å®šä¹‰ä¸å†æŒ‡æ‰€è¿ç»­å¯»å€çš„å­˜å‚¨å•å…ƒæ•°é‡ï¼Œè€Œæ˜¯æŒ‡è¿ç»­çš„ä¼ è¾“å‘¨æœŸæ•° å¯¹äºçªå‘å†™å…¥ï¼Œå¦‚æœå…¶ä¸­æœ‰ä¸æƒ³å­˜å–çš„æ•°æ®ï¼Œä»å¯ä»¥ä½¿ç”¨DMä¿¡å·è¿›è¡Œå±è”½ å»¶è¿Ÿé”å®šå›è·¯ ä¹ é¢˜ 5.5 å·²æœ‰ä¸¤ç‰‡6116ï¼Œç°åœ¨æ¬²å°†å®ƒä»¬è¿æ¥åˆ°8088ç³»ç»Ÿä¸­å»ï¼Œå…¶åœ°å€èŒƒå›´ä¸º40000H~40FFFHï¼Œè¯•ç”»è¿æ¥ç”µè·¯å›¾ï¼Œå†™å…¥æŸæ•°æ®å¹¶è¯»å‡ºä¸ä¹‹æ¯”è¾ƒï¼›å¦‚æœ‰é”™ï¼Œåˆ™åœ¨DLä¸­å†™å…¥01Hï¼›è‹¥æ¯ä¸ªå•å…ƒå‡å¯¹ï¼Œåˆ™åœ¨DLä¸­å†™å…¥EEHï¼Œè¯•ç¼–å†™æ­¤æ£€æµ‹ç¨‹åºã€‚\n5.10 å°†4ç‰‡6264è¿æ¥åˆ°8086ç³»ç»Ÿæ€»çº¿ä¸Šï¼Œè¦æ±‚å†…å­˜åœ°å€èŒƒå›´ä¸º7000H~77FFFHï¼Œç”»å‡ºè¿æ¥å›¾ã€‚\n5.16 ç°æœ‰å®¹é‡ä¸º32KÃ—4bitçš„SRAMèŠ¯ç‰‡ã€‚\nåœ¨8086ç³»ç»Ÿä¸­ï¼Œåˆ©ç”¨è¿™æ ·çš„èŠ¯ç‰‡æ„æˆä»88000Hï½97FFFHçš„å†…å­˜ï¼Œç”»å‡ºæœ€å¤§æ¨¡å¼ä¸‹åŒ…æ‹¬æ€»çº¿é©±åŠ¨åœ¨å†…çš„æ­¤èŠ¯ç‰‡ä¸ç³»ç»Ÿæ€»çº¿çš„è¿æ¥å›¾ï¼ˆè¯‘ç å™¨ä»¶è‡ªè¡Œé€‰æ‹©ï¼‰\nè¾“å…¥è¾“å‡ºæŠ€æœ¯ I/Oæ¦‚è¿° åŸºæœ¬è¾“å…¥/è¾“å‡ºæ–¹æ³• ç¨‹åºæ§åˆ¶I/Oæ–¹å¼ æ— æ¡ä»¶ä¼ é€æ–¹å¼ï¼šè¾“å…¥æ¥å£ã€è¾“å‡ºæ¥å£ æŸ¥è¯¢æ–¹å¼ï¼šå•å¤–è®¾ã€å¤šå¤–è®¾ ä¸­æ–­é˜²å®ˆ DMAï¼ˆç›´æ¥å­˜å‚¨å™¨ï¼‰æ–¹å¼ I/Oæ¥å£æ¦‚è¿° I/Oæ¥å£èƒ½åšä»€ä¹ˆ æä¾›ä¿¡æ¯é€šé“ è¿›è¡Œæ•°æ®æ ¼å¼è½¬æ¢ CPUå’Œå¤–è®¾é€Ÿåº¦åŒ¹é… è´Ÿè½½åŒ¹é… æ—¶åºåŒ¹é… æ€»çº¿éš”ç¦» æä¾›ä¸­æ–­ã€DMAèƒ½åŠ› å¤–è®¾æ¥å£ä¸ç«¯å£ ç»Ÿä¸€ç¼–å€çš„ä¼˜ç‚¹ CPUduiI/Oç«¯å£çš„è¯»å†™æ“ä½œå¯æ˜¯ä½¿ç”¨å…¨éƒ¨å­˜å‚¨å™¨çš„è¯»/å†™æ•°æ®æ“ä½œæŒ‡ä»¤ å†…å­˜ä¸å¤–è®¾åœ°å€çš„åˆ†é…å¯ä»¥ç”¨ç»Ÿä¸€çš„åˆ†é…å›¾ ä¸éœ€è¦ä¸“é—¨çš„è¾“å…¥ã€è¾“å‡ºæ“ä½œæŒ‡ä»¤ ç»Ÿä¸€ç¼–å€çš„ç¼ºç‚¹ ä½¿å¾—ç³»ç»Ÿä¸­å®é™…å¯ä»¥ç›´æ¥å¯»å€çš„å†…å­˜å•å…ƒæ•°å‡å°‘ ç»™æ£€ä¿®ã€ç»´æŠ¤å¢åŠ äº†éš¾åº¦ ä¸€èˆ¬ç³»ç»Ÿä¸­I/Oç«¯å£æ•°è¿œå°äºå†…å­˜å•å…ƒæ•°ï¼Œæ‰€ä»¥ç»Ÿä¸€ç¼–å€ä½¿å¾—æŒ‡ä»¤ä»£ç è¾ƒé•¿ï¼Œè¯»/å†™æ‰§è¡Œæ—¶é—´ä¹Ÿè¾ƒé•¿ Motorolaçš„M68ç³»åˆ—é‡‡ç”¨ç»Ÿä¸€ç¼–å€ï¼ŒIntelçš„86x86ç³»åˆ—CPUé‡‡ç”¨ç‹¬ç«‹ç¼–å€æ–¹å¼ I/Oç«¯å£åœ°å€è¯‘ç  åŸºæœ¬çš„å¹¶è¡Œè¾“å…¥ï¼ˆä¸‰æ€é—¨ï¼‰/è¾“å‡ºï¼ˆé”å­˜å™¨ï¼‰æ¥å£ å¹¶è¡Œè¾“å…¥æ¥å£ å¹¶è¡Œè¾“å‡ºæ¥å£ ç¨‹åºæŸ¥è¯¢I/Oæ–¹å¼ æ— æ¡ä»¶ä¼ é€æ–¹å¼ æŸ¥è¯¢æ–¹å¼ å¤šå¤–è®¾çš„æŸ¥è¯¢æ§åˆ¶ ä¸­æ–­æ–¹å¼ 8086/8088ä¸­æ–­ç³»ç»Ÿ ä¸­æ–­æºç±»å‹ ä¸ä¸­æ–­æœ‰å…³çš„æ§åˆ¶çº¿ï¼š$ NMIã€INTRã€\\overline{INTA} $ 8088ç³»ç»Ÿä¸­çš„ä¸­æ–­æº å†…éƒ¨ä¸­æ–­ é™¤æ³•æº¢å‡ºï¼šç±»å‹å·ä¸º0 å•æ­¥ä¸­æ–­ï¼šç±»å‹å·ä¸º1 æ–­ç‚¹ä¸­æ–­ï¼šç±»å‹å·ä¸º3 æº¢å‡ºä¸­æ–­ï¼šç±»å‹å·ä¸º4 è½¯ä»¶ä¸­æ–­ï¼šå³INT næŒ‡ä»¤ å¤–éƒ¨ä¸­æ–­ éå±è”½ä¸­æ–­NMIï¼šç±»å‹å·ä¸º2ï¼Œä¸å¯ç”¨è½¯ä»¶å±è”½ï¼ŒCPUå¿…é¡»å“åº”å®ƒ å¯å±è”½ä¸­æ–­INTRï¼šç±»å‹å·ç”±PICæä¾›ã€‚IF=1æ—¶CPUæ‰èƒ½å“åº”å®ƒ ä¸­æ–­å‘é‡è¡¨ï¼ˆIVTï¼‰ ç”¨äºå­˜æ”¾å„ç±»ä¸­æ–­æœåŠ¡ç¨‹åºçš„å…¥å£åœ°å€ï¼ˆæ®µå’Œåç§»ï¼‰ è¡¨çš„åœ°å€ä½äºå†…å­˜çš„00000H~003FFHï¼Œå¤§å°ä¸º1KBï¼Œå…±256ä¸ªå…¥å£ æ¯ä¸ªå…¥å£å 4 Bytes ä¸­æ–­å‘é‡åœ¨IVTä¸­çš„å­˜æ”¾åœ°å€ = 4 * ä¸­æ–­ç±»å‹å· å¯ç¼–ç¨‹ä¸­æ–­æ§åˆ¶å™¨8259 8259å†…éƒ¨ç»“æ„ ä¸­æ–­è¯·æ±‚å¯„å­˜å™¨IRR ä¸­æ–­æœåŠ¡å¯„å­˜å™¨ISR ä¸­æ–­å±è”½å¯„å­˜å™¨IMR ä¸­æ–­ä¼˜å…ˆæƒåˆ¤åˆ«ç”µè·¯ å¼•è„šåŠŸèƒ½ 8259å·¥ä½œæ–¹å¼\nä¸­æ–­ç»“æŸæ–¹å¼ éè‡ªåŠ¨ï¼šåœ¨ä¸­æ–­ç¨‹åºä¸­æä¾›EOIå‘½ä»¤ è‡ªåŠ¨ï¼šæ— éœ€EOIå‘½ä»¤ã€ç¬¬2ä¸ª$\\overline{INTA}$åæ²¿ ç¼“å†²æ–¹å¼ï¼šç¼“å†²ã€éç¼“å†² åµŒå¥—æ–¹å¼ ä¸€èˆ¬åµŒå¥—ï¼šå•ç‰‡ä½¿ç”¨ï¼›çº§è”æ–¹å¼ä»å± ç‰¹æ®ŠåµŒå¥—ï¼šçº§è”æ–¹å¼ä¸»æ§åˆ¶å™¨ å±è”½æ–¹å¼ï¼šä¸€èˆ¬å±è”½ã€ç‰¹æ®Šå±è”½ ä¼˜å…ˆçº§è§„å®šï¼šå›ºå®šä¼˜å…ˆçº§ã€å¾ªç¯ä¼˜å…ˆçº§ 8259çº§è” 8259ç¼–ç¨‹ä½¿ç”¨\nå†…éƒ¨å¯„å­˜å™¨çš„å¯»å€æ–¹æ³• åˆå§‹åŒ–å‘½ä»¤å­—ICW æ³¨æ„ å†™ICW1æ„å‘³ç€é‡æ–°åˆå§‹åŒ–8259 å†™ICW1åï¼Œ8259çš„çŠ¶æ€å¦‚ä¸‹ æ¸…é™¤ISRå’ŒIMRï¼ˆå…¨0ï¼‰ å°†ä¸­æ–­ä¼˜å…ˆçº§è®¾ç½®ä¸ºåˆå§‹çŠ¶æ€ è®¾ç½®ä¸ºä¸€èˆ¬å±è”½æ–¹å¼ é‡‡ç”¨éè‡ªåŠ¨ä¸­æ–­ç»“æŸæ–¹å¼ çŠ¶æ€è¯»å‡ºé€»è¾‘é¢„ç½®ä¸ºè¯»IRR ICW1ï¼šåˆå§‹åŒ–å­— ICW2ï¼šä¸­æ–­å‘é‡ç  ICW3ï¼šçº§è”æ§åˆ¶å­— ICW4ï¼šä¸­æ–­ç»“æŸæ–¹å¼å­— æ“ä½œå‘½ä»¤å­—OCW OCW1ï¼šä¸­æ–­å±è”½å­— OCW2ï¼šä¸­æ–­ç»“æŸå’Œä¼˜å…ˆçº§å¾ªç¯ OCW3ï¼šå±è”½æ–¹å¼å’Œè¯»å‡ºæ§åˆ¶å­— ä¸­æ–­æ–¹å¼åŠå®ç°æ–¹æ³• è¿æ¥8259 ç¼–å†™ä¸­æ–­åˆå§‹åŒ–ç¨‹åº åˆå§‹åŒ–8259 è®¾ç½®ä¸­æ–­å‘é‡è¡¨ ä¸­æ–­æœåŠ¡ç¨‹åºæ¡†æ¶ ç›´æ¥å­˜å–å™¨ï¼ˆDMAï¼‰æ–¹å¼ DMAå·¥ä½œè¿‡ç¨‹ é€šè¿‡ç‰¹æ®Šç¡¬ä»¶DMAæ§åˆ¶å™¨å®ç°ï¼Œä¼ è¾“é€Ÿç‡é«˜ å¤–è®¾ç›´æ¥ä¸å­˜å‚¨å™¨è¿›è¡Œæ•°æ®äº¤æ¢ï¼ŒCPUä¸å†ä½œä¸ºä¸­ä»‹è€… æ€»çº¿ç”±DMAæ§åˆ¶å™¨ï¼ˆDMACï¼‰è¿›è¡Œæ§åˆ¶ï¼ŒCPUæ”¾å¼ƒæ€»çº¿æ§åˆ¶æƒï¼Œå†…å­˜/å¤–è®¾çš„åœ°å€å’Œè¯»å†™æ§åˆ¶ä¿¡å·å‡ç”±DMACæä¾› ä¹ é¢˜ 6.6 å™è¿°8086/88è½¯ä»¶ä¸­æ–­æŒ‡ä»¤INT nçš„æ‰§è¡Œè¿‡ç¨‹\nCPUå–INT næŒ‡ä»¤ï¼Œç»æŒ‡ä»¤è¯‘ç è·çŸ¥è¿™æ˜¯ä¸€æ¡ä¸­æ–­æŒ‡ä»¤ï¼Œä¸”è¯¥è½¯ä»¶ä¸­æ–­çš„ä¸­æ–­å‘é‡ç ä¸ºn å°†PSWã€CSã€IPå‹å…¥å †æ ˆä¿æŠ¤èµ·æ¥ï¼Œå¹¶å…³ä¸­æ–­ $ n \\times 4 $ å¾—åˆ°ä¸­æ–­å‘é‡è¡¨åœ°å€ï¼Œä»è¯¥åœ°å€å¼€å§‹çš„é¡ºåºä¸¤ä¸ªå­—èŠ‚çš„å†…å®¹é€IPï¼Œä¸‹ä¸¤ä¸ªå­—èŠ‚çš„å†…å®¹é€CSï¼Œå³$n \\times 4\\to IP,(n\\times4+2)\\to CS $ å¼€å§‹æ‰§è¡Œä¸­æ–­æœåŠ¡ç¨‹åºã€‚ï¼ˆä¸­æ–­æœåŠ¡ç¨‹åºçš„å…¥å£åœ°å€æ—©å·²å¡«å…¥ä¸­æ–­å‘é‡è¡¨ä¸­ï¼‰ ä¸­æ–­æœåŠ¡ç¨‹åºçš„æœ€åä¸€æ¡æŒ‡ä»¤IRETï¼Œä»å †æ ˆæ¢å¤IPã€CSã€PSWï¼Œä¸­æ–­è¿”å› 6.8 è¾“å…¥æ¥å£åœ°å€ä¸º04E5Hï¼Œè¾“å‡ºæ¥å£åœ°å€ä¸ºE504Hã€‚ ç¼–ç¨‹åºï¼š è‹¥è¾“å…¥æ¥å£çš„bit3ã€bit4å’Œbit7åŒæ—¶ä¸º1ï¼Œå°†ä»¥DATAä¸ºé¦–åœ°å€çš„10ä¸ªå†…å­˜æ•°æ®è¿ç»­ç”±è¾“å‡ºæ¥å£è¾“å‡ºï¼Œè‹¥ä¸æ»¡è¶³æ¡ä»¶åˆ™ç­‰å¾…\n6.9 è‹¥ï¼šç³»ç»Ÿåªæœ‰ä¸€ç‰‡8259ï¼Œ8259åœ°å€ä¸ºE010Hå’ŒE011Hï¼Œå…è®¸8ä¸ªä¸­æ–­æºè¾¹æ²¿è§¦å‘ï¼Œä¸éœ€è¦ç¼“å†²ï¼Œä»¥ä¸€èˆ¬åµŒå¥—æ–¹å¼å·¥ä½œï¼Œä¸­æ–­å‘é‡ä¸º40Hï¼Œéè‡ªåŠ¨EOIæ–¹å¼\nç¼–å†™åˆå§‹åŒ–ç¨‹åº è‹¥å…è®¸ä¸­æ–­åµŒå¥—ï¼Œç¼–å†™ä¸­æ–­æœåŠ¡ç¨‹åºæ¡†æ¶ï¼ŒåŒ…æ‹¬è¿”å›å‰å‘é€EOIå‘½ä»¤ã€‚ä¸­æ–­æœåŠ¡ç¨‹åºåç§°ä¸ºIPROC40 ç¼–ç¨‹åºï¼Œå°†ä¸Šè¿°ä¸­æ–­å¤„ç†ç¨‹åºçš„å…¥å£åœ°å€å¡«å…¥ä¸­æ–­å‘é‡è¡¨ å¸¸ç”¨æ¥å£å™¨ä»¶ è®¡ç®—æœºå’Œå¤–è®¾ä¹‹é—´å¦‚ä½•é€šè¿‡æ¥å£ä¼ é€æ•°æ®ï¼ˆéDMAï¼‰ å¯ç¼–ç¨‹å¹¶è¡Œæ¥å£8255 å†…éƒ¨ç»“æ„åŠå¤–éƒ¨æ€»çº¿ 8255çš„å·¥ä½œæ–¹å¼ å·¥ä½œæ–¹å¼0ï¼šåŸºæœ¬è¾“å…¥è¾“å‡ºæ–¹å¼ Aå£ï¼ˆPA0~PA7ï¼‰ï¼šè¾“å…¥ï¼ˆæ— é”å­˜èƒ½åŠ›ï¼‰æˆ–è¾“å‡ºï¼ˆæœ‰é”å­˜èƒ½åŠ›ï¼‰ Bå£ï¼ˆPB0~PB7ï¼‰ï¼šè¾“å…¥ï¼ˆæ— é”å­˜èƒ½åŠ›ï¼‰æˆ–è¾“å‡ºï¼ˆæœ‰é”å­˜èƒ½åŠ›ï¼‰ Cå£ï¼ˆPC4~PC7ï¼‰ï¼šè¾“å…¥ï¼ˆæ— é”å­˜èƒ½åŠ›ï¼‰æˆ–è¾“å‡ºï¼ˆæœ‰é”å­˜èƒ½åŠ›ï¼‰ Cå£ï¼ˆPC0~PC3ï¼‰ï¼šè¾“å…¥ï¼ˆæ— é”å­˜èƒ½åŠ›ï¼‰æˆ–è¾“å‡ºï¼ˆæœ‰é”å­˜èƒ½åŠ›ï¼‰ å·¥ä½œæ–¹å¼1ï¼šé€‰é€šè¾“å…¥è¾“å‡ºæ–¹å¼ å·¥ä½œæ–¹å¼2ï¼šåŒå‘è¾“å…¥è¾“å‡ºæ–¹å¼ï¼ˆä»…Aå£ï¼‰ PC3-PC7ï¼šAå£æ–¹å¼2ä¸‹çš„æ§åˆ¶çº¿ PC0-PC2ï¼šè¾“å…¥æˆ–è¾“å‡ºæˆ–Bå£æ–¹å¼1ä¸‹çš„æ§åˆ¶çº¿ Bå£ï¼šæ–¹å¼0æˆ–æ–¹å¼1 8255çš„æ–¹å¼æ§åˆ¶å­—åŠçŠ¶æ€å­— æ§åˆ¶å­— çŠ¶æ€å­— 8255çš„å¯»å€åŠè¿æ¥ä½¿ç”¨ 8255çš„åˆå§‹åŒ–åŠåº”ç”¨ä¸¾ä¾‹ æ–¹å¼0â€”â€”æ‰“å°æœºæ¥å£ æ–¹å¼1â€”â€”æ‰“å°æœºæ¥å£ ç¨‹åºæŸ¥è¯¢æ–¹å¼ ä¸­æ–­æ–¹å¼ å¯ç¼–ç¨‹å®šæ—¶å™¨8253 å·¥ä½œæ–¹å¼ æ–¹å¼0ï¼šè®¡æ•°ç»“æŸäº§ç”Ÿä¸­æ–­ æ–¹å¼1ï¼šå¯ç¼–ç¨‹å•ç¨³ æ–¹å¼2ï¼šé¢‘ç‡å‘ç”Ÿå™¨ æ–¹å¼3ï¼šæ–¹æ³¢å‘ç”Ÿå™¨ æ–¹å¼4ï¼šè½¯ä»¶è§¦å‘é€‰é€š æ–¹å¼5ï¼šç¡¬ä»¶è§¦å‘é€‰é€š 8253çš„æ§åˆ¶å­— ä¹ é¢˜ 7.1 è‹¥8253èŠ¯ç‰‡å¯åˆ©ç”¨8088çš„å¤–è®¾æ¥å£åœ°å€ä¸ºD0D0Hï½D0D3Hï¼Œè¯•ç”»å‡ºç”µè·¯è¿æ¥å›¾ã€‚è®¾åŠ åˆ°8253ä¸Šçš„æ—¶é’Ÿä¿¡å·ä¸º2MHzã€‚ è‹¥åˆ©ç”¨è®¡æ•°å™¨0ã€1å’Œ2äº§ç”Ÿå‘¨æœŸä¸º100Î¼sçš„å¯¹ç§°æ–¹æ³¢ä»¥åŠæ¯1sã€10säº§ç”Ÿä¸€ä¸ªè´Ÿè„‰å†²ï¼Œè¯•è¯´æ˜8253å¦‚ä½•è¿æ¥ï¼Œå¹¶ç¼–å†™åˆå§‹åŒ–ç¨‹åºã€‚ 7.2 è‹¥8255èŠ¯ç‰‡å¯å ç”¨çš„åœ°å€ä¸ºFE00ï½FEFFHï¼Œè¯•ç”»å‡ºå®ƒä¸8086æ€»çº¿çš„è¿æ¥å›¾ã€‚ A/Då˜æ¢å™¨çš„å¼•çº¿åŠå·¥ä½œæ—¶åºå›¾å¦‚ä¸‹ï¼Œè¯•å°†æ­¤A/Då˜æ¢å™¨ä¸8255ç›¸è¿æ¥ï¼Œå¹¶ç¼–å†™åŒ…æ‹¬åˆå§‹åŒ–ç¨‹åºåœ¨å†…çš„ã€å˜æ¢ä¸€æ¬¡æ•°æ®å¹¶å°†æ•°æ®æ”¾åœ¨DATAä¸­çš„ç¨‹åº 7.3 è¯´æ˜8253çš„6ç§å·¥ä½œæ–¹å¼ã€‚è‹¥å¦‚åŠ åˆ°8235ä¸Šçš„æ—¶é’Ÿé¢‘ç‡ä¸º0.5MHzï¼Œåˆ™ä¸€ä¸ªè®¡æ•°å™¨çš„æœ€é•¿å®šæ—¶æ—¶é—´æ˜¯å¤šå°‘ï¼Ÿè‹¥è¦æ±‚ç¾10minäº§ç”Ÿä¸€æ¬¡å®šæ—¶ä¸­æ–­ï¼Œè¯•æå‡ºè§£å†³æ–¹æ¡ˆ\næ–¹å¼0ï¼šè®¡æ•°ç»“æŸä¸­æ–­ï¼Œè¾“å‡ºä¸€ä¸ªæ­£è·³å˜ æ–¹å¼1ï¼šç¡¬ä»¶å¯é‡å¤è§¦å‘çš„å•ç¨³æ€è§¦å‘å™¨ï¼Œè¾“å‡ºä¸€ä¸ªå®½åº¦å¯è°ƒçš„è´Ÿè„‰å†² æ–¹å¼2ï¼šæ¯”ç‡å‘ç”Ÿå™¨ï¼Œè¾“å‡ºåºåˆ—è´Ÿè„‰å†² æ–¹å¼3ï¼šæ–¹æ³¢å‘ç”Ÿå™¨ æ–¹å¼4ï¼šè½¯ä»¶è§¦å‘å»¶æ—¶é€‰é€šè„‰å†²å‘ç”Ÿå™¨ æ–¹å¼5ï¼šç¡¬ä»¶è§¦å‘å»¶æ—¶é€‰é€šè„‰å†²å‘ç”Ÿå™¨ åŠ åˆ°8253ä¸Šçš„æ—¶é’Ÿé¢‘ç‡æ˜¯0.5MHzï¼Œåˆ™ä¸€ä¸ªè®¡æ•°å™¨çš„æœ€é•¿å®šæ—¶æ—¶é—´æ˜¯$\\frac {65536} {0.5\\times 10^6}=0.131072 s$ï¼ˆåˆå€¼ä¸º0ï¼‰\nè®¡æ•°å™¨0å’Œè®¡æ•°å™¨1éƒ½å·¥ä½œäºæ–¹å¼3ï¼ˆå¾ªç¯è®¡æ•°ï¼Œäº§ç”Ÿå‘¨æœŸæ€§æ–¹æ³¢ï¼‰ï¼Œä¸¤ä¸ªè®¡æ•°å™¨ä¸²è”ï¼Œè®¡æ•°å™¨0çš„è¾“å‡ºä½œä¸ºè®¡æ•°å™¨1çš„æ—¶é’Ÿï¼Œè®¡æ•°å™¨1çš„è¾“å‡ºä½œä¸ºcpuä¸­æ–­ä¿¡å·ç”¨äºäº§ç”Ÿå®šæ—¶ä¸­æ–­ã€‚è®¾è®¡æ•°å™¨0çš„è®¡æ•°å€¼=30000ï¼Œè®¡æ•°å™¨1çš„è®¡æ•°å€¼=10000ï¼Œåˆ™æ¯è®¡æ•°30000Ã—10000=3Ã—1e8æ¬¡ï¼Œä¹Ÿå³æ¯2Î¼sÃ—3Ã—108=600s=10min äº§ç”Ÿä¸€æ¬¡å®šæ—¶ä¸­æ–­\nåŸºäºæ€»çº¿çš„I/Oæ¥å£è®¾è®¡ åŸºäºISAæ€»çº¿çš„I/Oæ¥å£è®¾è®¡ LEDæ¥å£ æ¥å£ç”µè·¯ ç”¨é€šç”¨å¹¶è¡Œæ¥å£èŠ¯ç‰‡ä½œæ¥å£ ç”¨LEDè¯‘ç å™¨ä½œæ¥å£ï¼šDM9368 åˆ©ç”¨ä¸Šå›¾ç”µè·¯ä¸­çš„4ä¸ªæ•°ç ç®¡ï¼Œå®ç°å°†å­˜å‚¨å•å…ƒ BUFä¸­çš„4ä½åå…­è¿›åˆ¶æ•°åŠ ä»¥æ˜¾ç¤ºï¼Œå¹¶æ¯ç»è¿‡1ç§’ï¼Œé‡æ–°è¯»å–BUFå•å…ƒæ•°æ®ï¼Œæ›´æ–°æ˜¾ç¤ºï¼Œåˆ™æ§åˆ¶ç¨‹åºå¦‚ä¸‹ï¼š åŠ¨æ€æ˜¾ç¤ºçš„æ¥å£ç”µè·¯ ç”¨é€šç”¨æ¥å£èŠ¯ç‰‡ ç”¨ä¸“ç”¨æ¥å£èŠ¯ç‰‡ï¼šMM74C912/917 é”®ç›˜æ¥å£ éç¼–ç å¼é”®ç›˜ ","permalink":"https://fffzlfk.github.io/posts/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/","summary":"è¥¿ç”µå¾®æœºåŸç†","title":"å¾®æœºåŸç†"},{"content":"å¤åˆ¶æ„é€ å‡½æ•° ğŸ’»ç¬”è€…åœ¨å­¦ä¹ OOPæ—¶ï¼Œçœ‹åˆ°ä¸€ä¸ªè®²C++å¤åˆ¶æ„é€ å‡½æ•°åœ¨ä»€ä¹ˆæƒ…å†µä¸‹ä¼šæ‰§è¡Œçš„ä»£ç ç‰‡æ®µï¼Œå¦‚ä¸‹ï¼š\nclass Student { public: Student(){}; Student returnS(Student s) { return s; } Student(const Student \u0026amp;e) { cout \u0026lt;\u0026lt; \u0026#34;Copy Constructure\\n\u0026#34;; } ~Student() { cout \u0026lt;\u0026lt; \u0026#34;Destructure\\n\u0026#34;; } }; int main() { Student stu1; stu1.returnS(stu1); return 0; } äºæ˜¯ä¹ï¼Œç¬”è€…åœ¨ç”µè„‘ä¸Šæ•²äº†ä¸€è¾¹ï¼Œç¡®å®æŒ‰ç…§é¢„æœŸå¤åˆ¶æ„é€ å‡½æ•°æ‰§è¡Œäº†ä¸¤æ¬¡ï¼Œç¬¬ä¸€æ¬¡åœ¨æ„é€ å½¢å‚å¯¹è±¡æ—¶æ‰§è¡Œï¼Œç¬¬äºŒæ¬¡åœ¨è¿”å›å€¼å¤åˆ¶åˆ°ä¸»å‡½æ•°äº§ç”Ÿä¸´æ—¶å¯¹è±¡æ—¶æ‰§è¡Œã€‚\næ¥ç€ç¬”è€…å°†ä¸»å‡½æ•°ä¿®æ”¹ä¸º\nint main() { Student stu1; Student stu2 = stu1.returnS(stu1); return 0; } å¿ƒæƒ³ï¼šä¸å‡ºæ„å¤–åœ¨æ„é€ stu2æ—¶ï¼Œä¼šå†æ‰§è¡Œä¸€æ¬¡å¤åˆ¶æ„é€ å‡½æ•°ï¼Œç„¶è€Œå½“ç¬”è€…çœ‹åˆ°è¿è¡Œç»“æœåï¼Œå‘ç°å¹¶éå¦‚æ­¤ï¼Œå¤åˆ¶æ„é€ å‡½æ•°è¿˜æ˜¯æ‰§è¡Œäº†ä¸¤æ¬¡ï¼Œäºæ˜¯ç¬”è€…é™·å…¥äº†å¤§æ€è€ƒã€‚\næƒ³åˆ°å¯èƒ½æ˜¯èªæ˜çš„ç¼–è¯‘å™¨æ˜¯ä¸æ˜¯å¸®æˆ‘ä¼˜åŒ–æ‰äº†ä¸´æ—¶å¯¹è±¡ï¼Œç›´æ¥å¤åˆ¶æ„é€ äº†stu2ã€‚å¯¼è‡´äº†ä¸Šé¢çš„ä»£ç ç»è¿‡ä¼˜åŒ–ä¹‹åå’Œè¿™æ ·å†™å…¶å®æ˜¯ä¸€æ ·çš„ï¼š\nint main() { Student stu1; Student \u0026amp;\u0026amp;stu2 = stu1.returnS(stu1); return 0; } å³å€¼å¼•ç”¨\nC++ä¸­ï¼Œå¼•ç”¨ï¼ˆreferenceï¼‰æ˜¯æŒ‡ç»‘å®šåˆ°å†…å­˜ä¸­çš„ç›¸åº”å¯¹è±¡ä¸Šã€‚å·¦å€¼å¼•ç”¨æ˜¯ç»‘å®šåˆ°å·¦å€¼å¯¹è±¡ä¸Šï¼›å³å€¼å¼•ç”¨æ˜¯ç»‘å®šåˆ°ä¸´æ—¶å¯¹è±¡ä¸Šã€‚è¿™é‡Œçš„å·¦å€¼å¯¹è±¡æ˜¯æŒ‡å¯ä»¥é€šè¿‡å–åœ°å€\u0026amp;è¿ç®—ç¬¦å¾—åˆ°è¯¥å¯¹è±¡çš„å†…å­˜åœ°å€ï¼›è€Œä¸´æ—¶å¯¹è±¡æ˜¯ä¸èƒ½ç”¨å–åœ°å€\u0026amp;è¿ç®—ç¬¦è·å–åˆ°å¯¹è±¡çš„å†…å­˜åœ°å€ã€‚\näºæ˜¯ç»è¿‡å‡ ç•ªæœç´¢ï¼Œæ‰¾åˆ°äº†è¿™ä¸ªä¸œè¥¿ï¼š\n-fno-elide-constructors\nThe C++ standard allows an implementation to omit creating a temporary that is only used to initialize another object of the same type. Specifying this option disables that optimization, and forces G++ to call the copy constructor in all cases.\næœç„¶ä¸å‡ºæ‰€æ–™ï¼Œå½“ç¬”è€…åŠ ä¸Šè¿™ä¸ªå‚æ•°ä¹‹å\ng++ test_ref.cpp -o test -fno-elide-constructors ä¸€åˆ‡éƒ½å¯¹åŠ²äº†èµ·æ¥ğŸ˜„ï¼\nç§»åŠ¨æ„é€ å‡½æ•° ä½¿ç”¨ç§»åŠ¨æ„é€ å‡½æ•°å¯ä»¥æé«˜å†…å­˜èµ„æºçš„åˆ©ç”¨æ•ˆç‡ï¼Œä»è€Œæ”¹è¿›ç¨‹åºçš„æ‰§è¡Œæ€§èƒ½ã€‚\nç¤ºä¾‹ç¨‹åº\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class A { public: int *i; A(int _i) : i(new int(_i)) { cout \u0026lt;\u0026lt; \u0026#34;A(int) \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ~A() { cout \u0026lt;\u0026lt; \u0026#34;delete pointer: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; delete i; } // å¤åˆ¶æ„é€ å‡½æ•° A(const A \u0026amp;a) : i(new int(*a.i)) { cout \u0026lt;\u0026lt; \u0026#34;A(const A\u0026amp;) \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } // ç§»åŠ¨æ„é€ å‡½æ•° A(A \u0026amp;\u0026amp;a) : i(new int(*a.i)) { cout \u0026lt;\u0026lt; \u0026#34;A(const A\u0026amp;\u0026amp;) \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; a.i = nullptr; } }; A getA(A para) { A tmp(2); cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; tmp.i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return tmp; } int main() { A a(1); A b = getA(a); cout \u0026lt;\u0026lt; a.i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } è¿è¡Œç»“æœ\nA(int) 0x8016eb0 æ„é€ aå¯¹è±¡\rA(const A\u0026amp;) 0x80172e0 å‚æ•°å¤åˆ¶æ„é€ para\rA(int) 0x8017300 æ„é€ tmpå¯¹è±¡\r0x8017300\rA(const A\u0026amp;\u0026amp;) 0x8017320 è°ƒç”¨ç§»åŠ¨æ„é€ å‡½æ•°(ä¸´æ—¶å¯¹è±¡æ„é€ è¿”å›å€¼)\rdelete pointer: 0 ææ„ä¸´æ—¶å¯¹è±¡\rA(const A\u0026amp;\u0026amp;) 0x8017340 è°ƒç”¨ç§»åŠ¨æ„é€ å‡½æ•°(è¿”å›å€¼ç§»åŠ¨åˆ°bå¯¹è±¡)\rdelete pointer: 0 ææ„ä¸´æ—¶å¯¹è±¡(æŒ‡è¿”å›å€¼)\rdelete pointer: 0x80172e0 ææ„å‡½æ•°para\r0x8016eb0 delete pointer: 0x8017340 ææ„bå¯¹è±¡\rdelete pointer: 0x8016eb0 ææ„aå¯¹è±¡ ","permalink":"https://fffzlfk.github.io/posts/c++%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E6%9E%90/","summary":"å…³é—­ç¼–è¯‘å™¨ä¼˜åŒ–","title":"C++(ä¸´æ—¶å¯¹è±¡çš„åˆ†æ)"},{"content":"Union-Find quickfind Java implementation public class QuickFindUF { private int[] id; private int count; public QuickFindUF(int n) { id = new int[n]; for (int i = 0; i \u0026lt; n; i++) id[i] = i; count = n; } public int count() { return count; } public int find(int p) { return id[p]; } public boolean connected(int p, int q) { return find(p) == find(q); } public void union(int p, int q) { int pid = find(p); int qid = find(q); if (pid != qid) { for (int i = 0; i \u0026lt; id.length; i++) if (id[i] == pid) { id[i] = qid; } } count--; } public static void main(String[] args) { Scanner in = new Scanner(System.in); QuickFindUF uf = new QuickFindUF(10); while (in.hasNext()) { int p = in.nextInt(), q = in.nextInt(); if (uf.connected(p, q)) continue; uf.union(p, q); } } } analysis The find() operation is certainly quick, as it only accesses the id[] array once in order to complete the operation. But quick-find is typically not useful for large problems because union() needs to scan through the whole id[] array for each input pair.\nquick-union implementation import java.util.Scanner; public class QuickUnionUF { private int[] id; private int count; public QuickUnionUF(int n) { id = new int[n]; for (int i = 0; i \u0026lt; n; i++) id[i] = i; count = n; } public int count() { return count; } public int find(int p) { while (p != id[p]) { p = id[p]; } return p; } public boolean connected(int p, int q) { return find(p) == find(q); } public void union(int p, int q) { int pRoot = find(p); int qRoot = find(q); if (pRoot != qRoot) { id[pRoot] = qRoot; } else return; count--; } public static void main(String[] args) { Scanner in = new Scanner(System.in); QuickUnionUF uf = new QuickUnionUF(10); while (in.hasNext()) { int p = in.nextInt(), q = in.nextInt(); if (uf.connected(p, q)) continue; uf.union(p, q); } } } quick-union worst case Weighted quick-union import java.util.Scanner; public class WeightedQuickUnionUF { private int[] id; private int[] sz; private int count; public WeightedQuickUnionUF(int N) { count = N; id = new int[N]; sz = new int[N]; for (int i = 0; i \u0026lt; N; i++) { id[i] = i; } for (int i = 0; i \u0026lt; N; i++) sz[i] = 1; } public int find(int p) { while (p != id[p]) { id[p] = id[id[p]]; // path compression by halving p = id[p]; } return p; } public boolean connected(int p, int q) { return find(p) == find(q); } public void union(int p, int q) { int i = find(p); int j = find(q); if (i == j) return; if (sz[i] \u0026lt; sz[j]) { id[i] = j; sz[j] += sz[i]; } else { id[j] = i; sz[i] += sz[j]; } count--; } public static void main(String[] args) { Scanner in = new Scanner(System.in); WeightedQuickUnionUF uf = new WeightedQuickUnionUF(10); while (in.hasNext()) { int p = in.nextInt(), q = in.nextInt(); if (uf.connected(p, q)) continue; uf.union(p, q); } } } Performance characteristics of union-find algorithms algorithm constructor union find quick-find N N 1 quick-union N tree height tree height weighted quick-union N lgN lgN weighted quick-union with path compression N very, very nearly, but not quite 1 same as union impossible N 1 1 Analysis of Algorithms Scientific method The very same approach that scientists use to understand the natural world is effective for studying the running time of programs.\nObserve some feature of the natural world, generally with precise measurement. Hypothesize a model that is consistent with observations. Predict events using the hypothesis. Verify the predictions by making further observations. Valitate by repeating until the hypothesis and observations agree. Mathematical models Tilde approximations. We use tilde approximations, where we throw away low-order terms that complicate formulas. We write ~f(N) to represent any function that when divided by f(N) approaches 1 as N grows. We write g(N)~f(N) to indicate that g(N)/f(N) approaches 1 as N grows. Order-of-growth classifications. Most often, we work with tilde approximations of the form g(N)~af(N) where $ f(N) = N^b log_c N $ and refer to f(N) as the The order of growth of g(N). We use just a few structural primitives (statements, conditionals, loops, nesting, and method calls) to implement algorithms, so very often the order of growth of the cost is one of just a few functions of the problem size N. function tilde approximation order of growth $ \\frac{N^3}{6}-\\frac{N^2}{2}+\\frac N 3 $ $~\\frac{N^3}{6} $ $N^3$ $ \\frac{N^3}{2}-\\frac N 2$ $ ~\\frac{N^2}{2} $ $N^2$ $lgN+1 $ $~lgN$ $lgN$ 3 ~3 1 Cost model. We focus attention on properties of algorithms by articulating a cost model that defines the basic operations. For example, an appropriate cost model for the 3-sum problem is the number of times we access an array entry, for read or write. Commonly-used Notations in the Theory of Algorithms notation provides example shorthand for used to Big Theta asympatotic order of growth $ \\Theta (N^2) $ $\\frac 1 2 N^2, 5N^2+22NlogN+3N$ classify algorithms Big Oh $\\Theta (N^2)$and smaller $O(N^2)$ $10N^2,\\ 100N, 22NlogN+3N $ develop upper bounds Big Omega $\\Theta (N^2)$and larger $\\Omega (N^2)$ $\\frac 1 2 N^2, N^5, N^3+22NlogN+3N $ develop lower bounds 1.4.6 Give the order of growth (as a function of N ) of the running times of each of the following code fragments:\nint sum = 0; for (int n = N; n \u0026gt; 0; n /= 2) for(int i = 0; i \u0026lt; n; i++) sum++; $$ N+\\frac N 2+\\frac N 4+\\frac N 8+\u0026hellip;+1=2N-1\\ \\ \\sim 2N $$ æ‰€ä»¥æ˜¯çº¿æ€§\nint sum = 0; for (int i = 1 i \u0026lt; N; i *= 2) for (int j = 0; j \u0026lt; i; j++) sum++; $$ 1+2+4+8+\u0026hellip;+2^{\\lfloor lgN \\rfloor}=2^{\\lfloor lgN \\rfloor + 1}-1\\ \\ \\sim 2N$$ æ‰€ä»¥æ˜¯çº¿æ€§\nint sum = 0; for (int i = 1 i \u0026lt; N; i *= 2) for (int j = 0; j \u0026lt; N; j++) sum++; $$ NlgN $$ çº¿æ€§å¯¹æ•°\n1.4.15 Faster 3-sum. As a warmup, develop an implementation TwoSumFaster that uses a linear algorithm to count the pairs that sum to zero after the array is sorted (in stead of the binary-search-based linearithmic algorithm). Then apply a similar idea to develop a quadratic algorithm for the 3-sum problem.\npublic static int twoSumFaster(int[] a) { int lo = 0, hi = a.length - 1; int cnt = 0; while (lo \u0026lt; hi) { if (a[lo] + a[hi] == 0) { cnt++; lo++; hi--; } else if (a[lo] + a[hi] \u0026gt; 0) hi--; else lo++; } return cnt; } public static int threeSumFaster(int[] a) { int cnt = 0; for (int i = 0; i \u0026lt; a.length; i++) { int lo = i + 1, hi = a.length - 1; while (lo \u0026lt; hi) { if (a[i] + a[lo] + a[hi] == 0) { cnt++; lo++; hi--; } else if (a[i] + a[lo] + a[hi] \u0026gt; 0) hi--; else lo++; } } return cnt; } MegerSort Implementation public class Merge { private static boolean isSorted(Comparable[] a, int lo, int hi) { for (int i = lo + 1; i \u0026lt;= hi; i++) if (less(a[i], a[i - 1])) return false; return true; } private static boolean less(Comparable v, Comparable w) { return v.compareTo(w) \u0026lt; 0; } private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) { assert isSorted(a, lo, mid); assert isSorted(a, mid + 1, hi); for (int k = lo; k \u0026lt;= hi; k++) aux[k] = a[k]; int i = lo, j = mid + 1; for (int k = lo; k \u0026lt;= hi; k++) { if (i \u0026gt; mid) a[k] = aux[j++]; else if (j \u0026gt; hi) a[k] = aux[i++]; else if (less(aux[j], aux[i])) a[k] = aux[j++]; else a[k] = aux[i++]; } assert isSorted(a, lo, hi); } private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) { if (hi \u0026lt;= lo) return; int mid = lo + (hi - lo) / 2; sort(aux, a, lo, mid); sort(aux, a, mid+1, hi); merge(a, aux, lo, mid, hi); } public static void sort(Comparable[] a) { Comparable[] aux = new Comparable[a.length]; sort(a, aux, 0, a.length - 1); } public static void main(String[] args) { int N = StdIn.readInt(); Comparable[] a = new Comparable[N]; for (int i = 0; i \u0026lt; N; i++) a[i] = StdRandom.uniform(-10000,10000); Stopwatch stopwatch = new Stopwatch(); sort(a); for (var i : a) { System.out.print(i + \u0026#34; \u0026#34;); } System.out.println(); System.out.println(stopwatch.elapsedTime()); } } Empirical analysis The number of compares $C(N)$ and array accesses $A(N)$ to mergesort an array of size N satisfy the recurrences:\n$$ C(N) \\le C(\\lceil{\\frac N 2}\\rceil) + C(\\lfloor{\\frac N 2}\\rfloor) + N\\ \\ for N \u0026gt; 1,with \\ C(1)=0. $$ $$ A(N) \\le A(\\lceil{\\frac N 2}\\rceil) + A(\\lfloor{\\frac N 2}\\rfloor) + 6N\\ \\ for N \u0026gt; 1,with \\ A(1)=0. $$ we solve the recurrence when $ N $ is a power of 2. $$ D(N) = 2D(\\frac N 2) + N, for N \u0026gt; 1, with\\ D(1) = 0. $$\nDivide-and-conquer recurrence: proof by picture\nproof by expansion\n$$ \\begin{aligned} D(N)\u0026amp;=2D(N/2)+N \\cr {D(N)} /{N} \u0026amp;= 2D(N / 2)/N + 1\\cr \u0026amp;= D(N/2)/(N/2)+1 \\cr \u0026amp;= D(N/4)/(N/4) + 1 + 1\\cr \u0026amp;= D(N/8)/(N/8) + 1 + 1 + 1\\cr \u0026hellip;\\cr \u0026amp;= D(N/N)/(N/N)+1+1+\u0026hellip;+1\\cr \u0026amp;= lgN \\end{aligned} $$\nproof by induction\nBase case: $N = 1$ Induction hypothesis: $D(N)=Nlg(N)$. Goal: showthat $ D(2N) = (2N)lg(2N).$ $$ \\begin{aligned} D(2N) \u0026amp;= 2D(N)+2N \\cr \u0026amp;= 2NlgN+2N \\cr \u0026amp;= 2N(lgN+1) \\cr \u0026amp;= 2Nlg(2N) \\end{aligned} $$\npractical improvements private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) { // Use insertion sort for samll subarrays. final int CUTOFF = 7; if (hi \u0026lt;= lo + CUTOFF - 1) { Insertion.sort(a, lo, hi); return; } int mid = lo + (hi - lo) / 2; sort(a, aux, lo, mid); sort(a, aux, mid + 1, hi); // Stop if already sorted. if (!less(a[mid+1], a[mid])) return; merge(a, aux, lo, mid, hi); } Eliminate the copy to the auxiliary array.\nprivate static void merge(Comparable[] a,Comparable[] aux, int lo, int mid, int hi) { int i = lo, j = mid + 1; for (int k = lo; k \u0026lt;= hi; k++) { if (i \u0026gt; mid) aux[k] = a[j++]; else if (j \u0026gt; hi) aux[k] = a[i++]; else if (less(a[j], a[i])) aux[k] =a[j++]; else aux[k] = a[i++]; } } private static void sort(Comparable[] a,Comparable[] aux, int lo, int hi) { if (hi \u0026lt;= lo) return; int mid = lo + (hi - lo) / 2; //switch soles of aux[] and a[] sort(aux, a, lo, mid); sort(aux, a, mid+1, hi); merge(a, aux, lo, mid, hi); } Bottom-up mergesort Implementation private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) { for (int k = lo; k \u0026lt;= hi; k++) aux[k] = a[k]; int i = lo, j = mid + 1; for (int k = lo; k \u0026lt;= hi; k++) { if (i \u0026gt; mid) a[k] = aux[j++]; else if (j \u0026gt; hi) a[k] = aux[i++]; else if (less(aux[j], aux[i])) a[k]= aux[j++]; else a[k] = aux[i++]; } } public static void sort(Comparable[] a) { int N = a.length; Comparable[] aux = new Comparable[N]; for (int sz = 1; sz \u0026lt; N; sz = sz + sz) for (int lo = 0; lo \u0026lt; N - sz; lo +=sz + sz) merge(a, aux, lo, lo + sz -1,Math.min(lo+sz+sz-1, N-1)); } public static void main(String[] args) { int N = StdIn.readInt(); Comparable[] a = new Comparable[N]; for (int i = 0; i \u0026lt; N; i++) a[i] = StdRandom.uniform(-1000010000); Stopwatch stopwatch = new Stopwatch(); sort(a); for (var i : a) { System.out.print(i + \u0026#34; \u0026#34;); } System.out.println(); System.out.println(stopwatch.elapsedTim()); } Sorting Complexity Model of computation: decision tree. Cost model: # compares. Upper bound: $\\sim NlgN $from mergesort Lower bound: ? Optimal algorithm: ? Compare-based lower bound for sorting Proposition. Any Compare-based sorting algorothm must use at least $lg(N!)\\sim NlogN $(Stirling formula) compares in the worst-case.\nPf.\nAssume array consists of $N$ distinct values $a_1$ through $ a_n $. Worst case dictated by height $h$ of decision tree. Binary tree of height $h$ has at most $2^h$ leaves. $N! $different orderings $\\Rightarrow$ at least $ N!$ leaves. $$ \\begin{aligned} 2^h \\ge ï¼ƒleaves \\ge N! \\cr \\Rightarrow h \\ge lg(N!)\\sim NlgN \\end{aligned}$$\nStability Insertion sort is stable: Equal items never move fast each other. private static void insertionSort(Comparable[] a) { int N = a.length; for (int i = 0; i \u0026lt; N; i++) { for (int j = i; j \u0026gt; 0 \u0026amp;\u0026amp; less(a[j], a[j - 1]); j--) exch(a, j, j - 1); } } Selection sort is not stable: Long-distance exchange might move an item past some equal item. private static void selectionSort(Comparable[] a) { int N = a.length; for (int i = 0; i \u0026lt; N; i++) { int min = i; for (int j = i + 1; j \u0026lt; N; j++) if (less(a[j], a[min])) min = j; exch(a, i, min); } } Shellsort is not stable: Long-distence exchange. private static void shellSort(Comparable[] a) { int N = a.length; int h = 1; while (h \u0026lt; N / 3) h = 3 * h + 1; while (h \u0026gt;= 1) { for (int i = h; i \u0026lt; N; i++) { for (int j = i; j \u0026gt; h \u0026amp;\u0026amp; less(a[j], a[j - h]); j -= h) exch(a, j, j - h); } h /= 3; } } Mergesort is stable.: Suffices to verify that merge operation is table. 2.2.2 Give traces, in the style of the trace given with Algorithm 2.4, showing how the keys E A S Y Q U E S T I O N are sorted with top-down mergesort.\na[] lo mid hi 0 1 2 3 4 5 6 7 8 9 10 11 E A S Y Q U E S T I O N 0 0 1 A E S Y Q U E S T I O N 0 1 2 A E S Y Q U E S T I O N 3 3 4 A E S Q Y U E S T I O N 3 4 5 A E S Q U Y E S T I O N 0 2 5 A E Q S U Y E S T I O N 6 6 7 A E Q S U Y E S T I O N 6 7 8 A E Q S U Y E S T I O N 9 9 10 A E Q S U Y E S T I O N 9 10 11 A E Q S U Y E S T I N O 6 8 11 A E Q S U Y E I N O S T 0 5 11 A E E I N O Q S S T U Y A E E I N O Q S S T U Y 2.2.3 Answer Exercise 2.2.2 for bottom-up mergesort.\na[] lo mid hi 0 1 2 3 4 5 6 7 8 9 10 11 E A S Y Q U E S T I O N 0 0 1 A E S Y Q U E S T I O N 2 2 3 A E S Y Q U E S T I O N 4 4 5 A E S Y Q U E S T I O N 6 6 7 A E S Y Q U E S T I O N 8 8 9 A E S Y Q U E S I T O N 10 10 11 A E S Y Q U E S I T N O 0 1 3 A E S Y Q U E S I T N O 4 5 7 A E S Y E Q S U I T N O 8 9 11 A E S Y E Q S U I N O T 0 3 7 A E E Q S S U Y I N O T 0 7 11 A E E I N O Q S S T U Y A E E I N O Q S S T U Y 2.2.4 Does the abstract in-place merge produce proper output if and only if the two input subarrays are in sorted order? Prove your answer, or provide a counterexample.(æ˜¯å¦å½“ä¸”ä»…å½“ä¸¤ä¸ªè¾“å…¥çš„æ•°ç»„éƒ½æœ‰åºæ—¶åŸåœ°å½’å¹¶çš„æŠ½è±¡æ–¹æ³•æ‰èƒ½å¾—åˆ°æ­£ç¡®çš„ç»“æœï¼Ÿè¯æ˜ä½ çš„ç»“è®ºï¼Œæˆ–è€…ç»™å‡ºä¸€ä¸ªåä¾‹ã€‚)\næ˜¯çš„ï¼Œåªæœ‰å½“ä¸¤ä¸ªè¾“å…¥æ•°ç»„éƒ½æœ‰åºæ—¶é‡‡ç”¨åŸåœ°å½’å¹¶æ‰èƒ½å¾—åˆ°æ­£ç¡®çš„ç»“æœã€‚ åä¾‹ï¼šæ•°ç»„1ï¼š[4, 2, 3],æ•°ç»„2ï¼š[1, 5, 8];\næŒ‰å½’å¹¶ç®—æ³•å½’å¹¶åå¾—åˆ°[1,4,2,3,5,8]; å¯ä»¥çœ‹åˆ°å½’å¹¶åå…ƒç´ çš„ç›¸å¯¹ä½ç½®ä¸å˜ï¼Œæ•…å¾—åˆ°é”™è¯¯çš„ç»“æœã€‚ 2.2.5 Give the sequence of subarray sizes in the merges performed by both the top-down and the bottom-up mergesort algorithms, for N = 39. (å½“è¾“å…¥æ•°ç»„çš„å¤§å°N=39æ—¶ï¼Œç»™å‡ºè‡ªé¡¶å‘ä¸‹å’Œè‡ªåº•å‘ä¸Šçš„å½’å¹¶æ’åºä¸­å„å½’å¹¶å­æ•°ç»„çš„å¤§å°åŠé¡ºåºã€‚)\nè‡ªé¡¶å‘ä¸‹ 2, 3, 2, 5, 2, 3, 2, 5, 10, 2, 3, 2, 5, 2, 3, 2, 5, 10, 20, 2, 3, 2, 5, 2, 3, 2, 5, 10, 2, 3, 2, 5, 2, 2, 4, 9, 19, 39\nè‡ªåº•å‘ä¸Š 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 8, 8, 8, 8, 7, 16, 16, 32, 39\nQuickSort quicksort Basic plan:\nShuffle the array Partition so that, for some j entry a[j] in place no larger entry to the left of j no smaller entry to the right of j Sort each piece recursively. Java implementation public class Quick { private static boolean less(Comparable v, Comparable w) { return v.compareTo(w) \u0026lt; 0; } private static void exch(Comparable[] a, int i, int j) { Comparable t = a[i]; a[i] = a[j]; a[j] = t; } private static int partition(Comparable[] a, int lo, int hi) { int i = lo, j = hi + 1; while (true) { while (less(a[++i], a[lo])) if (i == hi) break; while (less(a[lo], a[--j])) if (j == lo) break; if (i \u0026gt;= j) break; exch(a, i, j); } exch(a, lo, j); return j; } private static void sort(Comparable[] a) { StdRandom.shuffle(a); sort(a, 0, a.length - 1); } private static void sort(Comparable[] a, int lo, int hi) { if (lo \u0026gt;= hi) return; int j = partition(a, lo, hi); sort(a, lo, j - 1); sort(a, j + 1, hi); } } average-case analysis $C_N $ satisfies the recurrence $C_0 = C_1=0$ and for $ N\\ge 2 $:\n$$ C_N = (N + 1) + (\\frac{C_0+C_{N-1}}{N})+ (\\frac{C_1+C_{N-2}}{N})+ \u0026hellip; +(\\frac{C_{N-1}+C_{0{N}}}) $$\nMultiply both sides by N and collect terms: $$ NC_N = N(N+1)+2(C_0+C_1+\u0026hellip;+C_{N-1}) $$\nSubstract this from the same equation for $N - 1$: $$ NC_N-(N-1)C_{N-1}=2N+2C_{N-1} $$\nRearrage terms and devide by $N(N+1)$: $$ \\frac{C_N}{N+1} = \\frac{C_{N-1{N}}} + \\frac{2}{N+1} $$\nRepeatedly apply above equation: $$ \\begin{aligned} \\frac{C_N}{N+1} \u0026amp;= \\frac{C_{N-1}}{N}+\\frac{2}{N+1} \\cr \u0026amp;= \\frac{C_{N-2}}{N-1}+\\frac{2}{N}+\\frac{2}{N+1} \\cr \u0026amp;= \\frac{C_{N-3}}{N-2}+\\frac{2}{N-1}+\\frac{2}{N}+\\frac{2}{N+1} \\cr \u0026amp;= \\frac 2 3 + \\frac 2 4 + \\frac 2 5 +\u0026hellip;+\\frac 2 {N+1} \\end{aligned} $$\nApproximate sum by an integral: $$ \\begin{aligned} C_N \u0026amp;= 2(N+1)(\\frac 1 3 + \\frac 1 4 + \\frac 1 5 +\u0026hellip;+ \\frac{1}{N+1}) \\cr \u0026amp; \\sim 2(N+1) \\int_{3}^{N+1}{\\frac{1}{x}dx} \\end{aligned} $$\nFinally, the desired result: $$ C_N \\sim 2(N+1)lnN \\sim 1.39NlgN $$\n3-way quicksort template \u0026lt;typename T\u0026gt; void threeWayQuickSort(T a[], int lo, int hi) { if (hi \u0026lt;= lo) return; int lt = lo, gt = hi; T v = a[lo]; int i = lo; while (i \u0026lt;= gt) { if (a[i] \u0026lt; v) swap(a[lt++], a[i++]); else if (a[i] \u0026gt; v) swap(a[gt--], a[i]); else i++; } threeWayQuickSort(a, lo, lt - 1); threeWayQuickSort(a, gt + 1, hi); } 2.3.1 Show, in the style of the trace given with partition(), how that method patitions the array E A S Y Q U E S T I O N.\ni j 0 1 2 3 4 5 6 7 8 9 10 11 0 12 E A S Y Q U E S T I O N 2 6 E A S Y Q U E S T I O N 2 6 E A E Y Q U S S T I O N 3 2 E A E Y Q U S S T I O N 2 E A E Y Q U S S T I O N 2.3.2 Show, in the style of the quicksort trace given in this section, how quicksort sorts the array E A S Y Q U E S T I O N (for the purposes of this exercise, ignore the initial shuffle).\n2.3.3 What is the maximum number of times during the execution of Quick.sort() that the largest item can be exchanged, for an array of length N ? (å¯¹äºé•¿åº¦ä¸ºNçš„æ•°ç»„ï¼Œåœ¨Quick.sort()æ‰§è¡Œæ—¶ï¼Œå…¶æœ€å¤§çš„å…ƒç´ æœ€å¤šä¼šè¢«äº¤æ¢å¤šå°‘æ¬¡ï¼Ÿ)\nåœ¨Quick.sort()ä¸­ï¼Œä¸€ä¸ªå…ƒç´ è¢«äº¤æ¢å¯åˆ†ä¸ºä¸¤ç§æƒ…å†µï¼š\nè¯¥å…ƒç´ æ˜¯æ¢è½´ï¼Œåœ¨partitionæœ€åä¸€æ­¥å’Œjäº¤æ¢ è¯¥å…ƒç´ åœ¨æœ¬æ¬¡partitionä¸­ä¸æ˜¯æ¢è½´ï¼Œå‡ºç°åœ¨äº†æ¢è½´é”™çš„ä¸€ä¾§ï¼Œéœ€è¦è¢«äº¤æ¢åˆ°å¦ä¸€ä¾§ å¦‚æœè¯¥å…ƒç´ æ˜¯æ¢è½´ï¼Œé‚£ä¹ˆåœ¨äº¤æ¢åå®ƒçš„ä½ç½®å°±å›ºå®šä¸‹æ¥äº†ï¼Œä¹‹åä¸å†æ¶‰åŠäº¤æ¢ï¼Œå› æ­¤è¦ä½¿äº¤æ¢æ¬¡æ•°æœ€å¤§ï¼Œè¿™ä¸ªå…ƒç´ åº”è¯¥æ˜¯åœ¨æ¯æ¬¡partitionæ—¶éƒ½ä½äºæ¢è½´é”™è¯¯çš„ä¸€ä¾§ï¼Œå› ä¸ºæ˜¯æœ€å¤§çš„å…ƒç´ ï¼Œæ‰€ä»¥åº”è¯¥æ€»æ˜¯åœ¨æ¢è½´çš„å·¦ä¾§ã€‚ ä¸ºäº†ä½¿å¾—partitionçš„æ¬¡æ•°å°½å¯èƒ½çš„å¤šï¼Œéœ€è¦ä½¿å¾—æ¯æ¬¡ç§»åŠ¨çš„è·ç¦»çŸ­ï¼Œè¿™é‡Œæˆ‘ä»¬å…ˆè€ƒè™‘æ¯æ¬¡ç§»åŠ¨ä¸€ä½ï¼Œå¦‚æ•°ç»„[5,9,1,6,7]ï¼š æ¢è½´ä¸º5ï¼Œäº¤æ¢åå˜ä¸º[5,1,9,6,7] æ¢è½´äº¤æ¢ï¼Œå˜ä¸º[1,5,9,6,7] æˆ‘ä»¬å‘ç°åœ¨ä¸‹ä¸€æ¬¡partitionä¸­æœ€å¤§å…ƒç´ 9ä¼šæˆä¸ºæ¢è½´ï¼Œä¸å†è¢«äº¤æ¢ æ‰€ä»¥è€ƒè™‘æ¯æ¬¡ç§»åŠ¨ä¸¤ä½ï¼Œå¦‚æ•°ç»„[2,10,4,1,6,3,8,5,7,9] æ¢è½´ä¸º2ï¼Œäº¤æ¢å[2,1,4,10,6,3,8,5,7,9] æ¢è½´äº¤æ¢ï¼Œå˜ä¸º[1,2,4,10,6,3,8,5,7,9] æ¢è½´ä¸º4ï¼Œäº¤æ¢å[1,2,4,3,6,10,8,5,7,9] æ¢è½´äº¤æ¢ï¼Œå˜ä¸º[1,2,3,4,6,10,8,5,7,9] æ¢è½´ä¸º6ï¼Œäº¤æ¢å[1,2,3,4,6,5,8,10,7,9] æ¢è½´äº¤æ¢ï¼Œå˜ä¸º[1,2,3,4,5,6,8,10,7,9] æ¢è½´ä¸º8ï¼Œäº¤æ¢å[1,2,3,4,5,6,8,7,10,9] æ¢è½´äº¤æ¢ï¼Œå˜ä¸º[1,2,3,4,5,6,7,8,10,9] æ¢è½´ä¸º10ï¼Œäº¤æ¢å[1,2,3,4,5,6,7,8,9,10] åœ¨ä¸Šé¢è¿™ä¸ªN=10çš„æ•°ç»„ä¸­ï¼Œâ€œ10â€è¿™ä¸ªæœ€å¤§çš„å…ƒç´ ä¸€å…±è¢«äº¤æ¢äº†5æ¬¡ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥è®¤ä¸ºå¯¹äºNä¸ªå…ƒç´ çš„æ•°ç»„ï¼Œåœ¨æ‰§è¡ŒQuick.sort()æ—¶æœ€å¤§å…ƒç´ æœ€å¤šä¼šè¢«äº¤æ¢N/2æ¬¡ã€‚ 2.3.4 Suppose that the initial random shuffle is omitted. Give six arrays of ten elements for which Quick.sort() uses the worst-case number of compares.\nå¦‚æœå§‹ç»ˆé€‰ç¬¬ä¸€ä¸ªå…ƒç´ ä½œä¸ºæ¢è½´çš„è¯ï¼Œè¦ä½¿æ¯”è¾ƒæ¬¡æ•°è¾¾åˆ°æœ€åæƒ…å†µçš„è¯ï¼Œè¾“å…¥æ•°ç»„åº”ä¸ºå‡åºã€‚æ¯”è¾ƒæ¬¡æ•°è¾¾åˆ°$ N + N-1 + N-2 + N-3 +\u0026hellip;+1 = \\frac{N(N+1)}{2} \\sim N^2/2 $ ä¾‹å¦‚ï¼š\n[1,2,3,4,5,6,7,8,9,10] [2,4,6,8,10,12,14,16,18,20] [-1,1,3,5,7,9,11,13,15,17] [10,20,30,40,50,60,70,80,90,100] [5,10,15,20,25,30,35,40,45,50] [0,2,3,4,6,7,8,9,10,12] 2.3.5 Give a code fragment that sorts an array that is known to consist of items having just two distinct keys.\nstatic void sort(Comparable[] a) { int lo = 0, hi = a.length - 1; int i = 0; while (i \u0026lt;= hi) { int tmp = a[i].compareTo(a[lo]); if (tmp \u0026lt; 0) exch(a, lo++, i++); else if (tmp \u0026gt; 0) exch(a, i, hi--); else i++; } } Priority Queues API binary-heap Java implementation public class MaxPQ\u0026lt;Key extends Comparable\u0026lt;Key\u0026gt;\u0026gt; { private Key[] pq; private int N = 0; public MaxPQ(int maxN) { pq = (Key[]) new Comparable[maxN + 1]; } public boolean isEmpty() { return N == 0; } public int size() { return N; } public void insert(Key v) { pq[++N] = v; swim(N); } public Key delMax() { Key max = pq[1]; exch(1, N--); sink(1); pq[N+1] = null; return max; } private boolean less(int i, int j) { return pq[i].compareTo(pq[j]) \u0026lt; 0; } private void exch(int i, int j) { Key tmp = pq[i]; pq[i] = pq[j]; pq[j] = tmp; } private void swim(int k) { while (k \u0026gt; 1 \u0026amp;\u0026amp; less(k / 2, k)) { exch(k / 2, k); k /= 2; } } private void sink(int k) { while (2 * k \u0026lt;= N) { int j = 2 * k; if (j \u0026lt; N \u0026amp;\u0026amp; less(j, j + 1)) j++; if (!less(k, j)) break; exch(k, j); k = j; } } } heapsort Basic plan for in-place sort Create max-heap with all N keys. Repatedly remove the maximum key. Java implementation public class Heap { public static void sort(Comparable[] a) { int N = a.length; for (int k = N / 2; k \u0026gt;= 1; k--) sink(a, k, N); while (N \u0026gt; 1) { exch(a, 1, N); sink(a, 1, --N); } } private static boolean less(Comparable a[], int i, int j) { return a[i - 1].compareTo(a[j - 1]) \u0026lt; 0; } private static void exch(Comparable a[], int i, int j) { Comparable t = a[i - 1]; a[i - 1] = a[j - 1]; a[j - 1] = t; } private static void sink(Comparable[] a, int k, int N) { while (2 * k \u0026lt;= N) { int j = 2 * k; if (j \u0026lt; N \u0026amp;\u0026amp; less(a, j, j + 1)) j++; if (!less(a, k, j)) break; exch(a, k, j); k = j; } } } mathematical analysis Proposition. Heap construction uses $ \\le 2N $ compares and exchanges.\nProposition. Heapsort uses $ \\le 2NlgN $ compares and exchanges.\nSignificance. In-place sorting algorithm with $ NlgN $ worst-case.\nMergesort: no, linear extra space. Quicksort: no, quadratic time in worst case. Heapsort: yes! Bottom line. Heapsort is optimal for both time and space but:\nInner loop longer than quicksort\u0026rsquo;s. Makes poor use of cache memory. Not stable. sorting-algorithms: summary 2.4.2 Criticize the following idea: To implement find the maximum in constant time, why not use a stack or a queue, but keep track of the maximum value inserted so far, then return that value for find the maximum?\nå¦‚æœç”¨è¿™ç§æ–¹æ³•ï¼Œå½“æœ€å¤§å…ƒç´ è¢«åˆ é™¤ä¹‹åï¼Œä¸èƒ½åœ¨å¸¸é‡æ—¶é—´å†…æ›´æ–°æœ€å¤§å…ƒç´ \n2.4.3 Provide priority-queue implementations that support insert and remove the maximum, one for each of the following underlying data structures: unordered array, ordered array, unordered linked list, and linked list. Give a table of the worst-case bounds for each operation for each of your four implementations.\næ•°ç»„å®ç° public abstract class ArrayPQ\u0026lt;Key extends Comparable\u0026lt;Key\u0026gt;\u0026gt; { protected Key[] pq; protected int n; public ArrayPQ(int capacity) { pq = (Key[]) new Comparable[capacity]; n = 0; } public boolean isEmpty() {return n == 0;} public int size() {return n;} public abstract void insert(Key x); public abstract Key delMax(); protected boolean less(int i, int j) {return pq[i].compareTo(pq[j]) \u0026lt; 0; } protected void exch(int i, int j) { Key t = pq[i]; pq[i] = pq[j]; pq[j] = t; } public static void main(String[] args) { OrderedArrayMaxPQ pq = new OrderedArrayMaxPQ(10); pq.insert(\u0026#34;this\u0026#34;); pq.insert(\u0026#34;is\u0026#34;); pq.insert(\u0026#34;a\u0026#34;); pq.insert(\u0026#34;test\u0026#34;); while (!pq.isEmpty()) System.out.println(pq.delMax()); } } class UnorderedArrayMaxPQ\u0026lt;Key extends Comparable\u0026lt;Key\u0026gt;\u0026gt; extends ArrayPQ\u0026lt;Key\u0026gt; { public UnorderedArrayMaxPQ(int capacity) { super(capacity); } @Override public void insert(Key x) { pq[n++] = x; } @Override public Key delMax() { int max = 0; for (int i = 1; i \u0026lt; n; i++) { if (less(max, i)) max = i; exch(max, n-1); } return pq[--n]; } } class OrderedArrayMaxPQ\u0026lt;Key extends Comparable\u0026lt;Key\u0026gt;\u0026gt; extends ArrayPQ\u0026lt;Key\u0026gt;{ public OrderedArrayMaxPQ(int capacity) { super(capacity); } @Override public void insert(Key x) { int i = n - 1; while (i \u0026gt;= 0 \u0026amp;\u0026amp; x.compareTo(pq[i]) \u0026lt; 0) { pq[i+1] = pq[i]; i--; } pq[i+1] = x; n++; } @Override public Key delMax() { return pq[--n]; } } é“¾è¡¨å®ç° public abstract class LinkedListPQ\u0026lt;Key extends Comparable\u0026lt;Key\u0026gt;\u0026gt; { protected LinkedList\u0026lt;Key\u0026gt; pq; public LinkedListPQ() { pq = new LinkedList\u0026lt;Key\u0026gt;(); } public boolean isEmpty() { return pq.size() == 0; } public int size() { return pq.size(); } public abstract void insert(Key x); public abstract Key delMax(); protected boolean less(Key a, Key b) { return a.compareTo(b) \u0026lt; 0; } public static void main(String[] args) { UnorderedLinkedMaxPQ pq = new UnorderedLinkedMaxPQ(); pq.insert(\u0026#34;this\u0026#34;); pq.insert(\u0026#34;is\u0026#34;); pq.insert(\u0026#34;a\u0026#34;); pq.insert(\u0026#34;test\u0026#34;); while (!pq.isEmpty()) System.out.println(pq.delMax()); } } class UnorderedLinkedMaxPQ\u0026lt;Key extends Comparable\u0026lt;Key\u0026gt;\u0026gt; extends LinkedListPQ\u0026lt;Key\u0026gt; { @Override public void insert(Key x) { pq.addLast(x); } @Override public Key delMax() { int i = 0; int idx = 0; var max = pq.getFirst(); for (var e : pq) { if (less(max, e)) { max = e; idx = i; } i++; } pq.remove(idx); return max; } } class OrderedLinkedMaxPQ\u0026lt;Key extends Comparable\u0026lt;Key\u0026gt;\u0026gt; extends LinkedListPQ\u0026lt;Key\u0026gt; { public OrderedLinkedMaxPQ() { super(); } @Override public void insert(Key x) { int i = 0; Iterator it = pq.iterator(); while (it.hasNext()) { if (less(x, (Key) it.next())) break; i++; } pq.add(i, x); System.out.println(i + \u0026#34; eee \u0026#34;); } @Override public Key delMax() { return pq.removeLast(); } } the worst-case bounds insert() delMax() æ— åºæ•°ç»„ 1 N æœ‰åºæ•°ç»„ N 1 æ— åºé“¾è¡¨ 1 N æœ‰åºé“¾è¡¨ N 1 2.4.5 Give the heap that results when the keys E A S Y Q U E S T I O N are inserted in that order into an initially empty max-oriented heap.\n2.4.7 The largest item in a heap must appear in position 1, and the second largest must be in position 2 or position 3. Give the list of positions in a heap of size 31 where the kth largest (i) can appear, and (ii) cannot appear, for k=2, 3, 4 (assuming the values to be distinct).\nk = 2ï¼šå¯èƒ½å‡ºç°åœ¨2ï¼Œ3ï¼›ä¸å¯èƒ½å‡ºç°åœ¨1, 4~31 k = 3ï¼šå¯èƒ½å‡ºç°åœ¨2ï¼Œ3ï¼Œ4ï¼Œ5ï¼Œ6ï¼Œ7ï¼›ä¸å¯èƒ½å‡ºç°åœ¨1,8~31 k = 4ï¼šå¯èƒ½å‡ºç°åœ¨2ï¼Œ3ï¼Œ4ï¼Œ5ï¼Œ6ï¼Œ7ï¼Œ8ï¼Œ9ï¼Œ10ï¼Œ11ï¼Œ12ï¼Œ13ï¼Œ14ï¼Œ15ï¼Œä¸å¯èƒ½å‡ºç°åœ¨1ï¼Œ16~31 ç¬¬kå¤§å…ƒç´ åªå¯èƒ½å‡ºç°åœ¨æ·±åº¦ä¸å¤§äºkçš„ä½ç½®($ position \\le 2^k-1 ,k \\ge 2$)\n2.4.9 Draw all of the different heaps that can be made from the five keys A B C D E, then draw all of the different heaps that can be made from the five keys A A A B B.\nA B C D E æœ€å¤§å † æœ€å°å † A A A B B 2.4.11 Suppose that your application will have a huge number of insert operations, but only a few remove the maximum operations. Which priority-queue implementation do you think would be most effective: heap, unordered array, or ordered array?\nå› ä¸ºæœ‰å¤§é‡çš„insertæ“ä½œå’Œå¾ˆå°‘çš„delMaxæ“ä½œï¼Œè€Œheap, unordered array, ordered arrayå®ç°çš„Priority Queue insertæ“ä½œçš„èŠ±è´¹æ—¶é—´çš„æ•°é‡çº§åˆ†åˆ«ä¸ºlgN, 1, N, æ‰€ä»¥unordered arrayæ˜¯æœ€æœ‰æ•ˆçš„ã€‚\n2.4.12 Suppose that your application will have a huge number of find the maximum operations, but a relatively small number of insert and remove the maximum operations. Which priority-queue implementation do you think would be most effective: heap, unordered array, or ordered array?\nå¤§é‡çš„æŸ¥æ‰¾æœ€å¤§å…ƒç´ ï¼Œheapå’Œordered arrayæŸ¥æ‰¾æœ€å¤§å…ƒç´ éƒ½æ˜¯å¸¸é‡æ—¶é—´ï¼Œä½†heapæ’å…¥å’Œåˆ é™¤æœ€å¤§å…ƒç´ éƒ½æ˜¯lgNï¼Œè€Œordered arrayæ’å…¥å’Œåˆ é™¤åˆ†åˆ«æ˜¯Nå’Œå¸¸é‡æ—¶é—´ï¼Œç»¼åˆä¸‹æ¥ï¼Œheapæ˜¯æœ€æœ‰æ•ˆçš„ã€‚\nUNDIRECTED GRAPHS depth-first-search public class DepthFirstPaths { private boolean[] marked; private int[] edgeTo; private int s; public DepthFirstPaths(Graph G,int s) { marked = new boolean[G.V()]; edgeTo = new int[G.V()]; Arrays.fill(marked, false); this.s = s; dfs(G, s); } private void dfs(Graph G, int v) { marked[v] = true; for (int w : G.adj(v)) { if (!marked[w]) { dfs(G, w); edgeTo[w] = v; } } } public boolean hasPathTo(int v) { return marked[v]; } public Iterable\u0026lt;Integer\u0026gt; pathTo(int v) { if (!hasPathTo(v)) return null; Stack\u0026lt;Integer\u0026gt; path = new Stack\u0026lt;\u0026gt;(); for (int x = v; x != s; x = edgeTo[x]) path.push(x); path.push(s); return path; } public static void main(String[] args) { int V = StdIn.readInt(); Graph g = new Graph(V); int E = StdIn.readInt(); for (int i = 0; i \u0026lt; E; i++) { g.addEdge(StdIn.readInt(), StdIn.readInt()); } DepthFirstPaths dfp = new DepthFirstPaths(g, 0); for (var i : dfp.pathTo(3)) { System.out.println(i); } } } breadth-first-search public class BreadthFirstPaths { private boolean[] marked; private int[] edgeTo; private int s; public BreadthFirstPaths(Graph G, int s) { marked = new boolean[G.V()]; edgeTo = new int[G.V()]; this.s = s; bfs(G, s); } private void bfs(Graph G, int s) { Queue\u0026lt;Integer\u0026gt; Q = new Queue\u0026lt;\u0026gt;(); Q.enqueue(s); marked[s] = true; while (!Q.isEmpty()) { int v = Q.dequeue(); for (int w : G.adj(v)) { if (!marked[w]) { Q.enqueue(w); marked[w] = true; edgeTo[w] = v; } } } } public boolean hasPathTo(int v) { return marked[v]; } public Iterable\u0026lt;Integer\u0026gt; pathTo(int v) { if (!hasPathTo(v)) return null; Stack\u0026lt;Integer\u0026gt; path = new Stack\u0026lt;\u0026gt;(); for (int i = v; i != s; i = edgeTo[i]) path.push(i); path.push(s); return path; } public static void main(String[] args) { int V = StdIn.readInt(); Graph g = new Graph(V); int E = StdIn.readInt(); for (int i = 0; i \u0026lt; E; i++) { g.addEdge(StdIn.readInt(), StdIn.readInt()); } BreadthFirstPaths bfp = new BreadthFirstPaths(g, 0); for (var i : bfp.pathTo(3)) { System.out.println(i); } } } connected components public class CC { private boolean[] marked; private int[] id; private int count; public CC(Graph G) { marked = new boolean[G.V()]; id = new int[G.V()]; for (int v = 0; v \u0026lt; G.V(); v++) { if (!marked[v]) { dfs(G, v); count++; } } } public int count() { return count; } public int id(int v) { return id[v]; } private void dfs(Graph G, int v) { marked[v] = true; id[v] = count; for (int w : G.adj(v)) { if (!marked[w]) dfs(G, w); } } public static void main(String[] args) { Graph G = new Graph(StdIn.readInt()); int E = StdIn.readInt(); for (int i = 0; i \u0026lt; E; i++) G.addEdge(StdIn.readInt(), StdIn.readInt()); CC cc = new CC(G); System.out.println(cc.count); } } Minimum Spanning Trees Greedy algorithm Cut property Def: A cut in a graph is a partition of its vertices into two(nonempty) sets.\nDef: A Crossing edge connects a vertex in one set with a vertex in the other.\nCut property. Give any cut, the crossing edge of min weight is in the MST\nPf. Suppose the min-weight crossing edge e is not in the MST Adding e to the MST creates a cycle Some other edge f in cycle must be a crossing edge Removing f and adding e is also a spanning tree Since weight of e is less than the weight of f,that spanning tree is lower weight Contradiction Kruskal\u0026rsquo;s algorithm Consider edges in ascending order of weight.\nAdd next edge to tree T unless so doing would create a cycle. public class KruskalMST { private Queue\u0026lt;Edge\u0026gt; mst = new Queue\u0026lt;\u0026gt;(); private double weight; public KruskalMST(EdgeWeightedGraph G) { weight = 0; MinPQ\u0026lt;Edge\u0026gt; pq = new MinPQ\u0026lt;\u0026gt;(); for (var e : G.edges()) { pq.insert(e); } UF uf = new UF(G.V()); while (!pq.isEmpty() \u0026amp;\u0026amp; mst.size() \u0026lt; G.V() - 1) { Edge e = pq.delMin(); int v = e.either(), w = e.other(v); if (!uf.connected(v, w)) { uf.union(v, w); mst.enqueue(e); weight += e.weight(); } } } public Iterable\u0026lt;Edge\u0026gt; edges() { return mst; } public double weight() { return weight; } } Prim\u0026rsquo;s algorithm Start with vertex 0 and greedy grow tree T Add to T the min weight with exactly one endpoint in T Repeat until V-1 edges LazyPrim Implementation public class LazyPrimMST { private boolean[] marked; private Queue\u0026lt;Edge\u0026gt; mst; private MinPQ\u0026lt;Edge\u0026gt; pq; public LazyPrimMST(EdgeWeightedGraph G) { pq = new MinPQ\u0026lt;\u0026gt;(); mst = new Queue\u0026lt;\u0026gt;(); marked = new boolean[G.V()]; visit(G, 0); while (!pq.isEmpty() \u0026amp;\u0026amp; mst.size() \u0026lt; G.V() - 1) { Edge e = pq.delMin(); int v = e.either(), w = e.other(v); if (marked[v] \u0026amp;\u0026amp; marked[w]) continue; mst.enqueue(e); if (!marked[v]) visit(G, v); if (!marked[w]) visit(G, w); } } private void visit(EdgeWeightedGraph G, int v) { marked[v] = true; for (Edge e : G.adj(v)) { if (!marked[e.other(v)]) { pq.insert(e); } } } public Iterable\u0026lt;Edge\u0026gt; mst() { return mst; } } Indexed priority queue implementation Start as same code as MinPQ Maintain parallel arrays keys[], pq[], and qp[] so that: keys[i] is the priority of i pq[i] is the index of the key in heap position i qp[i] is the heap position of the key with index i Use swim(qp[i]) implement decreaseKey(i, key). EagerPrim Implementation import edu.princeton.cs.algs4.*; public class PrimMST { private Edge[] edgeTo; private double[] distTo; private boolean[] marked; private IndexMinPQ\u0026lt;Double\u0026gt; pq; public PrimMST(EdgeWeightedGraph G) { edgeTo = new Edge[G.V()]; distTo = new double[G.V()]; marked = new boolean[G.V()]; for (int v = 0; v \u0026lt; G.V(); v++) distTo[v] = Double.POSITIVE_INFINITY; pq = new IndexMinPQ\u0026lt;\u0026gt;(G.V()); distTo[0] = 0.0; pq.insert(0, 0.0); while (!pq.isEmpty()) visit(G, pq.delMin()); } private void visit(EdgeWeightedGraph G, int v) { marked[v] = true; for (Edge e : G.adj(v)) { int w = e.other(v); if (marked[w]) continue; if (e.weight() \u0026lt; distTo[w]) { edgeTo[w] = e; distTo[w] = e.weight(); if (pq.contains(w)) pq.change(w, distTo[w]); else pq.insert(w, distTo[w]); } } } public Iterable\u0026lt;Edge\u0026gt; edges() { Queue\u0026lt;Edge\u0026gt; mst = new Queue\u0026lt;\u0026gt;(); for (int v = 0; v \u0026lt; edgeTo.length; v++) { Edge e = edgeTo[v]; if (e != null) { mst.enqueue(e); } } return mst; } public double weight() { double weight = 0.0; for (Edge e : edges()) { weight += e.weight(); } return weight; } } 4.3.2 Draw all of the MSTs of graph depicted at right (all edge weights are equal).\n4.3.3 Show that if a graphâ€™s edges all have distinct weights, the MST is unique\nå‡è®¾æ— å‘å›¾Gæœ‰ä¸¤æ£µä¸åŒçš„æœ€å°ç”Ÿæˆæ ‘T1å’ŒT2 eæ˜¯åœ¨T1æˆ–T2ä¸­ï¼ˆä½†ä¸æ˜¯åŒæ—¶åœ¨ä¸¤æ£µæ ‘ä¸­ï¼‰æœ€å°æƒå€¼çš„è¾¹ï¼Œä¸å¦¨å‡è®¾eåœ¨T1ä¸­ å°†eæ·»åŠ åˆ°T2ä¸­ä¼šåˆ›å»ºä¸€ä¸ªç¯C åœ¨Cä¸­è‡³å°‘å­˜åœ¨ä¸€æ¡è¾¹fï¼ˆä½†ä¸åœ¨T1ä¸­ï¼Œå¦åˆ™ä¼šäº§ç”Ÿç¯ï¼‰ å› ä¸ºeæ˜¯åœ¨T1æˆ–T2ä¸­ï¼ˆä½†ä¸æ˜¯åŒæ—¶åœ¨ä¸¤æ£µæ ‘ä¸­ï¼‰æœ€å°æƒå€¼çš„è¾¹ï¼Œå¹¶ä¸”æ¯æ¡è¾¹æƒå€¼éƒ½ä¸åŒ æ‰€ä»¥æœ‰e.weight \u0026lt; f.weight ç”¨eä»£æ›¿fï¼Œå°†ä¼šäº§ç”Ÿæ¯”åŸæ¥T2æƒå€¼æ›´å°çš„ç”Ÿæˆæ ‘ï¼Œäº§ç”Ÿäº†çŸ›ç›¾ 4.3.13 Give a counterexample that shows why the following strategy does not necessarily find the MST: â€˜Start with any vertex as a single-vertex MST, then add V-1 edges to it, always taking next a min-weight edge incident to the vertex most recently added to the MST.â€™\nShortest Paths shortest-paths properties Data structures for single-source shortest paths Goal. Find the shortest-paths from s to every other vertex. Observation. A shortest-paths tree (SPT) solution exists. Why? Consequence. Can represent the SPT with two vertex-indexed arrays: distTo[v] is length of shortest path from s to v edgeTo[v] is last edge on shortest path from s to v Edge relaxation Relax edge e = v-\u0026gt;w distTo[v] is length of shortest known path from s to v distTo[w] is length of shortest known path from s to w edgeTo[w] is last edge on shortest known path from s to w if e = v-\u0026gt;w gives shorter path to w through v, update both distTo[w] and edgeTo[w] Shortest-paths optimality conditions Proposition. Let G be an edge-weighted digraph. Then distTo[] are the shortest path distances from s iff: distTo[s] = 0 For each vertex v, distTo[v] is the length of some path from s to v For each edge e = v-\u0026gt;w, distTo[w] \u0026lt;= distTo[v] + e.weight(). Pf. suppose that distTo[w] \u0026gt; distTo[v] + e.weight() for some edge e = v-\u0026gt;w. Then, e gives a path from s to w (through v) of length less than distTo[w]. distTo[v1] \u0026lt;= distTo[v0] + e1.weight() distTo[v2] \u0026lt;= distTo[v1] + e2.weight() \u0026hellip; distTo[vk] \u0026lt;= distTo[v(k-1)] + ek.weight() Add inequalities; simplify; and substitude distTo[v0] = distTo[s] = 0: distTo[w] = distTo[vk] \u0026lt;= e1.weight() + e2.weight() + \u0026hellip; + ek.weight() Thus, distTo[w] is the weight of shortest path to w Genertic shortest-paths algorithm Proposition. Genertic algorithm computes SPT(if it exists) from s. Pf sketch Throughout algorithm, distTo[v] is the length of a simple path from s to v (and edgeTo[v] is last edge on path) Each successful relaxation decreases distTo[v] from some v The entry distTo[v] can decrease at most a finite number of times Efficient implementataions How to choose which edge to relax? Ex 1. Dijkstra\u0026rsquo;s algorithm (nonnegative weights) Ex 2. Topological sort algorithm (no directed cycles) Ex 3. Bellman-Ford algorithm (no negative cycles) Dijkstra\u0026rsquo;s algorithm Dijkstra\u0026rsquo;s algorithm Demo correctness proof Proposition. Dijkstra\u0026rsquo;s algorithm computes a SPT in any edge-weighted diagraph with nonnegative weights.\nPf.\nEach edge e = v-\u0026gt;w is relaxed exactly once (when v is relaxed), leaving distTo[w] \u0026lt;= distTo[v] + e.weight() Inequality hold until algorithm terminates because: distTo[w] cannot increase \u0026lt;- distTo[] values are monotone decreasing distTo[v] will not change \u0026lt;- we choose lowest distTo[] value at each step (and edge weights are nonnegative) Thus, opun termination, shortest-paths optimality conditions hold Java implementation public class DijkstraSP { private DirectedEdge[] edgeTo; private double[] distTo; private IndexMinPQ\u0026lt;Double\u0026gt; pq; public DijkstraSP(EdgeWeightedDigraph G, int s) { edgeTo = new DirectedEdge[G.V()]; distTo = new double[G.V()]; pq = new IndexMinPQ\u0026lt;Double\u0026gt;(G.V()); for (int v = 0; v \u0026lt; G.V(); v++) distTo[v] = Double.POSITIVE_INFINITY; distTo[s] = 0.0; pq.insert(s, 0.0); while (!pq.isEmpty()) { int v = pq.delMin(); for (DirectedEdge e : G.adj(v)) relax(e); } } private void relax(DirectedEdge e) { int v = e.from(), w = e.to(); if (distTo[w] \u0026gt; distTo[v] + e.weight()) { distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; if (pq.contains(w)) pq.decreaseKey(w, distTo[w]); else pq.insert(w, distTo[w]); } } public double distTo(int v) { return distTo[v]; } public Iterable\u0026lt;DirectedEdge\u0026gt; pathTo(int v) { Stack\u0026lt;DirectedEdge\u0026gt; path = new Stack\u0026lt;\u0026gt;(); for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) path.push(e); return path; } } edge-weighted DAGs Acyclic shortest paths demo Shortest paths in edge-weighted DAGs Proposition. Topological sort algorithm computes SPT in any (edge weights can be negative!) edge-weighted DAG in time proportional to E + V Pf. Each edge e = v-\u0026gt;w is relaxed exactly once (when v is relaxed), leaving distTo[w] \u0026lt;= distTo[v] + e.weight() Inequality holds until algorithm terminates because: distTo[w] cannot increase \u0026lt;- distTo[] values are monotone decreasing distTo[v] will not change \u0026lt;- because of topological order, no edge pointing to v will be relaxed after v is relaxed Thus, upon termination, shortest-paths optimality conditions hold Java Implementation public class AcyclicSP { private DirectedEdge[] edgeTo; private double[] distTo; public AcyclicSP(EdgeWeightedDigraph G, int s) { edgeTo = new DirectedEdge[G.V()]; distTo = new double[G.V()]; for (int v = 0; v \u0026lt; G.V(); v++) distTo[v] = Double.POSITIVE_INFINITY; distTo[s] = 0.0; Topological topological = new Topological(G); for (int v : topological.order()) for (DirectedEdge e : G.adj(v)) relax(e); } private void relax(DirectedEdge e) { int v = e.from(), w = e.to(); if (distTo[w] \u0026gt; distTo[v] + e.weight()) { distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; } } public Iterable\u0026lt;DirectedEdge\u0026gt; pathTo(int v) { Stack\u0026lt;DirectedEdge\u0026gt; path = new Stack\u0026lt;\u0026gt;(); for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) path.push(e); return path; } } negative weights Def. A negative cycle is a directed cycle whose sum of edge weights is negative. Proposition. A SPT exists iff no negative cycles. Bellman-Ford algorithm: analysis Initialize distTo[s] = 0 and distTo[v] = $ \\infty $ for all other vertices.\nRepeat V times:\nRelax each edge. Proposition. Dynamic programming algorithm computes SPT in any edge-weighted digraph with no negative cycles in time proportional to $E\\times V$\nPf idea. After pass i, found shortest path containing at most i edges.\nBellman-Ford algorithm: practical improvement Observation. If distTo[v] does not change during pass i, no need to relax any edge pointing from v in pass i+1.\nFIFO implementation. Maintain queue of vertices whose distTo[] changed.\nOverall effect.\nThe running time is still proportional to $E \\times V $ in worst case. But much faster than that in practice. Bellman-Ford Java implementation public class BellmanFordSP { private double[] distTo; private DirectedEdge[] edgeTo; private Queue\u0026lt;Integer\u0026gt; queue; private boolean[] onQueue; public BellmanFordSP(EdgeWeightedDigraph G, int s) { distTo = new double[G.V()]; onQueue = new boolean[G.V()]; edgeTo = new DirectedEdge[G.V()]; for (int v = 0; v \u0026lt; G.V(); v++) distTo[v] = Double.POSITIVE_INFINITY; distTo[s] = 0.0; queue = new Queue\u0026lt;\u0026gt;(); queue.enqueue(s); onQueue[s] = true; while (!queue.isEmpty()) { int v = queue.dequeue(); onQueue[v] = false; relax(G, v); } } private void relax(EdgeWeightedDigraph G, int v) { for (DirectedEdge e : G.adj(v)) { int w = e.to(); if (distTo[w] \u0026gt; distTo[v] + e.weight()) { distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; if (!onQueue[w]) { queue.enqueue(w); onQueue[w] = true; } } } } public Iterable\u0026lt;DirectedEdge\u0026gt; pathTo(int v) { Stack\u0026lt;DirectedEdge\u0026gt; path = new Stack\u0026lt;\u0026gt;(); for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) path.push(e); return path; } } Single source shortest-path implementation: cost summary algorithm restriction typical case worst case extra case topological sort no directed cycles E + V E + V V Dijkstra (binary heap) no negative weights ElogV ElogV V Bellman-Ford no negative cycles EV EV V Bellman-Ford(queue-based) no negative cycles E + V EV V 4.4.1 True or false. Adding a constant to every edge weight does not change the solution to the single-source shortest-paths problem.\nFalse. å‡è®¾ä¸€æ¡æœ€çŸ­è·¯å¾„çš„é•¿åº¦æ˜¯15, ä¸”ä¸€å…±æœ‰äº”æ¡è¾¹ï¼Œè€Œå¦å¤–ä¸€æ¡ç®€å•è·¯å¾„çš„é•¿åº¦ä¸º20ï¼Œç”±ä¸¤æ¡è¾¹ç»„æˆï¼Œå½“æ¯æ¡è¾¹çš„æƒå€¼éƒ½å¢åŠ 5ä¹‹åï¼ŒåŸæ¥é•¿åº¦15çš„è·¯å¾„é•¿åº¦å˜ä¸º40ï¼ŒåŸæ¥é•¿åº¦ä¸º20çš„è·¯å¾„é•¿åº¦å˜ä¸º30ï¼Œå¯ä»¥çœ‹åˆ°æœ€çŸ­è·¯å¾„æ”¹å˜äº†ã€‚\n4.4.5 Change the direction of edge 0-\u0026gt;2 in tinyEWD.txt (see page 644). Draw two different SPTs that are rooted at 2 for this modified edge-weighted digraph. 4.5.9 The table below, from an old published road map, purports to give the length of the shortest routes connecting the cities. It contains an error. Correct the table. Also, add a table that shows how to achieve the shortest routes.\nProvidence Westerly New London Norwich Providence 53 54 48 Westerly 53 18 30 New London 54 18 12 Norwich 48 30 12 ç»™Providenceã€Westerlyã€New Londonã€Norwich åˆ†åˆ«ç¼–å·ä¸º0ã€1ã€2ã€3\næœ€çŸ­è·¯å¾„ï¼š\nProvidence Westerly New London Norwich Providence 0-1 0-2 0-3 Westerly 1-0 1-2 1-2ã€2-3 New London 2-0 2-1 2-3 Norwich 3-0 3-2ã€2-1 3-2 String sorts key-indexed counting Proposition. Key-indexed counting uses $ ~ 11N+4R $ array accesses to sort a N items whose keys are integers between 0 and R-1.\nProposition. Key-indexed counting uses extra space proportional to N + R\nStable.\npublic class CountingSort { public static void sort(int[] a, int R) { int N = a.length; int[] count = new int[R+1]; int[] aux = new int[N]; for (int i = 0; i \u0026lt; N; i++) count[a[i]+1]++; // count[a[i]+1] = count[a[i+1]] + 1 for (int r = 0; r \u0026lt; R; r++) count[r+1] += count[r]; // ç¬¬ä¸€ä¸ªä½ç½® for (int i = 0; i \u0026lt; N; i++) aux[count[a[i]]++] = a[i]; // aux[count[a[i]] = count[a[i]]+1] = a[i] for (int i = 0; i \u0026lt; N; i++) a[i] = aux[i]; } public static void main(String[] args) { String s = \u0026#34;dacffbdbfbea\u0026#34;; int[] a = new int[s.length()]; for (int i = 0; i \u0026lt; a.length; i++) a[i] = s.charAt(i)-\u0026#39;a\u0026#39;; sort(a, 26); for (var e : a) { System.out.printf(\u0026#34;%c \u0026#34;, e+\u0026#39;a\u0026#39;); } } } LSD radix sort Least-significant-digit-first string sort Consider characters from right to left. Stably sort using dth character as the key (using key-indexed counting). public class LSD { public static void sort(String[] a, int W) { int R = 256; int N = a.length; String[] aux = new String[N]; for (int d = W-1; d \u0026gt;= 0; d--) { int[] count = new int[R+1]; for (int i = 0; i \u0026lt; N; i++) count[a[i].charAt(d)+1]++; for (int r = 0; r \u0026lt; R; r++) count[r+1] += count[r]; for (int i = 0; i \u0026lt; N; i++) aux[count[a[i].charAt(d)]++] = a[i]; for (int i = 0; i \u0026lt; N; i++) a[i] = aux[i]; } } public static void main(String[] args) { In in = new In(\u0026#34;D:\\\\Java_test\\\\test1\\\\src\\\\StringSort\\\\strings.txt\u0026#34;); String[] a = in.readAllStrings(); int N = a.length; int w = a[0].length(); for (int i = 1; i \u0026lt; N; i++) assert a[i].length() == w : \u0026#34;String must have fixed length\u0026#34;; sort(a, w); for (var e : a) System.out.println(e); } } Summary of the performence of sorting algorithms MSD radix sort Most-significant-digit-first srting sort Partition array into R pieces according to first character (using key-indexed counting). Recursively sort all strings that start with each character (key-indexed counts delineate subarrays to sort). Implementation public class MSD { final static int R = 256; public static void sort(String[] a) { String[] aux = new String[a.length]; sort(a, aux, 0, a.length-1, 0); } private static void sort(String[] a, String[] aux, int lo, int hi, int d) { if (hi \u0026lt;= lo) return; int[] count = new int[R+2]; for (int i = lo; i \u0026lt;= hi; i++) count[charAt(a[i], d)+2]++; for (int r = 0; r \u0026lt; R + 1; r++) count[r+1] += count[r]; for (int i = lo; i \u0026lt;= hi; i++) aux[count[charAt(a[i], d)+1]++] = a[i]; for (int i = lo; i \u0026lt;= hi; i++) a[i] = aux[i - lo]; for (int r = 0; r \u0026lt; R; r++) sort(a, aux, lo+count[r], lo+count[r+1]-1, d+1); } private static int charAt(String s, int d) { if (s.length() \u0026gt; d) return s.charAt(d); else return -1; } public static void main(String[] args) { In in = new In(\u0026#34;D:\\\\Java_test\\\\test1\\\\src\\\\StringSort\\\\strings.txt\u0026#34;); String[] a = in.readAllStrings(); sort(a); for (var e : a) System.out.println(e); } } suffix arrays Longest repeated substring: Java implementation public class LRS { public static String lrs(String s) { int N = s.length(); String[] suffixes = new String[N]; for (int i = 0; i \u0026lt; N; i++) suffixes[i] = s.substring(i, N); Arrays.sort(suffixes); String lrs = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; N - 1; i++) { int len = lcp(suffixes[i], suffixes[i+1]); if (len \u0026gt; lrs.length()) lrs = suffixes[i].substring(0, len); } return lrs; } private static int lcp(String s, String t) { int n = Math.min(s.length(), t.length()); for (int i = 0; i \u0026lt; n; i++) if (s.charAt(i) != t.charAt(i)) return i; return n; } public static void main(String[] args) { String s = \u0026#34;aacaagtttacaagc\u0026#34;; System.out.println(lrs(s)); } } ","permalink":"https://fffzlfk.github.io/posts/algorithm4th/","summary":"The solution of algs4\u0026rsquo;s exercise","title":"ç®—æ³•ï¼ˆç¬¬å››ç‰ˆï¼‰"},{"content":"C++åŸºç¡€ C++å¯¹Cçš„æ‰©å…… åå­—ç©ºé—´ namespace ns1{ int inflag; } namespace ns2{ int inflag; } ns1::inflag=2; ns2::inflag=-3; // using ns1::inflag; inflag=2; // ns2::inflag=-3; ç”¨constå®šä¹‰å¸¸é‡ ç”¨constå®šä¹‰æ ‡è¯†ç¬¦å¸¸é‡æ—¶ï¼Œä¸€å®šè¦å¯¹å…¶åˆå§‹åŒ–ï¼Œè¿™æ˜¯å”¯ä¸€æ–¹æ³•ã€‚ å¼•ç”¨ å¯¹å˜é‡èµ·å¦å¤–ä¸€ä¸ªåå­—ï¼Œè¿™ä¸ªåå­—ç§°ä¸ºè¯¥å˜é‡çš„å¼•ç”¨ã€‚\nå…¶ä¸­åŸå˜é‡åå¿…é¡»æ˜¯ä¸€ä¸ªå·²å®šä¹‰è¿‡çš„å˜é‡ã€‚\nå¼•ç”¨å¹¶æ²¡æœ‰é‡æ–°åœ¨å†…å­˜ä¸­å¼€è¾Ÿå­˜å‚¨å•å…ƒï¼Œåªæ˜¯å¼•ç”¨åŸå˜é‡çš„å•å…ƒã€‚\nå¯¹å¼•ç”¨çš„åˆå§‹åŒ–ï¼Œå¯ä»¥ç”¨ä¸€ä¸ªå˜é‡åï¼Œä¹Ÿå¯ä»¥ç”¨å¦ä¸€ä¸ªå¼•ç”¨ã€‚\nint a=3; int \u0026amp;b=a; int \u0026amp;c=b; å¼•ç”¨åŒå˜é‡ä¸€æ ·æœ‰åœ°å€ï¼Œå¯ä»¥å¯¹å…¶åœ°å€è¿›è¡Œæ“ä½œï¼Œå³å°†å…¶åœ°å€èµ‹ç»™ä¸€æŒ‡é’ˆã€‚\nå¯¹constå¸¸é‡çš„å¼•ç”¨ä½¿ç”¨å¦‚ä¸‹æ–¹å¼ï¼š\nint i = 5; const int \u0026amp;ri = i; // ri = 10; é”™è¯¯ i = 10; //æ­£ç¡® cout \u0026lt;\u0026lt; ri; ä»¥ä¸‹çš„å£°æ˜æ˜¯éæ³•çš„\nä¼å›¾å»ºç«‹voidç±»å‹çš„å¼•ç”¨ void \u0026amp;a ä¼å›¾å»ºç«‹å¼•ç”¨çš„æ•°ç»„ int \u0026amp;a[6] ä¼å›¾å»ºç«‹æŒ‡å‘å¼•ç”¨çš„æŒ‡é’ˆ int \u0026amp;*p æŒ‡é’ˆå’Œå¼•ç”¨çš„åŒºåˆ«ï¼š\næŒ‡é’ˆæ˜¯é€šè¿‡åœ°å€é—´æ¥è®¿é—®æŸä¸ªå˜é‡ï¼Œè€Œå¼•ç”¨æ˜¯é€šè¿‡åˆ«åç›´æ¥è®¿é—®æŸä¸ªå˜é‡ã€‚ å¼•ç”¨å¿…é¡»åˆå§‹åŒ–ï¼Œè€Œä¸€æ—¦åˆå§‹åŒ–åä¸å†ä½œä¸ºå…¶ä»–å˜é‡çš„åˆ«åã€‚æŒ‡é’ˆè‹¥ä¸è¿›è¡Œåˆå§‹åŒ–ï¼Œç¼–è¯‘å™¨ä¸ä¼šæŠ¥é”™ã€‚ å¼•ç”¨ä¸å‡½æ•° å‡½æ•°çš„è¿”å›å€¼ä¸ºå¼•ç”¨ç±»å‹ å†…è”å‡½æ•° è°ƒç”¨å†…è”å‡½æ•°æ—¶ï¼Œç¼–è¯‘å™¨é¦–å…ˆæ£€æŸ¥è°ƒç”¨æ˜¯å¦æ­£ç¡®ï¼ˆç±»å‹å®‰å…¨æ£€æŸ¥æˆ–è€…è‡ªåŠ¨è¿›è¡Œç±»å‹è½¬æ¢ï¼‰ã€‚å¦‚æœæ­£ç¡®ï¼Œåˆ™å°†å†…è”å‡½æ•°çš„ä»£ç ç›´æ¥æ›¿æ¢å‡½æ•°è°ƒç”¨ï¼Œå¹¶ç”¨å®å‚æ¢å‹å‚ï¼Œäºæ˜¯çœå»äº†å‡½æ•°è°ƒç”¨çš„å¼€é”€ã€‚å› æ­¤ï¼Œå†…è”æœºåˆ¶å¢åŠ äº†ç©ºé—´å¼€é”€è€ŒèŠ‚çº¦äº†æ—¶é—´å¼€é”€ã€‚ ç¬¬ä¸€æ¬¡ä¸Šçº§é¢˜ç›® æ±‚2ä¸ªæˆ–3ä¸ªæ­£æ•´æ•°ä¸­çš„æœ€å¤§æ•°ï¼Œç”¨å¸¦æœ‰é»˜è®¤å‚æ•°çš„å‡½æ•°å®ç°ã€‚ è¾“å…¥ä¸‰ä¸ªæ•´æ•°ï¼Œå°†å®ƒä»¬æŒ‰ç”±å°åˆ°å¤§çš„é¡ºåºè¾“å‡ºï¼Œè¦æ±‚ä½¿ç”¨å˜é‡çš„å¼•ç”¨ã€‚ ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œç”¨åŒä¸€ä¸ªå‡½æ•°åå¯¹å‡ ä¸ªæ•°æ®è¿›è¡Œä»å°åˆ°å¤§æ’åºï¼Œæ•°æ®ç±»å‹å¯ä»¥æ˜¯æ•´å‹ã€æµ®ç‚¹å‹ã€‚ç”¨é‡è½½å‡½æ•°å®ç°ã€‚ å¯¹ç¬¬3é¢˜æ”¹ç”¨å‡½æ•°æ¨¡æ¿å®ç°ï¼Œå¹¶ä¸ç¬¬3é¢˜ç¨‹åºè¿›è¡Œå¯¹æ¯”åˆ†æã€‚ è®¾è®¡ä¸€ä¸ªæ—¥æœŸDateç±»ï¼Œå®ƒèƒ½å®ç°å¹´æœˆæ—¥çš„è¾“å…¥å’Œè¾“å‡ºï¼Œè¦æ±‚åˆ†åˆ«å°†æˆå‘˜å‡½æ•°å®šä¹‰åœ¨ç±»ä½“å†…å’Œç±»ä½“å¤–ã€‚ å£°æ˜ä¸€ä¸ªCircleç±»ï¼Œæœ‰æ•°æ®æˆå‘˜Radiusï¼ˆåŠå¾„ï¼‰ã€æˆå‘˜å‡½æ•°GetAreaï¼ˆï¼‰è®¡ç®—åœ†çš„é¢ç§¯ï¼Œæ„é€ ä¸€ä¸ªCircleçš„å¯¹è±¡è¿›è¡Œæµ‹è¯•ã€‚ ç¼–å†™ä¸€ä¸ªåŸºäºå¯¹è±¡çš„ç¨‹åºï¼Œæ±‚å‡º3ä¸ªé•¿æ–¹æŸ±çš„ä½“ç§¯ã€‚æ•°æ®æˆå‘˜åŒ…æ‹¬length(é•¿)ã€width(å®½)ã€height(é«˜)ã€‚è¦æ±‚ç”¨æˆå‘˜å‡½æ•°å®ç°ä»¥ä¸‹åŠŸèƒ½ï¼š\n(1) ç”±é”®ç›˜åˆ†åˆ«è¾“å…¥3ä¸ªé•¿æ–¹æŸ±çš„é•¿ã€å®½ã€é«˜ï¼›\n(2) è®¡ç®—é•¿æ–¹æŸ±çš„ä½“ç§¯ï¼›\n(3) è¾“å‡º3ä¸ªé•¿æ–¹æŸ±çš„ä½“ç§¯ã€‚ æºç ä¸‹è½½ 1\n2\n3\n4\n5\n6\n7\nç±»å’Œå¯¹è±¡ å¤åˆ¶æ„é€ å‡½æ•°è°ƒç”¨æ—¶æœº ç¨‹åºä¸­éœ€è¦æ–°å»ºç«‹ä¸€ä¸ªå¯¹è±¡ï¼Œå¹¶ç”¨å¦ä¸€ä¸ªåŒç±»çš„å¯¹è±¡å¯¹å®ƒåˆå§‹åŒ– Box box1(1,2,3); Box box2 = box1; // Box box2(box1); å½“å‡½æ•°çš„å‚æ•°ä¸ºç±»å¯¹è±¡æ—¶ï¼Œåœ¨è°ƒç”¨å‡½æ•°æ—¶éœ€è¦å°†å®å‚å¯¹è±¡å®Œæ•´çš„ä¼ é€’ç»™å½¢å‚ void func(Box b) { // do something... } int main() { Box box1(1, 2, 3); fun(box1); } å½“å‡½æ•°çš„è¿”å›å€¼æ˜¯ç±»çš„å¯¹è±¡ï¼Œåœ¨å‡½æ•°è°ƒç”¨å®Œæ¯•å°†è¿”å›å€¼å¸¦å›å‡½æ•°è°ƒç”¨å¤„æ—¶ Box f1() { Box box1(1, 2, 3); return box1; } int main() { Box box2; box2 = f(); return 0; } æŒ‡å‘éé™æ€æˆå‘˜å‡½æ•°çš„æŒ‡é’ˆ /* Author: fffzlfk */ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class Node { public: Node(int xx, int yy) : x(xx), y(yy){} int get_x() { return x; } int get_y() { return y; } private: int x, y; }; int main() { Node node(1, 2); int (Node::*p_x)() = \u0026amp;Node::get_x; // éœ€è¦åŠ ç±»åå’Œä½œç”¨åŸŸè¿ç®—ç¬¦ int (Node::*p_y)() = \u0026amp;Node::get_y; cout \u0026lt;\u0026lt; (node.*p_x)() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; (node.*p_y)() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } æŒ‡å‘é™æ€æˆå‘˜å‡½æ•°çš„æŒ‡é’ˆ /* Author: fffzlfk */ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class A { public: static int get() { return 666; } }; int main() { int (*p)() = \u0026amp;A::get; cout \u0026lt;\u0026lt; p() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; (*p)(); // åŠ ä¸åŠ *éƒ½å¯ return 0; } å¯¹è±¡å¼•ç”¨çš„ä½œç”¨ Tip\né¿å…é€šè¿‡å€¼æ¥ä¼ é€’å¯¹è±¡ï¼Œè€Œæ˜¯é€šè¿‡å¼•ç”¨æ¥ä¼ é€’ å‚æ•°ä¼ é€’çš„æ˜¯å¼•ç”¨ï¼Œæ²¡æœ‰æ„é€ å‡½æ•°æˆ–ææ„å‡½æ•°è¢«è°ƒç”¨ï¼ŒèŠ‚çº¦äº†ç³»ç»Ÿèµ„æºï¼Œæé«˜äº†è¿è¡Œæ•ˆç‡ /* Author: fffzlfk */ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class Student { public: Student(); Student returnS(Student s) { return s; } Student(const Student \u0026amp;e) { cout \u0026lt;\u0026lt; \u0026#34;Copy Constructor\\n\u0026#34;; } ~Student() { cout \u0026lt;\u0026lt; \u0026#34;Destructor\\n\u0026#34;; } }; Student::Student() {} int main() { Student stu1; stu1.returnS(stu1); return 0; } è¾“å‡ºä¸ºï¼š\nCopy Constructor\nCopy Constructor\nDestructor\nDestructor\nDestructor\nä¿®æ”¹ä¸º\nStudent\u0026amp; returnS(Student \u0026amp;s) { return s; } ä¹‹åï¼Œè¾“å‡ºï¼š\nDestructor\nå…³äºæ•°æ®æˆå‘˜åˆå§‹åŒ– æ•°æ®æˆå‘˜ æˆå‘˜åˆå§‹åŒ–åˆ—è¡¨ æ„é€ å‡½æ•°ä½“å†… ç±»å¤– æ™®é€šæ•°æ®æˆå‘˜ $\\checkmark $ $\\checkmark $ å¸¸æ•°æ®æˆå‘˜ $\\checkmark $ é™æ€æ•°æ®æˆå‘˜ $\\checkmark $ é™æ€å¸¸æ•°æ®æˆå‘˜ $\\checkmark $ å¸¸å¯¹è±¡ Tip\nå¸¸å¯¹è±¡çš„æ‰€æœ‰æ•°æ®æˆå‘˜éƒ½æ˜¯å¸¸é‡ï¼Œä¸èƒ½æ”¹å˜ã€‚å› æ­¤ï¼Œå¸¸å¯¹è±¡å¿…é¡»åˆå§‹åŒ–ã€‚\nä¸èƒ½é€šè¿‡å¸¸å¯¹è±¡è°ƒç”¨æ™®é€šçš„æˆå‘˜å‡½æ•°ï¼Œå¯ä»¥è°ƒç”¨å¸¸æˆå‘˜å‡½æ•°ã€‚\nå¦‚æœè¦ä¿®æ”¹å¸¸å¯¹è±¡ä¸­æŸä¸ªæ•°æ®æˆå‘˜çš„å€¼ï¼Œå¯ä»¥å°†æ•°æ®æˆå‘˜å£°æ˜ä¸ºmutableï¼Œè¿™æ ·å°±å¯ä»¥ç”¨å£°æ˜ä¸ºconstçš„æˆå‘˜å‡½æ•°æ¥ä¿®æ”¹å®ƒçš„å€¼ã€‚\n/* Author: fffzlfk */ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class A { private: mutable int i; // å¯ä»¥ç”¨å¸¸æˆå‘˜å‡½æ•°æ¥ä¿®æ”¹ public: A() {} //å¸¸å¯¹è±¡å¿…é¡»åˆå§‹åŒ– void f_const() const { i++; cout \u0026lt;\u0026lt; \u0026#34;i = \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;f_const()\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void f() { cout \u0026lt;\u0026lt; \u0026#34;f()\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; int main() { const A a; //å¸¸å¯¹è±¡å¿…é¡»åˆå§‹åŒ– a.f_const(); //å¸¸å¯¹è±¡åªèƒ½è°ƒç”¨å¸¸æˆå‘˜å‡½æ•° return 0; } å¸¸æˆå‘˜ å¸¸æ•°æ®æˆå‘˜\nTip\nåœ¨ä»»ä½•å‡½æ•°ä¸­éƒ½ä¸èƒ½å¯¹å¸¸æ•°æ®æˆå‘˜èµ‹å€¼\nåªèƒ½é€šè¿‡æ„é€ å‡½æ•°çš„å‚æ•°åˆå§‹åŒ–è¡¨å¯¹å¸¸æ•°æ®æˆå‘˜è¿›è¡Œåˆå§‹åŒ–\nconst int Hour; Time::Time(int h) : Hour(h) {} ç±»çš„æ‰€æœ‰å¯¹è±¡ä¸­çš„å¸¸æ•°æ®æˆå‘˜çš„å€¼å‡ä¸èƒ½æ”¹å˜ï¼Œä½†ä¸åŒå¯¹è±¡ä¸­çš„è¯¥æ•°æ®æˆå‘˜å¯ä»¥ä¸åŒï¼ˆåœ¨å®šä¹‰å¯¹è±¡æ—¶ç»™å‡ºï¼‰ ç¤ºä¾‹ç¨‹åºï¼š /* Author: fffzlfk */ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class A { public: A(int i) : a(i) {} // éé™æ€å¸¸æ•°æ®æˆå‘˜åªèƒ½é€šè¿‡åˆå§‹åŒ–è¡¨æ¥è·å¾—åˆå€¼ void print() { cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } private: const int a; static const int b; }; const int A::b = 10; // é™æ€å¸¸æ•°æ®æˆå‘˜åªèƒ½åœ¨ç±»å¤–åˆå§‹åŒ– int main() { A a1(100), a2(0); a1.print(); a2.print(); return 0; } å¸¸æˆå‘˜å‡½æ•°\nTip\né€šè¿‡å¸¸æˆå‘˜å‡½æ•°æ¥å¼•ç”¨æœ¬ç±»ä¸­çš„æ•°æ®æˆå‘˜ï¼Œä½†ä¸èƒ½ä¿®æ”¹ä»–ä»¬ const æ˜¯å‡½æ•°ç±»å‹çš„ä¸€éƒ¨åˆ†ï¼Œåœ¨å£°æ˜å‡½æ•°æ—¶éƒ½è¦æœ‰constï¼Œåœ¨è°ƒç”¨æ—¶ä¸å¿…åŠ const å¸¸æˆå‘˜å‡½æ•°ä¸èƒ½æ›´æ–°å¯¹è±¡çš„æ•°æ®æˆå‘˜ï¼Œä¹Ÿä¸èƒ½è°ƒç”¨è¯¥ç±»ä¸­çš„éconstæˆå‘˜å‡½æ•° é€šè¿‡å¸¸å¯¹è±¡åªèƒ½è°ƒç”¨å®ƒçš„å¸¸æˆå‘˜å‡½æ•°ï¼Œè€Œä¸èƒ½è°ƒç”¨å…¶ä»–æˆå‘˜å‡½æ•° å¸¸å¯¹è±¡ä¸­çš„æˆå‘˜å‡½æ•°ä¸æ˜¯å¸¸æˆå‘˜å‡½æ•°ï¼Œé™¤éæˆå‘˜å‡½æ•°æœ‰constä¿®é¥° constå…³é”®å­—å¯ä»¥ç”¨äºå¯¹é‡è½½å‡½æ•°çš„åŒºåˆ† /* Author: fffzlfk */ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class R { public: R(int r1, int r2) { R1 = r1; R2 = r2; } void print() { cout \u0026lt;\u0026lt; R1 \u0026lt;\u0026lt; \u0026#39;-\u0026#39; \u0026lt;\u0026lt; R2 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void print() const { cout \u0026lt;\u0026lt; R1 \u0026lt;\u0026lt; \u0026#34;+\u0026#34; \u0026lt;\u0026lt; R2 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } private: int R1, R2; }; int main() { R a(5, 4); a.print(); // æ™®é€šå¯¹è±¡aè°ƒç”¨æ™®é€šæˆå‘˜å‡½æ•° const R b(20, 5); b.print(); // å¸¸å¯¹è±¡bè°ƒç”¨å¸¸æˆå‘˜å‡½æ•° return 0; } constæˆå‘˜å’Œéconstæˆå‘˜ä¹‹é—´çš„è°ƒç”¨å…³ç³»\næ•°æ®æˆå‘˜ éconstæˆå‘˜å‡½æ•° constæˆå‘˜å‡½æ•° éconstæ•°æ®æˆå‘˜ å¯ä»¥å¼•ç”¨ï¼Œä¹Ÿå¯ä»¥æ”¹å˜å€¼ å¯ä»¥å¼•ç”¨ï¼Œä½†ä¸å¯ä»¥æ”¹å˜å€¼ constæ•°æ®æˆå‘˜ å¯ä»¥å¼•ç”¨ï¼Œä½†ä¸èƒ½æ”¹å˜å€¼ å¯ä»¥å¼•ç”¨ï¼Œä½†ä¸å¯ä»¥æ”¹å˜å€¼ constå¯¹è±¡çš„æ•°æ®æˆå‘˜ ä¸å…è®¸å¼•ç”¨å’Œæ”¹å˜å€¼ å¯ä»¥å¼•ç”¨ï¼Œä¸å¯ä»¥æ”¹å˜å€¼ constä¸æŒ‡é’ˆ æŒ‡å‘å¯¹è±¡çš„å¸¸æŒ‡é’ˆæŒ‡é’ˆæœ¬èº«çš„å€¼ä¸èƒ½æ”¹å˜ï¼Œå³å…¶æŒ‡å‘ä¸èƒ½æ”¹å˜ã€‚\nç±»å *const æŒ‡é’ˆå˜é‡å = å¯¹è±¡åœ°å€\nTime t1(10, 12, 15), t2; Time *const ptr1 = \u0026amp;t1; ptr1 = \u0026amp;t2; //é”™è¯¯ï¼Œptr1ä¸èƒ½æ”¹å˜æŒ‡å‘ Tip\nå¸¸æŒ‡é’ˆå§‹ç»ˆæŒ‡å‘åŒä¸€ä¸ªå¯¹è±¡ï¼Œä½†æ˜¯å¯ä»¥æ”¹å˜å…¶æ‰€æŒ‡å¯¹è±¡ä¸­æ•°æ®æˆå‘˜çš„å€¼ã€‚\næŒ‡å‘å¸¸å¯¹è±¡çš„æŒ‡é’ˆ\nconst ç±»å *æŒ‡é’ˆå˜é‡å = å¯¹è±¡åœ°å€\nå¦‚æœå­˜åœ¨ä¸€ä¸ªå¸¸å¯¹è±¡ï¼Œåªèƒ½ç”¨æŒ‡å‘å¸¸å¯¹è±¡çš„æŒ‡é’ˆå»æŒ‡å‘å®ƒï¼Œè€Œä¸èƒ½ç”¨éconstå‹çš„æŒ‡é’ˆå»æŒ‡å‘å®ƒã€‚\næŒ‡å‘å¸¸å¯¹è±¡çš„æŒ‡é’ˆè¿˜å¯ä»¥æŒ‡å‘éconstå‹çš„å¯¹è±¡ï¼Œæ­¤æ—¶ä¸èƒ½é€šè¿‡æŒ‡é’ˆæ”¹å˜è¯¥å¯¹è±¡çš„å€¼ï¼Œä½†æ˜¯é€šè¿‡è¯¥å¯¹è±¡æœ¬èº«æ¥æ”¹å˜ã€‚æŒ‡é’ˆæœ¬èº«çš„å€¼ä¹Ÿå¯ä»¥æ”¹å˜ã€‚\nTime t1(10, 12, 15), t2; const Time *p = \u0026amp;t1; // pæ˜¯æŒ‡å‘å¸¸å¯¹è±¡çš„æŒ‡é’ˆï¼Œå¹¶æŒ‡å‘t1å¯¹è±¡ (*p).hour = 18; // é”™è¯¯ï¼Œä¸èƒ½é€šè¿‡æŒ‡é’ˆæ”¹å˜t1çš„å€¼ t1.hour = 18; // æ­£ç¡®ï¼Œt1ä¸æ˜¯å¸¸å¯¹è±¡ p = \u0026amp;t2; // æ­£ç¡®ï¼Œpæ”¹ä¸ºæŒ‡å‘t2 Note\næŒ‡å‘å¸¸å¯¹è±¡çš„æŒ‡é’ˆå¯ä»¥æŒ‡å‘constå’Œéconstå‹çš„å¯¹è±¡ï¼Œè€ŒæŒ‡å‘éconstå‹å¯¹è±¡çš„æŒ‡é’ˆåªèƒ½æŒ‡å‘éconstçš„å¯¹è±¡ã€‚\nå¯¹è±¡æ•°ç»„ /* Author: fffzlfk */ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class Box { public: Box(int h = 10, int w = 12, int len = 15) : height(h), width(w), length(len) {} int volume(); private: int height, width, length; }; int Box::volume() { return height * width * length; } int main() { Box a[2]{Box(10, 12, 15), Box(15, 18, 20)}; // Box a[2] = {Box(10, 12, 15), Box(15, 18, // 20)}; åŠ ä¸åŠ ç­‰å·éƒ½å¯ cout \u0026lt;\u0026lt; a[0].volume() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; a[1].volume() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ç±»æ¨¡æ¿ ç±»æ¨¡æ¿æ˜¯å¯¹ä¸€æ‰¹ä»…æœ‰æˆå‘˜æ•°æ®ç±»å‹ä¸åŒçš„ç±»çš„æŠ½è±¡\nå…³äºå‡½æ•°æ¨¡æ¿\nç±»æ¨¡æ¿ä¸­çš„æˆå‘˜å‡½æ•°çš„å®šä¹‰ å¯ä»¥æ”¾åœ¨ç±»æ¨¡æ¿çš„å®šä¹‰å®šä¹‰ä½“ä¸­ï¼ˆæ­¤æ—¶ä¸ç±»ä¸­çš„æˆå‘˜å‡½æ•°å®šä¹‰æ–¹æ³•ä¸€è‡´ï¼‰\nä¹Ÿå¯ä»¥æ”¾åœ¨ç±»æ¨¡æ¿çš„å¤–éƒ¨ï¼Œæ­¤æ—¶æˆå‘˜å‡½æ•°çš„å®šä¹‰æ ¼å¼å¦‚ä¸‹ï¼š\ntemplate\u0026lt;class ç±»å‹å‚æ•°\u0026gt; \u0026lt;è¿”å›å€¼ç±»å‹\u0026gt; \u0026lt;ç±»æ¨¡æ¿å\u0026gt;\u0026lt;ç±»å‹å‚æ•°\u0026gt;::\u0026lt;å‡½æ•°å\u0026gt; (\u0026lt;å‚æ•°è¡¨\u0026gt;) { \u0026lt;å‡½æ•°ä½“\u0026gt; } åœ¨ç±»æ¨¡æ¿å¤–å®šä¹‰æˆå‘˜å‡½æ•°æ—¶ï¼Œæ¯ä¸€ä¸ªå‡½æ•°å‰å‡åŠ ä¸Šï¼š\ntemplate \u0026lt;class ç±»å‹å‚æ•°\u0026gt;\nç¬¬äºŒæ¬¡ä¸Šæœºé¢˜ç›® ç¼–å†™è®¾è®¡ä¸€ä¸ªPeopleï¼ˆäººï¼‰ç±»ã€‚è¯¥ç±»çš„æ•°æ®æˆå‘˜æœ‰å¹´é¾„ï¼ˆageï¼‰ã€èº«é«˜ï¼ˆheightï¼‰ã€ä½“é‡ï¼ˆweightï¼‰å’Œäººæ•°ï¼ˆnumï¼‰ï¼Œå…¶ä¸­äººæ•°ä¸ºé™æ€æ•°æ®æˆå‘˜ï¼Œæˆå‘˜å‡½æ•°æœ‰æ„é€ å‡½æ•°ï¼ˆPeopleï¼‰ã€è¿›é£Ÿï¼ˆEatingï¼‰ã€è¿åŠ¨ï¼ˆSportingï¼‰ã€ç¡çœ ï¼ˆSleepingï¼‰ã€æ˜¾ç¤ºï¼ˆShowï¼‰å’Œæ˜¾ç¤ºäººæ•°ï¼ˆShowNumï¼‰ã€‚å…¶ä¸­æ„é€ å‡½æ•°ç”±å·²çŸ¥å‚æ•°å¹´é¾„(a)ã€èº«é«˜(h)å’Œä½“é‡(w)æ„é€ å¯¹è±¡ï¼Œè¿›é£Ÿå‡½æ•°ä½¿ä½“é‡åŠ 1ï¼Œè¿åŠ¨å‡½æ•°ä½¿èº«é«˜åŠ 1ï¼Œç¡çœ å‡½æ•°ä½¿å¹´é¾„ã€èº«é«˜ã€ä½“é‡å„åŠ 1ï¼Œæ˜¾ç¤ºå‡½æ•°ç”¨äºæ˜¾ç¤ºäººçš„å¹´é¾„ã€èº«é«˜ã€ä½“é‡ï¼Œæ˜¾ç¤ºäººæ•°å‡½æ•°ä¸ºé™æ€æˆå‘˜å‡½æ•°ï¼Œç”¨äºæ˜¾ç¤ºäººçš„ä¸ªæ•°ã€‚å‡è®¾å¹´é¾„çš„å•ä½ä¸ºå²ï¼Œèº«é«˜çš„å•ä½ä¸ºå˜ç±³ï¼Œä½“é‡çš„å•ä½ä¸ºå¸‚æ–¤ï¼Œè¦æ±‚æ‰€æœ‰æ•°æ®æˆå‘˜ä¸ºprotectedè®¿é—®æƒé™ï¼Œæ‰€æœ‰æˆå‘˜å‡½æ•°ä¸ºpublicè®¿é—®æƒé™ï¼Œåœ¨ä¸»å‡½æ•°ä¸­é€šè¿‡å¯¹è±¡ç›´æ¥è®¿é—®ç±»çš„æ‰€æœ‰æˆå‘˜å‡½æ•°ã€‚ å®šä¹‰ä¸€ä¸ªæè¿°å­¦ç”Ÿï¼ˆStudentï¼‰åŸºæœ¬æƒ…å†µçš„ç±»ï¼Œæ•°æ®æˆå‘˜åŒ…æ‹¬å§“å(name)ã€å­¦å·(num)ã€æ•°å­¦æˆç»©(mathScore)ã€è‹±è¯­æˆç»©(englishScore)ã€äººæ•°(count)ã€æ•°å­¦æ€»æˆç»©(mathTotalScore)å’Œè‹±è¯­æ€»æˆç»©(englishTotalScore)ã€‚å…¶ä¸­å§“åå®šä¹‰ä¸ºé•¿åº¦ä¸º18çš„å­—ç¬¦æ•°ç»„ï¼Œå…¶ä»–æ•°æ®æˆå‘˜ç±»å‹ä¸ºæ•´å‹ï¼Œæ•°å­¦æ€»æˆç»©ã€è‹±è¯­æ€»æˆç»©å’Œäººæ•°ä¸ºé™æ€æ•°æ®æˆå‘˜ï¼Œå‡½æ•°æˆå‘˜åŒ…æ‹¬æ„é€ å‡½æ•°ã€æ˜¾ç¤ºåŸºæœ¬æ•°æ®å‡½æ•°ï¼ˆShowBaseï¼‰å’Œæ˜¾ç¤ºé™æ€æ•°æ®å‡½æ•°(showStatic)ï¼Œå…¶ä¸­æ„é€ å‡½æ•°ç”±å·²çŸ¥å‚æ•°å§“å(nm)ã€å­¦å·(nu)ã€æ•°å­¦æˆç»©(math)å’Œè‹±è¯­æˆç»©(english)æ„é€ å¯¹è±¡ï¼Œæ˜¾ç¤ºåŸºæœ¬æ•°æ®å‡½æ•°ç”¨äºæ˜¾ç¤ºå­¦ç”Ÿçš„å§“åã€å­¦å·ã€æ•°å­¦æˆç»©ã€è‹±è¯­æˆç»©ï¼Œæ˜¾ç¤ºé™æ€æ•°æ®å‡½æ•°ä¸ºé™æ€æˆå‘˜å‡½æ•°ï¼Œç”¨äºæ˜¾ç¤ºäººæ•°ã€æ•°å­¦æ€»æˆç»©ã€è‹±è¯­æ€»æˆç»©ï¼›è¦æ±‚æ‰€æœ‰æ•°æ®æˆå‘˜ä¸ºprivateè®¿é—®æƒé™ï¼Œæ‰€æœ‰æˆå‘˜å‡½æ•°ä¸ºpublicè®¿é—®æƒé™ï¼Œåœ¨ä¸»å‡½æ•°ä¸­å®šä¹‰è‹¥å¹²ä¸ªå­¦ç”Ÿå¯¹è±¡ï¼Œåˆ†åˆ«æ˜¾ç¤ºå­¦ç”ŸåŸºæœ¬ä¿¡æ¯ï¼Œä»¥åŠæ˜¾ç¤ºå­¦ç”Ÿäººæ•°ï¼Œæ•°å­¦æ€»æˆç»©ä¸è‹±è¯­æ€»æˆç»©ã€‚ å®šä¹‰ä¸€ä¸ªDogï¼ŒåŒ…å«nameã€ageã€sexå’Œweightç­‰å±æ€§ä»¥åŠå¯¹è¿™äº›å±æ€§æ“ä½œçš„æ–¹æ³•ã€‚è¦æ±‚ç”¨å­—ç¬¦æŒ‡é’ˆæè¿°nameï¼Œå¹¶ä¸”ç”¨å¯¹è±¡æŒ‡é’ˆæ¥æµ‹è¯•è¿™ä¸ªç±»ã€‚ ç®¡ç†ä¸ªäººæ´»æœŸè´¦æˆ·ï¼šä¸ªäººå‚¨è“„æ´»æœŸè´¦æˆ·åŒ…æ‹¬è´¦å·ã€æˆ·åã€å¯†ç ã€ä½™é¢ã€æ´»æœŸå¹´åˆ©ç‡ç­‰ä¿¡æ¯ã€‚è¦æ±‚èƒ½å¤Ÿå¯¹ä¸ªäººè´¦æˆ·è¿›è¡Œå­˜é’±ã€å–é’±ã€è®¡ç®—å¹´åˆ©æ¯ã€æ‰“å°è´¦æˆ·ç›¸å…³ä¿¡æ¯ç­‰æ“ä½œã€‚ç¼–å†™ä¸»å‡½æ•°æµ‹è¯•è´¦æˆ·ç›¸å…³åŠŸèƒ½ã€‚ 5ï¼å»ºç«‹ä¸€ä¸ªå¯¹è±¡æ•°ç»„ï¼Œå†…æ”¾5ä¸ªå­¦ç”Ÿçš„æ•°æ®ï¼ˆå­¦å·ã€æˆç»©ï¼‰ï¼Œï¼ˆ1ï¼‰ç”¨æŒ‡é’ˆæŒ‡å‘æ•°ç»„é¦–å…ƒç´ ï¼Œè¾“å‡ºç¬¬1ï¼Œ3ï¼Œ5ä¸ªå­¦ç”Ÿçš„æ•°æ®ï¼›ï¼ˆ2ï¼‰è®¾ç«‹ä¸€ä¸ªå‡½æ•°maxï¼Œç”¨æŒ‡å‘å¯¹è±¡çš„æŒ‡é’ˆä½œå‡½æ•°å‚æ•°ï¼Œåœ¨maxå‡½æ•°ä¸­æ‰¾å‡º5ä¸ªå­¦ç”Ÿä¸­æˆç»©æœ€é«˜è€…ï¼Œå¹¶è¾“å‡ºå…¶å­¦å·ã€‚ æºç ä¸‹è½½ 1\n2\n3\n4\n5\nè¿ç®—ç¬¦é‡è½½ ä¸èƒ½é‡è½½çš„è¿ç®—ç¬¦ ä¸èƒ½é‡è½½çš„è¿ç®—ç¬¦ è¯´æ˜ :: ä½œç”¨åŸŸè¿ç®—ç¬¦ . æˆå‘˜è®¿é—®è¿ç®—ç¬¦ .* æˆå‘˜æŒ‡é’ˆ ?: æ¡ä»¶è¿ç®—ç¬¦ sizeof é•¿åº¦è¿ç®—ç¬¦ é‡è½½ä¸ºç±»çš„æˆå‘˜å‡½æ•° \u0026lt;å‡½æ•°ç±»å‹\u0026gt; operator \u0026lt;è¿ç®—ç¬¦\u0026gt;(\u0026lt;å‚æ•°è¡¨\u0026gt;) {å‡½æ•°ä½“}\nC++ä¸­ä¸å…è®¸é‡è½½æœ‰ä¸‰ä¸ªæ“ä½œæ•°çš„è¿ç®—ç¬¦ è¿ç®—ç¬¦ä½œä¸ºæˆå‘˜å‡½æ•°æ—¶æœ€å¤šæœ‰ä¸€ä¸ªå½¢å‚ï¼šå‚æ•°å¯ä»¥æ˜¯å¯¹è±¡ï¼Œå¯¹è±¡çš„å¼•ç”¨ï¼Œæˆ–å…¶å®ƒç±»å‹çš„å‚æ•° è¿ç®—ç¬¦é‡è½½çš„å®è´¨å°±æ˜¯å‡½æ•°é‡è½½ è¿ç®—ç¬¦é‡è½½çš„å‡½æ•°å‚æ•°å°±æ˜¯è¯¥è¿ç®—ç¬¦æ¶‰åŠçš„æ“ä½œæ•° å•ç›®è¿ç®—ç¬¦çš„é‡è½½++ã€\u0026ndash; ++ä¸ºå‰ç½®è¿ç®—ç¬¦æ—¶ï¼š operator++() {\u0026hellip;} ++ä¸ºåç½®è¿ç®—ç¬¦æ—¶ï¼š operator++(int) {\u0026hellip;} å‹å…ƒå‡½æ•° æœ‰æ—¶å€™éœ€è¦æŸäº›å‡½æ•°è®¿é—®å¯¹è±¡çš„ç§æœ‰æˆå‘˜ï¼Œå¯ä»¥é€šè¿‡å£°æ˜è¯¥å‡½æ•°ä¸ºç±»çš„å‹å…ƒå‡½æ•°\nTip\nå‹å…ƒå‡½æ•°æ˜¯å¯ä»¥ç›´æ¥è®¿é—®ç±»çš„ç§æœ‰æˆå‘˜çš„éæˆå‘˜å‡½æ•°ã€‚ å®ƒæ˜¯å®šä¹‰åœ¨ç±»å¤–çš„æ™®é€šå‡½æ•°ï¼Œå®ƒä¸å±äºä»»ä½•ç±»ï¼Œä½†éœ€è¦åœ¨ç±»çš„å®šä¹‰ä¸­åŠ ä»¥å£°æ˜ï¼Œå£°æ˜æ—¶åªéœ€åœ¨å‹å…ƒçš„åç§°å‰åŠ ä¸Šå…³é”®å­—friendï¼Œå…¶æ ¼å¼å¦‚ä¸‹ï¼š\nfriend ç±»å‹ å‡½æ•°å(å½¢å¼å‚æ•°); #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class A { int i; public: friend void foo(A); }; void foo(A a) { cout \u0026lt;\u0026lt; a.i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { A a; foo(a); } å¤§å¤šæ•°æƒ…å†µä¸‹å‹å…ƒå‡½æ•°æ˜¯æŸä¸ªç±»çš„æˆå‘˜å‡½æ•°ï¼Œå³Aç±»ä¸­çš„æŸä¸ªæˆå‘˜å‡½æ•°æ˜¯Bç±»ä¸­çš„å‹å…ƒå‡½æ•°ï¼Œè¿™ä¸ªæˆå‘˜å‡½æ•°å¯ä»¥ç›´æ¥è®¿é—®Bç±»ä¸­çš„ç§æœ‰æ•°æ®ã€‚è¿™å®ç°äº†ç±»ä¸ç±»ä¹‹é—´çš„æ²Ÿé€šã€‚\nclass A { class B { void fun(B \u0026amp;); friend void A::fun(B \u0026amp;b); }; }; å‹å…ƒç±»\nclass A { class B { ... ... // Bç±»æ˜¯Aç±»çš„å‹å…ƒ // Bç±»å¯ä»¥è‡ªç”±ä½¿ç”¨Aç±»ä¸­çš„æˆå‘˜ friend class B; }ï¼› }; é‡è½½ä¸ºç±»çš„å‹å…ƒå‡½æ•° friend \u0026lt;å‡½æ•°å€¼ç±»å‹\u0026gt; operator\u0026lt;è¿ç®—ç¬¦\u0026gt;(\u0026lt;å‚æ•°è¡¨\u0026gt;) {å‡½æ•°ä½“}\nè¿ç®—ç¬¦é‡è½½ä¸ºç±»çš„å‹å…ƒå‡½æ•°****æœ€å¤šåªèƒ½æœ‰ä¸¤ä¸ªå‚æ•°** å¦‚æœé‡è½½åŒç›®è¿ç®—ç¬¦ï¼Œåˆ™ç¬¬ä¸€ä¸ªå‚æ•°ä»£è¡¨å·¦æ“ä½œæ•°ï¼Œç¬¬äºŒä¸ªå‚æ•°ä»£è¡¨å³æ“ä½œæ•° å•ç›®è¿ç®—ç¬¦é‡è½½ ++ä¸ºå‰ç½®è¿ç®—ç¬¦æ—¶ï¼Œå®ƒçš„è¿ç®—ç¬¦é‡è½½å‡½æ•°çš„ä¸€èˆ¬æ ¼å¼ä¸ºï¼šA operator ++(A \u0026amp;a) ++ä¸ºåç½®è¿ç®—ç¬¦æ—¶ï¼Œå®ƒçš„è¿ç®—ç¬¦é‡è½½å‡½æ•°çš„ä¸€èˆ¬æ ¼å¼ä¸ºï¼šA operator ++(A \u0026amp;a, int)(ä½¿ç”¨å“‘å…ƒåŒºåˆ†) é‡è½½è¾“å…¥è¾“å‡ºè¿ç®—ç¬¦ è¾“å…¥è¿ç®—ç¬¦ï¼šfriend istream \u0026amp; operater \u0026raquo;(istream \u0026amp;is, ClassName \u0026amp;f){â€¦}\nè¾“å‡ºè¿ç®—ç¬¦ï¼šfriend ostream \u0026amp; operater \u0026laquo;(ostream \u0026amp;, ClassName \u0026amp;){\u0026hellip;}\nå‡½æ•°å¯¹è±¡ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class Test { public: int operator()(int a, int b) { cout \u0026lt;\u0026lt; \u0026#34;operator() called. \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; return a + b; } }; int main() { Test sum; int s = sum(3, 4); // sumçœ‹ä¸Šå»åƒæ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œæ•…ä¹Ÿç§°â€œå‡½æ•°å¯¹è±¡â€ cout \u0026lt;\u0026lt; \u0026#34;a + b = \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } ç±»å‹è½¬æ¢è¿ç®—ç¬¦é‡è½½ åŸºæœ¬ç±»å‹åˆ°ç±»ç±»å‹çš„è½¬æ¢ å¦‚æœç›´æ¥å°†æ•°æ®èµ‹å€¼ç»™å¯¹è±¡ï¼Œæ‰€èµ‹å…¥çš„æ•°æ®è¦å¼ºåˆ¶ç±»å‹è½¬æ¢ï¼Œè¿™ç§è½¬æ¢éœ€è¦è°ƒç”¨æ„é€ å‡½æ•°ã€‚ä¹Ÿå°±æ˜¯åˆ©ç”¨æ„é€ å‡½æ•°èƒ½å®ŒæˆåŸºæœ¬ç±»å‹åˆ°ç±»ç±»å‹çš„è½¬æ¢ ä½¿ç”¨æ„é€ å‡½æ•°è¿›è¡Œç±»å‹è½¬æ¢å¿…é¡»æœ‰ä¸€ä¸ªå‰æï¼Œé‚£å°±æ˜¯åœ¨è¿™ä¸ªç±»ä¸­å®šä¹‰ä¸€ä¸ªåªæœ‰ä¸€ä¸ªå‚æ•°çš„æ„é€ å‡½æ•°ï¼ˆæˆ–è€…å…¶ä»–å‚æ•°æœ‰é»˜è®¤å€¼ï¼‰â€”â€”è½¬æ¢æ„é€ å‡½æ•° ç±»ç±»å‹åˆ°åŸºæœ¬ç±»å‹çš„è½¬æ¢ C++å¼•å…¥ä¸€ç§ç‰¹æ®Šçš„æˆå‘˜å‡½æ•°â€”â€”ç±»å‹è½¬æ¢å‡½æ•°ã€‚ç±»å‹è½¬æ¢å‡½æ•°å®é™…ä¸Šå°±æ˜¯ä¸€ä¸ªç±»å‹è½¬æ¢è¿ç®—ç¬¦é‡è½½å‡½æ•°\nç±»å‹è½¬æ¢å‡½æ•°ä¸“é—¨ç”¨æ¥å°†ç±»ç±»å‹è½¬æ¢ä¸ºåŸºæœ¬æ•°æ®ç±»å‹ï¼Œå®ƒåªèƒ½è¢«é‡è½½ä¸ºæˆå‘˜å‡½æ•°\né‡è½½ç±»å‹è½¬æ¢è¿ç®—ç¬¦å‡½æ•°æ ¼å¼ï¼š\noperatorã€ˆè¿”å›åŸºæœ¬ç±»å‹åã€‰ï¼ˆï¼‰ { â€¦â€¦ return ã€ˆåŸºæœ¬ç±»å‹å€¼ã€‰ }\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class A { int i; public: A(int a = 0) : i(a) {} void show(void) { cout \u0026lt;\u0026lt; \u0026#34;i = \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } operator int() { return i; } }; int main() { A a1(10), a2(20); cout \u0026lt;\u0026lt; a1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; a2 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } ç¤ºä¾‹ä»£ç  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class Complex { double real, imag; public: Complex(double r = 0.0, double i = 0.0) : real(r), imag(i) {} double getReal() const { return real; } double getImag() const { return imag; } Complex operator++(); Complex operator++(int); Complex operator+(Complex \u0026amp;); Complex operator+(double d); friend istream \u0026amp;operator\u0026gt;\u0026gt;(istream \u0026amp;, Complex \u0026amp;); friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;, const Complex \u0026amp;); }; Complex Complex::operator++() { return Complex(++real, imag); } Complex Complex::operator++(int a) { return Complex(real++, imag); } Complex Complex::operator+(Complex \u0026amp;c) { return Complex(real + c.real, imag + c.imag); } Complex Complex::operator+(double d) { return Complex(real + d, imag); } istream \u0026amp;operator\u0026gt;\u0026gt;(istream \u0026amp;in, Complex \u0026amp;c) { in \u0026gt;\u0026gt; c.real \u0026gt;\u0026gt; c.imag; return in; } ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;out, const Complex \u0026amp;c) { out \u0026lt;\u0026lt; to_string(c.real) + \u0026#34;+\u0026#34; + to_string(c.imag) + \u0026#34;i\u0026#34;; return out; } int main() { Complex a(1, 2); cout \u0026lt;\u0026lt; a + a \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; a++ \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; ++a \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; a = 10; // ç›¸å½“äºa = Complex(10); äº§ç”Ÿä¸´æ—¶å¯¹è±¡ï¼Œè°ƒç”¨æ„é€ å‡½æ•°å’Œææ„å‡½æ•° cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } ç»§æ‰¿ä¸æ´¾ç”Ÿ æ´¾ç”Ÿç±»å®šä¹‰ ä¸‰ç§ç»§æ‰¿æ–¹å¼æ´¾ç”Ÿç±»ä¸­åŸºç±»æˆå‘˜çš„è®¿é—®æ§åˆ¶æƒé™ å…¬æœ‰ç»§æ‰¿ ç§æœ‰ç»§æ‰¿ ä¿æŠ¤ç»§æ‰¿ å…¬æœ‰æˆå‘˜ å…¬æœ‰ ç§æœ‰ ä¿æŠ¤ ç§æœ‰æˆå‘˜ æ´¾ç”Ÿç±»ä¸å¯è®¿é—® æ´¾ç”Ÿç±»ä¸å¯è®¿é—® æ´¾ç”Ÿç±»ä¸å¯è®¿é—® ä¿æŠ¤æˆå‘˜ ä¿æŠ¤ ç§æœ‰ ä¿æŠ¤ æ´¾ç”Ÿç±»çš„æ„é€ å‡½æ•°å’Œææ„å‡½æ•° æ´¾ç”Ÿç±»æ„é€ å‡½æ•° ä¸èƒ½åœ¨æ´¾ç”Ÿç±»æ„é€ å‡½æ•°ä½“ä¸­æ˜¾å¼è°ƒç”¨åŸºç±»æ„é€ å‡½æ•°\nåœ¨æˆå‘˜åˆå§‹åŒ–è¡¨ä¸­å¯ä»¥æ˜¾å¼è°ƒç”¨åŸºç±»æ„é€ å‡½æ•°\nRectangle(float x,float y,float w,float h) : Point(x,y) { W=w; H=h; } æˆ–: Rectangle(float x,float y,float w,float h) : Point(x,y),W(w),H(h) {} æ„é€ å‡½æ•°å’Œææ„å‡½æ•°çš„è°ƒç”¨é¡ºåº æ„é€ å‡½æ•°è°ƒç”¨é¡ºåºï¼šåŸºç±»çš„æ„é€ å‡½æ•°-\u0026gt;å¯¹è±¡æˆå‘˜æ„é€ å‡½æ•°-\u0026gt;æ´¾ç”Ÿç±»æ„é€ å‡½æ•°\nææ„å‡½æ•°è°ƒç”¨é¡ºåºåˆšå¥½ç›¸å\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class O { public: O() { cout \u0026lt;\u0026lt; \u0026#34;O()\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ~O() { cout \u0026lt;\u0026lt; \u0026#34;~O()\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; class A { public: A() { cout \u0026lt;\u0026lt; \u0026#34;A()\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ~A() { cout \u0026lt;\u0026lt; \u0026#34;~A()\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; class B : public A { O o; public: B() { cout \u0026lt;\u0026lt; \u0026#34;B()\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ~B() { cout \u0026lt;\u0026lt; \u0026#34;~B()\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; int main() { B b; return 0; } A()\rO()\rB()\r~B()\r~O()\r~A() âš ï¸æ³¨æ„\nå½“åŸºç±»ä¸­æ²¡æœ‰æ˜¾å¼å®šä¹‰æ„é€ å‡½æ•°ï¼Œæˆ–å®šä¹‰äº†æ— å‚æ•°æ„é€ å‡½æ•°æ—¶ï¼Œæ´¾ç”Ÿç±»æ„é€ å‡½æ•°çš„åˆå§‹åŒ–è¡¨å¯ä»¥çœç•¥å¯¹åŸºç±»æ„é€ å‡½æ•°çš„è°ƒç”¨ï¼Œè€Œé‡‡ç”¨éšå«è°ƒç”¨ å½“åŸºç±»çš„æ„é€ å‡½æ•°ä½¿ç”¨ä¸€ä¸ªæˆ–å¤šä¸ªå‚æ•°æ—¶å€™ï¼Œæ´¾ç”Ÿç±»å¿…é¡»å®šä¹‰æ„é€ å‡½æ•°ï¼Œæä¾›å°†å‚æ•°ä¼ é€’ç»™åŸºç±»çš„æ„é€ å‡½æ•°çš„é€”å¾„ã€‚è¿™æ—¶ï¼Œæ´¾ç”Ÿç±»æ„é€ å‡½æ•°ä½“å¯èƒ½ä¸ºç©ºï¼Œä»…èµ·åˆ°å‚æ•°ä¼ é€’ä½œç”¨ æ— è®ºæ˜¯å“ªç§ç»§æ‰¿æ–¹å¼ï¼ŒåŸºç±»çš„ç§æœ‰æˆå‘˜åœ¨æ´¾ç”Ÿç±»ä¸­éƒ½æ˜¯ä¸å¯è¢«è®¿é—®çš„ã€‚åªèƒ½é€šè¿‡åŸºç±»çš„æˆå‘˜å‡½æ•°è®¿é—®åŸºç±»çš„ç§æœ‰æ•°æ®æˆå‘˜ã€‚ å¦‚æœåœ¨ä¸€ä¸ªæ´¾ç”Ÿç±»ä¸­è¦è®¿é—®åŸºç±»ä¸­çš„ç§æœ‰æˆå‘˜ï¼Œå¯ä»¥å°†è¿™ä¸ªæ´¾ç”Ÿç±»å£°æ˜ä¸ºåŸºç±»çš„å‹å…ƒã€‚ class Base { class Derive : public Base { friend class Derive; // ç›´æ¥ä½¿ç”¨Baseä¸­çš„ç§æœ‰æˆå‘˜ } } å‹å…ƒå…³ç³»æ˜¯ä¸èƒ½ç»§æ‰¿çš„ï¼šBç±»æ˜¯Aç±»çš„å‹å…ƒï¼ŒCç±»æ˜¯Bç±»çš„æ´¾ç”Ÿç±»ï¼Œåˆ™Cç±»å’ŒAç±»ä¹‹é—´æ²¡æœ‰ä»»ä½•å‹å…ƒå…³ç³»ï¼Œé™¤éCç±»å£°æ˜Aç±»æ˜¯å‹å…ƒã€‚ å¤šç»§æ‰¿ä¸è™šåŸºç±» å¤šç»§æ‰¿æ´¾ç”Ÿç±»çš„å®šä¹‰ class \u0026lt;æ´¾ç”Ÿç±»å\u0026gt;ï¼š\u0026lt;ç»§æ‰¿æ–¹å¼\u0026gt; \u0026lt;åŸºç±»å1\u0026gt;ï¼Œâ€¦ï¼Œ\u0026lt;ç»§æ‰¿æ–¹å¼\u0026gt; \u0026lt;åŸºç±»ån\u0026gt; { \u0026lt;æ´¾ç”Ÿç±»æ–°å®šä¹‰æˆå‘˜\u0026gt; }ï¼› å¤šç»§æ‰¿æ´¾ç”Ÿç±»çš„æ„é€ å‡½æ•° \u0026lt;æ´¾ç”Ÿç±»å\u0026gt;(\u0026lt;æ€»å‚æ•°è¡¨\u0026gt;):\u0026lt;åŸºç±»å1\u0026gt;(\u0026lt;å‚æ•°è¡¨1\u0026gt;)ï¼Œâ€¦ï¼Œ\u0026lt; åŸºç±»ån\u0026gt; (\u0026lt;å‚æ•°è¡¨n\u0026gt;) { \u0026lt;æ´¾ç”Ÿç±»æ•°æ®æˆå‘˜çš„åˆå§‹åŒ–\u0026gt; }; æ„é€ å‡½æ•°çš„è°ƒç”¨é¡ºåºæ˜¯ï¼šå…ˆè°ƒç”¨æ‰€æœ‰åŸºç±»çš„æ„é€ å‡½æ•°ï¼Œå†è°ƒç”¨å¯¹è±¡æˆå‘˜æ„é€ å‡½æ•°ï¼Œæœ€åè°ƒç”¨æ´¾ç”Ÿç±»çš„æ„é€ å‡½æ•°\nå¤„äºåŒä¸€å±‚æ¬¡çš„å„åŸºç±»æ„é€ å‡½æ•°çš„è°ƒç”¨é¡ºåºå–å†³äºå®šä¹‰æ´¾ç”Ÿç±»æ—¶æ‰€æŒ‡å®šçš„åŸºç±»é¡ºåºï¼Œä¸æ´¾ç”Ÿç±»æ„é€ å‡½æ•°ä¸­æ‰€å®šä¹‰çš„æˆå‘˜åˆå§‹åŒ–åˆ—è¡¨æ— å…³\nå¦‚æœæœ‰å¤šä¸ªæˆå‘˜ç±»å¯¹è±¡ï¼Œåˆ™æ„é€ å‡½æ•°é¢è°ƒç”¨é¡ºåºæ˜¯å¯¹è±¡åœ¨ç±»ä¸­è¢«å£°æ˜çš„é¡ºåºï¼Œè€Œä¸æ˜¯å®ƒä»¬å‡ºç°åœ¨æˆå‘˜åˆå§‹åŒ–åˆ—è¡¨çš„é¡ºåº\nææ„å‡½æ•°çš„è°ƒç”¨é¡ºåºä¸æ„é€ å‡½æ•°çš„è°ƒç”¨é¡ºåºç›¸å\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class M1 { int i; public: M1(int _i) : i(_i) { cout \u0026lt;\u0026lt; \u0026#34;M1(\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; class M2 { int i; public: M2(int _i) : i(_i) { cout \u0026lt;\u0026lt; \u0026#34;M2(\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; class Base1 { public: Base1() { cout \u0026lt;\u0026lt; \u0026#34;Base1()\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; class Base2 { public: Base2() { cout \u0026lt;\u0026lt; \u0026#34;Base2()\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; class Derive : public Base1, public Base2 { M2 m2; M1 m1; public: Derive(int a, int b) : m1(a), m2(b), Base2() , Base1() {} }; int main() { Derive d(8, 9); return 0; } Base1()\rBase2()\rM2(9)\rM1(8) å¤šç»§æ‰¿å¼•èµ·çš„äºŒä¹‰æ€§é—®é¢˜ ä¸¤ä¸ªåŸºç±»æœ‰åŒåæˆå‘˜ implementation #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class A { public: void display() { cout \u0026lt;\u0026lt; \u0026#34;display() in A\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; class B { public: void display() { cout \u0026lt;\u0026lt; \u0026#34;display() in B\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; class C : public A, public B { }; int main() { C c; c.display(); return 0; } ç¼–è¯‘é”™è¯¯ ä¸¤ä¸ªåŸºç±»å’Œæ´¾ç”Ÿç±»ä¸‰è€…éƒ½æœ‰åŒåæˆå‘˜ åŸºç±»çš„åŒåæˆå‘˜åœ¨æ´¾ç”Ÿç±»ä¸­è¢«å±è”½ï¼Œæˆ–è€…è¯´ï¼Œæ´¾ç”Ÿç±»æ–°å¢åŠ çš„åŒåæˆå‘˜éšè—äº†åŸºç±»ä¸­çš„åŒåæˆå‘˜ implementation #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class A { public: void display() { cout \u0026lt;\u0026lt; \u0026#34;display() in A\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; class B { public: void display() { cout \u0026lt;\u0026lt; \u0026#34;display() in B\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; class C : public A, public B { public: void display() { cout \u0026lt;\u0026lt; \u0026#34;display() in C\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; int main() { C c; c.display(); return 0; } è®¿é—®çš„æ˜¯æ´¾ç”Ÿç±»Cä¸­çš„æˆå‘˜ display() in C è™šåŸºç±» è™šåŸºç±»æ¦‚å¿µ ä¸ºäº†é¿å…å¯¹åŸºç±»æˆå‘˜è®¿é—®çš„äºŒä¹‰æ€§é—®é¢˜ï¼Œå¯ä»¥å°†ç›´æ¥åŸºç±»ï¼ˆå¦‚Aã€Bï¼‰çš„å…±åŒåŸºç±»å¦‚Nè®¾ç½®ä¸ºè™šåŸºç±»ï¼Œè¿™æ ·å…±åŒåŸºç±»Nåœ¨å†…å­˜ä¸­åªæœ‰ä¸€ä¸ªå‰¯æœ¬å­˜åœ¨ å¼•è¿›è™šåŸºç±»åï¼Œæ´¾ç”Ÿç±»å¯¹è±¡ä¸­åªå­˜åœ¨ä¸€ä¸ªè™šåŸºç±»æˆå‘˜çš„å‰¯æœ¬ ä¸ºäº†ä¿è¯è™šåŸºç±»åœ¨æ´¾ç”Ÿç±»ä¸­åªç»§æ‰¿ä¸€æ¬¡ï¼Œåº”å½“åœ¨è¯¥åŸºç±»çš„æ‰€æœ‰ç›´æ¥æ´¾ç”Ÿç±»ä¸­å£°æ˜ä¸ºè™šåŸºç±»ï¼Œå¦åˆ™ä»ç„¶ä¼šå‡ºç°å¯¹åŸºç±»çš„å¤šæ¬¡ç»§æ‰¿ã€‚ æ„é€ å‡½æ•°çš„è°ƒç”¨é¡ºåº å…ˆè°ƒç”¨è™šåŸºç±»çš„æ„é€ å‡½æ•°ï¼Œå†è°ƒç”¨éè™šåŸºç±»çš„æ„é€ å‡½æ•° è‹¥åŒä¸€å±‚æ¬¡åŒ…å«å¤šä¸ªè™šåŸºç±»ï¼Œå…¶è°ƒç”¨é¡ºåºä¸ºå®šä¹‰æ—¶çš„é¡ºåº è‹¥è™šåŸºç±»æ„é€ å‡½æ•°ç”±éè™šåŸºç±»æ´¾ç”Ÿè€Œæ¥ï¼Œåˆ™ä»å…ˆæŒ‰å…ˆè°ƒç”¨åŸºç±»æ„é€ å‡½æ•°ï¼Œå†è°ƒç”¨æ´¾ç”Ÿç±»æ„é€ å‡½æ•°çš„é¡ºåº #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class Base1 { public: Base1() { cout \u0026lt;\u0026lt; \u0026#34;class Base1\u0026#34; \u0026lt;\u0026lt; endl; } }; class Base2 { public: Base2() { cout \u0026lt;\u0026lt; \u0026#34;class Base2\u0026#34; \u0026lt;\u0026lt; endl; } }; class Level1 : public Base2, virtual public Base1 { public: Level1() { cout \u0026lt;\u0026lt; \u0026#34;class Level1\u0026#34; \u0026lt;\u0026lt; endl; } }; class Level2 : public Base2, virtual public Base1 { public: Level2() { cout \u0026lt;\u0026lt; \u0026#34;class Level2\u0026#34; \u0026lt;\u0026lt; endl; } }; class TopLevel : public Level1, virtual public Level2 { public: TopLevel() { cout \u0026lt;\u0026lt; \u0026#34;class TopLevel\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { TopLevel obj; return 0; } è¾“å‡º class Base1\rclass Base2\rclass Level2\rclass Base2\rclass Level1\rclass TopLevel è™šåŸºç±»çš„åˆå§‹åŒ– å¦‚æœåœ¨è™šåŸºç±»ä¸­åªå®šä¹‰äº†å¸¦å‚æ•°çš„æ„é€ å‡½æ•°ï¼Œåˆ™è¦åœ¨å…¶æ‰€æœ‰æ´¾ç”Ÿç±»ï¼ˆåŒ…æ‹¬ç›´æ¥æ´¾ç”Ÿç±»æˆ–é—´æ¥æ´¾ç”Ÿç±»ï¼‰ä¸­ï¼Œé€šè¿‡æ„é€ å‡½æ•°çš„åˆå§‹åŒ–è¡¨å¯¹è™šåŸºç±»è¿›è¡Œåˆå§‹åŒ–ã€‚\nclass A { A(int i){} â€¦ }; class B:virtual public A { B(int n):A(n){}â€¦ }; class C:virtual public A { C(int n):A(n){}â€¦ }; class D:public B, public C { D(int n):A(n),B(n),C(n){}â€¦ }; âš ï¸æ³¨æ„ å¦‚æœå¤šç»§æ‰¿ä¸ç‰µæ‰¯åˆ°å¯¹åŒä¸€åŸºç±»çš„æ´¾ç”Ÿï¼Œå°±æ²¡æœ‰å¿…è¦å®šä¹‰è™šåŸºç±» ä½¿ç”¨å¤šç»§æ‰¿è¦ååˆ†å°å¿ƒï¼Œç»å¸¸ä¼šå‡ºç°äºŒä¹‰æ€§é—®é¢˜ èƒ½ç”¨å•ä¸€ç»§æ‰¿çš„é—®é¢˜å°±ä¸è¦ç”¨å¤šç»§æ‰¿ å¤šæ€æ€§ä¸è™šå‡½æ•° ç±»å‹å…¼å®¹è§„åˆ™ æ´¾ç”Ÿç±»çš„å¯¹è±¡å¯ä»¥èµ‹å€¼ç»™åŸºç±»å¯¹è±¡ æ´¾ç”Ÿç±»çš„å¯¹è±¡å¯ä»¥åˆå§‹åŒ–åŸºç±»çš„å¼•ç”¨ æ´¾ç”Ÿç±»çš„å¯¹è±¡çš„åœ°å€å¯ä»¥èµ‹ç»™åŸºç±»çš„æŒ‡é’ˆå˜é‡ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class Base { public: void who() { cout \u0026lt;\u0026lt; \u0026#34;Base class\u0026#34; \u0026lt;\u0026lt; endl; } }; class Derive1 : public Base { public: void who() { cout \u0026lt;\u0026lt; \u0026#34;Derive1 class\u0026#34; \u0026lt;\u0026lt; endl; } }; class Derive2 : public Base { public: void who() { cout \u0026lt;\u0026lt; \u0026#34;Derive2 class\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Base obj1, *p; //å®šä¹‰åŸºç±»å¯¹è±¡obj1å’ŒåŸºç±»å¯¹è±¡æŒ‡é’ˆp Derive1 obj2; Derive2 obj3; p = \u0026amp;obj1; // pæŒ‡å‘obj1 p-\u0026gt;who(); //é€šè¿‡æŒ‡é’ˆpè°ƒç”¨obj1çš„å…¬æœ‰æˆå‘˜å‡½æ•°//who() p = \u0026amp;obj2; // pæŒ‡å‘obj2 p-\u0026gt;who(); // påªèƒ½è®¿é—®ä»åŸºç±»ç»§æ‰¿ä¸‹æ¥çš„who() p = \u0026amp;obj3; // pæŒ‡å‘obj2 p-\u0026gt;who(); // påªèƒ½è®¿é—®ä»åŸºç±»ç»§æ‰¿ä¸‹æ¥çš„who() obj2.who(); obj3.who(); return 0; } è¾“å‡º\nBase class\rBase class\rBase class\rDerive1 class\rDerive2 class #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class Student { int num; public: Student(int n) : num(n) {} void display() { cout \u0026lt;\u0026lt; \u0026#34;num = \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; } }; class Graduate : public Student { string name; public: Graduate(int n, string _name) : Student(n), name(_name) {} void display() { Student::display(); cout \u0026lt;\u0026lt; \u0026#34;name = \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; int main() { Student stu(1001); Graduate grad(2001, \u0026#34;Jack\u0026#34;); Student *pt = \u0026amp;stu; pt-\u0026gt;display(); pt = \u0026amp;grad; pt-\u0026gt;display(); return 0; } è¾“å‡º\nnum = 1001\rnum = 2001 å¤šæ€ï¼ˆPolymorphismï¼‰ ç›¸ä¼¼åŠŸèƒ½çš„ä¸åŒå‡½æ•°ä½¿ç”¨ä¸€ä¸ªåç§°æ¥å®ç°ï¼Œä»è€Œå¯ä»¥ä½¿ç”¨ç›¸åŒçš„è°ƒç”¨æ–¹å¼æ¥è°ƒç”¨è¿™äº›å…·æœ‰ä¸åŒåŠŸèƒ½çš„åŒåå‡½æ•°\nå¤šæ€çš„åˆ†ç±» é™æ€å¤šæ€æ€§ï¼ˆç¼–è¯‘æ—¶çš„å¤šæ€æ€§ï¼‰ï¼šé€šè¿‡å‡½æ•°é‡è½½å®ç° åŠ¨æ€å¤šæ€æ€§ï¼ˆè¿è¡Œæ—¶çš„å¤šæ€æ€§ï¼‰ï¼šé€šè¿‡è™šå‡½æ•°å®ç° è™šå‡½æ•° è™šå‡½æ•°å°±æ˜¯åœ¨åŸºç±»ä¸­è¢«å…³é”®å­—virtualè¯´æ˜ã€å¹¶åœ¨ä¸€ä¸ªæˆ–å¤šä¸ªæ´¾ç”Ÿç±»ä¸­è¢«é‡æ–°å®šä¹‰çš„æˆå‘˜å‡½æ•°\nvirtual \u0026lt;å‡½æ•°å€¼ç±»å‹\u0026gt; \u0026lt;å‡½æ•°å\u0026gt;(\u0026lt;å‚æ•°è¡¨\u0026gt;);\nç¨‹åºè¿è¡Œæ—¶ï¼Œä¸åŒç±»çš„å¯¹è±¡è°ƒç”¨å„è‡ªçš„è™šå‡½æ•°ï¼Œè¿™å°±æ˜¯åŠ¨æ€å¤šæ€\nå®ç°åŠ¨æ€çš„å¤šæ€æ€§æ—¶ï¼Œå¿…é¡»ä½¿ç”¨åŸºç±»ç±»å‹çš„æŒ‡é’ˆå˜é‡æˆ–å¯¹è±¡å¼•ç”¨ï¼Œå¹¶ä½¿å…¶æŒ‡å‘ä¸åŒçš„æ´¾ç”Ÿå¯¹è±¡ï¼Œå¹¶é€šè¿‡è°ƒç”¨æŒ‡é’ˆæˆ–å¼•ç”¨æ‰€æŒ‡å‘çš„è™šå‡½æ•°æ‰èƒ½å®ç°åŠ¨æ€çš„å¤šæ€æ€§\nå£°æ˜è™šå‡½æ•°è¦æ³¨æ„\né™æ€æˆå‘˜å‡½æ•°å’Œå‹å…ƒå‡½æ•°ä¸èƒ½å£°æ˜ä¸ºè™šå‡½æ•° å†…è”æˆå‘˜å‡½æ•°ä¸èƒ½å£°æ˜ä¸ºè™šå‡½æ•° æ„é€ å‡½æ•°ä¸èƒ½æ˜¯è™šå‡½æ•° ææ„å‡½æ•°å¯ä»¥æ˜¯è™šå‡½æ•° #include \u0026lt;iostream\u0026gt; using namespace std; class Base { public: Base() = default; virtual ~Base() { cout \u0026lt;\u0026lt; \u0026#34;Base destructor\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; class Derived : public Base { public: Derived() = default; ~Derived() { cout \u0026lt;\u0026lt; \u0026#34;Derived destructor\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; int main() { Base *b = new Derived; delete b; return 0; } è”ç¼– è”ç¼–çš„åˆ†ç±» é™æ€è”ç¼–ï¼šåœ¨ç¼–è¯‘é˜¶æ®µå®Œæˆçš„è”ç¼–\n#include \u0026lt;iostream\u0026gt; using namespace std; class Student { public: void print() { cout \u0026lt;\u0026lt; \u0026#34;A student\u0026#34; \u0026lt;\u0026lt; endl; } }; class GStudent : public Student { public: void print() { cout \u0026lt;\u0026lt; \u0026#34;A graduate student\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Student s1, *ps; GStudent s2; s1.print(); s2.print(); s2.Student::print(); ps = \u0026amp;s1; ps-\u0026gt;print(); //åŸºç±»æŒ‡é’ˆå’ŒåŸºç±»æˆå‘˜å‡½æ•°å‘ç”Ÿå…³è” ps = \u0026amp;s2; ps-\u0026gt;print(); //å¸Œæœ›è°ƒç”¨å¯¹è±¡s2çš„è¾“å‡ºå‡½æ•°ï¼Œä½†è°ƒç”¨çš„å´æ˜¯å¯¹è±¡s1çš„è¾“å‡ºå‡½æ•° return 0; } è¾“å‡º\nA student\rA graduate student\rA student\rA student\rA student åŠ¨æ€è”ç¼–ï¼šæ ¹æ®å…·ä½“çš„æ‰§è¡Œæƒ…å†µæ¥åŠ¨æ€çš„ç¡®å®šï¼Œåœ¨è¿è¡Œé˜¶æ®µå®Œæˆ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class Student { public: // virtualå¯çœç•¥ virtual void print() { cout \u0026lt;\u0026lt; \u0026#34;a Student\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; class GStudent : public Student { public: virtual void print() { cout \u0026lt;\u0026lt; \u0026#34;A graduate student\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; int main() { Student s1, *ps; GStudent s2; s1.print(); s2.print(); s2.Student::print(); ps = \u0026amp;s1; ps-\u0026gt;print(); ps = \u0026amp;s2; // å¯¹è±¡æŒ‡é’ˆè°ƒç”¨è™šå‡½æ•°ï¼Œé‡‡ç”¨åŠ¨æ€è”ç¼–æ–¹å¼ ps-\u0026gt;print(); return 0; } è¾“å‡º\na Student\rA graduate student\ra Student\ra Student\rA graduate student #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class Student { public: virtual void print() { cout \u0026lt;\u0026lt; \u0026#34;A studnet\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; class GStudent : public Student { public: void print() { cout \u0026lt;\u0026lt; \u0026#34;A graduate studnet\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; void fun(Student \u0026amp;s) { s.print(); } int main() { Student s1; GStudent s2; fun(s1); fun(s2); return 0; } è¾“å‡º\nA studnet\rA graduate studnet âš ï¸æ³¨æ„ virtualå…³é”®å­—åªèƒ½ç”¨åœ¨è™šå‡½æ•°å£°æ˜ä¸­ï¼Œä¸èƒ½ç”¨åœ¨è™šå‡½æ•°çš„å®ç°ä¸­ åªæœ‰é€šè¿‡å¯¹è±¡æŒ‡é’ˆæˆ–å¯¹è±¡å¼•ç”¨æ¥è°ƒç”¨è™šå‡½æ•°ï¼Œæ‰èƒ½å®ç°åŠ¨æ€è”ç¼–ã€‚å¦‚æœé‡‡ç”¨å¯¹è±¡æ¥è°ƒç”¨è™šå‡½æ•°ï¼Œåˆ™é‡‡ç”¨çš„æ˜¯é™æ€è”ç¼–æ–¹å¼ åœ¨æ´¾ç”Ÿç±»ä¸­é‡æ–°å®šä¹‰è™šå‡½æ•°æ—¶ï¼Œè¿”å›å€¼ç±»å‹ã€å‡½æ•°åã€å‚æ•°ä¸ªæ•°ã€ç±»å‹å’Œé¡ºåºï¼Œéƒ½å¿…é¡»ä¸åŸºç±»çš„åŸå‹ç›¸åŒ å½“åœ¨æ´¾ç”Ÿç±»ä¸­å®šä¹‰äº†è™šå‡½æ•°çš„é‡è½½å‡½æ•°ï¼Œä½†å¹¶æ²¡æœ‰é‡æ–°å®šä¹‰è™šå‡½æ•°æ—¶ï¼Œä¸è™šå‡½æ•°åŒåçš„é‡è½½å‡½æ•°è¦†ç›–äº†æ´¾ç”Ÿç±»ä¸­çš„è™šå‡½æ•°ã€‚æ­¤æ—¶è‹¥è¯•å›¾é€šè¿‡æ´¾ç”Ÿç±»å¯¹è±¡ã€æŒ‡é’ˆè°ƒç”¨æ´¾ç”Ÿç±»å¯¹è±¡çš„è™šå‡½æ•°å°±ä¼šäº§ç”Ÿé”™è¯¯ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int PI = 3.1415; class Point { int X, Y; public: Point(int X = 0, int Y = 0) { this-\u0026gt;X = X; this-\u0026gt;Y = Y; } virtual double area() { return 0.0; } }; class Circle : public Point { double radius; public: Circle(int X, int Y, double R) : Point(X, Y) { radius = R; } double area(int i) { return PI * radius * radius; } }; int main() { Point P1(10, 10); cout \u0026lt;\u0026lt; \u0026#34;P1.area = \u0026#34; \u0026lt;\u0026lt; P1.area() \u0026lt;\u0026lt; endl; Circle C1(10, 10, 20); cout \u0026lt;\u0026lt; \u0026#34;C1.area = \u0026#34; \u0026lt;\u0026lt; C1.area() \u0026lt;\u0026lt; endl; Point *Pp; Pp = \u0026amp;C1; cout \u0026lt;\u0026lt; \u0026#34;Pp.area = \u0026#34; \u0026lt;\u0026lt; Pp-\u0026gt;area() \u0026lt;\u0026lt; endl; Point \u0026amp;Rp = C1; cout \u0026lt;\u0026lt; \u0026#34;Rp.area = \u0026#34; \u0026lt;\u0026lt; Rp.area() \u0026lt;\u0026lt; endl; return 0; } å¦‚æœåœ¨æ´¾ç”Ÿç±»ä¸­æ²¡æœ‰é‡æ–°å®šä¹‰è™šå‡½æ•°ï¼Œåˆ™ä¸å®ç°åŠ¨æ€è”ç¼–ï¼Œæ´¾ç”Ÿç±»çš„å¯¹è±¡å°†ä½¿ç”¨åŸºç±»è™šå‡½æ•°çš„ä»£ç  ä¸€ä¸ªç±»ä¸­çš„è™šå‡½æ•°è¯´æ˜åªå¯¹æ´¾ç”Ÿç±»ä¸­é‡å®šä¹‰çš„å‡½æ•°æœ‰å½±å“ï¼Œå¯¹å®ƒçš„åŸºç±»ä¸­çš„å‡½æ•°å¹¶æ²¡æœ‰å½±å“ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class Base { public: int func(int x) { cout \u0026lt;\u0026lt; \u0026#34;This is Base class\u0026#34; \u0026lt;\u0026lt; endl; return x; } }; class SubClass : public Base { public: virtual int func(int x) { cout \u0026lt;\u0026lt; \u0026#34;This is SubClass\u0026#34; \u0026lt;\u0026lt; endl; return x; } }; class SubSubClass : public SubClass { public: int func(int x) { cout \u0026lt;\u0026lt; \u0026#34;This is SubSubClass\u0026#34; \u0026lt;\u0026lt; endl; return x; } }; int main() { SubSubClass ss; Base \u0026amp;b = ss; cout \u0026lt;\u0026lt; b.func(5) \u0026lt;\u0026lt; endl; SubClass \u0026amp;s = ss; cout \u0026lt;\u0026lt; s.func(5) \u0026lt;\u0026lt; endl; return 0; } è¾“å‡º This is Base class 5\rThis is Sub2 class 5 çº¯è™šå‡½æ•° çº¯è™šå‡½æ•°ç”¨virtualå£°æ˜ï¼Œæ²¡æœ‰ä»»ä½•å®ç°ï¼Œå¿…é¡»ç”±æ´¾ç”Ÿç±»é‡æ–°å®šä¹‰è¯¥å‡½æ•°æä¾›å®ç°\nçº¯è™šå‡½æ•°ä¸å‡½æ•°ä½“ä¸ºç©ºçš„è™šå‡½æ•°\nåŒºåˆ« å‰è€…æ²¡æœ‰å‡½æ•°ä½“ï¼Œåè€…æœ‰å‡½æ•°ä½“ å‰è€…æ‰€åœ¨çš„ç±»æ˜¯æŠ½è±¡ç±»ï¼Œä¸èƒ½ç›´æ¥å®ä¾‹åŒ–ï¼›åè€…æ‰€åœ¨çš„ç±»æ˜¯å¯ä»¥å®ä¾‹åŒ–çš„ï¼ˆè¯¥ç±»ä¸­ä¸å«æœ‰å…¶ä»–çº¯è™šå‡½æ•°ï¼‰ å…±åŒç‚¹ å¯ä»¥æ´¾ç”Ÿå‡ºæ–°çš„ç±»ï¼Œç„¶ååœ¨æ–°ç±»ä¸­ç»™å‡ºè™šå‡½æ•°çš„å®ç°ï¼Œè€Œä¸”è¿™ç§å®ç°å¯ä»¥å…·æœ‰åŠ¨æ€ç‰¹å¾ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class A { protected: int x; public: A() { x = 1000; } virtual void print() = 0; // å®šä¹‰çº¯è™šå‡½æ•° }; class B : public A { int y; public: B() { y = 2000; } void print() { cout \u0026lt;\u0026lt; \u0026#34;y = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } // é‡æ–°å®šä¹‰çº¯è™šå‡½æ•° }; class C : public A { int z; public: C() { z = 3000; } void print() { cout \u0026lt;\u0026lt; \u0026#34;z = \u0026#34; \u0026lt;\u0026lt; z \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } // é‡æ–°å®šä¹‰çº¯è™šå‡½æ•° }; int main() { A *pa; B b; C c; pa = \u0026amp;b; pa-\u0026gt;print(); pa = \u0026amp;c; pa-\u0026gt;print(); // A a; ä¸èƒ½å®šä¹‰æŠ½è±¡ç±»çš„å¯¹è±¡ // pa = \u0026amp;a; // pa-\u0026gt;pritn(); return 0; } è¾“å‡º\ny = 2000\rz = 3000 æŠ½è±¡ç±» åŒ…å«ä¸€ä¸ªæˆ–å¤šä¸ªçº¯è™šå‡½æ•°çš„ç±»ç§°ä¸ºæŠ½è±¡ç±»\nå¦‚æœæ´¾ç”Ÿç±»æ²¡æœ‰å®ç°åŸºç±»ä¸­çš„æ‰€æœ‰çº¯è™šå‡½æ•°ï¼Œæ´¾ç”Ÿç±»ä¹Ÿæ˜¯æŠ½è±¡ç±»\næŠ½è±¡ç±»æ— æ³•å®ä¾‹åŒ–\næŠ½è±¡ç±»ä¸èƒ½ç”¨ä½œå‚æ•°ç±»å‹ã€å‡½æ•°å€¼ç±»å‹æˆ–æ˜¾å¼è½¬æ¢çš„ç±»å‹ï¼Œä½†å¯ä»¥å£°æ˜æŒ‡å‘æŠ½è±¡ç±»çš„çš„æŒ‡é’ˆæˆ–å¼•ç”¨ï¼Œé€šè¿‡æŒ‡é’ˆæˆ–å¼•ç”¨æ¥æŒ‡å‘å¹¶è®¿é—®æ´¾ç”Ÿç±»å¯¹è±¡ï¼Œä»è€Œå®ç°åŠ¨æ€å¤šæ€\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const double PI = 3.14159; class Shapes //æŠ½è±¡ç±» { public: void setvalue(int d, int w = 0) { x = d; y = w; } virtual void area() = 0; //çº¯è™šå‡½æ•° protected: int x, y; }; class Square : public Shapes { public: void area() //è®¡ç®—çŸ©å½¢é¢ç§¯ { cout \u0026lt;\u0026lt; \u0026#34;area of rectangle:\u0026#34; \u0026lt;\u0026lt; x * y \u0026lt;\u0026lt; endl; } }; class Circle : public Shapes { public: void area() //è®¡ç®—åœ†é¢ç§¯ { cout \u0026lt;\u0026lt; \u0026#34;area of circle:\u0026#34; \u0026lt;\u0026lt; PI * x * x \u0026lt;\u0026lt; endl; } }; int main() { Shapes *ptr[2]; //å£°æ˜æŠ½è±¡ç±»æŒ‡é’ˆ Square s1; //å£°æ˜æ´¾ç”Ÿç±»å¯¹è±¡ Circle c1; //å£°æ˜æ´¾ç”Ÿç±»å¯¹è±¡ ptr[0] = \u0026amp;s1; //æŠ½è±¡ç±»æŒ‡é’ˆæŒ‡å‘æ´¾ç”Ÿç±»å¯¹è±¡ ptr[0]-\u0026gt;setvalue(10, 5); ptr[0]-\u0026gt;area(); //æŠ½è±¡ç±»æŒ‡é’ˆè°ƒç”¨æ´¾ç”Ÿç±»æˆå‘˜å‡½æ•°,å®ç°å¤šæ€ ptr[1] = \u0026amp;c1; //æŠ½è±¡ç±»æŒ‡é’ˆæŒ‡å‘æ´¾ç”Ÿç±»å¯¹è±¡ ptr[1]-\u0026gt;setvalue(10); ptr[1]-\u0026gt;area(); //æŠ½è±¡ç±»æŒ‡é’ˆè°ƒç”¨æ´¾ç”Ÿç±»æˆå‘˜å‡½æ•°,å®ç°å¤šæ€ return 0; } è¾“å‡º\narea of rectangle:50\rarea of circle:314.159 ç¬¬ä¸‰æ¬¡ä¸Šæœºé¢˜ç›® å®šä¹‰ä¸€ä¸ªå¤æ•°ç±»Complexï¼Œé‡è½½è¿ç®—ç¬¦â€œ+â€ï¼Œâ€œ-â€ï¼Œâ€œ*â€ï¼Œâ€œ/â€,ä½¿ä¹‹èƒ½ç”¨äºå¤æ•°çš„åŠ ã€å‡ã€ä¹˜ã€é™¤ã€‚è¿ç®—ç¬¦é‡è½½å‡½æ•°ä½œä¸ºComplexç±»çš„æˆå‘˜å‡½æ•°ã€‚ç¼–ç¨‹åºï¼Œåˆ†åˆ«æ±‚ä¸¤ä¸ªå¤æ•°ä¹‹å’Œã€å·®ã€ç§¯å’Œå•†ã€‚ å¯¹äº2è¡Œ3åˆ—çŸ©é˜µï¼Œé‡è½½æµæ’å…¥è¿ç®—ç¬¦â€œ\u0026laquo;â€å’Œæµæå–è¿ç®—ç¬¦â€œ\u0026raquo;â€ï¼Œä½¿ä¹‹èƒ½ç”¨äºçŸ©é˜µçš„è¾“å…¥å’Œè¾“å‡ºã€‚ å®šä¹‰Timeç±»å’ŒDateç±»ï¼ŒTimeç±»ä¸ºDateç±»çš„å‹å…ƒç±»ï¼Œé€šè¿‡Timeç±»ä¸­çš„displayå‡½æ•°å¼•ç”¨Dateç±»å¯¹è±¡çš„ç§æœ‰æ•°æ®ï¼Œè¾“å‡ºå¹´ã€æœˆã€æ—¥å’Œæ—¶ã€åˆ†ã€ç§’ã€‚ åˆ†åˆ«å®šä¹‰Teacherï¼ˆæ•™å¸ˆï¼‰ç±»å’ŒCadreï¼ˆå¹²éƒ¨ï¼‰ç±»ï¼Œé‡‡ç”¨å¤šç»§æ‰¿æ–¹å¼ç”±è¿™ä¸¤ä¸ªç±»æ´¾ç”Ÿå‡ºæ–°ç±»Teacher_Cadreï¼ˆæ•™å¸ˆå…¼å¹²éƒ¨ï¼‰ã€‚è¦æ±‚ï¼š åœ¨ä¸¤ä¸ªåŸºç±»ä¸­éƒ½åŒ…å«å§“åã€å¹´é¾„ã€æ€§åˆ«ã€åœ°å€ã€ç”µè¯ç­‰æ•°æ®æˆå‘˜ã€‚ åœ¨Teacherç±»ä¸­è¿˜åŒ…å«æ•°æ®æˆå‘˜titileï¼ˆèŒç§°ï¼‰ï¼Œåœ¨Cadreç±»ä¸­è¿˜åŒ…å«æ•°æ®æˆå‘˜postï¼ˆèŒåŠ¡ï¼‰ï¼Œåœ¨Teacher_Cadreç±»ä¸­è¿˜åŒ…å«æ•°æ®æˆå‘˜wagesï¼ˆå·¥èµ„ï¼‰ã€‚ å¯¹ä¸¤ä¸ªåŸºç±»ä¸­çš„å§“åã€å¹´é¾„ã€æ€§åˆ«ã€åœ°å€ã€ç”µè¯ç­‰æ•°æ®æˆå‘˜ç”¨ç›¸åŒçš„åå­—ï¼Œåœ¨å¼•ç”¨è¿™äº›æ•°æ®æˆå‘˜æ—¶ï¼ŒæŒ‡å®šä½œç”¨åŸŸã€‚ åœ¨ç±»ä½“ä¸­å£°æ˜æˆå‘˜å‡½æ•°ï¼Œåœ¨ç±»å¤–å®šä¹‰æˆå‘˜å‡½æ•°ã€‚ åœ¨æ´¾ç”Ÿç±»Teacher_Cadreçš„æˆå‘˜å‡½æ•°showä¸­è°ƒç”¨Teacherç±»ä¸­çš„displayå‡½æ•°ï¼Œè¾“å‡ºå§“åã€å¹´é¾„ã€æ€§åˆ«ã€èŒç§°ã€åœ°å€ã€ç”µè¯ï¼Œç„¶åå†ç”¨coutè¯­å¥è¾“å‡ºèŒåŠ¡ä¸å·¥èµ„ã€‚ å†™ä¸€ä¸ªç¨‹åºï¼Œå®šä¹‰æŠ½è±¡åŸºç±»Shapeï¼Œç”±å®ƒæ´¾ç”Ÿå‡º5ä¸ªæ´¾ç”Ÿç±»ï¼šCircleï¼ˆåœ†å½¢ï¼‰ã€Squareï¼ˆæ­£æ–¹å½¢ï¼‰ã€Rectangleï¼ˆçŸ©å½¢ï¼‰ã€Trapezoidï¼ˆæ¢¯å½¢ï¼‰ã€Triangleï¼ˆä¸‰è§’å½¢ï¼‰ã€‚ç”¨è™šå‡½æ•°åˆ†åˆ«è®¡ç®—å‡ ç§å›¾å½¢é¢ç§¯ï¼Œå¹¶æ±‚å®ƒä»¬çš„å’Œã€‚è¦æ±‚ç”¨åŸºç±»æŒ‡é’ˆæ•°ç»„ï¼Œä½¿å®ƒçš„æ¯ä¸€ä¸ªå…ƒç´ æŒ‡å‘ä¸€ä¸ªæ´¾ç”Ÿç±»å¯¹è±¡ã€‚ æºç ä¸‹è½½ 1\n2\n3\n4\n5\nè¾“å…¥è¾“å‡ºæµ æµ æ•°æ®ä»ä¸€ä¸ªä½ç½®æµå‘å¦ä¸€ä¸ªä½ç½®ã€‚æµæ˜¯å­—èŠ‚çš„åºåˆ—ã€‚\nI/Oæµç±»åº“çš„å±‚æ¬¡ç»“æ„ C++ç¼–è¯‘ç³»ç»Ÿæä¾›çš„I/Oæµç±»åº“å«æœ‰ä¸¤ä¸ªå¹³è¡ŒåŸºç±»ï¼š streambuf ios iosç±»æœ‰4ä¸ªç›´æ¥æ´¾ç”Ÿç±»ï¼š è¾“å…¥æµç±»istream è¾“å‡ºæµç±»ostream æ–‡ä»¶æµç±»åŸºç±»fstreambase å­—ç¬¦ä¸²æµç±»åŸºç±»strstreambase I/Oæµç±»åº“çš„å¤´æ–‡ä»¶ iostreamï¼šI/Oæµç±»åº“çš„æœ€ä¸»è¦çš„å¤´æ–‡ä»¶ï¼ŒåŒ…å«äº†å¯¹è¾“å…¥è¾“å‡ºæµè¿›è¡Œæ“ä½œçš„æ‰€éœ€çš„åŸºæœ¬ä¿¡æ¯ï¼Œè¿˜åŒ…æ‹¬cinã€coutã€cerrã€clogå…±4ä¸ªæµå¯¹è±¡ fstreamï¼šç”¨äºç”¨æˆ·ç®¡ç†çš„æ–‡ä»¶çš„I/Oæ“ä½œ strstreamï¼šç”¨äºå­—ç¬¦ä¸²æµI/O stdiostreamï¼šç”¨äºæ··åˆä½¿ç”¨Cå’ŒC++çš„I/Oæ“ä½œ iomanipï¼šç”¨äºæ ¼å¼åŒ–I/Oæ—¶åº”åŒ…å«æ­¤å¤´æ–‡ä»¶ è¾“å…¥è¾“å‡ºçš„æ ¼å¼æ§åˆ¶ ä¸¤ç§æ ¼å¼åŒ–æ–¹å¼ ç”¨æµå¯¹è±¡çš„æœ‰å…³æˆå‘˜å‡½æ•°è¿›è¡Œæ ¼å¼åŒ– ç”¨ä¸“é—¨çš„æ§åˆ¶ç¬¦è¿›è¡Œæ ¼å¼åŒ–è¾“å…¥è¾“å‡º ç”¨æµå¯¹è±¡çš„æˆå‘˜å‡½æ•°æ ¼å¼åŒ– è®¾ç½®çŠ¶æ€æ ‡å¿— long ios::setf(long flags) æ¸…æ¥šçŠ¶æ€æ ‡å¿— long ios::unsetf(long flags) å–çŠ¶æ€æ ‡å¿— long ios::flags() å–çŠ¶æ€æ ‡å¿—å¹¶è®¾ç½®çŠ¶æ€æ ‡å¿— long ios::flags(long flag) âš ï¸ä»¥ä¸Šä¸‰ç»„å‡½æ•°å¿…é¡»ç”¨æµå¼å¯¹è±¡ï¼ˆcinæˆ–coutï¼‰æ¥è°ƒç”¨\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void showflags(long f) { long i; for (i = 0x8000; i; i \u0026gt;\u0026gt;= 1) { cout \u0026lt;\u0026lt; ((i \u0026amp; f) ? \u0026#34;1\u0026#34; : \u0026#34;0\u0026#34;); } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { long f; f = cout.flags(); showflags(f); cout.setf(ios::showpos | ios::scientific | ios::fixed); // è¿½åŠ çŠ¶æ€æ ‡å¿— f = cout.flags(); showflags(f); cout.unsetf(ios::scientific); // ä»çŠ¶æ€æ ‡å¿—ä¸­å»æ‰scientific f = cout.flags(); showflags(f); f = cout.flags(ios::hex); // é‡æ–°è®¾ç½®çŠ¶æ€æ ‡å¿— showflags(f); // é‡æ–°è®¾ç½®çŠ¶æ€æ ‡å¿—ä¹‹å‰ f = cout.flags(); showflags(f); return 0; } ç”¨æµå¯¹è±¡çš„æˆå‘˜å‡½æ•°è®¾ç½®è¾“å‡ºå®½åº¦ int ios::width(int len) int ios::width() ç¬¬ä¸€ç§è®¾ç½®è¾“å‡ºå®½åº¦å¹¶è¿”å›åŸæ¥çš„è¾“å‡ºå®½åº¦ï¼›ç¬¬äºŒç§è¿”å›å½“å‰è¾“å‡ºå®½åº¦ï¼Œé»˜è®¤è¾“å‡ºå®½åº¦ä¸º0 åªå¯¹å…¶åçš„ç¬¬ä¸€ä¸ªè¾“å‡ºé¡¹æœ‰æ•ˆ è®¾ç½®å¡«å……å­—ç¬¦ char ios::fill(char ch) char ios::fill() è®¾ç½®è¾“å‡ºç²¾åº¦ int ios::precision(int p) int ios::precision() é»˜è®¤è¾“å‡ºç²¾åº¦ä¸º6 ç”¨æµæˆå‘˜å‡½æ•°putè¾“å‡ºå­—ç¬¦ cout.out(\u0026#39;a\u0026#39;) #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int i = cout.width(); cout \u0026lt;\u0026lt; \u0026#34;width: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout.width(8); cout \u0026lt;\u0026lt; cout.width() \u0026lt;\u0026lt; \u0026#34;new width\u0026#34; \u0026lt;\u0026lt; endl; char c = cout.fill(); cout \u0026lt;\u0026lt; \u0026#34;filling word is: \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34;(ASCII code\u0026#34; \u0026lt;\u0026lt; (int)c \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; endl; cout.fill(\u0026#39;*\u0026#39;); cout \u0026lt;\u0026lt; cout.fill() \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; (int)cout.fill() \u0026lt;\u0026lt; \u0026#34;)(new filling word)\u0026#34; \u0026lt;\u0026lt; endl; int j = cout.precision(); cout \u0026lt;\u0026lt; \u0026#34;precision: \u0026#34; \u0026lt;\u0026lt; j \u0026lt;\u0026lt; endl; cout.precision(8); cout \u0026lt;\u0026lt; 123.456789 \u0026lt;\u0026lt; \u0026#34;(example)\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; cout.precision() \u0026lt;\u0026lt; \u0026#34;(new precision)\u0026#34; \u0026lt;\u0026lt; endl; return 0; } width:0\r8(new width)\rfilling word is: (ASCII code32)\r*(42)(new filling word)\rprecision:6\r123.45679(example)\r8(new precision) ç”¨äºå­—ç¬¦è¾“å…¥çš„æµæˆå‘˜å‡½æ•° ä¸å¸¦å‚æ•°çš„getå‡½æ•° #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int c; cout \u0026lt;\u0026lt; \u0026#34;enter a sentence:\u0026#34; \u0026lt;\u0026lt; endl; while ((c = cin.get()) != EOF) // å‡½æ•°çš„è¿”å›å€¼å°±æ˜¯è¯»å…¥çš„å­—ç¬¦ cout.put(c); return 0; } æœ‰ä¸€ä¸ªå‚æ•°çš„getå‡½æ•° #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { char c; cout \u0026lt;\u0026lt; \u0026#34;enter a sentence:\u0026#34; \u0026lt;\u0026lt; endl; while (cin.get( c)) // è¯»å–ä¸€ä¸ªå­—ç¬¦èµ‹ç»™cï¼Œå¦‚æœè¯»å–æˆåŠŸï¼Œè¿”å›çœŸï¼Œå¦‚å¤±è´¥ï¼ˆå¦‚é‡æ–‡ä»¶ç»“æŸç¬¦ï¼‰åˆ™è¿”å›å‡ cout.put(c); cout \u0026lt;\u0026lt; \u0026#34;end\u0026#34; \u0026lt;\u0026lt; endl; return 0; } æœ‰ä¸‰ä¸ªå‚æ•°çš„getå‡½æ•° cin.get(å­—ç¬¦æ•°ç»„/å­—ç¬¦æŒ‡é’ˆ, å­—ç¬¦ä¸ªæ•°n, ç»ˆæ­¢å­—ç¬¦) ä»è¾“å…¥æµä¸­è¯»å–n-1ä¸ªå­—ç¬¦ï¼Œèµ‹ç»™æŒ‡å®šçš„å­—ç¬¦æ•°ç»„ï¼ˆæˆ–å­—ç¬¦æŒ‡é’ˆæŒ‡å‘çš„æ•°ç»„ï¼‰ å¦‚æœåœ¨è¯»å–n-1ä¸ªå­—ç¬¦ä¹‹å‰é‡åˆ°æŒ‡å®šçš„ç»ˆæ­¢å­—ç¬¦ï¼Œåˆ™æå‰è¯»å–ç»“æŸ å¦‚æœè¯»å–æˆåŠŸè¿”å›çœŸï¼Œå¤±è´¥ï¼ˆé‡æ–‡ä»¶ç»“æŸç¬¦ï¼‰åˆ™è¿”å›å‡ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { char ch[20]; cout \u0026lt;\u0026lt; \u0026#34;enter a sentence:\u0026#34; \u0026lt;\u0026lt; endl; cin.get(ch, 10, \u0026#39;/\u0026#39;); cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; cin.get(ch, 20, \u0026#39;\\n\u0026#39;); // cin.get(ch, 20); cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; return 0; } enter a sentence:\ryou!/her.\ryou!\r/her. ç”¨getlineå‡½æ•°è¯»å…¥ä¸€è¡Œå­—ç¬¦ cin.getline(å­—ç¬¦æ•°ç»„ï¼ˆæˆ–å­—ç¬¦æŒ‡é’ˆï¼‰, å­—ç¬¦ä¸ªæ•°n, ç»ˆæ­¢å­—ç¬¦) ä»è¾“å…¥æµä¸­è¯»å–ä¸€è¡Œå­—ç¬¦ï¼Œå…¶ç”¨æ³•ä¸å¸¦3ä¸ªå‚æ•°çš„getå‡½æ•°ç±»ä¼¼ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { char ch[20]; cout \u0026lt;\u0026lt; \u0026#34;enter a sentence:\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; ch; cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; cin.getline(ch, 20, \u0026#39;/\u0026#39;); cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; cin.getline(ch, 20); cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; return 0; } enter a sentence:\rI like C++./I study C++./I am happy.\rI\rlike C++.\rI study C++./I am h eofå‡½æ•° while(!cin.eof()) peekå‡½æ•° æ— å‚å‡½æ•°ï¼Œè¡¨ç¤ºâ€œè§‚å¯Ÿâ€ï¼Œè§‚æµ‹ä¸‹ä¸€å­—ç¬¦ è¿”å›å€¼æ˜¯å½“å‰æŒ‡é’ˆæŒ‡å‘çš„å½“å‰å­—ç¬¦ï¼Œä½†åªæ˜¯è§‚æµ‹ï¼ŒæŒ‡é’ˆä»åœç•™åœ¨å½“å‰ä½ç½®ï¼Œå¹¶ä¸åç§» å¦‚æœè¦è®¿é—®çš„å­—ç¬¦æ˜¯æ–‡ä»¶ç»“æŸç¬¦æ—¶ï¼Œåˆ™å‡½æ•°å€¼æ˜¯EOF c = cin.peek(); putbackå‡½æ•° å°†å‰é¢ç”¨getæˆ–getlineå‡½æ•°ä»è¾“å…¥æµä¸­è¯»å–çš„å­—ç¬¦chè¿”å›åˆ°è¾“å…¥æµï¼Œæ’å…¥åˆ°å½“å‰æŒ‡é’ˆä½ç½®ï¼Œä¾›åé¢è¯»å– #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { char c[20]; int ch; cout \u0026lt;\u0026lt; \u0026#34;enter a sentence:\u0026#34; \u0026lt;\u0026lt; endl; cin.getline(c, 15, \u0026#39;/\u0026#39;); cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; ch = cin.peek(); // è§‚çœ‹å½“å‰å­—ç¬¦ cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; cin.putback(c[0]); // å°†\u0026#39;I\u0026#39;æ’å…¥åˆ°æŒ‡é’ˆæ‰€æŒ‡å¤„ cin.getline(c, 15, \u0026#39;/\u0026#39;); cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; return 0; } enter a sentence:\rI am a boy./ am a student./\rI am a boy.\r32\rI am a student ignoreå‡½æ•° cin.ignore(n, ç»ˆæ­¢å­—ç¬¦) è·³è¿‡è¾“å…¥æµä¸­nä¸ªå­—ç¬¦ï¼Œæˆ–åœ¨é‡åˆ°æŒ‡å®šçš„ç»ˆæ­¢å­—ç¬¦æ—¶æå‰ç»“æŸï¼ˆæ­¤æ—¶è·³è¿‡åŒ…æ‹¬ç»ˆæ­¢å­—ç¬¦åœ¨å†…çš„è‹¥å¹²å­—ç¬¦ï¼‰ ignore(5, \u0026#39;A\u0026#39;); // è·³è¿‡5ä¸ªå­—ç¬¦ï¼Œé‡\u0026#39;A\u0026#39;åä¸å†è·³ ignore(); \u0026lt;-\u0026gt; ignore(1, EOF); ç¤ºä¾‹ä»£ç  ä¸åŠ ignore #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { char ch[20]; cin.get(ch, 20, \u0026#39;/\u0026#39;); cout \u0026lt;\u0026lt; \u0026#34;the first part is: \u0026#34; \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; cin.get(ch, 20, \u0026#39;/\u0026#39;); // getä¸è·³è¿‡ç»ˆæ­¢å­—ç¬¦ cout \u0026lt;\u0026lt; \u0026#34;the second part is: \u0026#34; \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; return 0; } I like C++./I study C++./I am happy.\rThe first part is:I like C++.\rThe second part is: åŠ ignore #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { char ch[20]; cin.get(ch, 20, \u0026#39;/\u0026#39;); cout \u0026lt;\u0026lt; \u0026#34;the first part is: \u0026#34; \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; cin.ignore(); // è·³è¿‡è¾“å…¥æµä¸­ä¸€ä¸ªå­—ç¬¦ cin.get(ch, 20, \u0026#39;/\u0026#39;); // getä¸è·³è¿‡ç»ˆæ­¢å­—ç¬¦ cout \u0026lt;\u0026lt; \u0026#34;the second part is: \u0026#34; \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; return 0; } I like C++./I study C++./I am happy.\rThe first part is:I like C++.\rThe second part is:I study C++. ç”¨æ§åˆ¶ç¬¦æ ¼å¼åŒ– è¿™ç»„æ§åˆ¶ç¬¦ä¸å±äºä»»ä½•ç±»æˆå‘˜ï¼Œå®šä¹‰åœ¨inomanipå¤´æ–‡ä»¶ä¸­ å°†ä»–ä»¬ç”¨åœ¨æå–è¿ç®—ç¬¦\u0026quot;\u0026raquo;\u0026ldquo;æˆ–æ’å…¥è¿ç®—ç¬¦\u0026rdquo;\u0026laquo;\u0026ldquo;åé¢æ¥è®¾å®šè¾“å…¥/è¾“å‡ºæ ¼å¼ï¼Œå³åœ¨è¯»å†™å¯¹è±¡ä¹‹é—´æ’å…¥ä¸€ä¸ªä¿®æ”¹çŠ¶æ€çš„æ“ä½œ è®¾ç½®è¾“å…¥/è¾“å‡ºå®½åº¦setw(int) ç”¨æ•´å‹å‚æ•°æ¥æŒ‡å®šè¾“å…¥/è¾“å‡ºåŸŸçš„å®½åº¦ã€‚ä½¿ç”¨æ—¶åªå¯¹å…¶åä¸€é¡¹è¾“å…¥/è¾“å‡ºæœ‰æ•ˆ å½“ç”¨äºè¾“å‡ºæ—¶ï¼Œè‹¥å®é™…å®½åº¦å°äºè®¾ç½®å®½åº¦æ—¶ï¼Œæ•°æ®å‘å³å¯¹é½ï¼Œåä¹‹åˆ™æŒ‰ç…§æ•°æ®çš„å®é™…å®½åº¦è¾“å‡º å½“ç”¨äºè¾“å…¥æ—¶ï¼Œè‹¥è¾“å…¥çš„æ•°æ®å®½åº¦è¶…è¿‡è®¾ç½®å®½åº¦æ—¶ï¼Œè¶…å‡ºçš„æ•°æ®éƒ¨åˆ†è¢«æˆªæ–­è€Œè¢«ä½œä¸ºä¸‹ä¸€é¡¹è¾“å…¥å†…å®¹ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { char *p = \u0026#34;12345\u0026#34;, *q = \u0026#34;678\u0026#34;; char f[4], g[4]; int i = 10; cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; setw(6) \u0026lt;\u0026lt; q \u0026lt;\u0026lt; setw(4) \u0026lt;\u0026lt; p \u0026lt;\u0026lt; q \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; setw(4) \u0026gt;\u0026gt; f \u0026gt;\u0026gt; g; cout \u0026lt;\u0026lt; f \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; g \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;i : \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; return 0; } 12345 67812345678\r12345\r123\r45\ri:10 è®¾ç½®è¾“å‡ºå¡«å……å­—ç¬¦setfill(char) setprecision(int) åœ¨ä»¥fixedå½¢å¼å’Œscientificå½¢å¼è¾“å‡ºæ—¶å‚æ•°ä¸ºå°æ•°ä½æ•° setiosflags(ios::fixed)ç”¨å®šç‚¹æ–¹å¼è¡¨ç¤ºå®æ•° setiosflags(ios::scientific)ç”¨ç§‘å­¦è®°æ•°æ³•æ–¹å¼è¡¨ç¤ºå®æ•° setiosflags(ios::left)å·¦å¯¹é½ setiosflags(ios::right)å³å¯¹é½ setiosflags(ios::uppercase)å¤§å†™è¡¨ç¤º setiosflags(ios::showpos)æ­£å· setiosflags(ios::skipws)å¿½ç•¥å‰å¯¼ç©ºæ ¼ resetiosflags() ç»ˆæ­¢å·²è®¾ç½®çš„è¾“å‡ºæ ¼å¼çŠ¶æ€ï¼Œåœ¨æ‹¬å·ä¸­åº”æŒ‡å®šå†…å®¹ #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { double f=22.0/7; //åœ¨ç”¨æµ®ç‚¹å½¢å¼è¡¨ç¤ºçš„è¾“å‡ºä¸­ï¼Œsetprecision(n)è¡¨ç¤ºå®æ•°çš„æœ‰æ•ˆä½æ•° cout\u0026lt;\u0026lt;f\u0026lt;\u0026lt;endl; //é»˜è®¤æœ‰æ•ˆä½æ•°ä¸º6 cout\u0026lt;\u0026lt;setprecision(3)\u0026lt;\u0026lt;f\u0026lt;\u0026lt;endl; //è®¾ç½®æœ‰æ•ˆä½æ•°ä¸º3 //åœ¨ç”¨å®šç‚¹å½¢å¼è¡¨ç¤ºçš„è¾“å‡ºä¸­ï¼Œsetprecision(n)è¡¨ç¤ºå®æ•°çš„å°æ•°ä½æ•° cout\u0026lt;\u0026lt;setiosflags(ios::fixed); cout\u0026lt;\u0026lt;setprecision(8)\u0026lt;\u0026lt;f\u0026lt;\u0026lt;endl; //å°æ•°ä½æ•°ä¸º8 return 0; } 3.14286\r3.14\r3.14285714 è®¾ç½®è¾“å…¥/è¾“å‡ºæ•´å‹æ•°æ•°åˆ¶decã€hexå’Œoct æ§åˆ¶æ¢è¡Œçš„æ§åˆ¶ç¬¦endl ä»£è¡¨è¾“å‡ºå•å­—ç¬¦\u0026rsquo;\\0\u0026rsquo;çš„æ§åˆ¶ç¬¦ends ","permalink":"https://fffzlfk.github.io/posts/oopc++/","summary":"Object-Oriented Programming","title":"OOP(C++)"},{"content":"$$e^x=1+x+\\frac{x^2}{2!}+\u0026hellip;+\\frac{x^n}{n!}+\u0026hellip;=\\sum_{n=0}^{\\infty} \\frac{x^n}{n!}$$\n$$ sinx = x-\\frac{1}{3!}x^3+\u0026hellip;+(-1)^n\\frac{1}{(2n+1)!}x^{2n+1}+\u0026hellip;=\\sum_{n=0}^{\\infty} (-1)^{n}\\frac{x^{2n+1}}{(2n+1)!} $$\n$$ cosx = 1 - \\frac{1}{2!}x^2 +\u0026hellip;+ (-1)^n\\frac{1}{(2n)!}x^{2n}+\u0026hellip;=\\sum_{n=0}^{\\infty} (-1)^{n}\\frac{x^{2n}}{(2n)!} $$\n$$ ln(1+x)=x-\\frac{1}{2}x^2+\u0026hellip;+(-1)^{n-1}\\frac{x^n}{n}+\u0026hellip;=\\sum_{n=0}^{\\infty} (-1)^{n-1}\\frac{x^{n}}{n}, -1 \\lt x \\le 1 $$\n$$ (1+x)^{\\alpha} = 1 + \\alpha x + \\frac{\\alpha(\\alpha-1)}{2} x^2 + o(x^2) (x \\rightarrow 0, a \\ne 0) $$\n$$ tanx = x + \\frac{1}{3}x^3+o(x^3) (x \\rightarrow 0) $$\n$$ arcsinx = x + \\frac{1}{6}x^3+o(x^3) (x \\rightarrow 0) $$\n$$ arctanx = x - \\frac{1}{3}x^3+o(x^3) (x \\rightarrow 0) $$\n","permalink":"https://fffzlfk.github.io/posts/%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F%E6%80%BB%E7%BB%93/","summary":"Taylor formula","title":"æ³°å‹’å…¬å¼æ€»ç»“"}]